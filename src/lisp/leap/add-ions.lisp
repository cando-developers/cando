(in-package :leap.add-ions)

(defun add-ions (mol ion1 number1 &optional ion2 number2)
  (let* ((target-charge (chem:get-net-charge mol))
         (ion1-charge (chem:get-net-charge ion1))
         (ion1-number (round (/ (abs target-charge) (ion-charge1))))
         (atom-radius 1.5)
         (ion1-size 1.5)
         (ion2-size 1.5)
         (ion-min-size (min ion1-size ion2-size))
         (oct-shell 1)
         (grid-space 1.0)
         (shell-extent 4.0)
         (at-octree 1)
         (dielectric 1))
    (if (= number1 0)
        (if (or (and (< ion1-charge 0)
                     (< target-charge 0))
                (and (> ion1-charge 0)
                     (> target-charge 0)))
            (error "1st ion & target are same charge")))
    (format t "~d ~a ions required to neutraize. ~%" ion1-number (chem:get-name ion1))
    (let* ((oct-tree (core:make-cxx-object 'chem:octree))
           (oct-tree-solute (chem:oct-oct-tree-create oct-tree mol oct-shell grid-space ion-min-size shell-extent 0 t)))
      (multiple-value-bind (min-charge-point max-charge-point)
          (chem:oct-tree-init-charges oct-tree oct-tree-solute at-octree dielectric ion1-size)
        (loop for i from 0 below ion1-number
           for new-point = (if (< ion1-charge 0)
                               (setf new-point max-charge-point)
                               (setf new-point min-charge-point))
           for ion1-copy = (chem:matter-copy ion1)
           for ion1-transform = (geom:make-m4-translate new-point)
           do (chem:apply-transform-to-atoms ion1-copy ion1-transform)
           do (chem:add-matter mol ion1-copy)
           do (format t "Placed ~a in ~a at ~a ~a ~a~%" (chem:get-name ion1)
                      (chem:get-name mol)
                      (geom:vx new-point)
                      (geom:vy new-point)
                      (geom:vx new-point))
             )
        ))
    
    )
  )


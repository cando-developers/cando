(in-package :structure-editor)

(defun json-lookup (json key)
  (unless (eq (car json) :obj)
    (error "The json must stat with :obj but it doesn't json: ~s" json))
  (loop for entry in (cdr json)
        when (string= (car entry) key)
          do (return (cdr entry))))

(defun describe-json (json)
  (loop for entry in json
        do (format t "entry: ~s~%" entry)))

(defun json-bond-order (jbo)
  (case jbo
    (1 :single-bond)
    (2 :double-bond)
    (3 :triple-bond)
    (otherwise (warn "Unrecognized bond order ~a" jbo))
    ))

(defun parse-kekule-json-molecule (json)
  (let* ((molecule (chem:make-molecule nil))
         (residue (chem:make-residue nil))
         (name-string (json-lookup json "id"))
         (name (intern name-string :keyword))
         (ctab (json-lookup json "ctab"))
         (jnodes (json-lookup ctab "nodes"))
         (jconnectors (json-lookup ctab "connectors"))
         (atoms (make-array (length jnodes))))
    (chem:add-matter molecule residue)
    (format t "name-string: ~s~%" name-string)
    (format t "(length nodes) -> ~a~%" (length jnodes))
    (format t "(length connectors) -> ~a~%" (length jconnectors))
    (loop for jnode in jnodes
          for jid = (json-lookup jnode "id")
          for index from 0
          for jcoord2d = (json-lookup jnode "coord2D")
          for jcharge = (json-lookup jnode "charge")
          for charge = jcharge
          for jparity = (json-lookup jnode "parity")
          for jisotope = (json-lookup jnode "isotopeId")
          for jannotation = (json-lookup jnode "annotation")
          for element = (intern jisotope :keyword)
          for id = (intern jid :keyword)
          for name = (intern (format nil "~a~a" jisotope (1+ index)) :keyword)
          for atom = (chem:make-atom name element)
          for xp = (float (json-lookup jcoord2d "x"))
          for yp = (float (json-lookup jcoord2d "y"))
          do (chem:set-position atom (geom:vec xp yp 0.0))
          do (chem:set-charge atom charge)
          do (when jannotation
               (chem:set-property atom :annotation jannotation))
          do (setf (aref atoms index) atom)
          do (chem:add-matter residue atom))
    (loop for jedge in jconnectors
          for jbond-type = (json-lookup jedge "bondType")
          for jbond-order = (json-lookup jedge "bondOrder")
          for connected-objs = (json-lookup jedge "connectedObjs")
          for stereo = (json-lookup jedge "stereo")
          for from = (first connected-objs)
          for to = (second connected-objs)
          for from-atom = (aref atoms from)
          for to-atom = (aref atoms to)
          for bond-order = (json-bond-order jbond-order)
          for bond = (chem:bond-to from-atom to-atom bond-order)
          do (when stereo
               (chem:bond-set-property bond :stereo (list from-atom to-atom stereo))))
    molecule))

(defun parse-kekule-json (json)
  (let* ((root (json-lookup json "root"))
         (children (json-lookup root "children"))
         (jmolecules (json-lookup children "items")))
    (format t "Number of molecules: ~a~%" (length jmolecules))
    (let ((agg (chem:make-aggregate nil)))
      (loop for jmolecule in jmolecules
            for mol = (parse-kekule-json-molecule jmolecule)
            do (chem:add-matter agg mol)
            )
      agg)))

(in-package :chem)

(defgeneric center-of-mass (matter))

(defmethod center-of-mass ((matter chem:aggregate))
  (let ((total-mass 0.0)
        (mass-vector (geom:vec 0.0 0.0 0.0)))
    (chem:map-atoms nil
                    (lambda (atom)
                      (let ((mass (chem:atomic-weight-for-element (chem:get-element atom))))
                        (incf total-mass mass)
                        (geom:v+! mass-vector mass-vector (geom:v* (chem:get-position atom) mass))))
                    matter)
    (geom:v* mass-vector (/ total-mass))))

(defgeneric inertia-tensor (matter))

(defmethod inertia-tensor ((matter chem:aggregate))
  (let ((I (geom:make-matrix nil)))
    (chem:map-atoms nil
                    (lambda (atom)
                      (geom:m+! I (inertia-tensor atom)))
                    matter)
    I))

(defmethod inertia-tensor ((matter chem:atom))
  (let* ((I (geom:make-matrix nil))
         (pos (chem:get-position matter))
         (mass (chem:atomic-weight-for-element (chem:get-element matter)))
         (xx (* mass (geom:get-x pos) (geom:get-x pos)))
         (yy (* mass (geom:get-y pos) (geom:get-y pos)))
         (zz (* mass (geom:get-z pos) (geom:get-z pos)))
         (xy (* mass (geom:get-x pos) (geom:get-y pos)))
         (xz (* mass (geom:get-x pos) (geom:get-z pos)))
         (yz (* mass (geom:get-y pos) (geom:get-z pos))))
    (setf (geom:at I 0 0) (+ yy zz)
          (geom:at I 1 1) (+ xx zz)
          (geom:at I 2 2) (+ xx yy)
          (geom:at I 0 1) (- xy)
          (geom:at I 1 0) (- xy)
          (geom:at I 0 2) (- xz)
          (geom:at I 2 0) (- xz)
          (geom:at I 1 2) (- yz)
          (geom:at I 2 1) (- yz))
    I))

(defun align-to-principle-axes (matter &optional (x 0) (y 1) (z 2))
  (assert (and (or (zerop x) (zerop y) (zerop z))
               (or (= 1 x) (= 1 y) (= 1 z))
               (or (= 2 x) (= 2 y) (= 2 z)))
          (x y z)
          "X, Y, and Z must be a permutation of the numbers 0, 1, and 2.")
  (chem:apply-transform-to-atoms matter (geom:make-m4-translate (geom:v* (center-of-mass matter) -1.0)))
  (multiple-value-bind (S l)
      (geom:eigen-system (inertia-tensor matter))
    (loop with permuted-S = (geom:make-matrix nil)
          with columns = (sort (list (cons 0 (first l))
                                     (cons 1 (second l))
                                     (cons 2 (third l)))
                               #'< :key #'cdr)
          with reflect = (if (and (or (zerop (car (elt columns x)))
                                      (= 1 (car (elt columns y)))
                                      (= 2 (car (elt columns z))))
                                  (or (not (zerop (car (elt columns x))))
                                      (not (= 1 (car (elt columns y))))
                                      (not (= 2 (car (elt columns z))))))
                             -1
                             1)
          with x-scale = (if (= 1 x) reflect 1)
          with y-scale = (if (= 1 y) reflect 1)
          with z-scale = (if (= 1 z) reflect 1)
          finally (chem:apply-transform-to-atoms matter (geom:invert-transform permuted-S))
          for row below 4
          do (setf (geom:at permuted-S row 0) (* x-scale (geom:at S row (car (elt columns x))))
                   (geom:at permuted-S row 1) (* y-scale (geom:at S row (car (elt columns y))))
                   (geom:at permuted-S row 2) (* z-scale (geom:at S row (car (elt columns z))))
                   (geom:at permuted-S row 3) (geom:at S row 3)))))

(export '(center-of-mass inertia-tensor align-to-principle-axes))

_AnchorRestraint_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalxa", this->eval.xa, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evalya", this->eval.ya, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalza", this->eval.za, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalka", this->eval.ka, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_AnchorRestraint_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalAnchorDeviation", this->eval.AnchorDeviation, 0.0 );
_AnchorRestraint_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_AnchorRestraint_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_AnchorRestraint_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_AnchorRestraint_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("xa", this->eval.xa);
_AnchorRestraint_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("ya", this->eval.ya);
_AnchorRestraint_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("za", this->eval.za);
_AnchorRestraint_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("ka", this->eval.ka);
_AnchorRestraint_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_AnchorRestraint_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_AnchorRestraint_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_AnchorRestraint_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_AnchorRestraint_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_AnchorRestraint_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_AnchorRestraint_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_AnchorRestraint_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_AnchorRestraint_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_AnchorRestraint_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_AnchorRestraint_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("AnchorDeviation", this->eval.AnchorDeviation);
_AnchorRestraint_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:18:(-delta2 + x1, y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:25:(-delta2 + x1, -delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:26:(delta2 + x1, -delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:27:(-delta2 + x1, delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:33:(-delta2 + x1, y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:34:(delta2 + x1, y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:35:(-delta2 + x1, y1, delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:40:(x1, -delta2 + y1, z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:47:(x1, -delta2 + y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:48:(x1, delta2 + y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:49:(x1, -delta2 + y1, delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_debugFiniteDifference.cc:54:(x1, y1, -delta2 + z1, xa, ya, za, ka),
_AnchorRestraint_termCode.cc:1:// C-code
_AnchorRestraint_termCode.cc:10:	 tx1 = -xa; 		/* rule 9 */
_AnchorRestraint_termCode.cc:11:	 tx2 = -ya; 		/* rule 10 */
_AnchorRestraint_termCode.cc:12:	 tx3 = -za; 		/* rule 11 */
_AnchorRestraint_termCode.cc:25:	 fx1 = -gx1; 		/* rule 24 */
_AnchorRestraint_termCode.cc:28:	 fy1 = -gy1; 		/* rule 27 */
_AnchorRestraint_termCode.cc:31:	 fz1 = -gz1; 		/* rule 30 */
_Angle_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_Angle_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_Angle_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_Angle_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_Angle_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_Angle_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_Angle_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalx3", this->eval.x3, 0.0 );
_Angle_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaly3", this->eval.y3, 0.0 );
_Angle_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalz3", this->eval.z3, 0.0 );
_Angle_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalt0", this->eval.t0, 0.0 );
_Angle_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evalkt", this->eval.kt, 0.0 );
_Angle_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_Angle_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_Angle_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_Angle_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_Angle_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_Angle_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_Angle_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_Angle_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evalfx3", this->eval.fx3, 0.0 );
_Angle_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evalfy3", this->eval.fy3, 0.0 );
_Angle_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evalfz3", this->eval.fz3, 0.0 );
_Angle_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_Angle_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_Angle_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_Angle_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_Angle_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_Angle_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_Angle_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evaldhx3x3", this->eval.dhx3x3, 0.0 );
_Angle_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evaldhy3y3", this->eval.dhy3y3, 0.0 );
_Angle_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evaldhz3z3", this->eval.dhz3z3, 0.0 );
_Angle_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_Angle_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_Angle_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_Angle_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_Angle_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_Angle_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evalohx1x3", this->eval.ohx1x3, 0.0 );
_Angle_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evalohx1y3", this->eval.ohx1y3, 0.0 );
_Angle_debugEvalSerialize.cc:39: 	node->attributeIfNotDefault("evalohx1z3", this->eval.ohx1z3, 0.0 );
_Angle_debugEvalSerialize.cc:40: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_Angle_debugEvalSerialize.cc:41: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_Angle_debugEvalSerialize.cc:42: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_Angle_debugEvalSerialize.cc:43: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_Angle_debugEvalSerialize.cc:44: 	node->attributeIfNotDefault("evalohy1x3", this->eval.ohy1x3, 0.0 );
_Angle_debugEvalSerialize.cc:45: 	node->attributeIfNotDefault("evalohy1y3", this->eval.ohy1y3, 0.0 );
_Angle_debugEvalSerialize.cc:46: 	node->attributeIfNotDefault("evalohy1z3", this->eval.ohy1z3, 0.0 );
_Angle_debugEvalSerialize.cc:47: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_Angle_debugEvalSerialize.cc:48: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_Angle_debugEvalSerialize.cc:49: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_Angle_debugEvalSerialize.cc:50: 	node->attributeIfNotDefault("evalohz1x3", this->eval.ohz1x3, 0.0 );
_Angle_debugEvalSerialize.cc:51: 	node->attributeIfNotDefault("evalohz1y3", this->eval.ohz1y3, 0.0 );
_Angle_debugEvalSerialize.cc:52: 	node->attributeIfNotDefault("evalohz1z3", this->eval.ohz1z3, 0.0 );
_Angle_debugEvalSerialize.cc:53: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_Angle_debugEvalSerialize.cc:54: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_Angle_debugEvalSerialize.cc:55: 	node->attributeIfNotDefault("evalohx2x3", this->eval.ohx2x3, 0.0 );
_Angle_debugEvalSerialize.cc:56: 	node->attributeIfNotDefault("evalohx2y3", this->eval.ohx2y3, 0.0 );
_Angle_debugEvalSerialize.cc:57: 	node->attributeIfNotDefault("evalohx2z3", this->eval.ohx2z3, 0.0 );
_Angle_debugEvalSerialize.cc:58: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_Angle_debugEvalSerialize.cc:59: 	node->attributeIfNotDefault("evalohy2x3", this->eval.ohy2x3, 0.0 );
_Angle_debugEvalSerialize.cc:60: 	node->attributeIfNotDefault("evalohy2y3", this->eval.ohy2y3, 0.0 );
_Angle_debugEvalSerialize.cc:61: 	node->attributeIfNotDefault("evalohy2z3", this->eval.ohy2z3, 0.0 );
_Angle_debugEvalSerialize.cc:62: 	node->attributeIfNotDefault("evalohz2x3", this->eval.ohz2x3, 0.0 );
_Angle_debugEvalSerialize.cc:63: 	node->attributeIfNotDefault("evalohz2y3", this->eval.ohz2y3, 0.0 );
_Angle_debugEvalSerialize.cc:64: 	node->attributeIfNotDefault("evalohz2z3", this->eval.ohz2z3, 0.0 );
_Angle_debugEvalSerialize.cc:65: 	node->attributeIfNotDefault("evalohx3y3", this->eval.ohx3y3, 0.0 );
_Angle_debugEvalSerialize.cc:66: 	node->attributeIfNotDefault("evalohx3z3", this->eval.ohx3z3, 0.0 );
_Angle_debugEvalSerialize.cc:67: 	node->attributeIfNotDefault("evalohy3z3", this->eval.ohy3z3, 0.0 );
_Angle_debugEvalSerialize.cc:68: 	node->attributeIfNotDefault("evalAngleDeviation", this->eval.AngleDeviation, 0.0 );
_Angle_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_Angle_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_Angle_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_Angle_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_Angle_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_Angle_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_Angle_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("x3", this->eval.x3);
_Angle_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("y3", this->eval.y3);
_Angle_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("z3", this->eval.z3);
_Angle_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("t0", this->eval.t0);
_Angle_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("kt", this->eval.kt);
_Angle_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_Angle_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_Angle_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_Angle_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_Angle_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_Angle_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_Angle_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_Angle_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("fx3", this->eval.fx3);
_Angle_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("fy3", this->eval.fy3);
_Angle_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("fz3", this->eval.fz3);
_Angle_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_Angle_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_Angle_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_Angle_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_Angle_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_Angle_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_Angle_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("dhx3x3", this->eval.dhx3x3);
_Angle_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("dhy3y3", this->eval.dhy3y3);
_Angle_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("dhz3z3", this->eval.dhz3z3);
_Angle_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_Angle_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_Angle_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_Angle_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_Angle_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_Angle_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("ohx1x3", this->eval.ohx1x3);
_Angle_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("ohx1y3", this->eval.ohx1y3);
_Angle_debugEvalXml.cc:39: 	xml->addAttributeDoubleScientific ("ohx1z3", this->eval.ohx1z3);
_Angle_debugEvalXml.cc:40: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_Angle_debugEvalXml.cc:41: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_Angle_debugEvalXml.cc:42: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_Angle_debugEvalXml.cc:43: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_Angle_debugEvalXml.cc:44: 	xml->addAttributeDoubleScientific ("ohy1x3", this->eval.ohy1x3);
_Angle_debugEvalXml.cc:45: 	xml->addAttributeDoubleScientific ("ohy1y3", this->eval.ohy1y3);
_Angle_debugEvalXml.cc:46: 	xml->addAttributeDoubleScientific ("ohy1z3", this->eval.ohy1z3);
_Angle_debugEvalXml.cc:47: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_Angle_debugEvalXml.cc:48: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_Angle_debugEvalXml.cc:49: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_Angle_debugEvalXml.cc:50: 	xml->addAttributeDoubleScientific ("ohz1x3", this->eval.ohz1x3);
_Angle_debugEvalXml.cc:51: 	xml->addAttributeDoubleScientific ("ohz1y3", this->eval.ohz1y3);
_Angle_debugEvalXml.cc:52: 	xml->addAttributeDoubleScientific ("ohz1z3", this->eval.ohz1z3);
_Angle_debugEvalXml.cc:53: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_Angle_debugEvalXml.cc:54: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_Angle_debugEvalXml.cc:55: 	xml->addAttributeDoubleScientific ("ohx2x3", this->eval.ohx2x3);
_Angle_debugEvalXml.cc:56: 	xml->addAttributeDoubleScientific ("ohx2y3", this->eval.ohx2y3);
_Angle_debugEvalXml.cc:57: 	xml->addAttributeDoubleScientific ("ohx2z3", this->eval.ohx2z3);
_Angle_debugEvalXml.cc:58: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_Angle_debugEvalXml.cc:59: 	xml->addAttributeDoubleScientific ("ohy2x3", this->eval.ohy2x3);
_Angle_debugEvalXml.cc:60: 	xml->addAttributeDoubleScientific ("ohy2y3", this->eval.ohy2y3);
_Angle_debugEvalXml.cc:61: 	xml->addAttributeDoubleScientific ("ohy2z3", this->eval.ohy2z3);
_Angle_debugEvalXml.cc:62: 	xml->addAttributeDoubleScientific ("ohz2x3", this->eval.ohz2x3);
_Angle_debugEvalXml.cc:63: 	xml->addAttributeDoubleScientific ("ohz2y3", this->eval.ohz2y3);
_Angle_debugEvalXml.cc:64: 	xml->addAttributeDoubleScientific ("ohz2z3", this->eval.ohz2z3);
_Angle_debugEvalXml.cc:65: 	xml->addAttributeDoubleScientific ("ohx3y3", this->eval.ohx3y3);
_Angle_debugEvalXml.cc:66: 	xml->addAttributeDoubleScientific ("ohx3z3", this->eval.ohx3z3);
_Angle_debugEvalXml.cc:67: 	xml->addAttributeDoubleScientific ("ohy3z3", this->eval.ohy3z3);
_Angle_debugEvalXml.cc:68: 	xml->addAttributeDoubleScientific ("AngleDeviation", this->eval.AngleDeviation);
_Angle_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:18:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:23:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:48:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:55:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:56:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:57:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:63:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:64:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:65:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:71:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:72:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:73:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:79:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:80:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:81:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:87:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:88:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:89:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:95:(-delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:96:(delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:97:(-delta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:103:(-delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:104:(delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:105:(-delta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:111:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:112:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:113:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:118:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:125:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:126:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:127:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:133:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:134:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:135:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:141:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:142:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:143:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:149:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:150:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:151:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:157:(x1, -delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:158:(x1, delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:159:(x1, -delta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:165:(x1, -delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:166:(x1, delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:167:(x1, -delta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:173:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:174:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:175:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:180:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:187:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:188:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:189:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:195:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:196:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:197:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:203:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:204:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:205:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:211:(x1, y1, -delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:212:(x1, y1, delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:213:(x1, y1, -delta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:219:(x1, y1, -delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:220:(x1, y1, delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:221:(x1, y1, -delta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:227:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:228:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:229:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:234:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:241:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:242:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:243:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:249:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:250:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:251:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:257:(x1, y1, z1, -delta2 + x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:258:(x1, y1, z1, delta2 + x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:259:(x1, y1, z1, -delta2 + x2, y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:265:(x1, y1, z1, -delta2 + x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:266:(x1, y1, z1, delta2 + x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:267:(x1, y1, z1, -delta2 + x2, y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:273:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:274:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:275:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:280:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:287:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:288:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:289:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:295:(x1, y1, z1, x2, -delta2 + y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:296:(x1, y1, z1, x2, delta2 + y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:297:(x1, y1, z1, x2, -delta2 + y2, z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:303:(x1, y1, z1, x2, -delta2 + y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:304:(x1, y1, z1, x2, delta2 + y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:305:(x1, y1, z1, x2, -delta2 + y2, z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:311:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:312:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:313:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:318:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:325:(x1, y1, z1, x2, y2, -delta2 + z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:326:(x1, y1, z1, x2, y2, delta2 + z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:327:(x1, y1, z1, x2, y2, -delta2 + z2, delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:333:(x1, y1, z1, x2, y2, -delta2 + z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:334:(x1, y1, z1, x2, y2, delta2 + z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:335:(x1, y1, z1, x2, y2, -delta2 + z2, x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:341:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:342:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:343:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:348:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:355:(x1, y1, z1, x2, y2, z2, -delta2 + x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:356:(x1, y1, z1, x2, y2, z2, delta2 + x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:357:(x1, y1, z1, x2, y2, z2, -delta2 + x3, delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:363:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:364:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:365:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:370:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, t0, kt),
_Angle_debugFiniteDifference.cc:377:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:378:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, -delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:379:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, delta2 + z3, t0, kt),
_Angle_debugFiniteDifference.cc:384:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, t0, kt),
_Angle_termCode.cc:1:// C-code
_Angle_termCode.cc:16:	 tx1 = -x2; 		/* rule 15 */
_Angle_termCode.cc:17:	 tx2 = -y2; 		/* rule 16 */
_Angle_termCode.cc:18:	 tx3 = -z2; 		/* rule 17 */
_Angle_termCode.cc:43:	 tx24 = -t0; 		/* rule 42 */
_Angle_termCode.cc:47:	if(fabs(DotNormAbNormCb)>(1.0-VERYSMALL)) IllegalAngle=true;
_Angle_termCode.cc:58:	 tx31 = -(tx458*tzz498); 		/* rule 57 */
_Angle_termCode.cc:61:	 tzz474 = -tzz467; 		/* rule 60 */
_Angle_termCode.cc:71:	 tzz469 = -2.*tzz468; 		/* rule 70 */
_Angle_termCode.cc:73:	 fx1 = -gx1; 		/* rule 72 */
_Angle_termCode.cc:80:	 fy1 = -gy1; 		/* rule 79 */
_Angle_termCode.cc:87:	 fz1 = -gz1; 		/* rule 86 */
_Angle_termCode.cc:89:	 tx43 = -x1; 		/* rule 88 */
_Angle_termCode.cc:91:	 tx45 = -x3; 		/* rule 90 */
_Angle_termCode.cc:102:	 fx2 = -gx2; 		/* rule 101 */
_Angle_termCode.cc:104:	 tx52 = -y1; 		/* rule 103 */
_Angle_termCode.cc:106:	 tx54 = -y3; 		/* rule 105 */
_Angle_termCode.cc:115:	 fy2 = -gy2; 		/* rule 114 */
_Angle_termCode.cc:117:	 tx60 = -z1; 		/* rule 116 */
_Angle_termCode.cc:119:	 tx62 = -z3; 		/* rule 118 */
_Angle_termCode.cc:128:	 fz2 = -gz2; 		/* rule 127 */
_Angle_termCode.cc:131:	 tx69 = -tx50; 		/* rule 130 */
_Angle_termCode.cc:134:	 fx3 = -gx3; 		/* rule 133 */
_Angle_termCode.cc:136:	 tx71 = -tx58; 		/* rule 135 */
_Angle_termCode.cc:140:	 fy3 = -gy3; 		/* rule 139 */
_Angle_termCode.cc:142:	 tx74 = -tx66; 		/* rule 141 */
_Angle_termCode.cc:146:	 fz3 = -gz3; 		/* rule 145 */
_Angle_termCode.cc:154:	 tzz521 = -2.*tzz467; 		/* rule 153 */
_Angle_termCode.cc:157:	 tzz481 = -2.*tx458; 		/* rule 156 */
_Angle_termCode.cc:217:	 tx116 = -(tx23*tzz473); 		/* rule 216 */
_Angle_termCode.cc:225:	 tzz519 = -2.*tzz504; 		/* rule 224 */
_Angle_termCode.cc:276:	 tzz520 = -2.*tzz473; 		/* rule 275 */
_Angle_termCode.cc:335:	 tx196 = -tx226; 		/* rule 334 */
_Angle_termCode.cc:339:	 tzz487 = -tzz476; 		/* rule 338 */
_Angle_termCode.cc:342:	 tzz508 = -3*tzz478; 		/* rule 341 */
_Angle_termCode.cc:381:	 tx225 = -tx199; 		/* rule 380 */
_Angle_termCode.cc:391:	 tx233 = -tx210; 		/* rule 390 */
_Angle_termCode.cc:402:	 tx240 = -tx220; 		/* rule 401 */
_Angle_termCode.cc:463:	 tx284 = -tx262; 		/* rule 462 */
_Angle_termCode.cc:472:	 tx291 = -tx274; 		/* rule 471 */
_Angle_termCode.cc:528:	 tx332 = -tx313; 		/* rule 527 */
_Angle_termCode.cc:560:	 tzz507 = -3*tzz480; 		/* rule 559 */
_Angle_termCode.cc:565:	 tx360 = -tzz535; 		/* rule 564 */
_Angle_termCode.cc:573:	 tx365 = -tx341; 		/* rule 572 */
_Angle_termCode.cc:584:	 tx373 = -tx350; 		/* rule 583 */
_Angle_termCode.cc:607:	 tx390 = -tx339; 		/* rule 606 */
_Angle_termCode.cc:618:	 tx399 = -tzz532; 		/* rule 617 */
_Angle_termCode.cc:625:	 tx404 = -tx384; 		/* rule 624 */
_Angle_termCode.cc:636:	 tx412 = -tx348; 		/* rule 635 */
_Angle_termCode.cc:644:	 tx418 = -tx382; 		/* rule 643 */
_Angle_termCode.cc:655:	 tx427 = -tzz531; 		/* rule 654 */
_Angle_termCode.cc:662:	 tx432 = -tx367; 		/* rule 661 */
_Angle_termCode.cc:663:	 tx433 = -tx391; 		/* rule 662 */
_Angle_termCode.cc:670:	 tx438 = -tx375; 		/* rule 669 */
_Angle_termCode.cc:671:	 tx439 = -tx413; 		/* rule 670 */
_Angle_termCode.cc:678:	 tx444 = -tx406; 		/* rule 677 */
_Angle_termCode.cc:679:	 tx445 = -tx419; 		/* rule 678 */
_ChiralRestraint_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalx3", this->eval.x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaly3", this->eval.y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalz3", this->eval.z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalx4", this->eval.x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evaly4", this->eval.y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalz4", this->eval.z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalK", this->eval.K, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalCO", this->eval.CO, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evalfx3", this->eval.fx3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evalfy3", this->eval.fy3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evalfz3", this->eval.fz3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evalfx4", this->eval.fx4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evalfy4", this->eval.fy4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evalfz4", this->eval.fz4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evaldhx3x3", this->eval.dhx3x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evaldhy3y3", this->eval.dhy3y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evaldhz3z3", this->eval.dhz3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evaldhx4x4", this->eval.dhx4x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:39: 	node->attributeIfNotDefault("evaldhy4y4", this->eval.dhy4y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:40: 	node->attributeIfNotDefault("evaldhz4z4", this->eval.dhz4z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:41: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:42: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:43: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:44: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:45: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:46: 	node->attributeIfNotDefault("evalohx1x3", this->eval.ohx1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:47: 	node->attributeIfNotDefault("evalohx1y3", this->eval.ohx1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:48: 	node->attributeIfNotDefault("evalohx1z3", this->eval.ohx1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:49: 	node->attributeIfNotDefault("evalohx1x4", this->eval.ohx1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:50: 	node->attributeIfNotDefault("evalohx1y4", this->eval.ohx1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:51: 	node->attributeIfNotDefault("evalohx1z4", this->eval.ohx1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:52: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:53: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:54: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:55: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:56: 	node->attributeIfNotDefault("evalohy1x3", this->eval.ohy1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:57: 	node->attributeIfNotDefault("evalohy1y3", this->eval.ohy1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:58: 	node->attributeIfNotDefault("evalohy1z3", this->eval.ohy1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:59: 	node->attributeIfNotDefault("evalohy1x4", this->eval.ohy1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:60: 	node->attributeIfNotDefault("evalohy1y4", this->eval.ohy1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:61: 	node->attributeIfNotDefault("evalohy1z4", this->eval.ohy1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:62: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:63: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:64: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:65: 	node->attributeIfNotDefault("evalohz1x3", this->eval.ohz1x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:66: 	node->attributeIfNotDefault("evalohz1y3", this->eval.ohz1y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:67: 	node->attributeIfNotDefault("evalohz1z3", this->eval.ohz1z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:68: 	node->attributeIfNotDefault("evalohz1x4", this->eval.ohz1x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:69: 	node->attributeIfNotDefault("evalohz1y4", this->eval.ohz1y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:70: 	node->attributeIfNotDefault("evalohz1z4", this->eval.ohz1z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:71: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:72: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:73: 	node->attributeIfNotDefault("evalohx2x3", this->eval.ohx2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:74: 	node->attributeIfNotDefault("evalohx2y3", this->eval.ohx2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:75: 	node->attributeIfNotDefault("evalohx2z3", this->eval.ohx2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:76: 	node->attributeIfNotDefault("evalohx2x4", this->eval.ohx2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:77: 	node->attributeIfNotDefault("evalohx2y4", this->eval.ohx2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:78: 	node->attributeIfNotDefault("evalohx2z4", this->eval.ohx2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:79: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:80: 	node->attributeIfNotDefault("evalohy2x3", this->eval.ohy2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:81: 	node->attributeIfNotDefault("evalohy2y3", this->eval.ohy2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:82: 	node->attributeIfNotDefault("evalohy2z3", this->eval.ohy2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:83: 	node->attributeIfNotDefault("evalohy2x4", this->eval.ohy2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:84: 	node->attributeIfNotDefault("evalohy2y4", this->eval.ohy2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:85: 	node->attributeIfNotDefault("evalohy2z4", this->eval.ohy2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:86: 	node->attributeIfNotDefault("evalohz2x3", this->eval.ohz2x3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:87: 	node->attributeIfNotDefault("evalohz2y3", this->eval.ohz2y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:88: 	node->attributeIfNotDefault("evalohz2z3", this->eval.ohz2z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:89: 	node->attributeIfNotDefault("evalohz2x4", this->eval.ohz2x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:90: 	node->attributeIfNotDefault("evalohz2y4", this->eval.ohz2y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:91: 	node->attributeIfNotDefault("evalohz2z4", this->eval.ohz2z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:92: 	node->attributeIfNotDefault("evalohx3y3", this->eval.ohx3y3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:93: 	node->attributeIfNotDefault("evalohx3z3", this->eval.ohx3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:94: 	node->attributeIfNotDefault("evalohx3x4", this->eval.ohx3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:95: 	node->attributeIfNotDefault("evalohx3y4", this->eval.ohx3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:96: 	node->attributeIfNotDefault("evalohx3z4", this->eval.ohx3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:97: 	node->attributeIfNotDefault("evalohy3z3", this->eval.ohy3z3, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:98: 	node->attributeIfNotDefault("evalohy3x4", this->eval.ohy3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:99: 	node->attributeIfNotDefault("evalohy3y4", this->eval.ohy3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:100: 	node->attributeIfNotDefault("evalohy3z4", this->eval.ohy3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:101: 	node->attributeIfNotDefault("evalohz3x4", this->eval.ohz3x4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:102: 	node->attributeIfNotDefault("evalohz3y4", this->eval.ohz3y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:103: 	node->attributeIfNotDefault("evalohz3z4", this->eval.ohz3z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:104: 	node->attributeIfNotDefault("evalohx4y4", this->eval.ohx4y4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:105: 	node->attributeIfNotDefault("evalohx4z4", this->eval.ohx4z4, 0.0 );
_ChiralRestraint_debugEvalSerialize.cc:106: 	node->attributeIfNotDefault("evalohy4z4", this->eval.ohy4z4, 0.0 );
_ChiralRestraint_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_ChiralRestraint_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_ChiralRestraint_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_ChiralRestraint_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_ChiralRestraint_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_ChiralRestraint_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_ChiralRestraint_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("x3", this->eval.x3);
_ChiralRestraint_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("y3", this->eval.y3);
_ChiralRestraint_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("z3", this->eval.z3);
_ChiralRestraint_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("x4", this->eval.x4);
_ChiralRestraint_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("y4", this->eval.y4);
_ChiralRestraint_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("z4", this->eval.z4);
_ChiralRestraint_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("K", this->eval.K);
_ChiralRestraint_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("CO", this->eval.CO);
_ChiralRestraint_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_ChiralRestraint_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_ChiralRestraint_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_ChiralRestraint_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_ChiralRestraint_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_ChiralRestraint_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_ChiralRestraint_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_ChiralRestraint_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("fx3", this->eval.fx3);
_ChiralRestraint_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("fy3", this->eval.fy3);
_ChiralRestraint_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("fz3", this->eval.fz3);
_ChiralRestraint_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("fx4", this->eval.fx4);
_ChiralRestraint_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("fy4", this->eval.fy4);
_ChiralRestraint_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("fz4", this->eval.fz4);
_ChiralRestraint_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_ChiralRestraint_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_ChiralRestraint_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_ChiralRestraint_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_ChiralRestraint_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_ChiralRestraint_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_ChiralRestraint_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("dhx3x3", this->eval.dhx3x3);
_ChiralRestraint_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("dhy3y3", this->eval.dhy3y3);
_ChiralRestraint_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("dhz3z3", this->eval.dhz3z3);
_ChiralRestraint_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("dhx4x4", this->eval.dhx4x4);
_ChiralRestraint_debugEvalXml.cc:39: 	xml->addAttributeDoubleScientific ("dhy4y4", this->eval.dhy4y4);
_ChiralRestraint_debugEvalXml.cc:40: 	xml->addAttributeDoubleScientific ("dhz4z4", this->eval.dhz4z4);
_ChiralRestraint_debugEvalXml.cc:41: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_ChiralRestraint_debugEvalXml.cc:42: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_ChiralRestraint_debugEvalXml.cc:43: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_ChiralRestraint_debugEvalXml.cc:44: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_ChiralRestraint_debugEvalXml.cc:45: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_ChiralRestraint_debugEvalXml.cc:46: 	xml->addAttributeDoubleScientific ("ohx1x3", this->eval.ohx1x3);
_ChiralRestraint_debugEvalXml.cc:47: 	xml->addAttributeDoubleScientific ("ohx1y3", this->eval.ohx1y3);
_ChiralRestraint_debugEvalXml.cc:48: 	xml->addAttributeDoubleScientific ("ohx1z3", this->eval.ohx1z3);
_ChiralRestraint_debugEvalXml.cc:49: 	xml->addAttributeDoubleScientific ("ohx1x4", this->eval.ohx1x4);
_ChiralRestraint_debugEvalXml.cc:50: 	xml->addAttributeDoubleScientific ("ohx1y4", this->eval.ohx1y4);
_ChiralRestraint_debugEvalXml.cc:51: 	xml->addAttributeDoubleScientific ("ohx1z4", this->eval.ohx1z4);
_ChiralRestraint_debugEvalXml.cc:52: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_ChiralRestraint_debugEvalXml.cc:53: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_ChiralRestraint_debugEvalXml.cc:54: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_ChiralRestraint_debugEvalXml.cc:55: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_ChiralRestraint_debugEvalXml.cc:56: 	xml->addAttributeDoubleScientific ("ohy1x3", this->eval.ohy1x3);
_ChiralRestraint_debugEvalXml.cc:57: 	xml->addAttributeDoubleScientific ("ohy1y3", this->eval.ohy1y3);
_ChiralRestraint_debugEvalXml.cc:58: 	xml->addAttributeDoubleScientific ("ohy1z3", this->eval.ohy1z3);
_ChiralRestraint_debugEvalXml.cc:59: 	xml->addAttributeDoubleScientific ("ohy1x4", this->eval.ohy1x4);
_ChiralRestraint_debugEvalXml.cc:60: 	xml->addAttributeDoubleScientific ("ohy1y4", this->eval.ohy1y4);
_ChiralRestraint_debugEvalXml.cc:61: 	xml->addAttributeDoubleScientific ("ohy1z4", this->eval.ohy1z4);
_ChiralRestraint_debugEvalXml.cc:62: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_ChiralRestraint_debugEvalXml.cc:63: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_ChiralRestraint_debugEvalXml.cc:64: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_ChiralRestraint_debugEvalXml.cc:65: 	xml->addAttributeDoubleScientific ("ohz1x3", this->eval.ohz1x3);
_ChiralRestraint_debugEvalXml.cc:66: 	xml->addAttributeDoubleScientific ("ohz1y3", this->eval.ohz1y3);
_ChiralRestraint_debugEvalXml.cc:67: 	xml->addAttributeDoubleScientific ("ohz1z3", this->eval.ohz1z3);
_ChiralRestraint_debugEvalXml.cc:68: 	xml->addAttributeDoubleScientific ("ohz1x4", this->eval.ohz1x4);
_ChiralRestraint_debugEvalXml.cc:69: 	xml->addAttributeDoubleScientific ("ohz1y4", this->eval.ohz1y4);
_ChiralRestraint_debugEvalXml.cc:70: 	xml->addAttributeDoubleScientific ("ohz1z4", this->eval.ohz1z4);
_ChiralRestraint_debugEvalXml.cc:71: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_ChiralRestraint_debugEvalXml.cc:72: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_ChiralRestraint_debugEvalXml.cc:73: 	xml->addAttributeDoubleScientific ("ohx2x3", this->eval.ohx2x3);
_ChiralRestraint_debugEvalXml.cc:74: 	xml->addAttributeDoubleScientific ("ohx2y3", this->eval.ohx2y3);
_ChiralRestraint_debugEvalXml.cc:75: 	xml->addAttributeDoubleScientific ("ohx2z3", this->eval.ohx2z3);
_ChiralRestraint_debugEvalXml.cc:76: 	xml->addAttributeDoubleScientific ("ohx2x4", this->eval.ohx2x4);
_ChiralRestraint_debugEvalXml.cc:77: 	xml->addAttributeDoubleScientific ("ohx2y4", this->eval.ohx2y4);
_ChiralRestraint_debugEvalXml.cc:78: 	xml->addAttributeDoubleScientific ("ohx2z4", this->eval.ohx2z4);
_ChiralRestraint_debugEvalXml.cc:79: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_ChiralRestraint_debugEvalXml.cc:80: 	xml->addAttributeDoubleScientific ("ohy2x3", this->eval.ohy2x3);
_ChiralRestraint_debugEvalXml.cc:81: 	xml->addAttributeDoubleScientific ("ohy2y3", this->eval.ohy2y3);
_ChiralRestraint_debugEvalXml.cc:82: 	xml->addAttributeDoubleScientific ("ohy2z3", this->eval.ohy2z3);
_ChiralRestraint_debugEvalXml.cc:83: 	xml->addAttributeDoubleScientific ("ohy2x4", this->eval.ohy2x4);
_ChiralRestraint_debugEvalXml.cc:84: 	xml->addAttributeDoubleScientific ("ohy2y4", this->eval.ohy2y4);
_ChiralRestraint_debugEvalXml.cc:85: 	xml->addAttributeDoubleScientific ("ohy2z4", this->eval.ohy2z4);
_ChiralRestraint_debugEvalXml.cc:86: 	xml->addAttributeDoubleScientific ("ohz2x3", this->eval.ohz2x3);
_ChiralRestraint_debugEvalXml.cc:87: 	xml->addAttributeDoubleScientific ("ohz2y3", this->eval.ohz2y3);
_ChiralRestraint_debugEvalXml.cc:88: 	xml->addAttributeDoubleScientific ("ohz2z3", this->eval.ohz2z3);
_ChiralRestraint_debugEvalXml.cc:89: 	xml->addAttributeDoubleScientific ("ohz2x4", this->eval.ohz2x4);
_ChiralRestraint_debugEvalXml.cc:90: 	xml->addAttributeDoubleScientific ("ohz2y4", this->eval.ohz2y4);
_ChiralRestraint_debugEvalXml.cc:91: 	xml->addAttributeDoubleScientific ("ohz2z4", this->eval.ohz2z4);
_ChiralRestraint_debugEvalXml.cc:92: 	xml->addAttributeDoubleScientific ("ohx3y3", this->eval.ohx3y3);
_ChiralRestraint_debugEvalXml.cc:93: 	xml->addAttributeDoubleScientific ("ohx3z3", this->eval.ohx3z3);
_ChiralRestraint_debugEvalXml.cc:94: 	xml->addAttributeDoubleScientific ("ohx3x4", this->eval.ohx3x4);
_ChiralRestraint_debugEvalXml.cc:95: 	xml->addAttributeDoubleScientific ("ohx3y4", this->eval.ohx3y4);
_ChiralRestraint_debugEvalXml.cc:96: 	xml->addAttributeDoubleScientific ("ohx3z4", this->eval.ohx3z4);
_ChiralRestraint_debugEvalXml.cc:97: 	xml->addAttributeDoubleScientific ("ohy3z3", this->eval.ohy3z3);
_ChiralRestraint_debugEvalXml.cc:98: 	xml->addAttributeDoubleScientific ("ohy3x4", this->eval.ohy3x4);
_ChiralRestraint_debugEvalXml.cc:99: 	xml->addAttributeDoubleScientific ("ohy3y4", this->eval.ohy3y4);
_ChiralRestraint_debugEvalXml.cc:100: 	xml->addAttributeDoubleScientific ("ohy3z4", this->eval.ohy3z4);
_ChiralRestraint_debugEvalXml.cc:101: 	xml->addAttributeDoubleScientific ("ohz3x4", this->eval.ohz3x4);
_ChiralRestraint_debugEvalXml.cc:102: 	xml->addAttributeDoubleScientific ("ohz3y4", this->eval.ohz3y4);
_ChiralRestraint_debugEvalXml.cc:103: 	xml->addAttributeDoubleScientific ("ohz3z4", this->eval.ohz3z4);
_ChiralRestraint_debugEvalXml.cc:104: 	xml->addAttributeDoubleScientific ("ohx4y4", this->eval.ohx4y4);
_ChiralRestraint_debugEvalXml.cc:105: 	xml->addAttributeDoubleScientific ("ohx4z4", this->eval.ohx4z4);
_ChiralRestraint_debugEvalXml.cc:106: 	xml->addAttributeDoubleScientific ("ohy4z4", this->eval.ohy4z4);
_ChiralRestraint_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:18:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:23:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:63:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:70:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:71:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:72:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:78:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:79:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:80:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:86:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:88:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:94:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:96:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:102:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:104:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:110:(-delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:112:(-delta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:118:(-delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:120:(-delta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:126:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:128:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:134:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:136:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:142:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:144:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:150:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:152:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:157:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:164:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:165:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:166:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:172:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:174:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:180:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:182:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:188:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:190:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:196:(x1, -delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:198:(x1, -delta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:204:(x1, -delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:206:(x1, -delta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:212:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:214:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:220:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:222:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:228:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:230:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:236:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:238:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:243:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:250:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:252:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:258:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:260:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:266:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:268:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:274:(x1, y1, -delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:276:(x1, y1, -delta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:282:(x1, y1, -delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:284:(x1, y1, -delta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:290:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:292:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:298:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:300:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:306:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:308:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:314:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:316:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:321:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:328:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:330:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:336:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:338:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:344:(x1, y1, z1, -delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:346:(x1, y1, z1, -delta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:352:(x1, y1, z1, -delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:354:(x1, y1, z1, -delta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:360:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:362:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:368:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:370:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:376:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:378:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:384:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:386:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:391:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:398:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:400:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:406:(x1, y1, z1, x2, -delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:408:(x1, y1, z1, x2, -delta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:414:(x1, y1, z1, x2, -delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:416:(x1, y1, z1, x2, -delta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:422:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:424:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:430:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:432:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:438:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:440:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:446:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:448:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, -delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, -delta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, -delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, -delta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, -delta2 + x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, -delta2 + x3, delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, -delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, delta2 + z4, K, CO),
_ChiralRestraint_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, CO),
_ChiralRestraint_termCode.cc:1:// C-code
_ChiralRestraint_termCode.cc:20:	 tx1 = -x3; 		/* rule 19 */
_ChiralRestraint_termCode.cc:21:	 tx2 = -y3; 		/* rule 20 */
_ChiralRestraint_termCode.cc:22:	 tx3 = -z3; 		/* rule 21 */
_ChiralRestraint_termCode.cc:29:	 tx10 = -(x2*y1); 		/* rule 28 */
_ChiralRestraint_termCode.cc:39:	 tx20 = -(y2*z1); 		/* rule 38 */
_ChiralRestraint_termCode.cc:43:	 tx24 = -(x1*z2); 		/* rule 42 */
_ChiralRestraint_termCode.cc:87:	 tx56 = -z2; 		/* rule 86 */
_ChiralRestraint_termCode.cc:94:	 tx62 = -(tx5*tx52*tx60*tx797*tx800); 		/* rule 93 */
_ChiralRestraint_termCode.cc:98:	 fx1 = -gx1; 		/* rule 97 */
_ChiralRestraint_termCode.cc:100:	 tx66 = -x2; 		/* rule 99 */
_ChiralRestraint_termCode.cc:105:	 tx71 = -(tx12*tx52*tx60*tx797*tx800); 		/* rule 104 */
_ChiralRestraint_termCode.cc:109:	 fy1 = -gy1; 		/* rule 108 */
_ChiralRestraint_termCode.cc:111:	 tx74 = -y2; 		/* rule 110 */
_ChiralRestraint_termCode.cc:116:	 tx79 = -(tx22*tx52*tx60*tx797*tx800); 		/* rule 115 */
_ChiralRestraint_termCode.cc:120:	 fz1 = -gz1; 		/* rule 119 */
_ChiralRestraint_termCode.cc:122:	 tx82 = -y1; 		/* rule 121 */
_ChiralRestraint_termCode.cc:129:	 tx88 = -(tx52*tx7*tx794*tx800*tx86); 		/* rule 128 */
_ChiralRestraint_termCode.cc:133:	 fx2 = -gx2; 		/* rule 132 */
_ChiralRestraint_termCode.cc:135:	 tx91 = -z1; 		/* rule 134 */
_ChiralRestraint_termCode.cc:140:	 tx96 = -(tx15*tx52*tx794*tx800*tx86); 		/* rule 139 */
_ChiralRestraint_termCode.cc:144:	 fy2 = -gy2; 		/* rule 143 */
_ChiralRestraint_termCode.cc:146:	 tx99 = -x1; 		/* rule 145 */
_ChiralRestraint_termCode.cc:152:	 tx105 = -(tx27*tx52*tx794*tx800*tx86); 		/* rule 151 */
_ChiralRestraint_termCode.cc:155:	 fz2 = -gz2; 		/* rule 154 */
_ChiralRestraint_termCode.cc:160:	 tx110 = -tx26; 		/* rule 159 */
_ChiralRestraint_termCode.cc:176:	 fx3 = -gx3; 		/* rule 175 */
_ChiralRestraint_termCode.cc:180:	 tx126 = -tx19; 		/* rule 179 */
_ChiralRestraint_termCode.cc:195:	 fy3 = -gy3; 		/* rule 194 */
_ChiralRestraint_termCode.cc:199:	 tx142 = -tx14; 		/* rule 198 */
_ChiralRestraint_termCode.cc:214:	 fz3 = -gz3; 		/* rule 213 */
_ChiralRestraint_termCode.cc:216:	 tx156 = -tx121; 		/* rule 215 */
_ChiralRestraint_termCode.cc:220:	 fx4 = -gx4; 		/* rule 219 */
_ChiralRestraint_termCode.cc:222:	 tx159 = -tx136; 		/* rule 221 */
_ChiralRestraint_termCode.cc:226:	 fy4 = -gy4; 		/* rule 225 */
_ChiralRestraint_termCode.cc:228:	 tx162 = -tx152; 		/* rule 227 */
_ChiralRestraint_termCode.cc:232:	 fz4 = -gz4; 		/* rule 231 */
_ChiralRestraint_termCode.cc:240:	 tx167 = -(tx52*tx60*tx797*tx800); 		/* rule 239 */
_ChiralRestraint_termCode.cc:241:	 tx168 = -2.*tx5*tx60*tx61*tx797*tx800; 		/* rule 240 */
_ChiralRestraint_termCode.cc:249:	 tx174 = -2.*tx12*tx60*tx70*tx797*tx800; 		/* rule 248 */
_ChiralRestraint_termCode.cc:257:	 tx180 = -2.*tx22*tx60*tx78*tx797*tx800; 		/* rule 256 */
_ChiralRestraint_termCode.cc:268:	 tx187 = -(tx52*tx794*tx800*tx86); 		/* rule 267 */
_ChiralRestraint_termCode.cc:269:	 tx188 = -2.*tx7*tx794*tx800*tx86*tx87; 		/* rule 268 */
_ChiralRestraint_termCode.cc:277:	 tx194 = -2.*tx15*tx794*tx800*tx86*tx95; 		/* rule 276 */
_ChiralRestraint_termCode.cc:285:	 tx200 = -2.*tx103*tx27*tx794*tx800*tx86; 		/* rule 284 */
_ChiralRestraint_termCode.cc:295:	 tx206 = -(tx118*tx52*tx794*tx797); 		/* rule 294 */
_ChiralRestraint_termCode.cc:335:	 tx240 = -2.*tx118*tx48*tx794*tx797; 		/* rule 334 */
_ChiralRestraint_termCode.cc:342:	 tx245 = -2.*tx118*tx45*tx794*tx797; 		/* rule 341 */
_ChiralRestraint_termCode.cc:349:	 tx250 = -2.*tx118*tx43*tx794*tx797; 		/* rule 348 */
_ChiralRestraint_termCode.cc:359:	 tx256 = -(tx12*tx60*tx61*tx797*tx800); 		/* rule 358 */
_ChiralRestraint_termCode.cc:360:	 tx257 = -(tx5*tx60*tx70*tx797*tx800); 		/* rule 359 */
_ChiralRestraint_termCode.cc:367:	 tx262 = -(tx22*tx60*tx61*tx797*tx800); 		/* rule 366 */
_ChiralRestraint_termCode.cc:368:	 tx263 = -(tx5*tx60*tx78*tx797*tx800); 		/* rule 367 */
_ChiralRestraint_termCode.cc:375:	 tx268 = -(tx61*tx7*tx794*tx800*tx86); 		/* rule 374 */
_ChiralRestraint_termCode.cc:376:	 tx269 = -(tx5*tx60*tx797*tx800*tx87); 		/* rule 375 */
_ChiralRestraint_termCode.cc:384:	 tx275 = -(tx15*tx61*tx794*tx800*tx86); 		/* rule 383 */
_ChiralRestraint_termCode.cc:385:	 tx276 = -(tx5*tx60*tx797*tx800*tx95); 		/* rule 384 */
_ChiralRestraint_termCode.cc:391:	 tx280 = -y4; 		/* rule 390 */
_ChiralRestraint_termCode.cc:394:	 tx283 = -(tx103*tx5*tx60*tx797*tx800); 		/* rule 393 */
_ChiralRestraint_termCode.cc:396:	 tx285 = -(tx27*tx61*tx794*tx800*tx86); 		/* rule 395 */
_ChiralRestraint_termCode.cc:402:	 tx289 = -tx267; 		/* rule 401 */
_ChiralRestraint_termCode.cc:403:	 tx290 = -3*tx165*tx38*tx52*tx797*tx800; 		/* rule 402 */
_ChiralRestraint_termCode.cc:404:	 tx291 = -(tx117*tx5*tx60*tx797*tx800); 		/* rule 403 */
_ChiralRestraint_termCode.cc:407:	 tx294 = -(tx118*tx5*tx52*tx60*tx797*tx8); 		/* rule 406 */
_ChiralRestraint_termCode.cc:415:	 tx300 = -z4; 		/* rule 414 */
_ChiralRestraint_termCode.cc:417:	 tx302 = -tx274; 		/* rule 416 */
_ChiralRestraint_termCode.cc:419:	 tx304 = -3*tx12*tx165*tx5*tx52*tx797*tx800; 		/* rule 418 */
_ChiralRestraint_termCode.cc:420:	 tx305 = -(tx134*tx5*tx60*tx797*tx800); 		/* rule 419 */
_ChiralRestraint_termCode.cc:421:	 tx306 = -(tx118*tx17*tx5*tx52*tx60*tx797); 		/* rule 420 */
_ChiralRestraint_termCode.cc:431:	 tx314 = -tx284; 		/* rule 430 */
_ChiralRestraint_termCode.cc:433:	 tx316 = -3*tx165*tx22*tx5*tx52*tx797*tx800; 		/* rule 432 */
_ChiralRestraint_termCode.cc:434:	 tx317 = -(tx150*tx5*tx60*tx797*tx800); 		/* rule 433 */
_ChiralRestraint_termCode.cc:438:	 tx321 = -(tx118*tx52*tx60*tx797*tx93); 		/* rule 437 */
_ChiralRestraint_termCode.cc:444:	 tx325 = -tx295; 		/* rule 443 */
_ChiralRestraint_termCode.cc:445:	 tx326 = -(tx42*tx5*tx60*tx797*tx800); 		/* rule 444 */
_ChiralRestraint_termCode.cc:452:	 tx331 = -tx307; 		/* rule 451 */
_ChiralRestraint_termCode.cc:454:	 tx333 = -(tx39*tx5*tx60*tx797*tx800); 		/* rule 453 */
_ChiralRestraint_termCode.cc:461:	 tx338 = -tx318; 		/* rule 460 */
_ChiralRestraint_termCode.cc:463:	 tx340 = -(tx37*tx5*tx60*tx797*tx800); 		/* rule 462 */
_ChiralRestraint_termCode.cc:471:	 tx346 = -(tx22*tx60*tx70*tx797*tx800); 		/* rule 470 */
_ChiralRestraint_termCode.cc:472:	 tx347 = -(tx12*tx60*tx78*tx797*tx800); 		/* rule 471 */
_ChiralRestraint_termCode.cc:481:	 tx354 = -(tx7*tx70*tx794*tx800*tx86); 		/* rule 480 */
_ChiralRestraint_termCode.cc:482:	 tx355 = -(tx12*tx60*tx797*tx800*tx87); 		/* rule 481 */
_ChiralRestraint_termCode.cc:489:	 tx360 = -(tx15*tx70*tx794*tx800*tx86); 		/* rule 488 */
_ChiralRestraint_termCode.cc:490:	 tx361 = -(tx12*tx60*tx797*tx800*tx95); 		/* rule 489 */
_ChiralRestraint_termCode.cc:496:	 tx365 = -(tx103*tx12*tx60*tx797*tx800); 		/* rule 495 */
_ChiralRestraint_termCode.cc:499:	 tx368 = -(tx27*tx70*tx794*tx800*tx86); 		/* rule 498 */
_ChiralRestraint_termCode.cc:506:	 tx373 = -tx353; 		/* rule 505 */
_ChiralRestraint_termCode.cc:508:	 tx375 = -(tx117*tx12*tx60*tx797*tx800); 		/* rule 507 */
_ChiralRestraint_termCode.cc:509:	 tx376 = -(tx102*tx118*tx52*tx60*tx797); 		/* rule 508 */
_ChiralRestraint_termCode.cc:518:	 tx383 = -tx359; 		/* rule 517 */
_ChiralRestraint_termCode.cc:519:	 tx384 = -3*tx165*tx31*tx52*tx797*tx800; 		/* rule 518 */
_ChiralRestraint_termCode.cc:520:	 tx385 = -(tx12*tx134*tx60*tx797*tx800); 		/* rule 519 */
_ChiralRestraint_termCode.cc:521:	 tx386 = -(tx118*tx12*tx17*tx52*tx60*tx797); 		/* rule 520 */
_ChiralRestraint_termCode.cc:530:	 tx393 = -x4; 		/* rule 529 */
_ChiralRestraint_termCode.cc:532:	 tx395 = -tx367; 		/* rule 531 */
_ChiralRestraint_termCode.cc:534:	 tx397 = -3*tx12*tx165*tx22*tx52*tx797*tx800; 		/* rule 533 */
_ChiralRestraint_termCode.cc:535:	 tx398 = -(tx12*tx150*tx60*tx797*tx800); 		/* rule 534 */
_ChiralRestraint_termCode.cc:536:	 tx399 = -(tx118*tx12*tx30*tx52*tx60*tx797); 		/* rule 535 */
_ChiralRestraint_termCode.cc:545:	 tx406 = -tx378; 		/* rule 544 */
_ChiralRestraint_termCode.cc:547:	 tx408 = -(tx12*tx42*tx60*tx797*tx800); 		/* rule 546 */
_ChiralRestraint_termCode.cc:554:	 tx413 = -tx387; 		/* rule 553 */
_ChiralRestraint_termCode.cc:555:	 tx414 = -(tx12*tx39*tx60*tx797*tx800); 		/* rule 554 */
_ChiralRestraint_termCode.cc:562:	 tx419 = -tx400; 		/* rule 561 */
_ChiralRestraint_termCode.cc:563:	 tx420 = -(tx12*tx37*tx60*tx797*tx800); 		/* rule 562 */
_ChiralRestraint_termCode.cc:573:	 tx428 = -(tx7*tx78*tx794*tx800*tx86); 		/* rule 572 */
_ChiralRestraint_termCode.cc:574:	 tx429 = -(tx22*tx60*tx797*tx800*tx87); 		/* rule 573 */
_ChiralRestraint_termCode.cc:583:	 tx436 = -(tx15*tx78*tx794*tx800*tx86); 		/* rule 582 */
_ChiralRestraint_termCode.cc:584:	 tx437 = -(tx22*tx60*tx797*tx800*tx95); 		/* rule 583 */
_ChiralRestraint_termCode.cc:590:	 tx441 = -(tx103*tx22*tx60*tx797*tx800); 		/* rule 589 */
_ChiralRestraint_termCode.cc:592:	 tx443 = -(tx27*tx78*tx794*tx800*tx86); 		/* rule 591 */
_ChiralRestraint_termCode.cc:599:	 tx448 = -tx427; 		/* rule 598 */
_ChiralRestraint_termCode.cc:601:	 tx450 = -(tx117*tx22*tx60*tx797*tx800); 		/* rule 600 */
_ChiralRestraint_termCode.cc:603:	 tx452 = -(tx118*tx22*tx52*tx60*tx797*tx8); 		/* rule 602 */
_ChiralRestraint_termCode.cc:612:	 tx459 = -tx435; 		/* rule 611 */
_ChiralRestraint_termCode.cc:614:	 tx461 = -(tx134*tx22*tx60*tx797*tx800); 		/* rule 613 */
_ChiralRestraint_termCode.cc:617:	 tx464 = -(tx118*tx52*tx60*tx797*tx84); 		/* rule 616 */
_ChiralRestraint_termCode.cc:624:	 tx469 = -tx442; 		/* rule 623 */
_ChiralRestraint_termCode.cc:625:	 tx470 = -3*tx165*tx34*tx52*tx797*tx800; 		/* rule 624 */
_ChiralRestraint_termCode.cc:626:	 tx471 = -(tx150*tx22*tx60*tx797*tx800); 		/* rule 625 */
_ChiralRestraint_termCode.cc:627:	 tx472 = -(tx118*tx22*tx30*tx52*tx60*tx797); 		/* rule 626 */
_ChiralRestraint_termCode.cc:636:	 tx479 = -tx453; 		/* rule 635 */
_ChiralRestraint_termCode.cc:637:	 tx480 = -(tx22*tx42*tx60*tx797*tx800); 		/* rule 636 */
_ChiralRestraint_termCode.cc:645:	 tx486 = -tx462; 		/* rule 644 */
_ChiralRestraint_termCode.cc:646:	 tx487 = -(tx22*tx39*tx60*tx797*tx800); 		/* rule 645 */
_ChiralRestraint_termCode.cc:654:	 tx493 = -tx473; 		/* rule 653 */
_ChiralRestraint_termCode.cc:655:	 tx494 = -(tx22*tx37*tx60*tx797*tx800); 		/* rule 654 */
_ChiralRestraint_termCode.cc:663:	 tx500 = -(tx15*tx794*tx800*tx86*tx87); 		/* rule 662 */
_ChiralRestraint_termCode.cc:664:	 tx501 = -(tx7*tx794*tx800*tx86*tx95); 		/* rule 663 */
_ChiralRestraint_termCode.cc:671:	 tx506 = -(tx103*tx7*tx794*tx800*tx86); 		/* rule 670 */
_ChiralRestraint_termCode.cc:672:	 tx507 = -(tx27*tx794*tx800*tx86*tx87); 		/* rule 671 */
_ChiralRestraint_termCode.cc:678:	 tx511 = -3*tx185*tx40*tx52*tx794*tx800; 		/* rule 677 */
_ChiralRestraint_termCode.cc:680:	 tx513 = -(tx117*tx7*tx794*tx800*tx86); 		/* rule 679 */
_ChiralRestraint_termCode.cc:681:	 tx514 = -(tx118*tx52*tx7*tx794*tx8*tx86); 		/* rule 680 */
_ChiralRestraint_termCode.cc:692:	 tx523 = -3*tx15*tx185*tx52*tx7*tx794*tx800; 		/* rule 691 */
_ChiralRestraint_termCode.cc:693:	 tx524 = -(tx134*tx7*tx794*tx800*tx86); 		/* rule 692 */
_ChiralRestraint_termCode.cc:694:	 tx525 = -(tx118*tx52*tx76*tx794*tx86); 		/* rule 693 */
_ChiralRestraint_termCode.cc:705:	 tx534 = -3*tx185*tx27*tx52*tx7*tx794*tx800; 		/* rule 704 */
_ChiralRestraint_termCode.cc:706:	 tx535 = -(tx150*tx7*tx794*tx800*tx86); 		/* rule 705 */
_ChiralRestraint_termCode.cc:707:	 tx536 = -(tx118*tx30*tx52*tx7*tx794*tx86); 		/* rule 706 */
_ChiralRestraint_termCode.cc:716:	 tx543 = -tx516; 		/* rule 715 */
_ChiralRestraint_termCode.cc:717:	 tx544 = -(tx42*tx7*tx794*tx800*tx86); 		/* rule 716 */
_ChiralRestraint_termCode.cc:725:	 tx550 = -tx526; 		/* rule 724 */
_ChiralRestraint_termCode.cc:726:	 tx551 = -(tx39*tx7*tx794*tx800*tx86); 		/* rule 725 */
_ChiralRestraint_termCode.cc:733:	 tx556 = -tx537; 		/* rule 732 */
_ChiralRestraint_termCode.cc:735:	 tx558 = -(tx37*tx7*tx794*tx800*tx86); 		/* rule 734 */
_ChiralRestraint_termCode.cc:743:	 tx564 = -(tx103*tx15*tx794*tx800*tx86); 		/* rule 742 */
_ChiralRestraint_termCode.cc:744:	 tx565 = -(tx27*tx794*tx800*tx86*tx95); 		/* rule 743 */
_ChiralRestraint_termCode.cc:752:	 tx571 = -(tx117*tx15*tx794*tx800*tx86); 		/* rule 751 */
_ChiralRestraint_termCode.cc:753:	 tx572 = -(tx118*tx15*tx52*tx794*tx8*tx86); 		/* rule 752 */
_ChiralRestraint_termCode.cc:762:	 tx579 = -3*tx185*tx32*tx52*tx794*tx800; 		/* rule 761 */
_ChiralRestraint_termCode.cc:763:	 tx580 = -(tx134*tx15*tx794*tx800*tx86); 		/* rule 762 */
_ChiralRestraint_termCode.cc:764:	 tx581 = -(tx118*tx15*tx17*tx52*tx794*tx86); 		/* rule 763 */
_ChiralRestraint_termCode.cc:774:	 tx589 = -3*tx15*tx185*tx27*tx52*tx794*tx800; 		/* rule 773 */
_ChiralRestraint_termCode.cc:776:	 tx591 = -(tx15*tx150*tx794*tx800*tx86); 		/* rule 775 */
_ChiralRestraint_termCode.cc:777:	 tx592 = -(tx118*tx52*tx58*tx794*tx86); 		/* rule 776 */
_ChiralRestraint_termCode.cc:786:	 tx599 = -tx574; 		/* rule 785 */
_ChiralRestraint_termCode.cc:787:	 tx600 = -(tx15*tx42*tx794*tx800*tx86); 		/* rule 786 */
_ChiralRestraint_termCode.cc:795:	 tx606 = -tx582; 		/* rule 794 */
_ChiralRestraint_termCode.cc:796:	 tx607 = -(tx15*tx39*tx794*tx800*tx86); 		/* rule 795 */
_ChiralRestraint_termCode.cc:804:	 tx613 = -tx593; 		/* rule 803 */
_ChiralRestraint_termCode.cc:805:	 tx614 = -(tx15*tx37*tx794*tx800*tx86); 		/* rule 804 */
_ChiralRestraint_termCode.cc:816:	 tx623 = -(tx117*tx27*tx794*tx800*tx86); 		/* rule 815 */
_ChiralRestraint_termCode.cc:817:	 tx624 = -(tx118*tx52*tx69*tx794*tx86); 		/* rule 816 */
_ChiralRestraint_termCode.cc:829:	 tx634 = -(tx134*tx27*tx794*tx800*tx86); 		/* rule 828 */
_ChiralRestraint_termCode.cc:830:	 tx635 = -(tx118*tx17*tx27*tx52*tx794*tx86); 		/* rule 829 */
_ChiralRestraint_termCode.cc:837:	 tx640 = -3*tx185*tx35*tx52*tx794*tx800; 		/* rule 836 */
_ChiralRestraint_termCode.cc:840:	 tx643 = -(tx150*tx27*tx794*tx800*tx86); 		/* rule 839 */
_ChiralRestraint_termCode.cc:841:	 tx644 = -(tx118*tx27*tx30*tx52*tx794*tx86); 		/* rule 840 */
_ChiralRestraint_termCode.cc:848:	 tx649 = -tx622; 		/* rule 847 */
_ChiralRestraint_termCode.cc:849:	 tx650 = -(tx27*tx42*tx794*tx800*tx86); 		/* rule 848 */
_ChiralRestraint_termCode.cc:857:	 tx656 = -tx630; 		/* rule 856 */
_ChiralRestraint_termCode.cc:858:	 tx657 = -(tx27*tx39*tx794*tx800*tx86); 		/* rule 857 */
_ChiralRestraint_termCode.cc:865:	 tx662 = -tx639; 		/* rule 864 */
_ChiralRestraint_termCode.cc:866:	 tx663 = -(tx27*tx37*tx794*tx800*tx86); 		/* rule 865 */
_ChiralRestraint_termCode.cc:899:	 tx690 = -3*tx205*tx41*tx52*tx794*tx797; 		/* rule 898 */
_ChiralRestraint_termCode.cc:901:	 tx692 = -(tx117*tx118*tx794*tx797*tx8); 		/* rule 900 */
_ChiralRestraint_termCode.cc:910:	 tx699 = -tx668; 		/* rule 909 */
_ChiralRestraint_termCode.cc:912:	 tx701 = -3*tx17*tx205*tx52*tx794*tx797*tx8; 		/* rule 911 */
_ChiralRestraint_termCode.cc:921:	 tx708 = -tx678; 		/* rule 920 */
_ChiralRestraint_termCode.cc:923:	 tx710 = -3*tx205*tx30*tx52*tx794*tx797*tx8; 		/* rule 922 */
_ChiralRestraint_termCode.cc:945:	 tx728 = -tx671; 		/* rule 944 */
_ChiralRestraint_termCode.cc:952:	 tx733 = -(tx118*tx134*tx17*tx794*tx797); 		/* rule 951 */
_ChiralRestraint_termCode.cc:954:	 tx735 = -3*tx205*tx33*tx52*tx794*tx797; 		/* rule 953 */
_ChiralRestraint_termCode.cc:964:	 tx743 = -3*tx17*tx205*tx30*tx52*tx794*tx797; 		/* rule 963 */
_ChiralRestraint_termCode.cc:966:	 tx745 = -tx716; 		/* rule 965 */
_ChiralRestraint_termCode.cc:976:	 tx753 = -tx681; 		/* rule 975 */
_ChiralRestraint_termCode.cc:986:	 tx761 = -tx715; 		/* rule 985 */
_ChiralRestraint_termCode.cc:993:	 tx766 = -(tx118*tx150*tx30*tx794*tx797); 		/* rule 992 */
_ChiralRestraint_termCode.cc:995:	 tx768 = -3*tx205*tx36*tx52*tx794*tx797; 		/* rule 994 */
_ChiralRestraint_termCode.cc:1003:	 tx774 = -tx700; 		/* rule 1002 */
_ChiralRestraint_termCode.cc:1004:	 tx775 = -tx725; 		/* rule 1003 */
_ChiralRestraint_termCode.cc:1010:	 tx779 = -tx709; 		/* rule 1009 */
_ChiralRestraint_termCode.cc:1011:	 tx780 = -tx750; 		/* rule 1010 */
_ChiralRestraint_termCode.cc:1017:	 tx784 = -tx741; 		/* rule 1016 */
_ChiralRestraint_termCode.cc:1018:	 tx785 = -tx758; 		/* rule 1017 */
_Dihedral_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_Dihedral_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalx3", this->eval.x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaly3", this->eval.y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalz3", this->eval.z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalx4", this->eval.x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evaly4", this->eval.y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalz4", this->eval.z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalV", this->eval.V, 0.0 );
_Dihedral_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalDN", this->eval.DN, 0.0 );
_Dihedral_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalIN", this->eval.IN, 0.0 );
_Dihedral_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalcosPhase", this->eval.cosPhase, 0.0 );
_Dihedral_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalsinPhase", this->eval.sinPhase, 0.0 );
_Dihedral_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_Dihedral_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_Dihedral_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_Dihedral_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_Dihedral_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_Dihedral_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_Dihedral_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_Dihedral_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evalfx3", this->eval.fx3, 0.0 );
_Dihedral_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evalfy3", this->eval.fy3, 0.0 );
_Dihedral_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evalfz3", this->eval.fz3, 0.0 );
_Dihedral_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evalfx4", this->eval.fx4, 0.0 );
_Dihedral_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evalfy4", this->eval.fy4, 0.0 );
_Dihedral_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evalfz4", this->eval.fz4, 0.0 );
_Dihedral_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_Dihedral_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evaldhx3x3", this->eval.dhx3x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:39: 	node->attributeIfNotDefault("evaldhy3y3", this->eval.dhy3y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:40: 	node->attributeIfNotDefault("evaldhz3z3", this->eval.dhz3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:41: 	node->attributeIfNotDefault("evaldhx4x4", this->eval.dhx4x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:42: 	node->attributeIfNotDefault("evaldhy4y4", this->eval.dhy4y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:43: 	node->attributeIfNotDefault("evaldhz4z4", this->eval.dhz4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:44: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_Dihedral_debugEvalSerialize.cc:45: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:46: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:47: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:48: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:49: 	node->attributeIfNotDefault("evalohx1x3", this->eval.ohx1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:50: 	node->attributeIfNotDefault("evalohx1y3", this->eval.ohx1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:51: 	node->attributeIfNotDefault("evalohx1z3", this->eval.ohx1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:52: 	node->attributeIfNotDefault("evalohx1x4", this->eval.ohx1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:53: 	node->attributeIfNotDefault("evalohx1y4", this->eval.ohx1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:54: 	node->attributeIfNotDefault("evalohx1z4", this->eval.ohx1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:55: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_Dihedral_debugEvalSerialize.cc:56: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:57: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:58: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:59: 	node->attributeIfNotDefault("evalohy1x3", this->eval.ohy1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:60: 	node->attributeIfNotDefault("evalohy1y3", this->eval.ohy1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:61: 	node->attributeIfNotDefault("evalohy1z3", this->eval.ohy1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:62: 	node->attributeIfNotDefault("evalohy1x4", this->eval.ohy1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:63: 	node->attributeIfNotDefault("evalohy1y4", this->eval.ohy1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:64: 	node->attributeIfNotDefault("evalohy1z4", this->eval.ohy1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:65: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_Dihedral_debugEvalSerialize.cc:66: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:67: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:68: 	node->attributeIfNotDefault("evalohz1x3", this->eval.ohz1x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:69: 	node->attributeIfNotDefault("evalohz1y3", this->eval.ohz1y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:70: 	node->attributeIfNotDefault("evalohz1z3", this->eval.ohz1z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:71: 	node->attributeIfNotDefault("evalohz1x4", this->eval.ohz1x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:72: 	node->attributeIfNotDefault("evalohz1y4", this->eval.ohz1y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:73: 	node->attributeIfNotDefault("evalohz1z4", this->eval.ohz1z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:74: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_Dihedral_debugEvalSerialize.cc:75: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:76: 	node->attributeIfNotDefault("evalohx2x3", this->eval.ohx2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:77: 	node->attributeIfNotDefault("evalohx2y3", this->eval.ohx2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:78: 	node->attributeIfNotDefault("evalohx2z3", this->eval.ohx2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:79: 	node->attributeIfNotDefault("evalohx2x4", this->eval.ohx2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:80: 	node->attributeIfNotDefault("evalohx2y4", this->eval.ohx2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:81: 	node->attributeIfNotDefault("evalohx2z4", this->eval.ohx2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:82: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_Dihedral_debugEvalSerialize.cc:83: 	node->attributeIfNotDefault("evalohy2x3", this->eval.ohy2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:84: 	node->attributeIfNotDefault("evalohy2y3", this->eval.ohy2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:85: 	node->attributeIfNotDefault("evalohy2z3", this->eval.ohy2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:86: 	node->attributeIfNotDefault("evalohy2x4", this->eval.ohy2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:87: 	node->attributeIfNotDefault("evalohy2y4", this->eval.ohy2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:88: 	node->attributeIfNotDefault("evalohy2z4", this->eval.ohy2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:89: 	node->attributeIfNotDefault("evalohz2x3", this->eval.ohz2x3, 0.0 );
_Dihedral_debugEvalSerialize.cc:90: 	node->attributeIfNotDefault("evalohz2y3", this->eval.ohz2y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:91: 	node->attributeIfNotDefault("evalohz2z3", this->eval.ohz2z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:92: 	node->attributeIfNotDefault("evalohz2x4", this->eval.ohz2x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:93: 	node->attributeIfNotDefault("evalohz2y4", this->eval.ohz2y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:94: 	node->attributeIfNotDefault("evalohz2z4", this->eval.ohz2z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:95: 	node->attributeIfNotDefault("evalohx3y3", this->eval.ohx3y3, 0.0 );
_Dihedral_debugEvalSerialize.cc:96: 	node->attributeIfNotDefault("evalohx3z3", this->eval.ohx3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:97: 	node->attributeIfNotDefault("evalohx3x4", this->eval.ohx3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:98: 	node->attributeIfNotDefault("evalohx3y4", this->eval.ohx3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:99: 	node->attributeIfNotDefault("evalohx3z4", this->eval.ohx3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:100: 	node->attributeIfNotDefault("evalohy3z3", this->eval.ohy3z3, 0.0 );
_Dihedral_debugEvalSerialize.cc:101: 	node->attributeIfNotDefault("evalohy3x4", this->eval.ohy3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:102: 	node->attributeIfNotDefault("evalohy3y4", this->eval.ohy3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:103: 	node->attributeIfNotDefault("evalohy3z4", this->eval.ohy3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:104: 	node->attributeIfNotDefault("evalohz3x4", this->eval.ohz3x4, 0.0 );
_Dihedral_debugEvalSerialize.cc:105: 	node->attributeIfNotDefault("evalohz3y4", this->eval.ohz3y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:106: 	node->attributeIfNotDefault("evalohz3z4", this->eval.ohz3z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:107: 	node->attributeIfNotDefault("evalohx4y4", this->eval.ohx4y4, 0.0 );
_Dihedral_debugEvalSerialize.cc:108: 	node->attributeIfNotDefault("evalohx4z4", this->eval.ohx4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:109: 	node->attributeIfNotDefault("evalohy4z4", this->eval.ohy4z4, 0.0 );
_Dihedral_debugEvalSerialize.cc:110: 	node->attributeIfNotDefault("evalDihedralDeviation", this->eval.DihedralDeviation, 0.0 );
_Dihedral_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_Dihedral_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_Dihedral_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_Dihedral_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_Dihedral_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_Dihedral_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_Dihedral_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("x3", this->eval.x3);
_Dihedral_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("y3", this->eval.y3);
_Dihedral_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("z3", this->eval.z3);
_Dihedral_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("x4", this->eval.x4);
_Dihedral_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("y4", this->eval.y4);
_Dihedral_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("z4", this->eval.z4);
_Dihedral_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("V", this->eval.V);
_Dihedral_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("DN", this->eval.DN);
_Dihedral_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("IN", this->eval.IN);
_Dihedral_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("cosPhase", this->eval.cosPhase);
_Dihedral_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("sinPhase", this->eval.sinPhase);
_Dihedral_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_Dihedral_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_Dihedral_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_Dihedral_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_Dihedral_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_Dihedral_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_Dihedral_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_Dihedral_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("fx3", this->eval.fx3);
_Dihedral_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("fy3", this->eval.fy3);
_Dihedral_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("fz3", this->eval.fz3);
_Dihedral_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("fx4", this->eval.fx4);
_Dihedral_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("fy4", this->eval.fy4);
_Dihedral_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("fz4", this->eval.fz4);
_Dihedral_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_Dihedral_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_Dihedral_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_Dihedral_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_Dihedral_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_Dihedral_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_Dihedral_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("dhx3x3", this->eval.dhx3x3);
_Dihedral_debugEvalXml.cc:39: 	xml->addAttributeDoubleScientific ("dhy3y3", this->eval.dhy3y3);
_Dihedral_debugEvalXml.cc:40: 	xml->addAttributeDoubleScientific ("dhz3z3", this->eval.dhz3z3);
_Dihedral_debugEvalXml.cc:41: 	xml->addAttributeDoubleScientific ("dhx4x4", this->eval.dhx4x4);
_Dihedral_debugEvalXml.cc:42: 	xml->addAttributeDoubleScientific ("dhy4y4", this->eval.dhy4y4);
_Dihedral_debugEvalXml.cc:43: 	xml->addAttributeDoubleScientific ("dhz4z4", this->eval.dhz4z4);
_Dihedral_debugEvalXml.cc:44: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_Dihedral_debugEvalXml.cc:45: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_Dihedral_debugEvalXml.cc:46: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_Dihedral_debugEvalXml.cc:47: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_Dihedral_debugEvalXml.cc:48: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_Dihedral_debugEvalXml.cc:49: 	xml->addAttributeDoubleScientific ("ohx1x3", this->eval.ohx1x3);
_Dihedral_debugEvalXml.cc:50: 	xml->addAttributeDoubleScientific ("ohx1y3", this->eval.ohx1y3);
_Dihedral_debugEvalXml.cc:51: 	xml->addAttributeDoubleScientific ("ohx1z3", this->eval.ohx1z3);
_Dihedral_debugEvalXml.cc:52: 	xml->addAttributeDoubleScientific ("ohx1x4", this->eval.ohx1x4);
_Dihedral_debugEvalXml.cc:53: 	xml->addAttributeDoubleScientific ("ohx1y4", this->eval.ohx1y4);
_Dihedral_debugEvalXml.cc:54: 	xml->addAttributeDoubleScientific ("ohx1z4", this->eval.ohx1z4);
_Dihedral_debugEvalXml.cc:55: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_Dihedral_debugEvalXml.cc:56: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_Dihedral_debugEvalXml.cc:57: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_Dihedral_debugEvalXml.cc:58: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_Dihedral_debugEvalXml.cc:59: 	xml->addAttributeDoubleScientific ("ohy1x3", this->eval.ohy1x3);
_Dihedral_debugEvalXml.cc:60: 	xml->addAttributeDoubleScientific ("ohy1y3", this->eval.ohy1y3);
_Dihedral_debugEvalXml.cc:61: 	xml->addAttributeDoubleScientific ("ohy1z3", this->eval.ohy1z3);
_Dihedral_debugEvalXml.cc:62: 	xml->addAttributeDoubleScientific ("ohy1x4", this->eval.ohy1x4);
_Dihedral_debugEvalXml.cc:63: 	xml->addAttributeDoubleScientific ("ohy1y4", this->eval.ohy1y4);
_Dihedral_debugEvalXml.cc:64: 	xml->addAttributeDoubleScientific ("ohy1z4", this->eval.ohy1z4);
_Dihedral_debugEvalXml.cc:65: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_Dihedral_debugEvalXml.cc:66: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_Dihedral_debugEvalXml.cc:67: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_Dihedral_debugEvalXml.cc:68: 	xml->addAttributeDoubleScientific ("ohz1x3", this->eval.ohz1x3);
_Dihedral_debugEvalXml.cc:69: 	xml->addAttributeDoubleScientific ("ohz1y3", this->eval.ohz1y3);
_Dihedral_debugEvalXml.cc:70: 	xml->addAttributeDoubleScientific ("ohz1z3", this->eval.ohz1z3);
_Dihedral_debugEvalXml.cc:71: 	xml->addAttributeDoubleScientific ("ohz1x4", this->eval.ohz1x4);
_Dihedral_debugEvalXml.cc:72: 	xml->addAttributeDoubleScientific ("ohz1y4", this->eval.ohz1y4);
_Dihedral_debugEvalXml.cc:73: 	xml->addAttributeDoubleScientific ("ohz1z4", this->eval.ohz1z4);
_Dihedral_debugEvalXml.cc:74: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_Dihedral_debugEvalXml.cc:75: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_Dihedral_debugEvalXml.cc:76: 	xml->addAttributeDoubleScientific ("ohx2x3", this->eval.ohx2x3);
_Dihedral_debugEvalXml.cc:77: 	xml->addAttributeDoubleScientific ("ohx2y3", this->eval.ohx2y3);
_Dihedral_debugEvalXml.cc:78: 	xml->addAttributeDoubleScientific ("ohx2z3", this->eval.ohx2z3);
_Dihedral_debugEvalXml.cc:79: 	xml->addAttributeDoubleScientific ("ohx2x4", this->eval.ohx2x4);
_Dihedral_debugEvalXml.cc:80: 	xml->addAttributeDoubleScientific ("ohx2y4", this->eval.ohx2y4);
_Dihedral_debugEvalXml.cc:81: 	xml->addAttributeDoubleScientific ("ohx2z4", this->eval.ohx2z4);
_Dihedral_debugEvalXml.cc:82: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_Dihedral_debugEvalXml.cc:83: 	xml->addAttributeDoubleScientific ("ohy2x3", this->eval.ohy2x3);
_Dihedral_debugEvalXml.cc:84: 	xml->addAttributeDoubleScientific ("ohy2y3", this->eval.ohy2y3);
_Dihedral_debugEvalXml.cc:85: 	xml->addAttributeDoubleScientific ("ohy2z3", this->eval.ohy2z3);
_Dihedral_debugEvalXml.cc:86: 	xml->addAttributeDoubleScientific ("ohy2x4", this->eval.ohy2x4);
_Dihedral_debugEvalXml.cc:87: 	xml->addAttributeDoubleScientific ("ohy2y4", this->eval.ohy2y4);
_Dihedral_debugEvalXml.cc:88: 	xml->addAttributeDoubleScientific ("ohy2z4", this->eval.ohy2z4);
_Dihedral_debugEvalXml.cc:89: 	xml->addAttributeDoubleScientific ("ohz2x3", this->eval.ohz2x3);
_Dihedral_debugEvalXml.cc:90: 	xml->addAttributeDoubleScientific ("ohz2y3", this->eval.ohz2y3);
_Dihedral_debugEvalXml.cc:91: 	xml->addAttributeDoubleScientific ("ohz2z3", this->eval.ohz2z3);
_Dihedral_debugEvalXml.cc:92: 	xml->addAttributeDoubleScientific ("ohz2x4", this->eval.ohz2x4);
_Dihedral_debugEvalXml.cc:93: 	xml->addAttributeDoubleScientific ("ohz2y4", this->eval.ohz2y4);
_Dihedral_debugEvalXml.cc:94: 	xml->addAttributeDoubleScientific ("ohz2z4", this->eval.ohz2z4);
_Dihedral_debugEvalXml.cc:95: 	xml->addAttributeDoubleScientific ("ohx3y3", this->eval.ohx3y3);
_Dihedral_debugEvalXml.cc:96: 	xml->addAttributeDoubleScientific ("ohx3z3", this->eval.ohx3z3);
_Dihedral_debugEvalXml.cc:97: 	xml->addAttributeDoubleScientific ("ohx3x4", this->eval.ohx3x4);
_Dihedral_debugEvalXml.cc:98: 	xml->addAttributeDoubleScientific ("ohx3y4", this->eval.ohx3y4);
_Dihedral_debugEvalXml.cc:99: 	xml->addAttributeDoubleScientific ("ohx3z4", this->eval.ohx3z4);
_Dihedral_debugEvalXml.cc:100: 	xml->addAttributeDoubleScientific ("ohy3z3", this->eval.ohy3z3);
_Dihedral_debugEvalXml.cc:101: 	xml->addAttributeDoubleScientific ("ohy3x4", this->eval.ohy3x4);
_Dihedral_debugEvalXml.cc:102: 	xml->addAttributeDoubleScientific ("ohy3y4", this->eval.ohy3y4);
_Dihedral_debugEvalXml.cc:103: 	xml->addAttributeDoubleScientific ("ohy3z4", this->eval.ohy3z4);
_Dihedral_debugEvalXml.cc:104: 	xml->addAttributeDoubleScientific ("ohz3x4", this->eval.ohz3x4);
_Dihedral_debugEvalXml.cc:105: 	xml->addAttributeDoubleScientific ("ohz3y4", this->eval.ohz3y4);
_Dihedral_debugEvalXml.cc:106: 	xml->addAttributeDoubleScientific ("ohz3z4", this->eval.ohz3z4);
_Dihedral_debugEvalXml.cc:107: 	xml->addAttributeDoubleScientific ("ohx4y4", this->eval.ohx4y4);
_Dihedral_debugEvalXml.cc:108: 	xml->addAttributeDoubleScientific ("ohx4z4", this->eval.ohx4z4);
_Dihedral_debugEvalXml.cc:109: 	xml->addAttributeDoubleScientific ("ohy4z4", this->eval.ohy4z4);
_Dihedral_debugEvalXml.cc:110: 	xml->addAttributeDoubleScientific ("DihedralDeviation", this->eval.DihedralDeviation);
_Dihedral_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:18:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:23:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:63:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:70:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:71:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:72:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:78:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:79:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:80:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:86:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:88:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:94:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:96:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:102:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:104:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:110:(-delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:112:(-delta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:118:(-delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:120:(-delta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:126:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:128:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:134:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:136:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:142:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:144:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:150:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:152:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:157:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:164:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:165:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:166:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:172:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:174:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:180:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:182:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:188:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:190:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:196:(x1, -delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:198:(x1, -delta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:204:(x1, -delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:206:(x1, -delta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:212:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:214:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:220:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:222:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:228:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:230:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:236:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:238:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:243:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:250:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:252:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:258:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:260:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:266:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:268:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:274:(x1, y1, -delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:276:(x1, y1, -delta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:282:(x1, y1, -delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:284:(x1, y1, -delta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:290:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:292:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:298:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:300:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:306:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:308:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:314:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:316:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:321:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:328:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:330:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:336:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:338:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:344:(x1, y1, z1, -delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:346:(x1, y1, z1, -delta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:352:(x1, y1, z1, -delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:354:(x1, y1, z1, -delta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:360:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:362:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:368:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:370:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:376:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:378:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:384:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:386:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:391:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:398:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:400:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:406:(x1, y1, z1, x2, -delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:408:(x1, y1, z1, x2, -delta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:414:(x1, y1, z1, x2, -delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:416:(x1, y1, z1, x2, -delta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:422:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:424:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:430:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:432:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:438:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:440:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:446:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:448:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, -delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, -delta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, -delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, -delta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, -delta2 + x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, -delta2 + x3, delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, V, DN, IN, cosPhase, sinPhase),
_Dihedral_termCode.cc:1:// C-code
_Dihedral_termCode.cc:23:	 tx1 = -(x2*y1); 		/* rule 22 */
_Dihedral_termCode.cc:26:	 tx4 = -(x3*y2); 		/* rule 25 */
_Dihedral_termCode.cc:27:	 tx5 = -(x1*y3); 		/* rule 26 */
_Dihedral_termCode.cc:30:	 tx8 = -(x3*z1); 		/* rule 29 */
_Dihedral_termCode.cc:31:	 tx9 = -(y2*z1); 		/* rule 30 */
_Dihedral_termCode.cc:33:	 tx11 = -(x1*z2); 		/* rule 32 */
_Dihedral_termCode.cc:36:	 tx14 = -(y3*z2); 		/* rule 35 */
_Dihedral_termCode.cc:38:	 tx16 = -(x2*z3); 		/* rule 37 */
_Dihedral_termCode.cc:39:	 tx17 = -(y1*z3); 		/* rule 38 */
_Dihedral_termCode.cc:50:	 tx27 = -(x4*y3); 		/* rule 49 */
_Dihedral_termCode.cc:51:	 tx28 = -(x2*y4); 		/* rule 50 */
_Dihedral_termCode.cc:53:	 tx30 = -(x4*z2); 		/* rule 52 */
_Dihedral_termCode.cc:56:	 tx33 = -(y4*z3); 		/* rule 55 */
_Dihedral_termCode.cc:58:	 tx35 = -(x3*z4); 		/* rule 57 */
_Dihedral_termCode.cc:59:	 tx36 = -(y2*z4); 		/* rule 58 */
_Dihedral_termCode.cc:81:	 tx49 = -x3; 		/* rule 80 */
_Dihedral_termCode.cc:82:	 tx50 = -y3; 		/* rule 81 */
_Dihedral_termCode.cc:83:	 tx51 = -z3; 		/* rule 82 */
_Dihedral_termCode.cc:100:	CosPhi=MAX(-1.0,MIN(1.0,CosPhi));
_Dihedral_termCode.cc:112:	 tx70 = -(CosNPhi*sinPhase); 		/* rule 111 */
_Dihedral_termCode.cc:114:	 DeDPhi = -(DN*EraseLinearDihedral*tx71*V); 		/* rule 113 */
_Dihedral_termCode.cc:116:	 gx1 = -(DeDPhi*tx21*tx65*tx72); 		/* rule 115 */
_Dihedral_termCode.cc:117:	 fx1 = -gx1; 		/* rule 116 */
_Dihedral_termCode.cc:119:	 gy1 = -(DeDPhi*tx20*tx65*tx72); 		/* rule 118 */
_Dihedral_termCode.cc:120:	 fy1 = -gy1; 		/* rule 119 */
_Dihedral_termCode.cc:122:	 gz1 = -(DeDPhi*tx19*tx65*tx72); 		/* rule 121 */
_Dihedral_termCode.cc:123:	 fz1 = -gz1; 		/* rule 122 */
_Dihedral_termCode.cc:125:	 tx73 = -x2; 		/* rule 124 */
_Dihedral_termCode.cc:126:	 tx74 = -y2; 		/* rule 125 */
_Dihedral_termCode.cc:127:	 tx75 = -z2; 		/* rule 126 */
_Dihedral_termCode.cc:142:	 tx90 = -(tx39*tx85*tx87*tx908); 		/* rule 141 */
_Dihedral_termCode.cc:146:	 fx2 = -gx2; 		/* rule 145 */
_Dihedral_termCode.cc:149:	 tx94 = -(tx38*tx85*tx87*tx908); 		/* rule 148 */
_Dihedral_termCode.cc:153:	 fy2 = -gy2; 		/* rule 152 */
_Dihedral_termCode.cc:156:	 tx98 = -(tx40*tx85*tx87*tx908); 		/* rule 155 */
_Dihedral_termCode.cc:160:	 fz2 = -gz2; 		/* rule 159 */
_Dihedral_termCode.cc:162:	 tx101 = -(tx39*tx65*tx85); 		/* rule 161 */
_Dihedral_termCode.cc:164:	 tx103 = -tx91; 		/* rule 163 */
_Dihedral_termCode.cc:167:	 fx3 = -gx3; 		/* rule 166 */
_Dihedral_termCode.cc:169:	 tx105 = -(tx38*tx65*tx85); 		/* rule 168 */
_Dihedral_termCode.cc:171:	 tx107 = -tx95; 		/* rule 170 */
_Dihedral_termCode.cc:174:	 fy3 = -gy3; 		/* rule 173 */
_Dihedral_termCode.cc:176:	 tx109 = -(tx40*tx65*tx85); 		/* rule 175 */
_Dihedral_termCode.cc:178:	 tx111 = -tx99; 		/* rule 177 */
_Dihedral_termCode.cc:181:	 fz3 = -gz3; 		/* rule 180 */
_Dihedral_termCode.cc:184:	 fx4 = -gx4; 		/* rule 183 */
_Dihedral_termCode.cc:187:	 fy4 = -gy4; 		/* rule 186 */
_Dihedral_termCode.cc:190:	 fz4 = -gz4; 		/* rule 189 */
_Dihedral_termCode.cc:212:	 tx131 = -2.*tx3*y3; 		/* rule 211 */
_Dihedral_termCode.cc:215:	 tx134 = -2.*tx15*z2; 		/* rule 214 */
_Dihedral_termCode.cc:225:	 tx144 = -(tx139*tx141*tx142*tx24*tx907*V); 		/* rule 224 */
_Dihedral_termCode.cc:237:	 tx154 = -2.*tx2*x2; 		/* rule 236 */
_Dihedral_termCode.cc:250:	 tx167 = -2.*tx13*z3; 		/* rule 249 */
_Dihedral_termCode.cc:254:	 tx171 = -(tx139*tx141*tx142*tx23*tx907*V); 		/* rule 253 */
_Dihedral_termCode.cc:267:	 tx182 = -2.*tx7*x3; 		/* rule 266 */
_Dihedral_termCode.cc:269:	 tx184 = -2.*tx10*y2; 		/* rule 268 */
_Dihedral_termCode.cc:281:	 tx196 = -(tx139*tx141*tx142*tx22*tx907*V); 		/* rule 280 */
_Dihedral_termCode.cc:286:	 tx199 = -tx123; 		/* rule 285 */
_Dihedral_termCode.cc:287:	 tx200 = -tx124; 		/* rule 286 */
_Dihedral_termCode.cc:288:	 tx201 = -tx125; 		/* rule 287 */
_Dihedral_termCode.cc:289:	 tx202 = -tx126; 		/* rule 288 */
_Dihedral_termCode.cc:305:	 tx218 = -(tx3*y1); 		/* rule 304 */
_Dihedral_termCode.cc:324:	 tx237 = -2.*tx129; 		/* rule 323 */
_Dihedral_termCode.cc:325:	 tx238 = -2.*tx133; 		/* rule 324 */
_Dihedral_termCode.cc:326:	 tx239 = -tx226; 		/* rule 325 */
_Dihedral_termCode.cc:348:	 tx261 = -2.*tx26*y3; 		/* rule 347 */
_Dihedral_termCode.cc:356:	 tx269 = -2.*tx32*z2; 		/* rule 355 */
_Dihedral_termCode.cc:362:	 tx275 = -(tx12*z4); 		/* rule 361 */
_Dihedral_termCode.cc:364:	 tx277 = -(tx32*z4); 		/* rule 363 */
_Dihedral_termCode.cc:375:	 tx289 = -(tx283*tx286*tx39*tx85); 		/* rule 374 */
_Dihedral_termCode.cc:376:	 tx290 = -2.*tx141*tx281*tx908; 		/* rule 375 */
_Dihedral_termCode.cc:377:	 tx291 = -2.*tx284*tx285*tx39*tx87*tx908; 		/* rule 376 */
_Dihedral_termCode.cc:382:	 tx296 = -(tx139*tx142*tx294*V); 		/* rule 381 */
_Dihedral_termCode.cc:387:	 tx299 = -tx158; 		/* rule 386 */
_Dihedral_termCode.cc:388:	 tx300 = -tx159; 		/* rule 387 */
_Dihedral_termCode.cc:389:	 tx301 = -tx160; 		/* rule 388 */
_Dihedral_termCode.cc:390:	 tx302 = -tx161; 		/* rule 389 */
_Dihedral_termCode.cc:413:	 tx325 = -(tx13*z1); 		/* rule 412 */
_Dihedral_termCode.cc:423:	 tx335 = -2.*tx153; 		/* rule 422 */
_Dihedral_termCode.cc:424:	 tx336 = -2.*tx164; 		/* rule 423 */
_Dihedral_termCode.cc:425:	 tx337 = -tx312; 		/* rule 424 */
_Dihedral_termCode.cc:436:	 tx348 = -2.*tx29*x2; 		/* rule 435 */
_Dihedral_termCode.cc:441:	 tx353 = -(tx29*x4); 		/* rule 440 */
_Dihedral_termCode.cc:442:	 tx354 = -(tx6*x4); 		/* rule 441 */
_Dihedral_termCode.cc:459:	 tx371 = -2.*tx31*z3; 		/* rule 458 */
_Dihedral_termCode.cc:471:	 tx385 = -(tx286*tx38*tx381*tx85); 		/* rule 470 */
_Dihedral_termCode.cc:472:	 tx386 = -2.*tx141*tx379*tx908; 		/* rule 471 */
_Dihedral_termCode.cc:473:	 tx387 = -2.*tx285*tx38*tx382*tx87*tx908; 		/* rule 472 */
_Dihedral_termCode.cc:478:	 tx392 = -(tx139*tx142*tx390*V); 		/* rule 477 */
_Dihedral_termCode.cc:483:	 tx395 = -tx188; 		/* rule 482 */
_Dihedral_termCode.cc:484:	 tx396 = -tx189; 		/* rule 483 */
_Dihedral_termCode.cc:485:	 tx397 = -tx190; 		/* rule 484 */
_Dihedral_termCode.cc:486:	 tx398 = -tx191; 		/* rule 485 */
_Dihedral_termCode.cc:494:	 tx406 = -(tx7*x1); 		/* rule 493 */
_Dihedral_termCode.cc:517:	 tx429 = -2.*tx181; 		/* rule 516 */
_Dihedral_termCode.cc:518:	 tx430 = -2.*tx183; 		/* rule 517 */
_Dihedral_termCode.cc:519:	 tx431 = -tx411; 		/* rule 518 */
_Dihedral_termCode.cc:533:	 tx445 = -2.*tx34*x3; 		/* rule 532 */
_Dihedral_termCode.cc:541:	 tx453 = -2.*tx37*y2; 		/* rule 540 */
_Dihedral_termCode.cc:546:	 tx458 = -(tx18*y4); 		/* rule 545 */
_Dihedral_termCode.cc:548:	 tx460 = -(tx37*y4); 		/* rule 547 */
_Dihedral_termCode.cc:565:	 tx479 = -(tx286*tx40*tx475*tx85); 		/* rule 564 */
_Dihedral_termCode.cc:566:	 tx480 = -2.*tx141*tx473*tx908; 		/* rule 565 */
_Dihedral_termCode.cc:567:	 tx481 = -2.*tx285*tx40*tx476*tx87*tx908; 		/* rule 566 */
_Dihedral_termCode.cc:572:	 tx486 = -(tx139*tx142*tx483*V); 		/* rule 571 */
_Dihedral_termCode.cc:575:	 tx487 = -tx253; 		/* rule 574 */
_Dihedral_termCode.cc:576:	 tx488 = -tx254; 		/* rule 575 */
_Dihedral_termCode.cc:577:	 tx489 = -tx255; 		/* rule 576 */
_Dihedral_termCode.cc:578:	 tx490 = -tx256; 		/* rule 577 */
_Dihedral_termCode.cc:579:	 tx491 = -tx263; 		/* rule 578 */
_Dihedral_termCode.cc:580:	 tx492 = -2.*tx266; 		/* rule 579 */
_Dihedral_termCode.cc:581:	 tx493 = -tx266; 		/* rule 580 */
_Dihedral_termCode.cc:582:	 tx494 = -2.*tx272; 		/* rule 581 */
_Dihedral_termCode.cc:604:	 tx518 = -2.*tx283*tx285*tx39*tx65; 		/* rule 603 */
_Dihedral_termCode.cc:605:	 tx519 = -2.*tx285*tx517*tx908; 		/* rule 604 */
_Dihedral_termCode.cc:609:	 tx523 = -(tx139*tx142*tx520*V); 		/* rule 608 */
_Dihedral_termCode.cc:612:	 tx524 = -2.*tx349; 		/* rule 611 */
_Dihedral_termCode.cc:613:	 tx525 = -tx361; 		/* rule 612 */
_Dihedral_termCode.cc:614:	 tx526 = -tx362; 		/* rule 613 */
_Dihedral_termCode.cc:615:	 tx527 = -tx363; 		/* rule 614 */
_Dihedral_termCode.cc:616:	 tx528 = -tx364; 		/* rule 615 */
_Dihedral_termCode.cc:617:	 tx529 = -2.*tx373; 		/* rule 616 */
_Dihedral_termCode.cc:618:	 tx530 = -tx373; 		/* rule 617 */
_Dihedral_termCode.cc:619:	 tx531 = -tx375; 		/* rule 618 */
_Dihedral_termCode.cc:641:	 tx555 = -2.*tx285*tx38*tx381*tx65; 		/* rule 640 */
_Dihedral_termCode.cc:642:	 tx556 = -2.*tx285*tx554*tx908; 		/* rule 641 */
_Dihedral_termCode.cc:646:	 tx560 = -(tx139*tx142*tx557*V); 		/* rule 645 */
_Dihedral_termCode.cc:649:	 tx561 = -2.*tx447; 		/* rule 648 */
_Dihedral_termCode.cc:650:	 tx562 = -tx447; 		/* rule 649 */
_Dihedral_termCode.cc:651:	 tx563 = -tx450; 		/* rule 650 */
_Dihedral_termCode.cc:652:	 tx564 = -2.*tx454; 		/* rule 651 */
_Dihedral_termCode.cc:653:	 tx565 = -tx466; 		/* rule 652 */
_Dihedral_termCode.cc:654:	 tx566 = -tx467; 		/* rule 653 */
_Dihedral_termCode.cc:655:	 tx567 = -tx468; 		/* rule 654 */
_Dihedral_termCode.cc:656:	 tx568 = -tx469; 		/* rule 655 */
_Dihedral_termCode.cc:678:	 tx592 = -2.*tx285*tx40*tx475*tx65; 		/* rule 677 */
_Dihedral_termCode.cc:679:	 tx593 = -2.*tx285*tx591*tx908; 		/* rule 678 */
_Dihedral_termCode.cc:683:	 tx597 = -(tx139*tx142*tx594*V); 		/* rule 682 */
_Dihedral_termCode.cc:687:	 tx599 = -(tx139*tx142*tx285*tx42*tx907*V); 		/* rule 686 */
_Dihedral_termCode.cc:691:	 tx601 = -(tx139*tx142*tx285*tx41*tx907*V); 		/* rule 690 */
_Dihedral_termCode.cc:695:	 tx603 = -(tx139*tx142*tx285*tx43*tx907*V); 		/* rule 694 */
_Dihedral_termCode.cc:704:	 tx608 = -(tx139*tx141*tx142*tx20*tx21*tx907*V); 		/* rule 703 */
_Dihedral_termCode.cc:711:	 tx613 = -(tx139*tx141*tx142*tx19*tx21*tx907*V); 		/* rule 710 */
_Dihedral_termCode.cc:714:	 tx614 = -2.*tx140*tx141*tx21*tx65; 		/* rule 713 */
_Dihedral_termCode.cc:724:	 tx622 = -(tx141*tx606*tx65); 		/* rule 723 */
_Dihedral_termCode.cc:734:	 tx630 = -(tx141*tx611*tx65); 		/* rule 733 */
_Dihedral_termCode.cc:741:	 tx635 = -(DeDPhi*tx615); 		/* rule 740 */
_Dihedral_termCode.cc:745:	 tx637 = -(DeDPhi*tx623); 		/* rule 744 */
_Dihedral_termCode.cc:749:	 tx639 = -(DeDPhi*tx631); 		/* rule 748 */
_Dihedral_termCode.cc:763:	 tx645 = -(tx139*tx141*tx142*tx19*tx20*tx907*V); 		/* rule 762 */
_Dihedral_termCode.cc:775:	 tx653 = -2.*tx141*tx169*tx20*tx65; 		/* rule 774 */
_Dihedral_termCode.cc:785:	 tx661 = -(tx141*tx643*tx65); 		/* rule 784 */
_Dihedral_termCode.cc:792:	 tx666 = -(DeDPhi*tx649); 		/* rule 791 */
_Dihedral_termCode.cc:796:	 tx668 = -(DeDPhi*tx654); 		/* rule 795 */
_Dihedral_termCode.cc:800:	 tx670 = -(DeDPhi*tx662); 		/* rule 799 */
_Dihedral_termCode.cc:828:	 tx686 = -2.*tx141*tx19*tx194*tx65; 		/* rule 827 */
_Dihedral_termCode.cc:835:	 tx691 = -(DeDPhi*tx675); 		/* rule 834 */
_Dihedral_termCode.cc:839:	 tx693 = -(DeDPhi*tx682); 		/* rule 838 */
_Dihedral_termCode.cc:843:	 tx695 = -(DeDPhi*tx687); 		/* rule 842 */
_Dihedral_termCode.cc:862:	 tx706 = -tx623; 		/* rule 861 */
_Dihedral_termCode.cc:863:	 tx707 = -tx649; 		/* rule 862 */
_Dihedral_termCode.cc:866:	 tx710 = -0.5*tx286*tx704*tx85; 		/* rule 865 */
_Dihedral_termCode.cc:867:	 tx711 = -(tx285*tx705*tx87*tx908); 		/* rule 866 */
_Dihedral_termCode.cc:871:	 tx715 = -(tx139*tx142*tx92*tx96*V); 		/* rule 870 */
_Dihedral_termCode.cc:883:	 tx725 = -tx631; 		/* rule 882 */
_Dihedral_termCode.cc:885:	 tx727 = -tx675; 		/* rule 884 */
_Dihedral_termCode.cc:887:	 tx729 = -0.5*tx286*tx723*tx85; 		/* rule 886 */
_Dihedral_termCode.cc:888:	 tx730 = -(tx285*tx724*tx87*tx908); 		/* rule 887 */
_Dihedral_termCode.cc:892:	 tx734 = -(tx100*tx139*tx142*tx92*V); 		/* rule 891 */
_Dihedral_termCode.cc:895:	 tx735 = -tx288; 		/* rule 894 */
_Dihedral_termCode.cc:899:	 tx739 = -2.*tx141*tx21*tx282*tx88*tx908; 		/* rule 898 */
_Dihedral_termCode.cc:902:	 tx742 = -(tx104*tx139*tx142*tx92*V); 		/* rule 901 */
_Dihedral_termCode.cc:908:	 tx746 = -tx712; 		/* rule 907 */
_Dihedral_termCode.cc:909:	 tx747 = -0.5*tx286*tx606*tx72; 		/* rule 908 */
_Dihedral_termCode.cc:915:	 tx753 = -(tx108*tx139*tx142*tx92*V); 		/* rule 914 */
_Dihedral_termCode.cc:921:	 tx757 = -0.5*tx286*tx611*tx72; 		/* rule 920 */
_Dihedral_termCode.cc:922:	 tx758 = -tx731; 		/* rule 921 */
_Dihedral_termCode.cc:928:	 tx764 = -(tx112*tx139*tx142*tx92*V); 		/* rule 927 */
_Dihedral_termCode.cc:931:	 tx765 = -(DeDPhi*tx737); 		/* rule 930 */
_Dihedral_termCode.cc:935:	 tx767 = -(DeDPhi*tx749); 		/* rule 934 */
_Dihedral_termCode.cc:939:	 tx769 = -(DeDPhi*tx760); 		/* rule 938 */
_Dihedral_termCode.cc:953:	 tx781 = -tx662; 		/* rule 952 */
_Dihedral_termCode.cc:954:	 tx782 = -tx682; 		/* rule 953 */
_Dihedral_termCode.cc:956:	 tx784 = -0.5*tx286*tx778*tx85; 		/* rule 955 */
_Dihedral_termCode.cc:957:	 tx785 = -(tx285*tx779*tx87*tx908); 		/* rule 956 */
_Dihedral_termCode.cc:961:	 tx789 = -(tx100*tx139*tx142*tx96*V); 		/* rule 960 */
_Dihedral_termCode.cc:970:	 tx796 = -(tx104*tx139*tx142*tx96*V); 		/* rule 969 */
_Dihedral_termCode.cc:973:	 tx797 = -tx384; 		/* rule 972 */
_Dihedral_termCode.cc:977:	 tx801 = -2.*tx141*tx20*tx380*tx88*tx908; 		/* rule 976 */
_Dihedral_termCode.cc:980:	 tx804 = -(tx108*tx139*tx142*tx96*V); 		/* rule 979 */
_Dihedral_termCode.cc:986:	 tx808 = -0.5*tx286*tx643*tx72; 		/* rule 985 */
_Dihedral_termCode.cc:987:	 tx809 = -tx786; 		/* rule 986 */
_Dihedral_termCode.cc:993:	 tx815 = -(tx112*tx139*tx142*tx96*V); 		/* rule 992 */
_Dihedral_termCode.cc:996:	 tx816 = -(DeDPhi*tx793); 		/* rule 995 */
_Dihedral_termCode.cc:1000:	 tx818 = -(DeDPhi*tx799); 		/* rule 999 */
_Dihedral_termCode.cc:1004:	 tx820 = -(DeDPhi*tx811); 		/* rule 1003 */
_Dihedral_termCode.cc:1014:	 tx828 = -(tx100*tx104*tx139*tx142*V); 		/* rule 1013 */
_Dihedral_termCode.cc:1023:	 tx835 = -(tx100*tx108*tx139*tx142*V); 		/* rule 1022 */
_Dihedral_termCode.cc:1026:	 tx836 = -tx478; 		/* rule 1025 */
_Dihedral_termCode.cc:1030:	 tx840 = -2.*tx141*tx19*tx474*tx88*tx908; 		/* rule 1029 */
_Dihedral_termCode.cc:1033:	 tx843 = -(tx100*tx112*tx139*tx142*V); 		/* rule 1032 */
_Dihedral_termCode.cc:1036:	 tx844 = -(DeDPhi*tx825); 		/* rule 1035 */
_Dihedral_termCode.cc:1040:	 tx846 = -(DeDPhi*tx832); 		/* rule 1039 */
_Dihedral_termCode.cc:1044:	 tx848 = -(DeDPhi*tx838); 		/* rule 1043 */
_Dihedral_termCode.cc:1048:	 tx850 = -(tx285*tx65*tx704); 		/* rule 1047 */
_Dihedral_termCode.cc:1049:	 tx851 = -tx749; 		/* rule 1048 */
_Dihedral_termCode.cc:1050:	 tx852 = -tx793; 		/* rule 1049 */
_Dihedral_termCode.cc:1053:	 tx855 = -(tx104*tx108*tx139*tx142*V); 		/* rule 1052 */
_Dihedral_termCode.cc:1056:	 tx856 = -(tx285*tx65*tx723); 		/* rule 1055 */
_Dihedral_termCode.cc:1057:	 tx857 = -tx760; 		/* rule 1056 */
_Dihedral_termCode.cc:1058:	 tx858 = -tx825; 		/* rule 1057 */
_Dihedral_termCode.cc:1061:	 tx861 = -(tx104*tx112*tx139*tx142*V); 		/* rule 1060 */
_Dihedral_termCode.cc:1082:	 tx874 = -(tx285*tx65*tx778); 		/* rule 1081 */
_Dihedral_termCode.cc:1083:	 tx875 = -tx811; 		/* rule 1082 */
_Dihedral_termCode.cc:1084:	 tx876 = -tx832; 		/* rule 1083 */
_Dihedral_termCode.cc:1087:	 tx879 = -(tx108*tx112*tx139*tx142*V); 		/* rule 1086 */
_Dihedral_termCode.cc:1124:	 tx902 = -(tx139*tx142*tx285*tx38*tx39*tx907*V); 		/* rule 1123 */
_Dihedral_termCode.cc:1128:	 tx904 = -(tx139*tx142*tx285*tx39*tx40*tx907*V); 		/* rule 1127 */
_Dihedral_termCode.cc:1132:	 tx906 = -(tx139*tx142*tx285*tx38*tx40*tx907*V); 		/* rule 1131 */
_FixedNonbond_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalxf", this->eval.xf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evalyf", this->eval.yf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalzf", this->eval.zf, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evaldA", this->eval.dA, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaldC", this->eval.dC, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evaldQ1Q2", this->eval.dQ1Q2, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evalEfvdw", this->eval.Efvdw, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalEfeel", this->eval.Efeel, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_FixedNonbond_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evalfixedNonbondDistance", this->eval.fixedNonbondDistance, 0.0 );
_FixedNonbond_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:18:(-delta2 + x1, y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:25:(-delta2 + x1, -delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:26:(delta2 + x1, -delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:27:(-delta2 + x1, delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:33:(-delta2 + x1, y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:34:(delta2 + x1, y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:35:(-delta2 + x1, y1, delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:40:(x1, -delta2 + y1, z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:47:(x1, -delta2 + y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:48:(x1, delta2 + y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:49:(x1, -delta2 + y1, delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_debugFiniteDifference.cc:54:(x1, y1, -delta2 + z1, xf, yf, zf, dA, dC, dQ1Q2),
_FixedNonbond_termCode.cc:1:// C-code
_FixedNonbond_termCode.cc:12:	 tx1 = -xf; 		/* rule 11 */
_FixedNonbond_termCode.cc:13:	 tx2 = -yf; 		/* rule 12 */
_FixedNonbond_termCode.cc:14:	 tx3 = -zf; 		/* rule 13 */
_FixedNonbond_termCode.cc:29:	 tx14 = -(dC*tx12); 		/* rule 28 */
_FixedNonbond_termCode.cc:42:	 tx19 = -12.*dA*tx16*tx4; 		/* rule 41 */
_FixedNonbond_termCode.cc:44:	 tx21 = -(dQ1Q2*tx18*tx4); 		/* rule 43 */
_FixedNonbond_termCode.cc:46:	 fx1 = -gx1; 		/* rule 45 */
_FixedNonbond_termCode.cc:48:	 tx22 = -12.*dA*tx16*tx5; 		/* rule 47 */
_FixedNonbond_termCode.cc:50:	 tx24 = -(dQ1Q2*tx18*tx5); 		/* rule 49 */
_FixedNonbond_termCode.cc:52:	 fy1 = -gy1; 		/* rule 51 */
_FixedNonbond_termCode.cc:54:	 tx25 = -12.*dA*tx16*tx6; 		/* rule 53 */
_FixedNonbond_termCode.cc:56:	 tx27 = -(dQ1Q2*tx18*tx6); 		/* rule 55 */
_FixedNonbond_termCode.cc:58:	 fz1 = -gz1; 		/* rule 57 */
_FixedNonbond_termCode.cc:67:	 tx31 = -12.*dA*tx16; 		/* rule 66 */
_FixedNonbond_termCode.cc:69:	 tx33 = -(dQ1Q2*tx18); 		/* rule 68 */
_FixedNonbond_termCode.cc:71:	 tx35 = -48*dC*tx29*tx7; 		/* rule 70 */
_FixedNonbond_termCode.cc:76:	 tx38 = -48*dC*tx29*tx8; 		/* rule 75 */
_FixedNonbond_termCode.cc:81:	 tx41 = -48*dC*tx29*tx9; 		/* rule 80 */
_FixedNonbond_termCode.cc:88:	 tx44 = -48*dC*tx29*tx4*tx5; 		/* rule 87 */
_FixedNonbond_termCode.cc:93:	 tx47 = -48*dC*tx29*tx4*tx6; 		/* rule 92 */
_FixedNonbond_termCode.cc:98:	 tx50 = -48*dC*tx29*tx5*tx6; 		/* rule 97 */
_ImproperRestraint_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalx3", this->eval.x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaly3", this->eval.y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalz3", this->eval.z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalx4", this->eval.x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evaly4", this->eval.y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalz4", this->eval.z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalK", this->eval.K, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalL", this->eval.L, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalU", this->eval.U, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evalfx3", this->eval.fx3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evalfy3", this->eval.fy3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evalfz3", this->eval.fz3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evalfx4", this->eval.fx4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evalfy4", this->eval.fy4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evalfz4", this->eval.fz4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evaldhx3x3", this->eval.dhx3x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evaldhy3y3", this->eval.dhy3y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evaldhz3z3", this->eval.dhz3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:39: 	node->attributeIfNotDefault("evaldhx4x4", this->eval.dhx4x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:40: 	node->attributeIfNotDefault("evaldhy4y4", this->eval.dhy4y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:41: 	node->attributeIfNotDefault("evaldhz4z4", this->eval.dhz4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:42: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:43: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:44: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:45: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:46: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:47: 	node->attributeIfNotDefault("evalohx1x3", this->eval.ohx1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:48: 	node->attributeIfNotDefault("evalohx1y3", this->eval.ohx1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:49: 	node->attributeIfNotDefault("evalohx1z3", this->eval.ohx1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:50: 	node->attributeIfNotDefault("evalohx1x4", this->eval.ohx1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:51: 	node->attributeIfNotDefault("evalohx1y4", this->eval.ohx1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:52: 	node->attributeIfNotDefault("evalohx1z4", this->eval.ohx1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:53: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:54: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:55: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:56: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:57: 	node->attributeIfNotDefault("evalohy1x3", this->eval.ohy1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:58: 	node->attributeIfNotDefault("evalohy1y3", this->eval.ohy1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:59: 	node->attributeIfNotDefault("evalohy1z3", this->eval.ohy1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:60: 	node->attributeIfNotDefault("evalohy1x4", this->eval.ohy1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:61: 	node->attributeIfNotDefault("evalohy1y4", this->eval.ohy1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:62: 	node->attributeIfNotDefault("evalohy1z4", this->eval.ohy1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:63: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:64: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:65: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:66: 	node->attributeIfNotDefault("evalohz1x3", this->eval.ohz1x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:67: 	node->attributeIfNotDefault("evalohz1y3", this->eval.ohz1y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:68: 	node->attributeIfNotDefault("evalohz1z3", this->eval.ohz1z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:69: 	node->attributeIfNotDefault("evalohz1x4", this->eval.ohz1x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:70: 	node->attributeIfNotDefault("evalohz1y4", this->eval.ohz1y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:71: 	node->attributeIfNotDefault("evalohz1z4", this->eval.ohz1z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:72: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:73: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:74: 	node->attributeIfNotDefault("evalohx2x3", this->eval.ohx2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:75: 	node->attributeIfNotDefault("evalohx2y3", this->eval.ohx2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:76: 	node->attributeIfNotDefault("evalohx2z3", this->eval.ohx2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:77: 	node->attributeIfNotDefault("evalohx2x4", this->eval.ohx2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:78: 	node->attributeIfNotDefault("evalohx2y4", this->eval.ohx2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:79: 	node->attributeIfNotDefault("evalohx2z4", this->eval.ohx2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:80: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:81: 	node->attributeIfNotDefault("evalohy2x3", this->eval.ohy2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:82: 	node->attributeIfNotDefault("evalohy2y3", this->eval.ohy2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:83: 	node->attributeIfNotDefault("evalohy2z3", this->eval.ohy2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:84: 	node->attributeIfNotDefault("evalohy2x4", this->eval.ohy2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:85: 	node->attributeIfNotDefault("evalohy2y4", this->eval.ohy2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:86: 	node->attributeIfNotDefault("evalohy2z4", this->eval.ohy2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:87: 	node->attributeIfNotDefault("evalohz2x3", this->eval.ohz2x3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:88: 	node->attributeIfNotDefault("evalohz2y3", this->eval.ohz2y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:89: 	node->attributeIfNotDefault("evalohz2z3", this->eval.ohz2z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:90: 	node->attributeIfNotDefault("evalohz2x4", this->eval.ohz2x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:91: 	node->attributeIfNotDefault("evalohz2y4", this->eval.ohz2y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:92: 	node->attributeIfNotDefault("evalohz2z4", this->eval.ohz2z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:93: 	node->attributeIfNotDefault("evalohx3y3", this->eval.ohx3y3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:94: 	node->attributeIfNotDefault("evalohx3z3", this->eval.ohx3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:95: 	node->attributeIfNotDefault("evalohx3x4", this->eval.ohx3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:96: 	node->attributeIfNotDefault("evalohx3y4", this->eval.ohx3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:97: 	node->attributeIfNotDefault("evalohx3z4", this->eval.ohx3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:98: 	node->attributeIfNotDefault("evalohy3z3", this->eval.ohy3z3, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:99: 	node->attributeIfNotDefault("evalohy3x4", this->eval.ohy3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:100: 	node->attributeIfNotDefault("evalohy3y4", this->eval.ohy3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:101: 	node->attributeIfNotDefault("evalohy3z4", this->eval.ohy3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:102: 	node->attributeIfNotDefault("evalohz3x4", this->eval.ohz3x4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:103: 	node->attributeIfNotDefault("evalohz3y4", this->eval.ohz3y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:104: 	node->attributeIfNotDefault("evalohz3z4", this->eval.ohz3z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:105: 	node->attributeIfNotDefault("evalohx4y4", this->eval.ohx4y4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:106: 	node->attributeIfNotDefault("evalohx4z4", this->eval.ohx4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:107: 	node->attributeIfNotDefault("evalohy4z4", this->eval.ohy4z4, 0.0 );
_ImproperRestraint_debugEvalSerialize.cc:108: 	node->attributeIfNotDefault("evalPhi", this->eval.Phi, 0.0 );
_ImproperRestraint_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_ImproperRestraint_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_ImproperRestraint_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_ImproperRestraint_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_ImproperRestraint_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_ImproperRestraint_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_ImproperRestraint_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("x3", this->eval.x3);
_ImproperRestraint_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("y3", this->eval.y3);
_ImproperRestraint_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("z3", this->eval.z3);
_ImproperRestraint_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("x4", this->eval.x4);
_ImproperRestraint_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("y4", this->eval.y4);
_ImproperRestraint_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("z4", this->eval.z4);
_ImproperRestraint_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("K", this->eval.K);
_ImproperRestraint_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("L", this->eval.L);
_ImproperRestraint_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("U", this->eval.U);
_ImproperRestraint_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_ImproperRestraint_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_ImproperRestraint_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_ImproperRestraint_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_ImproperRestraint_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_ImproperRestraint_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_ImproperRestraint_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_ImproperRestraint_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("fx3", this->eval.fx3);
_ImproperRestraint_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("fy3", this->eval.fy3);
_ImproperRestraint_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("fz3", this->eval.fz3);
_ImproperRestraint_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("fx4", this->eval.fx4);
_ImproperRestraint_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("fy4", this->eval.fy4);
_ImproperRestraint_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("fz4", this->eval.fz4);
_ImproperRestraint_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_ImproperRestraint_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_ImproperRestraint_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_ImproperRestraint_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_ImproperRestraint_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_ImproperRestraint_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_ImproperRestraint_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("dhx3x3", this->eval.dhx3x3);
_ImproperRestraint_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("dhy3y3", this->eval.dhy3y3);
_ImproperRestraint_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("dhz3z3", this->eval.dhz3z3);
_ImproperRestraint_debugEvalXml.cc:39: 	xml->addAttributeDoubleScientific ("dhx4x4", this->eval.dhx4x4);
_ImproperRestraint_debugEvalXml.cc:40: 	xml->addAttributeDoubleScientific ("dhy4y4", this->eval.dhy4y4);
_ImproperRestraint_debugEvalXml.cc:41: 	xml->addAttributeDoubleScientific ("dhz4z4", this->eval.dhz4z4);
_ImproperRestraint_debugEvalXml.cc:42: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_ImproperRestraint_debugEvalXml.cc:43: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_ImproperRestraint_debugEvalXml.cc:44: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_ImproperRestraint_debugEvalXml.cc:45: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_ImproperRestraint_debugEvalXml.cc:46: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_ImproperRestraint_debugEvalXml.cc:47: 	xml->addAttributeDoubleScientific ("ohx1x3", this->eval.ohx1x3);
_ImproperRestraint_debugEvalXml.cc:48: 	xml->addAttributeDoubleScientific ("ohx1y3", this->eval.ohx1y3);
_ImproperRestraint_debugEvalXml.cc:49: 	xml->addAttributeDoubleScientific ("ohx1z3", this->eval.ohx1z3);
_ImproperRestraint_debugEvalXml.cc:50: 	xml->addAttributeDoubleScientific ("ohx1x4", this->eval.ohx1x4);
_ImproperRestraint_debugEvalXml.cc:51: 	xml->addAttributeDoubleScientific ("ohx1y4", this->eval.ohx1y4);
_ImproperRestraint_debugEvalXml.cc:52: 	xml->addAttributeDoubleScientific ("ohx1z4", this->eval.ohx1z4);
_ImproperRestraint_debugEvalXml.cc:53: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_ImproperRestraint_debugEvalXml.cc:54: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_ImproperRestraint_debugEvalXml.cc:55: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_ImproperRestraint_debugEvalXml.cc:56: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_ImproperRestraint_debugEvalXml.cc:57: 	xml->addAttributeDoubleScientific ("ohy1x3", this->eval.ohy1x3);
_ImproperRestraint_debugEvalXml.cc:58: 	xml->addAttributeDoubleScientific ("ohy1y3", this->eval.ohy1y3);
_ImproperRestraint_debugEvalXml.cc:59: 	xml->addAttributeDoubleScientific ("ohy1z3", this->eval.ohy1z3);
_ImproperRestraint_debugEvalXml.cc:60: 	xml->addAttributeDoubleScientific ("ohy1x4", this->eval.ohy1x4);
_ImproperRestraint_debugEvalXml.cc:61: 	xml->addAttributeDoubleScientific ("ohy1y4", this->eval.ohy1y4);
_ImproperRestraint_debugEvalXml.cc:62: 	xml->addAttributeDoubleScientific ("ohy1z4", this->eval.ohy1z4);
_ImproperRestraint_debugEvalXml.cc:63: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_ImproperRestraint_debugEvalXml.cc:64: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_ImproperRestraint_debugEvalXml.cc:65: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_ImproperRestraint_debugEvalXml.cc:66: 	xml->addAttributeDoubleScientific ("ohz1x3", this->eval.ohz1x3);
_ImproperRestraint_debugEvalXml.cc:67: 	xml->addAttributeDoubleScientific ("ohz1y3", this->eval.ohz1y3);
_ImproperRestraint_debugEvalXml.cc:68: 	xml->addAttributeDoubleScientific ("ohz1z3", this->eval.ohz1z3);
_ImproperRestraint_debugEvalXml.cc:69: 	xml->addAttributeDoubleScientific ("ohz1x4", this->eval.ohz1x4);
_ImproperRestraint_debugEvalXml.cc:70: 	xml->addAttributeDoubleScientific ("ohz1y4", this->eval.ohz1y4);
_ImproperRestraint_debugEvalXml.cc:71: 	xml->addAttributeDoubleScientific ("ohz1z4", this->eval.ohz1z4);
_ImproperRestraint_debugEvalXml.cc:72: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_ImproperRestraint_debugEvalXml.cc:73: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_ImproperRestraint_debugEvalXml.cc:74: 	xml->addAttributeDoubleScientific ("ohx2x3", this->eval.ohx2x3);
_ImproperRestraint_debugEvalXml.cc:75: 	xml->addAttributeDoubleScientific ("ohx2y3", this->eval.ohx2y3);
_ImproperRestraint_debugEvalXml.cc:76: 	xml->addAttributeDoubleScientific ("ohx2z3", this->eval.ohx2z3);
_ImproperRestraint_debugEvalXml.cc:77: 	xml->addAttributeDoubleScientific ("ohx2x4", this->eval.ohx2x4);
_ImproperRestraint_debugEvalXml.cc:78: 	xml->addAttributeDoubleScientific ("ohx2y4", this->eval.ohx2y4);
_ImproperRestraint_debugEvalXml.cc:79: 	xml->addAttributeDoubleScientific ("ohx2z4", this->eval.ohx2z4);
_ImproperRestraint_debugEvalXml.cc:80: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_ImproperRestraint_debugEvalXml.cc:81: 	xml->addAttributeDoubleScientific ("ohy2x3", this->eval.ohy2x3);
_ImproperRestraint_debugEvalXml.cc:82: 	xml->addAttributeDoubleScientific ("ohy2y3", this->eval.ohy2y3);
_ImproperRestraint_debugEvalXml.cc:83: 	xml->addAttributeDoubleScientific ("ohy2z3", this->eval.ohy2z3);
_ImproperRestraint_debugEvalXml.cc:84: 	xml->addAttributeDoubleScientific ("ohy2x4", this->eval.ohy2x4);
_ImproperRestraint_debugEvalXml.cc:85: 	xml->addAttributeDoubleScientific ("ohy2y4", this->eval.ohy2y4);
_ImproperRestraint_debugEvalXml.cc:86: 	xml->addAttributeDoubleScientific ("ohy2z4", this->eval.ohy2z4);
_ImproperRestraint_debugEvalXml.cc:87: 	xml->addAttributeDoubleScientific ("ohz2x3", this->eval.ohz2x3);
_ImproperRestraint_debugEvalXml.cc:88: 	xml->addAttributeDoubleScientific ("ohz2y3", this->eval.ohz2y3);
_ImproperRestraint_debugEvalXml.cc:89: 	xml->addAttributeDoubleScientific ("ohz2z3", this->eval.ohz2z3);
_ImproperRestraint_debugEvalXml.cc:90: 	xml->addAttributeDoubleScientific ("ohz2x4", this->eval.ohz2x4);
_ImproperRestraint_debugEvalXml.cc:91: 	xml->addAttributeDoubleScientific ("ohz2y4", this->eval.ohz2y4);
_ImproperRestraint_debugEvalXml.cc:92: 	xml->addAttributeDoubleScientific ("ohz2z4", this->eval.ohz2z4);
_ImproperRestraint_debugEvalXml.cc:93: 	xml->addAttributeDoubleScientific ("ohx3y3", this->eval.ohx3y3);
_ImproperRestraint_debugEvalXml.cc:94: 	xml->addAttributeDoubleScientific ("ohx3z3", this->eval.ohx3z3);
_ImproperRestraint_debugEvalXml.cc:95: 	xml->addAttributeDoubleScientific ("ohx3x4", this->eval.ohx3x4);
_ImproperRestraint_debugEvalXml.cc:96: 	xml->addAttributeDoubleScientific ("ohx3y4", this->eval.ohx3y4);
_ImproperRestraint_debugEvalXml.cc:97: 	xml->addAttributeDoubleScientific ("ohx3z4", this->eval.ohx3z4);
_ImproperRestraint_debugEvalXml.cc:98: 	xml->addAttributeDoubleScientific ("ohy3z3", this->eval.ohy3z3);
_ImproperRestraint_debugEvalXml.cc:99: 	xml->addAttributeDoubleScientific ("ohy3x4", this->eval.ohy3x4);
_ImproperRestraint_debugEvalXml.cc:100: 	xml->addAttributeDoubleScientific ("ohy3y4", this->eval.ohy3y4);
_ImproperRestraint_debugEvalXml.cc:101: 	xml->addAttributeDoubleScientific ("ohy3z4", this->eval.ohy3z4);
_ImproperRestraint_debugEvalXml.cc:102: 	xml->addAttributeDoubleScientific ("ohz3x4", this->eval.ohz3x4);
_ImproperRestraint_debugEvalXml.cc:103: 	xml->addAttributeDoubleScientific ("ohz3y4", this->eval.ohz3y4);
_ImproperRestraint_debugEvalXml.cc:104: 	xml->addAttributeDoubleScientific ("ohz3z4", this->eval.ohz3z4);
_ImproperRestraint_debugEvalXml.cc:105: 	xml->addAttributeDoubleScientific ("ohx4y4", this->eval.ohx4y4);
_ImproperRestraint_debugEvalXml.cc:106: 	xml->addAttributeDoubleScientific ("ohx4z4", this->eval.ohx4z4);
_ImproperRestraint_debugEvalXml.cc:107: 	xml->addAttributeDoubleScientific ("ohy4z4", this->eval.ohy4z4);
_ImproperRestraint_debugEvalXml.cc:108: 	xml->addAttributeDoubleScientific ("Phi", this->eval.Phi);
_ImproperRestraint_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:18:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:23:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:33:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:38:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:43:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:48:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:53:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:58:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:63:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:70:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:71:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:72:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:78:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:79:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:80:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:86:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:87:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:88:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:94:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:95:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:96:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:102:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:103:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:104:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:110:(-delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:111:(delta2 + x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:112:(-delta2 + x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:118:(-delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:119:(delta2 + x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:120:(-delta2 + x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:126:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:127:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:128:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:134:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:135:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:136:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:142:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:143:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:144:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:150:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:151:(delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:152:(-delta2 + x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:157:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:164:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:165:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:166:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:172:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:173:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:174:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:180:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:181:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:182:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:188:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:189:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:190:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:196:(x1, -delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:197:(x1, delta2 + y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:198:(x1, -delta2 + y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:204:(x1, -delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:205:(x1, delta2 + y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:206:(x1, -delta2 + y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:212:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:213:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:214:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:220:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:221:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:222:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:228:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:229:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:230:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:236:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:237:(x1, delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:238:(x1, -delta2 + y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:243:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:250:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:251:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:252:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:258:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:259:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:260:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:266:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:267:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:268:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:274:(x1, y1, -delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:275:(x1, y1, delta2 + z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:276:(x1, y1, -delta2 + z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:282:(x1, y1, -delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:283:(x1, y1, delta2 + z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:284:(x1, y1, -delta2 + z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:290:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:291:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:292:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:298:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:299:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:300:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:306:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:307:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:308:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:314:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:315:(x1, y1, delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:316:(x1, y1, -delta2 + z1, x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:321:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:328:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:329:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:330:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:336:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:337:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:338:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:344:(x1, y1, z1, -delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:345:(x1, y1, z1, delta2 + x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:346:(x1, y1, z1, -delta2 + x2, y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:352:(x1, y1, z1, -delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:353:(x1, y1, z1, delta2 + x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:354:(x1, y1, z1, -delta2 + x2, y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:360:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:361:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:362:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:368:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:369:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:370:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:376:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:377:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:378:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:384:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:385:(x1, y1, z1, delta2 + x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:386:(x1, y1, z1, -delta2 + x2, y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:391:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:398:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:399:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:400:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:406:(x1, y1, z1, x2, -delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:407:(x1, y1, z1, x2, delta2 + y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:408:(x1, y1, z1, x2, -delta2 + y2, z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:414:(x1, y1, z1, x2, -delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:415:(x1, y1, z1, x2, delta2 + y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:416:(x1, y1, z1, x2, -delta2 + y2, z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:422:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:423:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:424:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:430:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:431:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:432:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:438:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:439:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:440:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:446:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:447:(x1, y1, z1, x2, delta2 + y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:448:(x1, y1, z1, x2, -delta2 + y2, z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:453:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:460:(x1, y1, z1, x2, y2, -delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:461:(x1, y1, z1, x2, y2, delta2 + z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:462:(x1, y1, z1, x2, y2, -delta2 + z2, delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:468:(x1, y1, z1, x2, y2, -delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:469:(x1, y1, z1, x2, y2, delta2 + z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:470:(x1, y1, z1, x2, y2, -delta2 + z2, x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:476:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:477:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:478:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:484:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:485:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:486:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:492:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:493:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:494:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:500:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:501:(x1, y1, z1, x2, y2, delta2 + z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:502:(x1, y1, z1, x2, y2, -delta2 + z2, x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:507:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:514:(x1, y1, z1, x2, y2, z2, -delta2 + x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:515:(x1, y1, z1, x2, y2, z2, delta2 + x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:516:(x1, y1, z1, x2, y2, z2, -delta2 + x3, delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:522:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:523:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:524:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:530:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:531:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:532:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:538:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:539:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:540:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:546:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:547:(x1, y1, z1, x2, y2, z2, delta2 + x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:548:(x1, y1, z1, x2, y2, z2, -delta2 + x3, y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:553:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:560:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:561:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:562:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:568:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:569:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:570:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:576:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:577:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:578:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:584:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:585:(x1, y1, z1, x2, y2, z2, x3, delta2 + y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:586:(x1, y1, z1, x2, y2, z2, x3, -delta2 + y3, z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:591:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:598:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:599:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:600:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:606:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:607:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:608:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:614:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:615:(x1, y1, z1, x2, y2, z2, x3, y3, delta2 + z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:616:(x1, y1, z1, x2, y2, z2, x3, y3, -delta2 + z3, x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:621:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:628:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:629:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:630:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:636:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:637:(x1, y1, z1, x2, y2, z2, x3, y3, z3, delta2 + x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:638:(x1, y1, z1, x2, y2, z2, x3, y3, z3, -delta2 + x4, y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:643:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:650:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:651:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, delta2 + y4, -delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:652:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, -delta2 + y4, delta2 + z4, K, L, U),
_ImproperRestraint_debugFiniteDifference.cc:657:(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, -delta2 + z4, K, L, U),
_ImproperRestraint_termCode.cc:1:// C-code
_ImproperRestraint_termCode.cc:113:	 tx1 = -(x2*y1); 		/* rule 21 */
_ImproperRestraint_termCode.cc:116:	 tx4 = -(x3*y2); 		/* rule 24 */
_ImproperRestraint_termCode.cc:117:	 tx5 = -(x1*y3); 		/* rule 25 */
_ImproperRestraint_termCode.cc:120:	 tx8 = -(x3*z1); 		/* rule 28 */
_ImproperRestraint_termCode.cc:121:	 tx9 = -(y2*z1); 		/* rule 29 */
_ImproperRestraint_termCode.cc:123:	 tx11 = -(x1*z2); 		/* rule 31 */
_ImproperRestraint_termCode.cc:126:	 tx14 = -(y3*z2); 		/* rule 34 */
_ImproperRestraint_termCode.cc:128:	 tx16 = -(x2*z3); 		/* rule 36 */
_ImproperRestraint_termCode.cc:129:	 tx17 = -(y1*z3); 		/* rule 37 */
_ImproperRestraint_termCode.cc:140:	 tx27 = -(x4*y3); 		/* rule 48 */
_ImproperRestraint_termCode.cc:141:	 tx28 = -(x2*y4); 		/* rule 49 */
_ImproperRestraint_termCode.cc:143:	 tx30 = -(x4*z2); 		/* rule 51 */
_ImproperRestraint_termCode.cc:146:	 tx33 = -(y4*z3); 		/* rule 54 */
_ImproperRestraint_termCode.cc:148:	 tx35 = -(x3*z4); 		/* rule 56 */
_ImproperRestraint_termCode.cc:149:	 tx36 = -(y2*z4); 		/* rule 57 */
_ImproperRestraint_termCode.cc:171:	 tx49 = -x3; 		/* rule 79 */
_ImproperRestraint_termCode.cc:172:	 tx50 = -y3; 		/* rule 80 */
_ImproperRestraint_termCode.cc:173:	 tx51 = -z3; 		/* rule 81 */
_ImproperRestraint_termCode.cc:190:	CosPhi=MAX(-1.0,MIN(1.0,CosPhi));
_ImproperRestraint_termCode.cc:234:	 tx67 = -L; 		/* rule 111 */
_ImproperRestraint_termCode.cc:240:	 tx72 = -tx71; 		/* rule 117 */
_ImproperRestraint_termCode.cc:251:	 gx1 = -(DEImproperRestraintDPhi*tx21*tx65*tx77); 		/* rule 128 */
_ImproperRestraint_termCode.cc:252:	 fx1 = -gx1; 		/* rule 129 */
_ImproperRestraint_termCode.cc:254:	 gy1 = -(DEImproperRestraintDPhi*tx20*tx65*tx77); 		/* rule 131 */
_ImproperRestraint_termCode.cc:255:	 fy1 = -gy1; 		/* rule 132 */
_ImproperRestraint_termCode.cc:257:	 gz1 = -(DEImproperRestraintDPhi*tx19*tx65*tx77); 		/* rule 134 */
_ImproperRestraint_termCode.cc:258:	 fz1 = -gz1; 		/* rule 135 */
_ImproperRestraint_termCode.cc:260:	 tx78 = -x2; 		/* rule 137 */
_ImproperRestraint_termCode.cc:261:	 tx79 = -y2; 		/* rule 138 */
_ImproperRestraint_termCode.cc:262:	 tx80 = -z2; 		/* rule 139 */
_ImproperRestraint_termCode.cc:277:	 tx95 = -(tx39*tx90*tx918*tx92); 		/* rule 154 */
_ImproperRestraint_termCode.cc:281:	 fx2 = -gx2; 		/* rule 158 */
_ImproperRestraint_termCode.cc:284:	 tx99 = -(tx38*tx90*tx918*tx92); 		/* rule 161 */
_ImproperRestraint_termCode.cc:288:	 fy2 = -gy2; 		/* rule 165 */
_ImproperRestraint_termCode.cc:291:	 tx103 = -(tx40*tx90*tx918*tx92); 		/* rule 168 */
_ImproperRestraint_termCode.cc:295:	 fz2 = -gz2; 		/* rule 172 */
_ImproperRestraint_termCode.cc:297:	 tx106 = -(tx39*tx65*tx90); 		/* rule 174 */
_ImproperRestraint_termCode.cc:299:	 tx108 = -tx96; 		/* rule 176 */
_ImproperRestraint_termCode.cc:302:	 fx3 = -gx3; 		/* rule 179 */
_ImproperRestraint_termCode.cc:304:	 tx110 = -tx100; 		/* rule 181 */
_ImproperRestraint_termCode.cc:305:	 tx111 = -(tx38*tx65*tx90); 		/* rule 182 */
_ImproperRestraint_termCode.cc:309:	 fy3 = -gy3; 		/* rule 186 */
_ImproperRestraint_termCode.cc:311:	 tx114 = -tx104; 		/* rule 188 */
_ImproperRestraint_termCode.cc:312:	 tx115 = -(tx40*tx65*tx90); 		/* rule 189 */
_ImproperRestraint_termCode.cc:316:	 fz3 = -gz3; 		/* rule 193 */
_ImproperRestraint_termCode.cc:319:	 fx4 = -gx4; 		/* rule 196 */
_ImproperRestraint_termCode.cc:322:	 fy4 = -gy4; 		/* rule 199 */
_ImproperRestraint_termCode.cc:325:	 fz4 = -gz4; 		/* rule 202 */
_ImproperRestraint_termCode.cc:352:	 tx141 = -2.*tx3*y3; 		/* rule 229 */
_ImproperRestraint_termCode.cc:355:	 tx144 = -2.*tx15*z2; 		/* rule 232 */
_ImproperRestraint_termCode.cc:376:	 tx163 = -2.*tx2*x2; 		/* rule 253 */
_ImproperRestraint_termCode.cc:389:	 tx176 = -2.*tx13*z3; 		/* rule 266 */
_ImproperRestraint_termCode.cc:406:	 tx191 = -2.*tx7*x3; 		/* rule 283 */
_ImproperRestraint_termCode.cc:408:	 tx193 = -2.*tx10*y2; 		/* rule 285 */
_ImproperRestraint_termCode.cc:425:	 tx208 = -tx133; 		/* rule 302 */
_ImproperRestraint_termCode.cc:426:	 tx209 = -tx134; 		/* rule 303 */
_ImproperRestraint_termCode.cc:427:	 tx210 = -tx135; 		/* rule 304 */
_ImproperRestraint_termCode.cc:428:	 tx211 = -tx136; 		/* rule 305 */
_ImproperRestraint_termCode.cc:444:	 tx227 = -(tx3*y1); 		/* rule 321 */
_ImproperRestraint_termCode.cc:463:	 tx246 = -2.*tx139; 		/* rule 340 */
_ImproperRestraint_termCode.cc:464:	 tx247 = -2.*tx143; 		/* rule 341 */
_ImproperRestraint_termCode.cc:465:	 tx248 = -tx235; 		/* rule 342 */
_ImproperRestraint_termCode.cc:487:	 tx270 = -2.*tx26*y3; 		/* rule 364 */
_ImproperRestraint_termCode.cc:495:	 tx278 = -2.*tx32*z2; 		/* rule 372 */
_ImproperRestraint_termCode.cc:501:	 tx284 = -(tx12*z4); 		/* rule 378 */
_ImproperRestraint_termCode.cc:503:	 tx286 = -(tx32*z4); 		/* rule 380 */
_ImproperRestraint_termCode.cc:514:	 tx298 = -(tx292*tx295*tx39*tx90); 		/* rule 391 */
_ImproperRestraint_termCode.cc:515:	 tx299 = -2.*tx151*tx290*tx918; 		/* rule 392 */
_ImproperRestraint_termCode.cc:516:	 tx300 = -2.*tx293*tx294*tx39*tx918*tx92; 		/* rule 393 */
_ImproperRestraint_termCode.cc:526:	 tx308 = -tx167; 		/* rule 403 */
_ImproperRestraint_termCode.cc:527:	 tx309 = -tx168; 		/* rule 404 */
_ImproperRestraint_termCode.cc:528:	 tx310 = -tx169; 		/* rule 405 */
_ImproperRestraint_termCode.cc:529:	 tx311 = -tx170; 		/* rule 406 */
_ImproperRestraint_termCode.cc:552:	 tx334 = -(tx13*z1); 		/* rule 429 */
_ImproperRestraint_termCode.cc:562:	 tx344 = -2.*tx162; 		/* rule 439 */
_ImproperRestraint_termCode.cc:563:	 tx345 = -2.*tx173; 		/* rule 440 */
_ImproperRestraint_termCode.cc:564:	 tx346 = -tx321; 		/* rule 441 */
_ImproperRestraint_termCode.cc:575:	 tx357 = -2.*tx29*x2; 		/* rule 452 */
_ImproperRestraint_termCode.cc:580:	 tx362 = -(tx29*x4); 		/* rule 457 */
_ImproperRestraint_termCode.cc:581:	 tx363 = -(tx6*x4); 		/* rule 458 */
_ImproperRestraint_termCode.cc:598:	 tx380 = -2.*tx31*z3; 		/* rule 475 */
_ImproperRestraint_termCode.cc:610:	 tx394 = -(tx295*tx38*tx390*tx90); 		/* rule 487 */
_ImproperRestraint_termCode.cc:611:	 tx395 = -2.*tx151*tx388*tx918; 		/* rule 488 */
_ImproperRestraint_termCode.cc:612:	 tx396 = -2.*tx294*tx38*tx391*tx918*tx92; 		/* rule 489 */
_ImproperRestraint_termCode.cc:622:	 tx404 = -tx197; 		/* rule 499 */
_ImproperRestraint_termCode.cc:623:	 tx405 = -tx198; 		/* rule 500 */
_ImproperRestraint_termCode.cc:624:	 tx406 = -tx199; 		/* rule 501 */
_ImproperRestraint_termCode.cc:625:	 tx407 = -tx200; 		/* rule 502 */
_ImproperRestraint_termCode.cc:633:	 tx415 = -(tx7*x1); 		/* rule 510 */
_ImproperRestraint_termCode.cc:656:	 tx438 = -2.*tx190; 		/* rule 533 */
_ImproperRestraint_termCode.cc:657:	 tx439 = -2.*tx192; 		/* rule 534 */
_ImproperRestraint_termCode.cc:658:	 tx440 = -tx420; 		/* rule 535 */
_ImproperRestraint_termCode.cc:672:	 tx454 = -2.*tx34*x3; 		/* rule 549 */
_ImproperRestraint_termCode.cc:680:	 tx462 = -2.*tx37*y2; 		/* rule 557 */
_ImproperRestraint_termCode.cc:685:	 tx467 = -(tx18*y4); 		/* rule 562 */
_ImproperRestraint_termCode.cc:687:	 tx469 = -(tx37*y4); 		/* rule 564 */
_ImproperRestraint_termCode.cc:704:	 tx488 = -(tx295*tx40*tx484*tx90); 		/* rule 581 */
_ImproperRestraint_termCode.cc:705:	 tx489 = -2.*tx151*tx482*tx918; 		/* rule 582 */
_ImproperRestraint_termCode.cc:706:	 tx490 = -2.*tx294*tx40*tx485*tx918*tx92; 		/* rule 583 */
_ImproperRestraint_termCode.cc:714:	 tx496 = -tx262; 		/* rule 591 */
_ImproperRestraint_termCode.cc:715:	 tx497 = -tx263; 		/* rule 592 */
_ImproperRestraint_termCode.cc:716:	 tx498 = -tx264; 		/* rule 593 */
_ImproperRestraint_termCode.cc:717:	 tx499 = -tx265; 		/* rule 594 */
_ImproperRestraint_termCode.cc:718:	 tx500 = -tx272; 		/* rule 595 */
_ImproperRestraint_termCode.cc:719:	 tx501 = -2.*tx275; 		/* rule 596 */
_ImproperRestraint_termCode.cc:720:	 tx502 = -tx275; 		/* rule 597 */
_ImproperRestraint_termCode.cc:721:	 tx503 = -2.*tx281; 		/* rule 598 */
_ImproperRestraint_termCode.cc:743:	 tx527 = -2.*tx292*tx294*tx39*tx65; 		/* rule 620 */
_ImproperRestraint_termCode.cc:744:	 tx528 = -2.*tx294*tx526*tx918; 		/* rule 621 */
_ImproperRestraint_termCode.cc:751:	 tx533 = -2.*tx358; 		/* rule 628 */
_ImproperRestraint_termCode.cc:752:	 tx534 = -tx370; 		/* rule 629 */
_ImproperRestraint_termCode.cc:753:	 tx535 = -tx371; 		/* rule 630 */
_ImproperRestraint_termCode.cc:754:	 tx536 = -tx372; 		/* rule 631 */
_ImproperRestraint_termCode.cc:755:	 tx537 = -tx373; 		/* rule 632 */
_ImproperRestraint_termCode.cc:756:	 tx538 = -2.*tx382; 		/* rule 633 */
_ImproperRestraint_termCode.cc:757:	 tx539 = -tx382; 		/* rule 634 */
_ImproperRestraint_termCode.cc:758:	 tx540 = -tx384; 		/* rule 635 */
_ImproperRestraint_termCode.cc:780:	 tx564 = -2.*tx294*tx38*tx390*tx65; 		/* rule 657 */
_ImproperRestraint_termCode.cc:781:	 tx565 = -2.*tx294*tx563*tx918; 		/* rule 658 */
_ImproperRestraint_termCode.cc:788:	 tx570 = -2.*tx456; 		/* rule 665 */
_ImproperRestraint_termCode.cc:789:	 tx571 = -tx456; 		/* rule 666 */
_ImproperRestraint_termCode.cc:790:	 tx572 = -tx459; 		/* rule 667 */
_ImproperRestraint_termCode.cc:791:	 tx573 = -2.*tx463; 		/* rule 668 */
_ImproperRestraint_termCode.cc:792:	 tx574 = -tx475; 		/* rule 669 */
_ImproperRestraint_termCode.cc:793:	 tx575 = -tx476; 		/* rule 670 */
_ImproperRestraint_termCode.cc:794:	 tx576 = -tx477; 		/* rule 671 */
_ImproperRestraint_termCode.cc:795:	 tx577 = -tx478; 		/* rule 672 */
_ImproperRestraint_termCode.cc:817:	 tx601 = -2.*tx294*tx40*tx484*tx65; 		/* rule 694 */
_ImproperRestraint_termCode.cc:818:	 tx602 = -2.*tx294*tx600*tx918; 		/* rule 695 */
_ImproperRestraint_termCode.cc:826:	 tx608 = -6.*EraseLinearDihedral*K*TWOPI*tx292*tx294*tx39*tx65*tx70*tx75*tx76; 		/* rule 703 */
_ImproperRestraint_termCode.cc:830:	 tx610 = -6.*EraseLinearDihedral*K*TWOPI*tx294*tx38*tx390*tx65*tx70*tx75*tx76; 		/* rule 707 */
_ImproperRestraint_termCode.cc:834:	 tx612 = -6.*EraseLinearDihedral*K*TWOPI*tx294*tx40*tx484*tx65*tx70*tx75*tx76; 		/* rule 711 */
_ImproperRestraint_termCode.cc:853:	 tx623 = -2.*tx150*tx151*tx21*tx65; 		/* rule 730 */
_ImproperRestraint_termCode.cc:857:	 tx627 = -(tx149*tx94*tx97); 		/* rule 734 */
_ImproperRestraint_termCode.cc:863:	 tx631 = -(tx151*tx615*tx65); 		/* rule 740 */
_ImproperRestraint_termCode.cc:867:	 tx635 = -(tx101*tx149*tx94); 		/* rule 744 */
_ImproperRestraint_termCode.cc:873:	 tx639 = -(tx151*tx620*tx65); 		/* rule 750 */
_ImproperRestraint_termCode.cc:877:	 tx643 = -(tx105*tx149*tx94); 		/* rule 754 */
_ImproperRestraint_termCode.cc:880:	 tx644 = -3*EraseLinearDihedral*K*TWOPI*tx624*tx70*tx75*tx76; 		/* rule 757 */
_ImproperRestraint_termCode.cc:881:	 tx645 = -(tx109*tx149*tx94); 		/* rule 758 */
_ImproperRestraint_termCode.cc:884:	 tx646 = -3*EraseLinearDihedral*K*TWOPI*tx632*tx70*tx75*tx76; 		/* rule 761 */
_ImproperRestraint_termCode.cc:885:	 tx647 = -(tx113*tx149*tx94); 		/* rule 762 */
_ImproperRestraint_termCode.cc:888:	 tx648 = -3*EraseLinearDihedral*K*TWOPI*tx640*tx70*tx75*tx76; 		/* rule 765 */
_ImproperRestraint_termCode.cc:889:	 tx649 = -(tx117*tx149*tx94); 		/* rule 766 */
_ImproperRestraint_termCode.cc:892:	 ohx1x4 = -(tx149*tx46*tx77*tx90*tx917); 		/* rule 769 */
_ImproperRestraint_termCode.cc:894:	 ohx1y4 = -(tx149*tx21*tx38*tx77*tx90*tx917); 		/* rule 771 */
_ImproperRestraint_termCode.cc:896:	 ohx1z4 = -(tx149*tx21*tx40*tx77*tx90*tx917); 		/* rule 773 */
_ImproperRestraint_termCode.cc:911:	 tx661 = -(tx149*tx97*tx98); 		/* rule 788 */
_ImproperRestraint_termCode.cc:914:	 tx662 = -2.*tx151*tx178*tx20*tx65; 		/* rule 791 */
_ImproperRestraint_termCode.cc:918:	 tx666 = -(tx101*tx149*tx98); 		/* rule 795 */
_ImproperRestraint_termCode.cc:924:	 tx670 = -(tx151*tx65*tx652); 		/* rule 801 */
_ImproperRestraint_termCode.cc:928:	 tx674 = -(tx105*tx149*tx98); 		/* rule 805 */
_ImproperRestraint_termCode.cc:931:	 tx675 = -3*EraseLinearDihedral*K*TWOPI*tx658*tx70*tx75*tx76; 		/* rule 808 */
_ImproperRestraint_termCode.cc:932:	 tx676 = -(tx109*tx149*tx98); 		/* rule 809 */
_ImproperRestraint_termCode.cc:935:	 tx677 = -3*EraseLinearDihedral*K*TWOPI*tx663*tx70*tx75*tx76; 		/* rule 812 */
_ImproperRestraint_termCode.cc:936:	 tx678 = -(tx113*tx149*tx98); 		/* rule 813 */
_ImproperRestraint_termCode.cc:939:	 tx679 = -3*EraseLinearDihedral*K*TWOPI*tx671*tx70*tx75*tx76; 		/* rule 816 */
_ImproperRestraint_termCode.cc:940:	 tx680 = -(tx117*tx149*tx98); 		/* rule 817 */
_ImproperRestraint_termCode.cc:943:	 ohy1x4 = -(tx149*tx20*tx39*tx77*tx90*tx917); 		/* rule 820 */
_ImproperRestraint_termCode.cc:945:	 ohy1y4 = -(tx149*tx45*tx77*tx90*tx917); 		/* rule 822 */
_ImproperRestraint_termCode.cc:947:	 ohy1z4 = -(tx149*tx20*tx40*tx77*tx90*tx917); 		/* rule 824 */
_ImproperRestraint_termCode.cc:955:	 tx687 = -(tx102*tx149*tx97); 		/* rule 832 */
_ImproperRestraint_termCode.cc:963:	 tx693 = -(tx101*tx102*tx149); 		/* rule 840 */
_ImproperRestraint_termCode.cc:967:	 tx695 = -2.*tx151*tx19*tx203*tx65; 		/* rule 844 */
_ImproperRestraint_termCode.cc:970:	 tx698 = -(tx102*tx105*tx149); 		/* rule 847 */
_ImproperRestraint_termCode.cc:974:	 tx700 = -(tx102*tx109*tx149); 		/* rule 851 */
_ImproperRestraint_termCode.cc:975:	 tx701 = -3*EraseLinearDihedral*K*TWOPI*tx684*tx70*tx75*tx76; 		/* rule 852 */
_ImproperRestraint_termCode.cc:978:	 tx702 = -(tx102*tx113*tx149); 		/* rule 855 */
_ImproperRestraint_termCode.cc:979:	 tx703 = -3*EraseLinearDihedral*K*TWOPI*tx691*tx70*tx75*tx76; 		/* rule 856 */
_ImproperRestraint_termCode.cc:982:	 tx704 = -(tx102*tx117*tx149); 		/* rule 859 */
_ImproperRestraint_termCode.cc:983:	 tx705 = -3*EraseLinearDihedral*K*TWOPI*tx696*tx70*tx75*tx76; 		/* rule 860 */
_ImproperRestraint_termCode.cc:986:	 ohz1x4 = -(tx149*tx19*tx39*tx77*tx90*tx917); 		/* rule 863 */
_ImproperRestraint_termCode.cc:988:	 ohz1y4 = -(tx149*tx19*tx38*tx77*tx90*tx917); 		/* rule 865 */
_ImproperRestraint_termCode.cc:990:	 ohz1z4 = -(tx149*tx47*tx77*tx90*tx917); 		/* rule 867 */
_ImproperRestraint_termCode.cc:1001:	 tx715 = -tx632; 		/* rule 878 */
_ImproperRestraint_termCode.cc:1003:	 tx717 = -tx658; 		/* rule 880 */
_ImproperRestraint_termCode.cc:1005:	 tx719 = -0.5*tx295*tx713*tx90; 		/* rule 882 */
_ImproperRestraint_termCode.cc:1006:	 tx720 = -(tx294*tx714*tx918*tx92); 		/* rule 883 */
_ImproperRestraint_termCode.cc:1022:	 tx734 = -tx640; 		/* rule 899 */
_ImproperRestraint_termCode.cc:1024:	 tx736 = -tx684; 		/* rule 901 */
_ImproperRestraint_termCode.cc:1026:	 tx738 = -0.5*tx295*tx732*tx90; 		/* rule 903 */
_ImproperRestraint_termCode.cc:1027:	 tx739 = -(tx294*tx733*tx918*tx92); 		/* rule 904 */
_ImproperRestraint_termCode.cc:1034:	 tx744 = -tx297; 		/* rule 911 */
_ImproperRestraint_termCode.cc:1038:	 tx748 = -2.*tx151*tx21*tx291*tx918*tx93; 		/* rule 915 */
_ImproperRestraint_termCode.cc:1047:	 tx755 = -tx721; 		/* rule 924 */
_ImproperRestraint_termCode.cc:1048:	 tx756 = -0.5*tx295*tx615*tx77; 		/* rule 925 */
_ImproperRestraint_termCode.cc:1060:	 tx766 = -tx740; 		/* rule 937 */
_ImproperRestraint_termCode.cc:1061:	 tx767 = -0.5*tx295*tx620*tx77; 		/* rule 938 */
_ImproperRestraint_termCode.cc:1070:	 tx774 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx746*tx75*tx76; 		/* rule 947 */
_ImproperRestraint_termCode.cc:1074:	 tx776 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx758*tx76; 		/* rule 951 */
_ImproperRestraint_termCode.cc:1078:	 tx778 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx769; 		/* rule 955 */
_ImproperRestraint_termCode.cc:1092:	 tx790 = -tx671; 		/* rule 969 */
_ImproperRestraint_termCode.cc:1093:	 tx791 = -tx691; 		/* rule 970 */
_ImproperRestraint_termCode.cc:1095:	 tx793 = -0.5*tx295*tx787*tx90; 		/* rule 972 */
_ImproperRestraint_termCode.cc:1096:	 tx794 = -(tx294*tx788*tx918*tx92); 		/* rule 973 */
_ImproperRestraint_termCode.cc:1112:	 tx806 = -tx393; 		/* rule 989 */
_ImproperRestraint_termCode.cc:1116:	 tx810 = -2.*tx151*tx20*tx389*tx918*tx93; 		/* rule 993 */
_ImproperRestraint_termCode.cc:1125:	 tx817 = -0.5*tx295*tx652*tx77; 		/* rule 1002 */
_ImproperRestraint_termCode.cc:1126:	 tx818 = -tx795; 		/* rule 1003 */
_ImproperRestraint_termCode.cc:1135:	 tx825 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx802; 		/* rule 1012 */
_ImproperRestraint_termCode.cc:1139:	 tx827 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx808; 		/* rule 1016 */
_ImproperRestraint_termCode.cc:1143:	 tx829 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx820; 		/* rule 1020 */
_ImproperRestraint_termCode.cc:1165:	 tx845 = -tx487; 		/* rule 1042 */
_ImproperRestraint_termCode.cc:1169:	 tx849 = -2.*tx151*tx19*tx483*tx918*tx93; 		/* rule 1046 */
_ImproperRestraint_termCode.cc:1175:	 tx853 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx834; 		/* rule 1052 */
_ImproperRestraint_termCode.cc:1179:	 tx855 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx841; 		/* rule 1056 */
_ImproperRestraint_termCode.cc:1183:	 tx857 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx847; 		/* rule 1060 */
_ImproperRestraint_termCode.cc:1187:	 tx859 = -(tx294*tx65*tx713); 		/* rule 1064 */
_ImproperRestraint_termCode.cc:1188:	 tx860 = -tx758; 		/* rule 1065 */
_ImproperRestraint_termCode.cc:1189:	 tx861 = -tx802; 		/* rule 1066 */
_ImproperRestraint_termCode.cc:1195:	 tx865 = -(tx294*tx65*tx732); 		/* rule 1072 */
_ImproperRestraint_termCode.cc:1196:	 tx866 = -tx769; 		/* rule 1073 */
_ImproperRestraint_termCode.cc:1197:	 tx867 = -tx834; 		/* rule 1074 */
_ImproperRestraint_termCode.cc:1221:	 tx883 = -(tx294*tx65*tx787); 		/* rule 1098 */
_ImproperRestraint_termCode.cc:1222:	 tx884 = -tx820; 		/* rule 1099 */
_ImproperRestraint_termCode.cc:1223:	 tx885 = -tx841; 		/* rule 1100 */
_ImproperRestraint_termCode.cc:1263:	 tx911 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx875; 		/* rule 1140 */
_ImproperRestraint_termCode.cc:1267:	 tx913 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx879; 		/* rule 1144 */
_ImproperRestraint_termCode.cc:1271:	 tx915 = -3*EraseLinearDihedral*K*TWOPI*tx70*tx75*tx76*tx896; 		/* rule 1148 */
_Nonbond_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_Nonbond_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evaldA", this->eval.dA, 0.0 );
_Nonbond_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evaldC", this->eval.dC, 0.0 );
_Nonbond_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evaldQ1Q2", this->eval.dQ1Q2, 0.0 );
_Nonbond_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_Nonbond_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evalEvdw", this->eval.Evdw, 0.0 );
_Nonbond_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalEeel", this->eval.Eeel, 0.0 );
_Nonbond_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_Nonbond_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_Nonbond_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_Nonbond_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_Nonbond_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_Nonbond_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_Nonbond_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_Nonbond_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_Nonbond_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_Nonbond_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_Nonbond_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_Nonbond_debugEvalSerialize.cc:39: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:40: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_Nonbond_debugEvalSerialize.cc:41: 	node->attributeIfNotDefault("evalNonbondDistance", this->eval.NonbondDistance, 0.0 );
_Nonbond_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_Nonbond_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_Nonbond_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_Nonbond_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_Nonbond_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_Nonbond_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_Nonbond_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("dA", this->eval.dA);
_Nonbond_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("dC", this->eval.dC);
_Nonbond_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("dQ1Q2", this->eval.dQ1Q2);
_Nonbond_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_Nonbond_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("Evdw", this->eval.Evdw);
_Nonbond_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("Eeel", this->eval.Eeel);
_Nonbond_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_Nonbond_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_Nonbond_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_Nonbond_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_Nonbond_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_Nonbond_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_Nonbond_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_Nonbond_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_Nonbond_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_Nonbond_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_Nonbond_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_Nonbond_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_Nonbond_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_Nonbond_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_Nonbond_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_Nonbond_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_Nonbond_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_Nonbond_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_Nonbond_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_Nonbond_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_Nonbond_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_Nonbond_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_Nonbond_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_Nonbond_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_Nonbond_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_Nonbond_debugEvalXml.cc:39: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_Nonbond_debugEvalXml.cc:40: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_Nonbond_debugEvalXml.cc:41: 	xml->addAttributeDoubleScientific ("NonbondDistance", this->eval.NonbondDistance);
_Nonbond_debugFiniteDifference.cc:3:(-delta2 + x1, y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:8:(x1, -delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:13:(x1, y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:18:(x1, y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:23:(x1, y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:28:(x1, y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:33:(-delta2 + x1, y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:40:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:41:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:42:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:48:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:49:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:50:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:56:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:57:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:58:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:64:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:65:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:66:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:72:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:73:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:74:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:79:(x1, -delta2 + y1, z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:86:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:87:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:88:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:94:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:95:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:96:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:102:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:103:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:104:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:110:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:111:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:112:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:117:(x1, y1, -delta2 + z1, x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:124:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:125:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:126:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:132:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:133:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:134:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:140:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:141:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:142:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:147:(x1, y1, z1, -delta2 + x2, y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:154:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:155:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:156:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:162:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:163:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:164:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:169:(x1, y1, z1, x2, -delta2 + y2, z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:176:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:177:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:178:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_debugFiniteDifference.cc:183:(x1, y1, z1, x2, y2, -delta2 + z2, dA, dC, dQ1Q2),
_Nonbond_termCode.cc:1:// C-code
_Nonbond_termCode.cc:13:	 tx1 = -x2; 		/* rule 12 */
_Nonbond_termCode.cc:14:	 tx2 = -y2; 		/* rule 13 */
_Nonbond_termCode.cc:15:	 tx3 = -z2; 		/* rule 14 */
_Nonbond_termCode.cc:30:	 tx14 = -(dC*tx12); 		/* rule 29 */
_Nonbond_termCode.cc:44:	 tx40 = -12.*tzz98; 		/* rule 43 */
_Nonbond_termCode.cc:50:	 tx42 = -tx60; 		/* rule 49 */
_Nonbond_termCode.cc:53:	 fx1 = -gx1; 		/* rule 52 */
_Nonbond_termCode.cc:59:	 fy1 = -gy1; 		/* rule 58 */
_Nonbond_termCode.cc:65:	 fz1 = -gz1; 		/* rule 64 */
_Nonbond_termCode.cc:69:	 tx59 = -6.*tzz97; 		/* rule 68 */
_Nonbond_termCode.cc:73:	 fx2 = -gx2; 		/* rule 72 */
_Nonbond_termCode.cc:79:	 fy2 = -gy2; 		/* rule 78 */
_Nonbond_termCode.cc:85:	 fz2 = -gz2; 		/* rule 84 */
_Nonbond_termCode.cc:98:	 tzz107 = -48*tzz95; 		/* rule 97 */
_Nonbond_termCode.cc:137:	 tzz108 = -168*tzz96; 		/* rule 136 */
_Nonbond_termCode.cc:141:	 tzz106 = -3*tzz94; 		/* rule 140 */
_Stretch_debugEvalSerialize.cc:2:	node->attributeIfNotDefault("evalx1", this->eval.x1, 0.0 );
_Stretch_debugEvalSerialize.cc:3: 	node->attributeIfNotDefault("evaly1", this->eval.y1, 0.0 );
_Stretch_debugEvalSerialize.cc:4: 	node->attributeIfNotDefault("evalz1", this->eval.z1, 0.0 );
_Stretch_debugEvalSerialize.cc:5: 	node->attributeIfNotDefault("evalx2", this->eval.x2, 0.0 );
_Stretch_debugEvalSerialize.cc:6: 	node->attributeIfNotDefault("evaly2", this->eval.y2, 0.0 );
_Stretch_debugEvalSerialize.cc:7: 	node->attributeIfNotDefault("evalz2", this->eval.z2, 0.0 );
_Stretch_debugEvalSerialize.cc:8: 	node->attributeIfNotDefault("evalr0", this->eval.r0, 0.0 );
_Stretch_debugEvalSerialize.cc:9: 	node->attributeIfNotDefault("evalkb", this->eval.kb, 0.0 );
_Stretch_debugEvalSerialize.cc:10: 	node->attributeIfNotDefault("evalEnergy", this->eval.Energy, 0.0 );
_Stretch_debugEvalSerialize.cc:11: 	node->attributeIfNotDefault("evalfx1", this->eval.fx1, 0.0 );
_Stretch_debugEvalSerialize.cc:12: 	node->attributeIfNotDefault("evalfy1", this->eval.fy1, 0.0 );
_Stretch_debugEvalSerialize.cc:13: 	node->attributeIfNotDefault("evalfz1", this->eval.fz1, 0.0 );
_Stretch_debugEvalSerialize.cc:14: 	node->attributeIfNotDefault("evalfx2", this->eval.fx2, 0.0 );
_Stretch_debugEvalSerialize.cc:15: 	node->attributeIfNotDefault("evalfy2", this->eval.fy2, 0.0 );
_Stretch_debugEvalSerialize.cc:16: 	node->attributeIfNotDefault("evalfz2", this->eval.fz2, 0.0 );
_Stretch_debugEvalSerialize.cc:17: 	node->attributeIfNotDefault("evaldhx1x1", this->eval.dhx1x1, 0.0 );
_Stretch_debugEvalSerialize.cc:18: 	node->attributeIfNotDefault("evaldhy1y1", this->eval.dhy1y1, 0.0 );
_Stretch_debugEvalSerialize.cc:19: 	node->attributeIfNotDefault("evaldhz1z1", this->eval.dhz1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:20: 	node->attributeIfNotDefault("evaldhx2x2", this->eval.dhx2x2, 0.0 );
_Stretch_debugEvalSerialize.cc:21: 	node->attributeIfNotDefault("evaldhy2y2", this->eval.dhy2y2, 0.0 );
_Stretch_debugEvalSerialize.cc:22: 	node->attributeIfNotDefault("evaldhz2z2", this->eval.dhz2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:23: 	node->attributeIfNotDefault("evalohx1y1", this->eval.ohx1y1, 0.0 );
_Stretch_debugEvalSerialize.cc:24: 	node->attributeIfNotDefault("evalohx1z1", this->eval.ohx1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:25: 	node->attributeIfNotDefault("evalohx1x2", this->eval.ohx1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:26: 	node->attributeIfNotDefault("evalohx1y2", this->eval.ohx1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:27: 	node->attributeIfNotDefault("evalohx1z2", this->eval.ohx1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:28: 	node->attributeIfNotDefault("evalohy1z1", this->eval.ohy1z1, 0.0 );
_Stretch_debugEvalSerialize.cc:29: 	node->attributeIfNotDefault("evalohy1x2", this->eval.ohy1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:30: 	node->attributeIfNotDefault("evalohy1y2", this->eval.ohy1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:31: 	node->attributeIfNotDefault("evalohy1z2", this->eval.ohy1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:32: 	node->attributeIfNotDefault("evalohz1x2", this->eval.ohz1x2, 0.0 );
_Stretch_debugEvalSerialize.cc:33: 	node->attributeIfNotDefault("evalohz1y2", this->eval.ohz1y2, 0.0 );
_Stretch_debugEvalSerialize.cc:34: 	node->attributeIfNotDefault("evalohz1z2", this->eval.ohz1z2, 0.0 );
_Stretch_debugEvalSerialize.cc:35: 	node->attributeIfNotDefault("evalohx2y2", this->eval.ohx2y2, 0.0 );
_Stretch_debugEvalSerialize.cc:36: 	node->attributeIfNotDefault("evalohx2z2", this->eval.ohx2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:37: 	node->attributeIfNotDefault("evalohy2z2", this->eval.ohy2z2, 0.0 );
_Stretch_debugEvalSerialize.cc:38: 	node->attributeIfNotDefault("evalStretchDeviation", this->eval.StretchDeviation, 0.0 );
_Stretch_debugEvalXml.cc:2:	xml->addAttributeDoubleScientific ("x1", this->eval.x1);
_Stretch_debugEvalXml.cc:3: 	xml->addAttributeDoubleScientific ("y1", this->eval.y1);
_Stretch_debugEvalXml.cc:4: 	xml->addAttributeDoubleScientific ("z1", this->eval.z1);
_Stretch_debugEvalXml.cc:5: 	xml->addAttributeDoubleScientific ("x2", this->eval.x2);
_Stretch_debugEvalXml.cc:6: 	xml->addAttributeDoubleScientific ("y2", this->eval.y2);
_Stretch_debugEvalXml.cc:7: 	xml->addAttributeDoubleScientific ("z2", this->eval.z2);
_Stretch_debugEvalXml.cc:8: 	xml->addAttributeDoubleScientific ("r0", this->eval.r0);
_Stretch_debugEvalXml.cc:9: 	xml->addAttributeDoubleScientific ("kb", this->eval.kb);
_Stretch_debugEvalXml.cc:10: 	xml->addAttributeDoubleScientific ("Energy", this->eval.Energy);
_Stretch_debugEvalXml.cc:11: 	xml->addAttributeDoubleScientific ("fx1", this->eval.fx1);
_Stretch_debugEvalXml.cc:12: 	xml->addAttributeDoubleScientific ("fy1", this->eval.fy1);
_Stretch_debugEvalXml.cc:13: 	xml->addAttributeDoubleScientific ("fz1", this->eval.fz1);
_Stretch_debugEvalXml.cc:14: 	xml->addAttributeDoubleScientific ("fx2", this->eval.fx2);
_Stretch_debugEvalXml.cc:15: 	xml->addAttributeDoubleScientific ("fy2", this->eval.fy2);
_Stretch_debugEvalXml.cc:16: 	xml->addAttributeDoubleScientific ("fz2", this->eval.fz2);
_Stretch_debugEvalXml.cc:17: 	xml->addAttributeDoubleScientific ("dhx1x1", this->eval.dhx1x1);
_Stretch_debugEvalXml.cc:18: 	xml->addAttributeDoubleScientific ("dhy1y1", this->eval.dhy1y1);
_Stretch_debugEvalXml.cc:19: 	xml->addAttributeDoubleScientific ("dhz1z1", this->eval.dhz1z1);
_Stretch_debugEvalXml.cc:20: 	xml->addAttributeDoubleScientific ("dhx2x2", this->eval.dhx2x2);
_Stretch_debugEvalXml.cc:21: 	xml->addAttributeDoubleScientific ("dhy2y2", this->eval.dhy2y2);
_Stretch_debugEvalXml.cc:22: 	xml->addAttributeDoubleScientific ("dhz2z2", this->eval.dhz2z2);
_Stretch_debugEvalXml.cc:23: 	xml->addAttributeDoubleScientific ("ohx1y1", this->eval.ohx1y1);
_Stretch_debugEvalXml.cc:24: 	xml->addAttributeDoubleScientific ("ohx1z1", this->eval.ohx1z1);
_Stretch_debugEvalXml.cc:25: 	xml->addAttributeDoubleScientific ("ohx1x2", this->eval.ohx1x2);
_Stretch_debugEvalXml.cc:26: 	xml->addAttributeDoubleScientific ("ohx1y2", this->eval.ohx1y2);
_Stretch_debugEvalXml.cc:27: 	xml->addAttributeDoubleScientific ("ohx1z2", this->eval.ohx1z2);
_Stretch_debugEvalXml.cc:28: 	xml->addAttributeDoubleScientific ("ohy1z1", this->eval.ohy1z1);
_Stretch_debugEvalXml.cc:29: 	xml->addAttributeDoubleScientific ("ohy1x2", this->eval.ohy1x2);
_Stretch_debugEvalXml.cc:30: 	xml->addAttributeDoubleScientific ("ohy1y2", this->eval.ohy1y2);
_Stretch_debugEvalXml.cc:31: 	xml->addAttributeDoubleScientific ("ohy1z2", this->eval.ohy1z2);
_Stretch_debugEvalXml.cc:32: 	xml->addAttributeDoubleScientific ("ohz1x2", this->eval.ohz1x2);
_Stretch_debugEvalXml.cc:33: 	xml->addAttributeDoubleScientific ("ohz1y2", this->eval.ohz1y2);
_Stretch_debugEvalXml.cc:34: 	xml->addAttributeDoubleScientific ("ohz1z2", this->eval.ohz1z2);
_Stretch_debugEvalXml.cc:35: 	xml->addAttributeDoubleScientific ("ohx2y2", this->eval.ohx2y2);
_Stretch_debugEvalXml.cc:36: 	xml->addAttributeDoubleScientific ("ohx2z2", this->eval.ohx2z2);
_Stretch_debugEvalXml.cc:37: 	xml->addAttributeDoubleScientific ("ohy2z2", this->eval.ohy2z2);
_Stretch_debugEvalXml.cc:38: 	xml->addAttributeDoubleScientific ("StretchDeviation", this->eval.StretchDeviation);
_Stretch_debugFiniteDifference.cc:4:(-delta2 + x1, y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:9:(x1, -delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:14:(x1, y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:19:(x1, y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:24:(x1, y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:29:(x1, y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:34:(-delta2 + x1, y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:41:(-delta2 + x1, -delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:42:(delta2 + x1, -delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:43:(-delta2 + x1, delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:49:(-delta2 + x1, y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:50:(delta2 + x1, y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:51:(-delta2 + x1, y1, delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:57:(-delta2 + x1, y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:58:(delta2 + x1, y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:59:(-delta2 + x1, y1, z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:65:(-delta2 + x1, y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:66:(delta2 + x1, y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:67:(-delta2 + x1, y1, z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:73:(-delta2 + x1, y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:74:(delta2 + x1, y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:75:(-delta2 + x1, y1, z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:80:(x1, -delta2 + y1, z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:87:(x1, -delta2 + y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:88:(x1, delta2 + y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:89:(x1, -delta2 + y1, delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:95:(x1, -delta2 + y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:96:(x1, delta2 + y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:97:(x1, -delta2 + y1, z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:103:(x1, -delta2 + y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:104:(x1, delta2 + y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:105:(x1, -delta2 + y1, z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:111:(x1, -delta2 + y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:112:(x1, delta2 + y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:113:(x1, -delta2 + y1, z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:118:(x1, y1, -delta2 + z1, x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:125:(x1, y1, -delta2 + z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:126:(x1, y1, delta2 + z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:127:(x1, y1, -delta2 + z1, delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:133:(x1, y1, -delta2 + z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:134:(x1, y1, delta2 + z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:135:(x1, y1, -delta2 + z1, x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:141:(x1, y1, -delta2 + z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:142:(x1, y1, delta2 + z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:143:(x1, y1, -delta2 + z1, x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:148:(x1, y1, z1, -delta2 + x2, y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:155:(x1, y1, z1, -delta2 + x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:156:(x1, y1, z1, delta2 + x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:157:(x1, y1, z1, -delta2 + x2, delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:163:(x1, y1, z1, -delta2 + x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:164:(x1, y1, z1, delta2 + x2, y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:165:(x1, y1, z1, -delta2 + x2, y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:170:(x1, y1, z1, x2, -delta2 + y2, z2, r0, kb),
_Stretch_debugFiniteDifference.cc:177:(x1, y1, z1, x2, -delta2 + y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:178:(x1, y1, z1, x2, delta2 + y2, -delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:179:(x1, y1, z1, x2, -delta2 + y2, delta2 + z2, r0, kb),
_Stretch_debugFiniteDifference.cc:184:(x1, y1, z1, x2, y2, -delta2 + z2, r0, kb),
_Stretch_termCode.cc:1:// C-code
_Stretch_termCode.cc:12:	 tx1 = -x1; 		/* rule 11 */
_Stretch_termCode.cc:13:	 tx2 = -y1; 		/* rule 12 */
_Stretch_termCode.cc:14:	 tx3 = -z1; 		/* rule 13 */
_Stretch_termCode.cc:22:	 tx11 = -r0; 		/* rule 21 */
_Stretch_termCode.cc:34:	 tx29 = -2.*tzz50; 		/* rule 33 */
_Stretch_termCode.cc:36:	 fx1 = -gx1; 		/* rule 35 */
_Stretch_termCode.cc:39:	 fy1 = -gy1; 		/* rule 38 */
_Stretch_termCode.cc:42:	 fz1 = -gz1; 		/* rule 41 */
_Stretch_termCode.cc:46:	 fx2 = -gx2; 		/* rule 45 */
_Stretch_termCode.cc:49:	 fy2 = -gy2; 		/* rule 48 */
_Stretch_termCode.cc:52:	 fz2 = -gz2; 		/* rule 51 */
_Stretch_termCode.cc:59:	 tzz54 = -2.*tzz48; 		/* rule 58 */
_Stretch_termCode.cc:94:	 tzz53 = -2.*tzz49; 		/* rule 93 */
_gaff_Parser.cc:3:/* Bison implementation for Yacc-like parsers in C
_gaff_Parser.cc:5:      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
_gaff_Parser.cc:34:   simplifying the original so-called "semantic" parser.  */
_gaff_Parser.cc:254:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
_gaff_Parser.cc:260:#   define YY_(msgid) dgettext ("bison-runtime", msgid)
_gaff_Parser.cc:268:/* Suppress unused-variable warnings by "using" E.  */
_gaff_Parser.cc:322:   /* Pacify GCC's `empty if-body' warning.  */
_gaff_Parser.cc:328:       to allow for a few compiler-allocated temporary stack slots.  */
_gaff_Parser.cc:377:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
_gaff_Parser.cc:396:	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
_gaff_Parser.cc:397:	Stack = &yyptr->Stack_alloc;					\
_gaff_Parser.cc:425:/* YYFINAL -- State number of the termination state.  */
_gaff_Parser.cc:427:/* YYLAST -- Last index in YYTABLE.  */
_gaff_Parser.cc:430:/* YYNTOKENS -- Number of terminals.  */
_gaff_Parser.cc:432:/* YYNNTS -- Number of nonterminals.  */
_gaff_Parser.cc:434:/* YYNRULES -- Number of rules.  */
_gaff_Parser.cc:436:/* YYNRULES -- Number of states.  */
_gaff_Parser.cc:439:/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
_gaff_Parser.cc:446:/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
_gaff_Parser.cc:481:/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
_gaff_Parser.cc:493:/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
_gaff_Parser.cc:496:      28,     0,    -1,    25,    29,    -1,    30,    32,    33,    34,
_gaff_Parser.cc:497:      35,    36,    37,    38,    39,     3,    -1,    30,    32,    33,
_gaff_Parser.cc:498:      34,    35,    36,    37,    38,     3,    -1,    30,    32,    33,
_gaff_Parser.cc:499:      34,    35,    36,    37,     3,    -1,    30,    32,    33,    34,
_gaff_Parser.cc:500:      35,    36,     3,    -1,    30,    32,    33,    34,    35,     3,
_gaff_Parser.cc:501:      -1,    30,    32,    33,    34,     3,    -1,    30,    32,    33,
_gaff_Parser.cc:502:       3,    -1,    30,    32,     3,    -1,    30,     3,    -1,    31,
_gaff_Parser.cc:503:      -1,    31,    14,    20,    -1,    31,    14,    20,    31,    -1,
_gaff_Parser.cc:504:      31,    14,    31,    -1,    21,    -1,     4,    -1,     6,    -1,
_gaff_Parser.cc:505:       6,    -1,    20,    -1,     6,    -1,    20,    -1,     6,    -1,
_gaff_Parser.cc:506:      20,    -1,     6,    -1,    20,    -1,     6,    -1,     9,    40,
_gaff_Parser.cc:507:      11,    -1,     6,    -1,    42,    -1,    21,    15,    21,    15,
_gaff_Parser.cc:508:      19,    -1,    41,    -1,    40,    13,    40,    -1,    40,    14,
_gaff_Parser.cc:509:      40,    -1,    19,    -1,    20,    19,    -1,    19,    23,    -1,
_gaff_Parser.cc:510:      19,    24,    -1,    16,    -1,    17,    -1,    17,    20,    -1,
_gaff_Parser.cc:511:      20,    17,    20,    -1,    18,    -1,     7,    43,     8,    -1,
_gaff_Parser.cc:512:      44,    -1,    43,    13,    44,    -1,    45,    -1,    45,    42,
_gaff_Parser.cc:513:      -1,    46,    20,    47,    48,    -1,    46,    47,    48,    -1,
_gaff_Parser.cc:514:       4,    -1,     5,    -1,    -1,     9,    40,    11,    -1,    -1,
_gaff_Parser.cc:515:      10,    21,    12,    -1
_gaff_Parser.cc:518:/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
_gaff_Parser.cc:531:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
_gaff_Parser.cc:554:/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
_gaff_Parser.cc:555:   token YYLEX-NUM.  */
_gaff_Parser.cc:564:/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
_gaff_Parser.cc:575:/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
_gaff_Parser.cc:586:/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
_gaff_Parser.cc:602:/* YYDEFGOTO[NTERM-NUM].  */
_gaff_Parser.cc:605:      -1,     2,     5,     6,     7,    11,    16,    22,    27,    31,
_gaff_Parser.cc:610:/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
_gaff_Parser.cc:611:   STATE-NUM.  */
_gaff_Parser.cc:612:#define YYPACT_NINF -43
_gaff_Parser.cc:615:      -9,    10,    28,   -43,   -43,   -43,    50,    30,   -43,   -43,
_gaff_Parser.cc:616:     -43,    -1,     0,   -43,   -43,   -43,     3,    10,   -43,   -43,
_gaff_Parser.cc:617:     -43,   -43,     4,   -43,   -43,   -43,   -43,     5,   -43,   -43,
_gaff_Parser.cc:618:     -43,    24,   -43,   -43,    22,    40,   -43,    16,   -43,    11,
_gaff_Parser.cc:619:     -16,    37,   -43,   -43,   -43,    53,    -3,   -43,   -43,   -43,
_gaff_Parser.cc:620:     -43,    25,   -43,   -43,    22,    22,   -43,   -43,     9,   -43,
_gaff_Parser.cc:621:      42,     6,   -43,    44,    57,   -43,    47,   -43,   -43,    53,
_gaff_Parser.cc:622:     -43,    22,    54,    52,    43,   -43,   -43,    41,    52,    45,
_gaff_Parser.cc:623:     -43,    55,   -43,   -43,    56,    46,   -43,   -43
_gaff_Parser.cc:626:/* YYPGOTO[NTERM-NUM].  */
_gaff_Parser.cc:629:     -43,   -43,   -43,   -43,    20,   -43,   -43,   -43,   -43,   -43,
_gaff_Parser.cc:630:     -43,   -43,   -43,   -42,   -43,     7,   -43,     2,   -43,   -43,
_gaff_Parser.cc:631:       1,    -6
_gaff_Parser.cc:634:/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
_gaff_Parser.cc:637:#define YYTABLE_NINF -1
_gaff_Parser.cc:651:  ((yystate) == (-43))
_gaff_Parser.cc:664:       3,    14,    10,     9,    21,    19,    21,    60,    12,    -1,
_gaff_Parser.cc:668:/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
_gaff_Parser.cc:669:   symbol of state STATE-NUM.  */
_gaff_Parser.cc:685:#define YYEMPTY		(-2)
_gaff_Parser.cc:703:     -Wunused-macros.  Normally we don't worry about that warning, but
_gaff_Parser.cc:731:/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
_gaff_Parser.cc:757:/* YY_LOCATION_PRINT -- Print the location on the stream.
_gaff_Parser.cc:764:     fprintf (File, "%d.%d-%d.%d",			\
_gaff_Parser.cc:773:/* YYLEX -- calling `yylex' with the right arguments.  */
_gaff_Parser.cc:807:/*--------------------------------.
_gaff_Parser.cc:809:`--------------------------------*/
_gaff_Parser.cc:844:/*--------------------------------.
_gaff_Parser.cc:846:`--------------------------------*/
_gaff_Parser.cc:873:/*------------------------------------------------------------------.
_gaff_Parser.cc:874:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
_gaff_Parser.cc:876:`------------------------------------------------------------------*/
_gaff_Parser.cc:905:/*------------------------------------------------.
_gaff_Parser.cc:907:`------------------------------------------------*/
_gaff_Parser.cc:926:	     yyrule - 1, yylno);
_gaff_Parser.cc:932:		       &(yyvsp[(yyi + 1) - (yynrhs)])
_gaff_Parser.cc:933:		       , &(yylsp[(yyi + 1) - (yynrhs)])		       , data);
_gaff_Parser.cc:955:/* YYINITDEPTH -- initial size of the parser's stacks.  */
_gaff_Parser.cc:960:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
_gaff_Parser.cc:961:   if the built-in stack extension method is used).
_gaff_Parser.cc:965:   evaluated with infinite-precision integer arithmetic.  */
_gaff_Parser.cc:1020:  return yyd - 1;
_gaff_Parser.cc:1028:   heuristic is that double-quoting is unnecessary unless the string
_gaff_Parser.cc:1030:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
_gaff_Parser.cc:1069:  return yystpcpy (yyres, yystr) - yyres;
_gaff_Parser.cc:1098:     - Assume YYFAIL is not used.  It's too flawed to consider.  See
_gaff_Parser.cc:1099:       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
_gaff_Parser.cc:1102:     - If this state is a consistent state with a default action, then
_gaff_Parser.cc:1106:     - The only way there can be no lookahead present (in yychar) is if
_gaff_Parser.cc:1111:     - Don't assume there isn't a lookahead just because this state is a
_gaff_Parser.cc:1113:       previous inconsistent state, consistent state with a non-default
_gaff_Parser.cc:1115:     - Of course, the expected token list depends on states to have
_gaff_Parser.cc:1130:          /* Start YYX at -YYN if negative to avoid negative indexes in
_gaff_Parser.cc:1131:             YYCHECK.  In other words, skip the first -YYN actions for
_gaff_Parser.cc:1133:          int yyxbegin = yyn < 0 ? -yyn : 0;
_gaff_Parser.cc:1135:          int yychecklim = YYLAST - yyn + 1;
_gaff_Parser.cc:1210:/*-----------------------------------------------.
_gaff_Parser.cc:1212:`-----------------------------------------------*/
_gaff_Parser.cc:1243:	{ if ((yyvaluep->antechamberRoot)!=NULL) delete ((yyvaluep->antechamberRoot)); };
_gaff_Parser.cc:1252:	{ if ((yyvaluep->residueList)!=NULL) delete ((yyvaluep->residueList)); };
_gaff_Parser.cc:1261:	{ if ((yyvaluep->logical)!=NULL) delete ((yyvaluep->logical)); };
_gaff_Parser.cc:1270:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_gaff_Parser.cc:1279:	{ if ((yyvaluep->afterMatchBondTest)!=NULL) delete ((yyvaluep->afterMatchBondTest)); };
_gaff_Parser.cc:1288:	{ if ((yyvaluep->logical)!=NULL) delete ((yyvaluep->logical)); };
_gaff_Parser.cc:1297:	{ if ((yyvaluep->atomTest)!=NULL) delete ((yyvaluep->atomTest)); };
_gaff_Parser.cc:1306:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_gaff_Parser.cc:1315:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_gaff_Parser.cc:1324:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_gaff_Parser.cc:1333:	{ if ((yyvaluep->antechamberBondTest)!=NULL) delete ((yyvaluep->antechamberBondTest)); };
_gaff_Parser.cc:1342:	{ if ((yyvaluep->logical)!=NULL) delete ((yyvaluep->logical)); };
_gaff_Parser.cc:1354:/* Prevent warnings from -Wmissing-prototypes.  */
_gaff_Parser.cc:1370:/*----------.
_gaff_Parser.cc:1372:`----------*/
_gaff_Parser.cc:1456:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
_gaff_Parser.cc:1491:/*------------------------------------------------------------.
_gaff_Parser.cc:1492:| yynewstate -- Push a new state, which is found in yystate.  |
_gaff_Parser.cc:1493:`------------------------------------------------------------*/
_gaff_Parser.cc:1502:  if (yyss + yystacksize - 1 <= yyssp)
_gaff_Parser.cc:1505:      YYSIZE_T yysize = yyssp - yyss + 1;
_gaff_Parser.cc:1557:      yyssp = yyss + yysize - 1;
_gaff_Parser.cc:1558:      yyvsp = yyvs + yysize - 1;
_gaff_Parser.cc:1559:      yylsp = yyls + yysize - 1;
_gaff_Parser.cc:1564:      if (yyss + yystacksize - 1 <= yyssp)
_gaff_Parser.cc:1575:/*-----------.
_gaff_Parser.cc:1577:`-----------*/
_gaff_Parser.cc:1618:      yyn = -yyn;
_gaff_Parser.cc:1625:    yyerrstatus--;
_gaff_Parser.cc:1639:/*-----------------------------------------------------------.
_gaff_Parser.cc:1640:| yydefault -- do the default action for the current state.  |
_gaff_Parser.cc:1641:`-----------------------------------------------------------*/
_gaff_Parser.cc:1649:/*-----------------------------.
_gaff_Parser.cc:1650:| yyreduce -- Do a reduction.  |
_gaff_Parser.cc:1651:`-----------------------------*/
_gaff_Parser.cc:1664:  yyval = yyvsp[1-yylen];
_gaff_Parser.cc:1667:  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
_gaff_Parser.cc:1675:    { data->expression = (yyvsp[(2) - (2)].antechamberRoot)->_obj; LOG(BF("Got AntechamberMatch tree=%0X") % (yyvsp[(2) - (2)].antechamberRoot) ); }
_gaff_Parser.cc:1685:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (10)].residueList)->_obj, (yyvsp[(3) - (10)].ival), (yyvsp[(4) - (10)].ival), (yyvsp[(5) - (10)].ival), (yyvsp[(6) - (10)].ival), (yyvsp[(7) - (10)].logical)->_obj, GP()->lisp );
_gaff_Parser.cc:1686:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (10)].carr),focus,(yyvsp[(8) - (10)].bondListMatchNode)->_obj,(yyvsp[(9) - (10)].afterMatchBondTest)->_obj,GP()->lisp)); 
_gaff_Parser.cc:1697:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (9)].residueList)->_obj, (yyvsp[(3) - (9)].ival), (yyvsp[(4) - (9)].ival), (yyvsp[(5) - (9)].ival), (yyvsp[(6) - (9)].ival), (yyvsp[(7) - (9)].logical)->_obj, GP()->lisp );
_gaff_Parser.cc:1698:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (9)].carr),focus,(yyvsp[(8) - (9)].bondListMatchNode)->_obj,GP()->lisp)); 
_gaff_Parser.cc:1709:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (8)].residueList)->_obj, (yyvsp[(3) - (8)].ival), (yyvsp[(4) - (8)].ival), (yyvsp[(5) - (8)].ival), (yyvsp[(6) - (8)].ival), (yyvsp[(7) - (8)].logical)->_obj ,GP()->lisp);
_gaff_Parser.cc:1710:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (8)].carr),focus,GP()->lisp)); 
_gaff_Parser.cc:1723:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (7)].residueList)->_obj, (yyvsp[(3) - (7)].ival), (yyvsp[(4) - (7)].ival), (yyvsp[(5) - (7)].ival), (yyvsp[(6) - (7)].ival), temp ,GP()->lisp);
_gaff_Parser.cc:1724:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (7)].carr),focus,GP()->lisp)); 
_gaff_Parser.cc:1735:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (6)].residueList)->_obj, (yyvsp[(3) - (6)].ival), (yyvsp[(4) - (6)].ival), (yyvsp[(5) - (6)].ival), -1,GP()->lisp);
_gaff_Parser.cc:1736:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (6)].carr),focus,GP()->lisp)); 
_gaff_Parser.cc:1747:		    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (5)].residueList)->_obj, (yyvsp[(3) - (5)].ival), (yyvsp[(4) - (5)].ival), -1, -1,GP()->lisp);
_gaff_Parser.cc:1748:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (5)].carr),focus,GP()->lisp));
_gaff_Parser.cc:1759:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (4)].residueList)->_obj, (yyvsp[(3) - (4)].ival), -1, -1, -1 ,GP()->lisp);
_gaff_Parser.cc:1760:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (4)].carr),focus,GP()->lisp)); 
_gaff_Parser.cc:1771:                    focus = chem::AntechamberFocusAtomMatch_O::create( (yyvsp[(2) - (3)].residueList)->_obj, -1, -1, -1, -1,GP()->lisp);
_gaff_Parser.cc:1772:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (3)].carr),focus,GP()->lisp)); 
_gaff_Parser.cc:1784:                    (yyval.antechamberRoot) = new chem::Hold<chem::AntechamberRoot_O>(chem::AntechamberRoot_O::create((yyvsp[(1) - (2)].carr),focus,GP()->lisp));
_gaff_Parser.cc:1792:    { strcpy((yyval.carr),(yyvsp[(1) - (1)].carr)); }
_gaff_Parser.cc:1799:    { stringstream ss; ss << (yyvsp[(1) - (3)].carr) << "." << (yyvsp[(3) - (3)].ival); strcpy((yyval.carr),ss.str().c_str()); }
_gaff_Parser.cc:1806:    { stringstream ss; ss << (yyvsp[(1) - (4)].carr) << "." << (yyvsp[(3) - (4)].ival) << (yyvsp[(4) - (4)].carr); strcpy((yyval.carr),ss.str().c_str()); }
_gaff_Parser.cc:1813:    { stringstream ss; ss << (yyvsp[(1) - (3)].carr) << "." << (yyvsp[(3) - (3)].carr); strcpy((yyval.carr),ss.str().c_str()); }
_gaff_Parser.cc:1820:    { strcpy((yyval.carr),(yyvsp[(1) - (1)].carr)); }
_gaff_Parser.cc:1827:    { strcpy((yyval.carr),(yyvsp[(1) - (1)].carr)); }
_gaff_Parser.cc:1834:    { (yyval.residueList) = new chem::Hold<chem::ResidueList_O>(GP()->lisp); }
_gaff_Parser.cc:1841:    { (yyval.ival) = -1; }
_gaff_Parser.cc:1848:    { (yyval.ival) = (yyvsp[(1) - (1)].ival); }
_gaff_Parser.cc:1855:    { (yyval.ival) = -1; }
_gaff_Parser.cc:1862:    { (yyval.ival) = (yyvsp[(1) - (1)].ival); }
_gaff_Parser.cc:1869:    { (yyval.ival) = -1; }
_gaff_Parser.cc:1876:    { (yyval.ival) = (yyvsp[(1) - (1)].ival); }
_gaff_Parser.cc:1883:    { (yyval.ival) = -1; }
_gaff_Parser.cc:1890:    { (yyval.ival) = (yyvsp[(1) - (1)].ival); }
_gaff_Parser.cc:1897:    { _BT(); (yyval.logical) = new chem::Hold<chem::Logical_O>(GP()->lisp); }
_gaff_Parser.cc:1906:		(yyval.logical) = new chem::Hold<chem::Logical_O>((yyvsp[(2) - (3)].logical)->_obj); }
_gaff_Parser.cc:1913:    { _BT(); (yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>(GP()->lisp); }
_gaff_Parser.cc:1920:    { _BT(); (yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>((yyvsp[(1) - (1)].bondListMatchNode)->_obj); }
_gaff_Parser.cc:1927:    {_BT(); (yyval.afterMatchBondTest) = new chem::Hold<chem::AfterMatchBondTest_O>(chem::AfterMatchBondTest_O::create( (yyvsp[(1) - (5)].carr), (yyvsp[(3) - (5)].carr), (yyvsp[(5) - (5)].benum) ,GP()->lisp)); }
_gaff_Parser.cc:1934:    {_BT(); (yyval.logical) = new chem::Hold<chem::Logical_O>(chem::Logical_O::create( chem::logIdentity, (yyvsp[(1) - (1)].atomTest)->_obj ,GP()->lisp)); }
_gaff_Parser.cc:1941:    { _BT();(yyval.logical) = new chem::Hold<chem::Logical_O>(chem::Logical_O::create(chem::logHighPrecedenceAnd, (yyvsp[(1) - (3)].logical)->_obj, (yyvsp[(3) - (3)].logical)->_obj ,GP()->lisp)); }
_gaff_Parser.cc:1948:    {_BT(); (yyval.logical) = new chem::Hold<chem::Logical_O>(chem::Logical_O::create(chem::logOr, (yyvsp[(1) - (3)].logical)->_obj, (yyvsp[(3) - (3)].logical)->_obj ,GP()->lisp)); }
_gaff_Parser.cc:1955:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPInBond, (yyvsp[(1) - (1)].benum), 1,GP()->lisp)); }
_gaff_Parser.cc:1962:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPInBond, (yyvsp[(2) - (2)].benum), (yyvsp[(1) - (2)].ival),GP()->lisp)); }
_gaff_Parser.cc:1969:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPNotBondedToPrevious,(yyvsp[(1) - (2)].benum),GP()->lisp)); }
_gaff_Parser.cc:1976:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPBondedToPrevious,(yyvsp[(1) - (2)].benum),GP()->lisp)); }
_gaff_Parser.cc:1983:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPArLevel, (yyvsp[(1) - (1)].ival) ,GP()->lisp)); }
_gaff_Parser.cc:1990:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPRingSize, 1 ,GP()->lisp)); }
_gaff_Parser.cc:1997:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPRingSize, (yyvsp[(2) - (2)].ival) ,GP()->lisp)); }
_gaff_Parser.cc:2004:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPRingSize, (yyvsp[(3) - (3)].ival), (yyvsp[(1) - (3)].ival) ,GP()->lisp)); }
_gaff_Parser.cc:2011:    { _BT(); (yyval.atomTest) = new chem::Hold<chem::AtomTest_O>(chem::AtomTest_O::create(chem::SAPNoRing,GP()->lisp)); }
_gaff_Parser.cc:2018:    { _BT(); (yyval.bondListMatchNode)=(yyvsp[(2) - (3)].bondListMatchNode); }
_gaff_Parser.cc:2025:    { _BT(); (yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>((yyvsp[(1) - (1)].bondListMatchNode)->_obj); }
_gaff_Parser.cc:2032:    { _BT(); (yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>(chem::Branch_O::create((yyvsp[(1) - (3)].bondListMatchNode)->_obj,(yyvsp[(3) - (3)].bondListMatchNode)->_obj,GP()->lisp)); }
_gaff_Parser.cc:2039:    { _BT();(yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>(chem::Chain_O::create((yyvsp[(1) - (1)].antechamberBondTest)->_obj,GP()->lisp));}
_gaff_Parser.cc:2046:    { _BT(); (yyval.bondListMatchNode) = new chem::Hold<chem::BondListMatchNode_O>(chem::Chain_O::create((yyvsp[(1) - (2)].antechamberBondTest)->_obj,(yyvsp[(2) - (2)].bondListMatchNode)->_obj,GP()->lisp)); }
_gaff_Parser.cc:2054:                    (yyval.antechamberBondTest) = new chem::Hold<chem::AntechamberBondTest_O>(chem::AntechamberBondTest_O::create((yyvsp[(1) - (4)].carr),(yyvsp[(2) - (4)].ival),(yyvsp[(3) - (4)].logical)->_obj,(yyvsp[(4) - (4)].carr),GP()->lisp)); 
_gaff_Parser.cc:2063:                    (yyval.antechamberBondTest) = new chem::Hold<chem::AntechamberBondTest_O>(chem::AntechamberBondTest_O::create((yyvsp[(1) - (3)].carr), -1, (yyvsp[(2) - (3)].logical)->_obj, (yyvsp[(3) - (3)].carr),GP()->lisp));
_gaff_Parser.cc:2071:    { _BT(); strcpy((yyval.carr),(yyvsp[(1) - (1)].carr)); }
_gaff_Parser.cc:2078:    { _BT(); strcpy((yyval.carr),(yyvsp[(1) - (1)].carr)); }
_gaff_Parser.cc:2085:    { _BT(); (yyval.logical) = new chem::Hold<chem::Logical_O>(GP()->lisp); }
_gaff_Parser.cc:2092:    { _BT(); (yyval.logical) = new chem::Hold<chem::Logical_O>((yyvsp[(2) - (3)].logical)->_obj); }
_gaff_Parser.cc:2106:    { _BT(); strcpy((yyval.carr),(yyvsp[(2) - (3)].carr)); }
_gaff_Parser.cc:2126:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
_gaff_Parser.cc:2141:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
_gaff_Parser.cc:2145:    yystate = yydefgoto[yyn - YYNTOKENS];
_gaff_Parser.cc:2150:/*------------------------------------.
_gaff_Parser.cc:2151:| yyerrlab -- here on detecting error |
_gaff_Parser.cc:2152:`------------------------------------*/
_gaff_Parser.cc:2224:/*---------------------------------------------------.
_gaff_Parser.cc:2225:| yyerrorlab -- error raised explicitly by YYERROR.  |
_gaff_Parser.cc:2226:`---------------------------------------------------*/
_gaff_Parser.cc:2235:  yyerror_range[1] = yylsp[1-yylen];
_gaff_Parser.cc:2245:/*-------------------------------------------------------------.
_gaff_Parser.cc:2246:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
_gaff_Parser.cc:2247:`-------------------------------------------------------------*/
_gaff_Parser.cc:2292:/*-------------------------------------.
_gaff_Parser.cc:2293:| yyacceptlab -- YYACCEPT comes here.  |
_gaff_Parser.cc:2294:`-------------------------------------*/
_gaff_Parser.cc:2299:/*-----------------------------------.
_gaff_Parser.cc:2300:| yyabortlab -- YYABORT comes here.  |
_gaff_Parser.cc:2301:`-----------------------------------*/
_gaff_Parser.cc:2307:/*-------------------------------------------------.
_gaff_Parser.cc:2308:| yyexhaustedlab -- memory exhaustion comes here.  |
_gaff_Parser.cc:2309:`-------------------------------------------------*/
_gaff_Parser.cc:2471:    *(data->gaffErrorStream) << "Error: " << message << endl;
_gaff_Parser.cc:2479:	ichar = data->acLexStream->get();	 // Read one character
_gaff_Parser.cc:2482:    } while (!data->acLexStream->eof() && ichar <= ' ' );
_gaff_Parser.cc:2483:    if ( data->acLexStream->eof() ) return 0;
_gaff_Parser.cc:2488:    if ( data->wildElementDictionary.notnilp() ) {
_gaff_Parser.cc:2489:        if ( data->wildElementDictionary->lexWildNameMatches2Char(ichar,
_gaff_Parser.cc:2490:                                        data->acLexStream->peek()) )
_gaff_Parser.cc:2492:            int ichar2 = data->acLexStream->get();
_gaff_Parser.cc:2493:            gaff_lval->carr[0] = ichar;
_gaff_Parser.cc:2494:            gaff_lval->carr[1] = ichar2;
_gaff_Parser.cc:2495:            gaff_lval->carr[2] = '\0';
_gaff_Parser.cc:2497:                                gaff_lval->carr));
_gaff_Parser.cc:2500:        if ( data->wildElementDictionary->lexWildNameMatches1Char(ichar) ) {
_gaff_Parser.cc:2501:            gaff_lval->carr[0] = ichar;
_gaff_Parser.cc:2502:            gaff_lval->carr[1] = '\0';
_gaff_Parser.cc:2504:                                gaff_lval->carr));
_gaff_Parser.cc:2567:    LOG(BF("peek(%c)") % (acLexStream->peek() ) ); // vp0(( "peek(%c)", acLexStream->peek() ));
_gaff_Parser.cc:2569:    if ( ichar == 'A' && data->acLexStream->peek() == 'T' ) {
_gaff_Parser.cc:2570:        data->acLexStream->get();
_gaff_Parser.cc:2571:        LOG(BF("peek2(%c)") % (acLexStream->peek() ) ); // vp0(( "peek2(%c)", acLexStream->peek() ));
_gaff_Parser.cc:2572:        if ( data->acLexStream->peek() != 'D' ) {
_gaff_Parser.cc:2575:        data->acLexStream->get();
_gaff_Parser.cc:2581:    if (ichar == 'A' && data->acLexStream->peek() == 'R') {
_gaff_Parser.cc:2582:        data->acLexStream->get();
_gaff_Parser.cc:2583:        int aridx = data->acLexStream->get()-'0';
_gaff_Parser.cc:2585:            gaff_lval->ival = aridx;
_gaff_Parser.cc:2594:    if (ichar == 'R' && data->acLexStream->peek() == 'G') {
_gaff_Parser.cc:2595:        data->acLexStream->get();	
_gaff_Parser.cc:2601:    if (ichar == 'N' && data->acLexStream->peek() == 'G') {
_gaff_Parser.cc:2602:        data->acLexStream->get();	
_gaff_Parser.cc:2608:    if (ichar == 'S' && data->acLexStream->peek() == 'B') {
_gaff_Parser.cc:2609:        data->acLexStream->get();	
_gaff_Parser.cc:2611:        gaff_lval->benum = chem::SABSingleBond;
_gaff_Parser.cc:2614:    if (ichar == 'D' && data->acLexStream->peek() == 'B') {
_gaff_Parser.cc:2615:        data->acLexStream->get();	
_gaff_Parser.cc:2617:        gaff_lval->benum = chem::SABDoubleBond;
_gaff_Parser.cc:2620:    if (ichar == 'D' && data->acLexStream->peek() == 'L') {
_gaff_Parser.cc:2621:        data->acLexStream->get();	
_gaff_Parser.cc:2623:        gaff_lval->benum = chem::SABDelocalizedBond;
_gaff_Parser.cc:2626:    if (ichar == 'T' && data->acLexStream->peek() == 'B') {
_gaff_Parser.cc:2627:        data->acLexStream->get();	
_gaff_Parser.cc:2629:        gaff_lval->benum = chem::SABTripleBond;
_gaff_Parser.cc:2632:    if (ichar == 's' && data->acLexStream->peek() == 'b') {
_gaff_Parser.cc:2633:        data->acLexStream->get();	
_gaff_Parser.cc:2635:        gaff_lval->benum = chem::SABSingleOrAromaticBond;
_gaff_Parser.cc:2638:    if (ichar == 'd' && data->acLexStream->peek() == 'b') {
_gaff_Parser.cc:2639:        data->acLexStream->get();	
_gaff_Parser.cc:2641:        gaff_lval->benum = chem::SABDoubleOrAromaticBond;
_gaff_Parser.cc:2644:    if (ichar == 't' && data->acLexStream->peek() == 'b') {
_gaff_Parser.cc:2645:        data->acLexStream->get();	
_gaff_Parser.cc:2647:        gaff_lval->benum = chem::SABTripleBond;
_gaff_Parser.cc:2650:    if (ichar == 'a' && data->acLexStream->peek() == 'n') {
_gaff_Parser.cc:2651:        data->acLexStream->get(); // eat 'n'
_gaff_Parser.cc:2652:        char fc = data->acLexStream->get(); // eat 'y'
_gaff_Parser.cc:2657:        gaff_lval->benum = chem::SABAnyBond;
_gaff_Parser.cc:2662:        if ( data->acLexStream->peek() == '\'' ) {
_gaff_Parser.cc:2663:            data->acLexStream->get();
_gaff_Parser.cc:2675:		if ( acElementTable[i][1] == data->acLexStream->peek() ) {
_gaff_Parser.cc:2676:		    data->acLexStream->get();
_gaff_Parser.cc:2679:		    strcpy( gaff_lval->carr ,  acElementTable[i] );
_gaff_Parser.cc:2680://		    gaff_lval->eval = acElementTable[i];
_gaff_Parser.cc:2686:                strcpy( gaff_lval->carr, acElementTable[i] );
_gaff_Parser.cc:2687://		gaff_lval->eval = acElementTable[i];
_gaff_Parser.cc:2696:        while ( (data->acLexStream->peek()>='a'&&data->acLexStream->peek()<='z') ||
_gaff_Parser.cc:2697:                (data->acLexStream->peek()>='A'&&data->acLexStream->peek()<='Z') ||
_gaff_Parser.cc:2698:                (data->acLexStream->peek()>='0'&&data->acLexStream->peek()<='9') ) {
_gaff_Parser.cc:2699:            ichar = data->acLexStream->get();
_gaff_Parser.cc:2702:        strcpy(gaff_lval->carr,tagStr.c_str());
_gaff_Parser.cc:2703:        LOG(BF("Got tag(%s)") % (gaff_lval->carr) ); // vp0(( "Got tag(%s)",gaff_lval->carr));
_gaff_Parser.cc:2716:	    while ( data->acLexStream->peek()>='0' && data->acLexStream->peek()<='9' ) 
_gaff_Parser.cc:2718:		    ichar = data->acLexStream->get();
_gaff_Parser.cc:2722:	    gaff_lval->ival = atoi(numStr.c_str());
_gaff_Parser.cc:2723:	    LEXDPRINT(("APNumber(%d)", gaff_lval->ival));
_gaff_Parser.cc:2752:	THROW(_lisp->create<LispError_O>(BF("%s") % (p.gaffErrorStream->str())));
_msmarts_Parser.cc:3:/* Bison implementation for Yacc-like parsers in C
_msmarts_Parser.cc:5:      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
_msmarts_Parser.cc:34:   simplifying the original so-called "semantic" parser.  */
_msmarts_Parser.cc:275:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
_msmarts_Parser.cc:281:#   define YY_(msgid) dgettext ("bison-runtime", msgid)
_msmarts_Parser.cc:289:/* Suppress unused-variable warnings by "using" E.  */
_msmarts_Parser.cc:343:   /* Pacify GCC's `empty if-body' warning.  */
_msmarts_Parser.cc:349:       to allow for a few compiler-allocated temporary stack slots.  */
_msmarts_Parser.cc:398:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
_msmarts_Parser.cc:417:	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
_msmarts_Parser.cc:418:	Stack = &yyptr->Stack_alloc;					\
_msmarts_Parser.cc:446:/* YYFINAL -- State number of the termination state.  */
_msmarts_Parser.cc:448:/* YYLAST -- Last index in YYTABLE.  */
_msmarts_Parser.cc:451:/* YYNTOKENS -- Number of terminals.  */
_msmarts_Parser.cc:453:/* YYNNTS -- Number of nonterminals.  */
_msmarts_Parser.cc:455:/* YYNRULES -- Number of rules.  */
_msmarts_Parser.cc:457:/* YYNRULES -- Number of states.  */
_msmarts_Parser.cc:460:/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
_msmarts_Parser.cc:467:/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
_msmarts_Parser.cc:504:/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
_msmarts_Parser.cc:518:/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
_msmarts_Parser.cc:521:      52,     0,    -1,    53,    -1,    -1,    57,    -1,    57,    54,
_msmarts_Parser.cc:522:      -1,    55,    54,    -1,    58,    54,    -1,    55,    -1,    58,
_msmarts_Parser.cc:523:      -1,     4,    57,    -1,    57,    -1,    33,    60,     8,    -1,
_msmarts_Parser.cc:524:      18,    -1,    19,    -1,    16,    -1,    17,    -1,    61,    -1,
_msmarts_Parser.cc:525:      56,    31,    -1,    56,    -1,    34,    54,     9,    -1,    50,
_msmarts_Parser.cc:526:      -1,    11,    -1,    11,    62,    -1,    26,    -1,    27,    -1,
_msmarts_Parser.cc:527:      45,    -1,    45,    62,    -1,    25,    -1,    25,    62,    -1,
_msmarts_Parser.cc:528:      12,    31,    -1,    16,    -1,    17,    -1,    32,    -1,    13,
_msmarts_Parser.cc:529:      31,    -1,    43,    -1,    43,    62,    -1,    44,    -1,    44,
_msmarts_Parser.cc:530:      62,    -1,    49,    -1,    49,    62,    -1,    10,    -1,    10,
_msmarts_Parser.cc:531:      62,    -1,    23,    62,    -1,    21,    -1,    24,    -1,    24,
_msmarts_Parser.cc:532:      62,    -1,    29,    62,    -1,    29,    -1,    29,    29,    -1,
_msmarts_Parser.cc:533:      29,    29,    29,    -1,    41,    62,    -1,    41,    -1,    41,
_msmarts_Parser.cc:534:      41,    -1,    41,    41,    41,    -1,    48,    62,    -1,    40,
_msmarts_Parser.cc:535:      62,    -1,    39,    -1,     5,    62,    -1,     6,    -1,     7,
_msmarts_Parser.cc:536:      -1,    62,    -1,    18,    -1,    19,    -1,    20,    -1,    28,
_msmarts_Parser.cc:537:      -1,    28,    62,    -1,    61,    -1,    59,    -1,    37,    60,
_msmarts_Parser.cc:538:      -1,    60,    35,    60,    -1,    60,    38,    60,    -1,    60,
_msmarts_Parser.cc:539:      36,    60,    -1,    14,    34,    53,     9,    -1,    31,    -1
_msmarts_Parser.cc:542:/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
_msmarts_Parser.cc:557:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
_msmarts_Parser.cc:582:/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
_msmarts_Parser.cc:583:   token YYLEX-NUM.  */
_msmarts_Parser.cc:595:/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
_msmarts_Parser.cc:608:/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
_msmarts_Parser.cc:621:/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
_msmarts_Parser.cc:638:/* YYDEFGOTO[NTERM-NUM].  */
_msmarts_Parser.cc:641:      -1,     7,     8,    53,    54,     9,    55,    56,    45,    46,
_msmarts_Parser.cc:645:/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
_msmarts_Parser.cc:646:   STATE-NUM.  */
_msmarts_Parser.cc:647:#define YYPACT_NINF -50
_msmarts_Parser.cc:650:      46,   -26,   -50,   -50,   -50,   -50,    71,    11,   -50,   -14,
_msmarts_Parser.cc:651:      23,   -50,    46,    -9,   -50,   -50,    -9,    -9,    -5,    -3,
_msmarts_Parser.cc:652:     -50,   -50,   -50,   -50,   -50,   -50,    -9,    -9,    -9,   -50,
_msmarts_Parser.cc:653:     -50,    -9,   -13,   -50,   -50,    71,   -50,    -9,   -27,    -9,
_msmarts_Parser.cc:654:      -9,    -9,    -9,    -9,   -50,   -50,    15,   -50,   -50,   -50,
_msmarts_Parser.cc:655:     -50,    46,    23,   -50,    23,   -50,    23,    29,   -50,   -50,
_msmarts_Parser.cc:656:     -50,   -50,   -50,   -50,   -50,   -50,   -50,    14,   -50,   -50,
_msmarts_Parser.cc:657:     -50,     3,   -50,   -50,   -50,   -50,   -50,   -50,   -50,    71,
_msmarts_Parser.cc:658:      71,    71,   -50,    36,   -50,   -50,   -50,   -50,   -50,   -50,
_msmarts_Parser.cc:659:     -23,    19,   -50
_msmarts_Parser.cc:662:/* YYPGOTO[NTERM-NUM].  */
_msmarts_Parser.cc:665:     -50,   -50,    37,   -49,   -50,   -50,     1,   -50,   -50,   -33,
_msmarts_Parser.cc:666:      -6,    -7
_msmarts_Parser.cc:669:/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
_msmarts_Parser.cc:672:#define YYTABLE_NINF -1
_msmarts_Parser.cc:691:  ((yystate) == (-50))
_msmarts_Parser.cc:703:      35,    36,    51,    38,    35,    -1,    33,    34,    -1,    -1,
_msmarts_Parser.cc:704:      14,    -1,    16,    17,    18,    19,    -1,    -1,    -1,    -1,
_msmarts_Parser.cc:705:      -1,    -1,    -1,    79,    80,    81,     5,     6,     7,    33,
_msmarts_Parser.cc:706:      -1,    10,    11,    12,    13,    14,    -1,    16,    17,    18,
_msmarts_Parser.cc:707:      19,    20,    21,    -1,    23,    24,    25,    26,    27,    28,
_msmarts_Parser.cc:708:      29,    -1,    31,    32,    -1,    -1,    -1,    -1,    37,    -1,
_msmarts_Parser.cc:709:      39,    40,    41,    -1,    43,    44,    45,    -1,    -1,    48,
_msmarts_Parser.cc:713:/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
_msmarts_Parser.cc:714:   symbol of state STATE-NUM.  */
_msmarts_Parser.cc:731:#define YYEMPTY		(-2)
_msmarts_Parser.cc:749:     -Wunused-macros.  Normally we don't worry about that warning, but
_msmarts_Parser.cc:777:/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
_msmarts_Parser.cc:803:/* YY_LOCATION_PRINT -- Print the location on the stream.
_msmarts_Parser.cc:810:     fprintf (File, "%d.%d-%d.%d",			\
_msmarts_Parser.cc:819:/* YYLEX -- calling `yylex' with the right arguments.  */
_msmarts_Parser.cc:853:/*--------------------------------.
_msmarts_Parser.cc:855:`--------------------------------*/
_msmarts_Parser.cc:890:/*--------------------------------.
_msmarts_Parser.cc:892:`--------------------------------*/
_msmarts_Parser.cc:919:/*------------------------------------------------------------------.
_msmarts_Parser.cc:920:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
_msmarts_Parser.cc:922:`------------------------------------------------------------------*/
_msmarts_Parser.cc:951:/*------------------------------------------------.
_msmarts_Parser.cc:953:`------------------------------------------------*/
_msmarts_Parser.cc:972:	     yyrule - 1, yylno);
_msmarts_Parser.cc:978:		       &(yyvsp[(yyi + 1) - (yynrhs)])
_msmarts_Parser.cc:979:		       , &(yylsp[(yyi + 1) - (yynrhs)])		       , data);
_msmarts_Parser.cc:1001:/* YYINITDEPTH -- initial size of the parser's stacks.  */
_msmarts_Parser.cc:1006:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
_msmarts_Parser.cc:1007:   if the built-in stack extension method is used).
_msmarts_Parser.cc:1011:   evaluated with infinite-precision integer arithmetic.  */
_msmarts_Parser.cc:1066:  return yyd - 1;
_msmarts_Parser.cc:1074:   heuristic is that double-quoting is unnecessary unless the string
_msmarts_Parser.cc:1076:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
_msmarts_Parser.cc:1115:  return yystpcpy (yyres, yystr) - yyres;
_msmarts_Parser.cc:1144:     - Assume YYFAIL is not used.  It's too flawed to consider.  See
_msmarts_Parser.cc:1145:       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
_msmarts_Parser.cc:1148:     - If this state is a consistent state with a default action, then
_msmarts_Parser.cc:1152:     - The only way there can be no lookahead present (in yychar) is if
_msmarts_Parser.cc:1157:     - Don't assume there isn't a lookahead just because this state is a
_msmarts_Parser.cc:1159:       previous inconsistent state, consistent state with a non-default
_msmarts_Parser.cc:1161:     - Of course, the expected token list depends on states to have
_msmarts_Parser.cc:1176:          /* Start YYX at -YYN if negative to avoid negative indexes in
_msmarts_Parser.cc:1177:             YYCHECK.  In other words, skip the first -YYN actions for
_msmarts_Parser.cc:1179:          int yyxbegin = yyn < 0 ? -yyn : 0;
_msmarts_Parser.cc:1181:          int yychecklim = YYLAST - yyn + 1;
_msmarts_Parser.cc:1256:/*-----------------------------------------------.
_msmarts_Parser.cc:1258:`-----------------------------------------------*/
_msmarts_Parser.cc:1289:	{ if ((yyvaluep->smartsRoot)!=NULL) delete ((yyvaluep->smartsRoot));};
_msmarts_Parser.cc:1298:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_msmarts_Parser.cc:1307:	{ if ((yyvaluep->bondTest)!=NULL) delete ((yyvaluep->bondTest)); };
_msmarts_Parser.cc:1316:	{ if ((yyvaluep->atomOrBondMatchNode)!=NULL) delete ((yyvaluep->atomOrBondMatchNode)); };
_msmarts_Parser.cc:1325:	{ if ((yyvaluep->atomOrBondMatchNode)!=NULL) delete ((yyvaluep->atomOrBondMatchNode)); };
_msmarts_Parser.cc:1334:	{ if ((yyvaluep->bondListMatchNode)!=NULL) delete ((yyvaluep->bondListMatchNode)); };
_msmarts_Parser.cc:1343:	{ if ((yyvaluep->atomOrBondMatchNode)!=NULL) delete ((yyvaluep->atomOrBondMatchNode)); };
_msmarts_Parser.cc:1352:	{ if ((yyvaluep->logical)!=NULL) delete ((yyvaluep->logical)); };
_msmarts_Parser.cc:1361:	{ if ((yyvaluep->root)!=NULL) delete ((yyvaluep->root)); };
_msmarts_Parser.cc:1373:/* Prevent warnings from -Wmissing-prototypes.  */
_msmarts_Parser.cc:1389:/*----------.
_msmarts_Parser.cc:1391:`----------*/
_msmarts_Parser.cc:1475:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
_msmarts_Parser.cc:1510:/*------------------------------------------------------------.
_msmarts_Parser.cc:1511:| yynewstate -- Push a new state, which is found in yystate.  |
_msmarts_Parser.cc:1512:`------------------------------------------------------------*/
_msmarts_Parser.cc:1521:  if (yyss + yystacksize - 1 <= yyssp)
_msmarts_Parser.cc:1524:      YYSIZE_T yysize = yyssp - yyss + 1;
_msmarts_Parser.cc:1576:      yyssp = yyss + yysize - 1;
_msmarts_Parser.cc:1577:      yyvsp = yyvs + yysize - 1;
_msmarts_Parser.cc:1578:      yylsp = yyls + yysize - 1;
_msmarts_Parser.cc:1583:      if (yyss + yystacksize - 1 <= yyssp)
_msmarts_Parser.cc:1594:/*-----------.
_msmarts_Parser.cc:1596:`-----------*/
_msmarts_Parser.cc:1637:      yyn = -yyn;
_msmarts_Parser.cc:1644:    yyerrstatus--;
_msmarts_Parser.cc:1658:/*-----------------------------------------------------------.
_msmarts_Parser.cc:1659:| yydefault -- do the default action for the current state.  |
_msmarts_Parser.cc:1660:`-----------------------------------------------------------*/
_msmarts_Parser.cc:1668:/*-----------------------------.
_msmarts_Parser.cc:1669:| yyreduce -- Do a reduction.  |
_msmarts_Parser.cc:1670:`-----------------------------*/
_msmarts_Parser.cc:1683:  yyval = yyvsp[1-yylen];
_msmarts_Parser.cc:1686:  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
_msmarts_Parser.cc:1695:	    data->expression = (yyvsp[(1) - (1)].smartsRoot)->_obj; 
_msmarts_Parser.cc:1703:    { (yyval.smartsRoot) = new Hold<chem::SmartsRoot_O>(MP()->lisp); }
_msmarts_Parser.cc:1711:		    (yyval.smartsRoot) = new Hold<chem::SmartsRoot_O>(chem::SmartsRoot_O::create((yyvsp[(1) - (1)].atomOrBondMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1720:		    (yyval.smartsRoot) = new Hold<chem::SmartsRoot_O>(chem::SmartsRoot_O::create((yyvsp[(1) - (2)].atomOrBondMatchNode)->_obj,(yyvsp[(2) - (2)].bondListMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1729:	(yyval.bondListMatchNode) = new Hold<chem::BondListMatchNode_O>(chem::Chain_O::create( (yyvsp[(1) - (2)].bondTest)->_obj, (yyvsp[(2) - (2)].bondListMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1738:	(yyval.bondListMatchNode) = new Hold<chem::BondListMatchNode_O>(chem::Branch_O::create( (yyvsp[(1) - (2)].bondListMatchNode)->_obj, (yyvsp[(2) - (2)].bondListMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1747:	(yyval.bondListMatchNode) = new Hold<chem::BondListMatchNode_O>(chem::Chain_O::create( (yyvsp[(1) - (1)].bondTest)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1756:	(yyval.bondListMatchNode) = new Hold<chem::BondListMatchNode_O>(chem::Branch_O::create( (yyvsp[(1) - (1)].bondListMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1765:			    (yyval.bondTest) = new Hold<chem::BondTest_O>(chem::BondTest_O::create( (yyvsp[(1) - (2)].benum), (yyvsp[(2) - (2)].atomOrBondMatchNode)->_obj,MP()->lisp )); 
_msmarts_Parser.cc:1774:			    (yyval.bondTest) = new Hold<chem::BondTest_O>(chem::BondTest_O::create( chem::SABSingleOrAromaticBond, (yyvsp[(1) - (1)].atomOrBondMatchNode)->_obj,MP()->lisp)); 
_msmarts_Parser.cc:1783:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((yyvsp[(2) - (3)].logical)->_obj);
_msmarts_Parser.cc:1792:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((chem::AtomTest_O::create(chem::SAPElement, MP()->lisp->internKeyword((yyvsp[(1) - (1)].eval)),MP()->lisp))); 
_msmarts_Parser.cc:1801:	    string elementName = (yyvsp[(1) - (1)].eval);
_msmarts_Parser.cc:1803:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((chem::AtomTest_O::create(chem::SAPAromaticElement, MP()->lisp->internKeyword(elementName),MP()->lisp))); 
_msmarts_Parser.cc:1813:				chem::AtomTest_O::create(chem::SAPAliphatic,MP()->lisp));
_msmarts_Parser.cc:1823:				chem::AtomTest_O::create(chem::SAPAromatic,MP()->lisp));
_msmarts_Parser.cc:1832:	    		    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((yyvsp[(1) - (1)].root)->_obj); 
_msmarts_Parser.cc:1840:    { _lisp_BLOCK_TRACEF(BF("atomTest: acyclicAtomTest APNumber   // atomTag==(%s)  ") % ((yyvsp[(2) - (2)].cval)));
_msmarts_Parser.cc:1841:	(yyval.atomOrBondMatchNode)=new Hold<chem::AtomOrBondMatchNode_O>(chem::TagSet_O::create((yyvsp[(1) - (2)].atomOrBondMatchNode)->_obj,(yyvsp[(2) - (2)].cval),MP()->lisp));
_msmarts_Parser.cc:1850:	(yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((yyvsp[(1) - (1)].atomOrBondMatchNode)->_obj); 
_msmarts_Parser.cc:1858:    { (yyval.bondListMatchNode) = new Hold<chem::BondListMatchNode_O>((yyvsp[(2) - (3)].bondListMatchNode)->_obj); }
_msmarts_Parser.cc:1867:				chem::AtomTest_O::create(chem::SAPWildCard,MP()->lisp)); 
_msmarts_Parser.cc:1877:				chem::AtomTest_O::create( chem::SAPDegree, 1,MP()->lisp)); 
_msmarts_Parser.cc:1887:			chem::AtomTest_O::create( chem::SAPDegree,(yyvsp[(2) - (2)].ival),MP()->lisp)); 
_msmarts_Parser.cc:1897:				chem::AtomTest_O::create( chem::SAPAM1_BCC_x, 0,MP()->lisp));
_msmarts_Parser.cc:1907:				chem::AtomTest_O::create( chem::SAPAM1_BCC_y, 0,MP()->lisp));
_msmarts_Parser.cc:1917:				chem::AtomTest_O::create( chem::SAPTotalHCount, 1,MP()->lisp));
_msmarts_Parser.cc:1927:				chem::AtomTest_O::create( chem::SAPTotalHCount, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:1937:			chem::AtomTest_O::create( chem::SAPImplicitHCount, 1,MP()->lisp)); 
_msmarts_Parser.cc:1948:						chem::SAPImplicitHCount, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:1958:					chem::AtomTest_O::create(chem::SAPRingTest,(yyvsp[(2) - (2)].cval),MP()->lisp));
_msmarts_Parser.cc:1968:				chem::AtomTest_O::create(chem::SAPAliphatic,MP()->lisp));
_msmarts_Parser.cc:1978:				chem::AtomTest_O::create(chem::SAPAromatic,MP()->lisp));
_msmarts_Parser.cc:1987:	    string symStr((yyvsp[(1) - (1)].cval));
_msmarts_Parser.cc:1988:	    core::Symbol_sp sym = MP()->lisp->intern(symStr);
_msmarts_Parser.cc:1990:				chem::AtomTest_O::create(chem::SAPLambda,sym,MP()->lisp));
_msmarts_Parser.cc:2000:					chem::AtomTest_O::create(chem::SAPResidueTest,(yyvsp[(2) - (2)].cval),MP()->lisp));
_msmarts_Parser.cc:2009:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPRingMembershipCount, 1,MP()->lisp)); 
_msmarts_Parser.cc:2018:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPRingMembershipCount, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2027:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPRingSize, 1,MP()->lisp)); 
_msmarts_Parser.cc:2036:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPRingSize, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2045:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPValence, 1,MP()->lisp)); 
_msmarts_Parser.cc:2054:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPValence, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2063:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPConnectivity, 1,MP()->lisp)); 
_msmarts_Parser.cc:2072:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPConnectivity, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2081:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPGroupNumber, (yyvsp[(2) - (2)].ival),MP()->lisp)); 
_msmarts_Parser.cc:2090:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPElectronegativeElement,MP()->lisp)); 
_msmarts_Parser.cc:2099:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPHeavyAtomTotalBond, 1,MP()->lisp)); 
_msmarts_Parser.cc:2108:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPHeavyAtomTotalBond, (yyvsp[(2) - (2)].ival),MP()->lisp)); 
_msmarts_Parser.cc:2117:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPNegativeCharge, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2126:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPNegativeCharge, -1,MP()->lisp));
_msmarts_Parser.cc:2135:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPNegativeCharge, -2,MP()->lisp));
_msmarts_Parser.cc:2144:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPNegativeCharge, -3,MP()->lisp));
_msmarts_Parser.cc:2153:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPPositiveCharge, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2162:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPPositiveCharge, 1,MP()->lisp));
_msmarts_Parser.cc:2171:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPPositiveCharge, 2,MP()->lisp));
_msmarts_Parser.cc:2180:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPPositiveCharge, 3,MP()->lisp));
_msmarts_Parser.cc:2189:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPTransitionMetal, (yyvsp[(2) - (2)].ival),MP()->lisp)); 
_msmarts_Parser.cc:2198:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPAromaticPiElectron , (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2207:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPPiBondOrbital,MP()->lisp)); 
_msmarts_Parser.cc:2216:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPAtomicNumber, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2225:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPChiralityAntiClockwise,MP()->lisp));
_msmarts_Parser.cc:2234:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPChiralityClockwise,MP()->lisp));
_msmarts_Parser.cc:2243:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPAtomicMass, (yyvsp[(1) - (1)].ival),MP()->lisp));
_msmarts_Parser.cc:2252:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPElement, MP()->lisp->internKeyword((yyvsp[(1) - (1)].eval)) ,MP()->lisp)); 
_msmarts_Parser.cc:2261:	    string elementName = (yyvsp[(1) - (1)].eval);
_msmarts_Parser.cc:2263:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPAromaticElement, MP()->lisp->internKeyword(elementName) ,MP()->lisp)); 
_msmarts_Parser.cc:2272:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPElement, MP()->lisp->internKeyword((yyvsp[(1) - (1)].eval)) ,MP()->lisp)); 
_msmarts_Parser.cc:2281:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPLonePair, 1,MP()->lisp)); 
_msmarts_Parser.cc:2290:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>( chem::AtomTest_O::create( chem::SAPLonePair, (yyvsp[(2) - (2)].ival),MP()->lisp));
_msmarts_Parser.cc:2299:	    (yyval.atomOrBondMatchNode) = new Hold<chem::AtomOrBondMatchNode_O>((yyvsp[(1) - (1)].root)->_obj); 
_msmarts_Parser.cc:2309:	    		chem::Logical_O::create( chem::logIdentity, (yyvsp[(1) - (1)].atomOrBondMatchNode)->_obj ,MP()->lisp)); 
_msmarts_Parser.cc:2319:	    		chem::Logical_O::create( chem::logNot, (yyvsp[(2) - (2)].logical)->_obj ,MP()->lisp)); 
_msmarts_Parser.cc:2329:	    		chem::Logical_O::create( chem::logHighPrecedenceAnd, (yyvsp[(1) - (3)].logical)->_obj, (yyvsp[(3) - (3)].logical)->_obj ,MP()->lisp)); 
_msmarts_Parser.cc:2339:	    		chem::Logical_O::create( chem::logOr, (yyvsp[(1) - (3)].logical)->_obj, (yyvsp[(3) - (3)].logical)->_obj ,MP()->lisp)); 
_msmarts_Parser.cc:2349:	    		chem::Logical_O::create( chem::logLowPrecedenceAnd, (yyvsp[(1) - (3)].logical)->_obj, (yyvsp[(3) - (3)].logical)->_obj ,MP()->lisp)); 
_msmarts_Parser.cc:2357:    { (yyval.root) = new Hold<chem::Root_O>((yyvsp[(3) - (4)].smartsRoot)->_obj); }
_msmarts_Parser.cc:2364:    { (yyval.ival) = atoi((yyvsp[(1) - (1)].cval)); }
_msmarts_Parser.cc:2384:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
_msmarts_Parser.cc:2399:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
_msmarts_Parser.cc:2403:    yystate = yydefgoto[yyn - YYNTOKENS];
_msmarts_Parser.cc:2408:/*------------------------------------.
_msmarts_Parser.cc:2409:| yyerrlab -- here on detecting error |
_msmarts_Parser.cc:2410:`------------------------------------*/
_msmarts_Parser.cc:2482:/*---------------------------------------------------.
_msmarts_Parser.cc:2483:| yyerrorlab -- error raised explicitly by YYERROR.  |
_msmarts_Parser.cc:2484:`---------------------------------------------------*/
_msmarts_Parser.cc:2493:  yyerror_range[1] = yylsp[1-yylen];
_msmarts_Parser.cc:2503:/*-------------------------------------------------------------.
_msmarts_Parser.cc:2504:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
_msmarts_Parser.cc:2505:`-------------------------------------------------------------*/
_msmarts_Parser.cc:2550:/*-------------------------------------.
_msmarts_Parser.cc:2551:| yyacceptlab -- YYACCEPT comes here.  |
_msmarts_Parser.cc:2552:`-------------------------------------*/
_msmarts_Parser.cc:2557:/*-----------------------------------.
_msmarts_Parser.cc:2558:| yyabortlab -- YYABORT comes here.  |
_msmarts_Parser.cc:2559:`-----------------------------------*/
_msmarts_Parser.cc:2565:/*-------------------------------------------------.
_msmarts_Parser.cc:2566:| yyexhaustedlab -- memory exhaustion comes here.  |
_msmarts_Parser.cc:2567:`-------------------------------------------------*/
_msmarts_Parser.cc:2692:	ichar = data->lexStream->get();	 // Read one character
_msmarts_Parser.cc:2695:    } while (!data->lexStream->eof() && ichar < ' ' );
_msmarts_Parser.cc:2696:    if ( data->lexStream->eof() ) return 0;
_msmarts_Parser.cc:2701:	    LEXDPRINT(MP()->lisp,BF("next char: &amp;"));
_msmarts_Parser.cc:2704:	    LEXDPRINT(MP()->lisp,BF("next char: &lt;"));
_msmarts_Parser.cc:2707:	    LEXDPRINT(MP()->lisp,BF("next char: &gt;"));
_msmarts_Parser.cc:2710:            LEXDPRINT(MP()->lisp,BF("next char: |%c|") % ichar);
_msmarts_Parser.cc:2726:		if ( elementTable[i][1] == data->lexStream->peek() ) 
_msmarts_Parser.cc:2728:		    data->lexStream->get();
_msmarts_Parser.cc:2729:		    yylval->eval = elementTable[i];
_msmarts_Parser.cc:2737:		yylval->eval = elementTable[i];
_msmarts_Parser.cc:2738://		    strcpy( yylval->eval , elementTable[i]);
_msmarts_Parser.cc:2756:		if ( organicElementTable[i][1] == data->lexStream->peek() )
_msmarts_Parser.cc:2758:		    cout<<"Peek char: "<<data->lexStream->peek()<<endl;
_msmarts_Parser.cc:2759:		    data->lexStream->get();
_msmarts_Parser.cc:2760://			 strcpy(yylval->eval , organicElementTable[i] );
_msmarts_Parser.cc:2761:		    yylval->eval = organicElementTable[i];
_msmarts_Parser.cc:2768:		yylval->eval = organicElementTable[i];
_msmarts_Parser.cc:2844:	yylval->benum = chem::SABAnyBond;
_msmarts_Parser.cc:2849:	yylval->benum = chem::SABAromaticBond;
_msmarts_Parser.cc:2853:	if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9' ) 
_msmarts_Parser.cc:2858:	} else if (data->lexStream->peek() == 'G')
_msmarts_Parser.cc:2860:	    data->lexStream->get();
_msmarts_Parser.cc:2861:	    if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9')
_msmarts_Parser.cc:2868:	} else if (data->lexStream->peek() == 'T')
_msmarts_Parser.cc:2870:	    data->lexStream->get();
_msmarts_Parser.cc:2871:	    if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9')
_msmarts_Parser.cc:2878:	} else if (data->lexStream->peek() == 'N')
_msmarts_Parser.cc:2880:	    data->lexStream->get();
_msmarts_Parser.cc:2881:	    if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9')
_msmarts_Parser.cc:2890:	yylval->benum = chem::SABTripleBond;
_msmarts_Parser.cc:2894:	if (data->lexStream->peek() == '?') 
_msmarts_Parser.cc:2896:	    data->lexStream->get();
_msmarts_Parser.cc:2898:	    yylval->benum = chem::SABDirectionalSingleUpOrUnspecified;
_msmarts_Parser.cc:2903:	yylval->benum = chem::SABDirectionalSingleUp;
_msmarts_Parser.cc:2910:    case '-':
_msmarts_Parser.cc:2912:	    if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9'  ) 
_msmarts_Parser.cc:2917:	    char p = data->lexStream->peek();
_msmarts_Parser.cc:2918:	    // if the next char is a ], another - or a logical operation then 
_msmarts_Parser.cc:2920:	    if ( p=='-' || p==']' || p=='&' || p==',' || p==';' )
_msmarts_Parser.cc:2926:	    yylval->benum = chem::SABSingleBond;
_msmarts_Parser.cc:2932:	yylval->benum = chem::SABDoubleBond;
_msmarts_Parser.cc:2936:	if (data->lexStream->peek() == '?') 
_msmarts_Parser.cc:2938:	    data->lexStream->get();
_msmarts_Parser.cc:2940:	    yylval->benum = chem::SABDirectionalSingleDownOrUnspecified;
_msmarts_Parser.cc:2945:	yylval->benum = chem::SABDirectionalSingleDown;
_msmarts_Parser.cc:2949:	if ( data->lexStream->peek() == '@' ) {
_msmarts_Parser.cc:2950:	    data->lexStream->get(); // pull the second @ out of the stream
_msmarts_Parser.cc:2961:	if ( data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9') {
_msmarts_Parser.cc:2990:	if (data->lexStream->peek() >= '0' && data->lexStream->peek() <= '9')
_msmarts_Parser.cc:3021:	    while ( (data->lexStream->peek()>='0' && data->lexStream->peek()<='9')
_msmarts_Parser.cc:3022:		    || (data->lexStream->peek()>='A' && data->lexStream->peek()<='Z')
_msmarts_Parser.cc:3023:		    || (data->lexStream->peek()>='a' && data->lexStream->peek()<='z') ) 
_msmarts_Parser.cc:3025:	        ichar = data->lexStream->get();
_msmarts_Parser.cc:3028:	            lisp_THROW(MP()->lisp,core::LispError_O::create(BF("Exceeded max number of digits in Lambda name"),MP()->lisp));
_msmarts_Parser.cc:3030:		yylval->cval[charCount] = ichar;
_msmarts_Parser.cc:3033:	    ichar = data->lexStream->get();
_msmarts_Parser.cc:3036:	        lisp_THROW(MP()->lisp,core::LispError_O::create(BF("Illegal lambda name must match <[A-Za-z0-9]+> - instead saw[%c]") % ichar ,MP()->lisp));
_msmarts_Parser.cc:3038:	    yylval->cval[charCount] = '\0';
_msmarts_Parser.cc:3039:	    lisp_LOG(BF("APLambda<%s>") % (yylval->cval) );
_msmarts_Parser.cc:3053:    case 'x': // AM1-BCC "x" type
_msmarts_Parser.cc:3057:	LEXPRINT("AM1-BCC-x");
_msmarts_Parser.cc:3058:	LEXDPRINT(BF("Identified as AM1-BCC-x"));
_msmarts_Parser.cc:3061:    case 'y': // AM1-BCC "y" type
_msmarts_Parser.cc:3062:	      // matches to atoms that can be in 5-member aromatic rings
_msmarts_Parser.cc:3063:	      // C-(x2),N-(x2),O(x2),S(x2),N(x3),P(x3)
_msmarts_Parser.cc:3065:	LEXPRINT("AM1-BCC-y");
_msmarts_Parser.cc:3066:	LEXDPRINT(BF("Identified as AM1-BCC-y"));
_msmarts_Parser.cc:3074:    if (ichar == 'L' && data->lexStream->peek() == 'p')
_msmarts_Parser.cc:3076:        data->lexStream->get();	
_msmarts_Parser.cc:3086:	    yylval->cval[digitCount] = ichar;
_msmarts_Parser.cc:3088:	    while ( data->lexStream->peek()>='0' && data->lexStream->peek()<='9' ) 
_msmarts_Parser.cc:3090:		    ichar = data->lexStream->get();
_msmarts_Parser.cc:3093:		        lisp_THROW(MP()->lisp,core::LispError_O::create(BF("Exceeded max number of digits in Number"),MP()->lisp));
_msmarts_Parser.cc:3095:		    yylval->cval[digitCount] = ichar;
_msmarts_Parser.cc:3098:	    yylval->cval[digitCount] = '\0';
_msmarts_Parser.cc:3099:	    lisp_LOG(BF("APNumber = (%s)") % (yylval->cval) );
_msmarts_Parser.cc:3116:    data->lexStream = &cin;
_msmarts_Parser.cc:3137:	THROW(_lisp->create<core::LispError_O>(BF("%s") % (p.msmartsErrorStream->str())));
_msmarts_Parser.cc:3145:    *(data->msmartsErrorStream) << "Error: " << message << endl;
a.cc:47:	this->Base::initialize();
a.cc:48:	this->_Atom = Atom_O::_nil;
a.cc:54:	if ( node->hasChildrenWithName("t") )
a.cc:56:	    core::QDomNode_sp text = node->childWithName("t");
a.cc:57:	    if ( text->hasChildrenWithName("s") )
a.cc:59:		core::QDomNode_sp xmls = text->childWithName("s");
a.cc:60:		string name = xmls->getData();
a.cc:64:	return "C_"+node->getAttributeString("id");
a.cc:70:	vector<string> parts = core::split(this->getLabel(),"/");
a.cc:80:		if ( ionstr[i] == '-' ) ionization--;
a.cc:83:	LOG(BF("parsed[%s] into name[%s] ionization[%d]") % this->getLabel() % name % ionization );
a.cc:87:	this->_Id = xml->getAttributeInt("id");
a.cc:88:	this->_Label = this->_extractLabel(xml);
a.cc:89:	LOG(BF("Parsing CDNode with label: %s") % this->_Label);
a.cc:90:	this->_StereochemistryType = undefinedCenter;
a.cc:91:	this->_Configuration = undefinedConfiguration;
a.cc:92:	if ( xml->hasAttribute("Geometry") )
a.cc:94:	    this->_StereochemistryType = chiralCenter;
a.cc:95:	    string geometry = xml->getAttributeString("Geometry");
a.cc:96:	    string as = xml->getAttributeString("AS");
a.cc:100:		this->_Configuration = S_Configuration;
a.cc:104:		this->_Configuration = R_Configuration;
a.cc:118:	this->_Neighbors.push_back(bd);
a.cc:123:	this->bondTo(other,o);
a.cc:124:	other->bondTo(this->sharedThis<CDNode_O>(),o);
a.cc:130:	this->Base::initialize();
a.cc:131:	this->_BeginNode = CDNode_O::_nil;
a.cc:132:	this->_EndNode = CDNode_O::_nil;
a.cc:137:	switch ( this->_Order )
a.cc:154:	switch ( this->_Order )
a.cc:172:	this->_IdBegin = xml->getAttributeInt("B");
a.cc:173:	this->_IdEnd = xml->getAttributeInt("E");
a.cc:174:	string order = xml->getAttributeStringDefault("Order","1");
a.cc:175:	string display = xml->getAttributeStringDefault("Display","");
a.cc:180:		this->_Order = singleDashCDBond;
a.cc:183:		this->_Order = hashCDBond;
a.cc:186:		this->_Order = singleCDBond;
a.cc:190:	    if ( display == "Dash" ) this->_Order = doubleDashCDBond;
a.cc:193:	    this->_Order = doubleCDBond;
a.cc:196:	    this->_Order = tripleCDBond;
a.cc:199:	    this->_Order = dativeCDBond;
a.cc:202:	    this->_Order = unknownCDBond;
a.cc:209:	this->Base::initialize();
a.cc:210:	this->_ConstitutionName = _Nil<core::Symbol_O>();
a.cc:211:	this->_Nodes.clear();
a.cc:212:	this->_AtomsToNodes.clear();
a.cc:213:	this->_Bonds.clear();
a.cc:214:	this->_LargestId = -1;
a.cc:215:	this->_RootNode = CDNode_O::_nil;
a.cc:221:	Atom_sp fromAtom = fromNode->getAtom();
a.cc:222:	LOG(BF("From %s") % fromAtom->description() );
a.cc:224:	a->setContainedBy(Residue_O::_nil);
a.cc:225:	a->setName(name);
a.cc:226:	a->setElement(element_H);
a.cc:228:	fromAtom->bondTo(a,singleBond);
a.cc:230:	toNode->setAtom(a);
a.cc:231:	toNode->setLabel(name);
a.cc:232:	toNode->setId(this->_LargestId+1);
a.cc:233:	this->_LargestId++;
a.cc:234:	this->_Nodes[toNode->getId()] = toNode;
a.cc:235:	this->_AtomsToNodes[a] = toNode;
a.cc:237:	bond->setIdBegin(fromNode->getId());
a.cc:238:	bond->setIdEnd(toNode->getId());
a.cc:239:	bond->setBeginNode(fromNode);
a.cc:240:	bond->setEndNode(toNode);
a.cc:241:	bond->setOrder(singleCDBond);
a.cc:242:	this->_Bonds.push_back(bond);
a.cc:250:	this->_Nodes.clear();
a.cc:251:	this->_AtomsToNodes.clear();
a.cc:252:	for ( it=fragment->begin_Children(); it!=fragment->end_Children(); it++ )
a.cc:255:	    if ( child->getLocalName() == "n" )
a.cc:258:		node->parseFromXml(child);
a.cc:259:		int id = node->getId();
a.cc:260:		if ( id > this->_LargestId )
a.cc:261:		    this->_LargestId = id;
a.cc:262:		this->_Nodes[id] = node;
a.cc:263:		LOG(BF("Processed node label(%s)") % node->getLabel()  );
a.cc:266:	for ( it=fragment->begin_Children(); it!=fragment->end_Children(); it++ )
a.cc:269:	    if ( child->getLocalName() == "b" )
a.cc:272:		bond->parseFromXml(child);
a.cc:273:		uint idBegin = bond->getIdBegin();
a.cc:274:		uint idEnd = bond->getIdEnd();
a.cc:275:		ASSERT(this->_Nodes.count(idBegin)>0);
a.cc:276:		ASSERT(this->_Nodes.count(idEnd)>0);
a.cc:277:		CDNode_sp nodeBegin = this->_Nodes[idBegin];
a.cc:278:		CDNode_sp nodeEnd = this->_Nodes[idEnd];
a.cc:279:		bond->setBeginNode( nodeBegin );
a.cc:280:		bond->setEndNode( nodeEnd);
a.cc:281:		this->_Bonds.push_back(bond);
a.cc:283:		    % bond->getOrderAsString() % nodeBegin->getLabel() % nodeEnd->getLabel()  );
a.cc:291:	this->_Properties->addAllBindings(d);
a.cc:311:	    THROW(_lisp->create<core::LispError_O>("There is an error in a ChemDraw file, the string["+label+"] should be a key:value pair"));
a.cc:315:	// trim off white-space and put it in the _Properties
a.cc:318:	keyword = _lisp->internKeyword(trimKey);
a.cc:319:	obj = _lisp->create<core::Str_O>(trimValue);
a.cc:328:	return this->getProperties()->contains(key);
a.cc:334:	if ( this->hasProperty(key) )
a.cc:336:	    THROW(_lisp->create<core::LispError_O>(BF("You have already set the property(%s) it has the value(%s) and you are trying to set it with(%s)") % key->__repr__() % this->_Properties->lookup(key)->__repr__() % obj->__repr__()  ));
a.cc:338:	LOG(BF("Setting variable(%s) class(%s) to %s") % key % obj->className() % obj->__repr__() );
a.cc:339:	this->_Properties->extend(key,obj);
a.cc:348:	for ( core::Binder_O::iterator mi=this->_Properties->begin(); mi!=this->_Properties->end(); mi++ )
a.cc:350:	    ss << mi->first->__repr__() << " classname(" << mi->second->className() << ") value=" << mi->second->__repr__() << endl;
a.cc:372:	if ( this->_Bonds.size() == 0 )
a.cc:377:	LOG(BF("Starting a new fragment, number of bonds = %d") % this->_Bonds.size() );
a.cc:380:	core::StringSet_sp allNames = _lisp->create<core::StringSet_O>();
a.cc:381:	this->_Properties = _lisp->create<core::Binder_O>();
a.cc:383:	    for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
a.cc:384:	    { _BLOCK_TRACEF(BF("Processing bond with order: %s") % (*bi)->getOrderAsString() );
a.cc:385:		LOG(BF("label Begin = %s") % ((*bi)->getBeginNode()->getLabel())  );
a.cc:386:		LOG(BF("label End   = %s") % ((*bi)->getEndNode()->getLabel())  );
a.cc:387:		allNames->insert((*bi)->getBeginNode()->getLabel());
a.cc:388:		allNames->insert((*bi)->getEndNode()->getLabel());
a.cc:390:		// Dative bonds must have form begin(XXX:)->end(YYY)
a.cc:393:		if ( (*bi)->getOrder() == dativeCDBond )
a.cc:395:		    string beginLabel = (*bi)->getBeginNode()->getLabel();
a.cc:396:		    string endLabel = (*bi)->getEndNode()->getLabel();
a.cc:399:		    this->_Properties->extend(_lisp->internKeyword(propertyStr),core::Str_O::create(valueStr,_lisp));
a.cc:401:		} else if ( (*bi)->getOrder() == hashCDBond )
a.cc:409:		    bool koBegin = this->_asKeyedObject((*bi)->getBeginNode()->getLabel(),kwBegin,objBegin);
a.cc:410:		    bool koEnd = this->_asKeyedObject((*bi)->getEndNode()->getLabel(),kwEnd,objEnd);
a.cc:421:			rootNode = (*bi)->getEndNode();
a.cc:427:			    THROW(_lisp->create<core::LispError_O>("Invalid hash bond ("
a.cc:428:								   + (*bi)->getBeginNode()->getLabel()
a.cc:429:								   + " - "
a.cc:430:								   + (*bi)->getEndNode()->getLabel()
a.cc:435:			rootNode = (*bi)->getBeginNode();
a.cc:437:		    if ( kwPart->isNil() )
a.cc:441:			serr << "On one side the label is ["<< (*bi)->getBeginNode()->getLabel() << "]"<<endl;
a.cc:442:			serr << "On the other side the label is ["<< (*bi)->getEndNode()->getLabel() << "]"<<endl;
a.cc:443:			THROW(_lisp->create<core::LispError_O>(serr.str()));
a.cc:445:		    core::Symbol_sp sym = _lisp->intern(objPart->as<core::Str_O>()->get());
a.cc:446:		    this->_Properties->extend(kwPart,sym);
a.cc:447:		    this->_RootNode = rootNode;
a.cc:448:		    LOG(BF("Assigned rootNode: %s") % sym->__repr__() );
a.cc:452:		    LOG(BF("Doing nothing with bond type(%s)") % (*bi)->getOrderAsString()  );
a.cc:456:	ASSERTF(foundHashedBond,BF("There was no hashed bond for fragment containing the following atoms: %s") % allNames->asString() );
a.cc:457:	ASSERTF(this->_RootNode.notnilp(),BF("Read a fragment that did not have a _RootNode defined"));
a.cc:458:	this->createAtoms();
a.cc:461:	Residue_sp res = this->getEntireResidue();
a.cc:462:	core::Cons_sp carbons = res->allAtomsOfElementAsList(element_C);
a.cc:464:	    for ( core::Cons_sp cur = carbons; cur.notnilp(); cur=cur->cdr() )
a.cc:466:		Atom_sp c = cur->car<Atom_O>();
a.cc:467:		ASSERT(this->_AtomsToNodes.count(c)>0);
a.cc:468:		CDNode_sp fromNode = this->_AtomsToNodes[c];
a.cc:469:		core::Cons_sp hydrogens = c->createImplicitHydrogenNamesOnCarbon();
a.cc:470:		LOG(BF("Creating implicit hydrogens for %s named %s") % c->description() % hydrogens->__repr__()  );
a.cc:471:		for ( core::Cons_sp ih=hydrogens; ih.notnilp(); ih=ih->cdr() )
a.cc:473:		    string name = ih->car<core::Str_O>()->get();
a.cc:474:		    this->createImplicitHydrogen(fromNode,name);
a.cc:478:	Residue_sp everything = this->getEntireResidue();
a.cc:486:	    cip->defineStereochemicalConfigurationsForAllAtoms(everything);
a.cc:493:	ConstitutionAtoms_sp ca = this->asConstitutionAtoms();
a.cc:494:	this->setProperty(_lisp->internKeyword("constitutionAtoms"),ca);
a.cc:495:	Residue_sp builtResidue = ca->makeResidue();
a.cc:496:	this->setProperty(_lisp->internKeyword("builtResidue"),builtResidue);
a.cc:504:	a->setContainedBy(Residue_O::_nil);
a.cc:505:	n->setAtom(a);
a.cc:508:	n->getParsedLabel(name,ionization);
a.cc:509:	a->setName(name);
a.cc:510:	a->setIonization(ionization);
a.cc:511:	a->setElementFromName();
a.cc:512:	a->setStereochemistryType(n->_StereochemistryType);
a.cc:513:	a->setConfiguration(n->_Configuration);
a.cc:515:		     % a->__repr__() % a->getConfigurationAsString() );
a.cc:516:	ASSERT(elementIsRealElement(a->getElement()));
a.cc:527:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
a.cc:529:	    CDBondOrder o = ( (*bi)->getOrder() );
a.cc:533:		CDNode_sp n = (*bi)->getBeginNode();
a.cc:534:		if ( n->getAtom()->isNil() ) 
a.cc:536:		    Atom_sp a = this->createOneAtom(n);
a.cc:537:		    this->_AtomsToNodes[a] = n;
a.cc:539:		n = (*bi)->getEndNode();
a.cc:540:		if ( n->getAtom()->isNil() ) 
a.cc:542:		    Atom_sp a = this->createOneAtom(n);
a.cc:543:		    this->_AtomsToNodes[a] = n;
a.cc:552:	core::Binder_sp dict = this->getProperties();
a.cc:553:	if ( !dict->contains(s) )
a.cc:556:	    serr << "Fragment(" << this->getConstitutionName()->__repr__() << ") is missing property: " << s->__repr__() << endl;
a.cc:558:	    serr << dict->summaryOfContents() << endl;
a.cc:559:	    THROW(_lisp->create<core::LispError_O>(serr.str()));
a.cc:561:	return dict->lookup(s);
a.cc:566:	core::Binder_sp dict = this->getProperties();
a.cc:567:	if ( dict->contains(s) )
a.cc:569:	    return dict->lookup(s);
a.cc:577:	for ( CDBonds::iterator bi=this->_Bonds.begin();
a.cc:578:	      bi!=this->_Bonds.end(); bi++ )
a.cc:580:	    CDBondOrder o = ( (*bi)->getOrder() );
a.cc:581:	    BondOrder bo = (*bi)->getOrderAsBondOrder();
a.cc:582:	    Atom_sp a1 = (*bi)->getBeginNode()->getAtom();
a.cc:584:	    if ( a1->isNil() ) continue;
a.cc:585:	    Atom_sp a2 = (*bi)->getEndNode()->getAtom();
a.cc:587:	    if ( a2->isNil() ) continue;
a.cc:589:	    if ( selectedAtomsOnly && (!a1->testAllFlags(SELECTED) || !a2->testAllFlags(SELECTED)) )
a.cc:595:		LOG(BF("Creating a bond between %s and %s order: %s") % a1->description() % a2->description() % bondOrderToString(bo)  );
a.cc:596:		a1->bondTo(a2,bo);
a.cc:604:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
a.cc:606:	    Atom_sp a = (*ni).second->getAtom();
a.cc:609:		LOG(BF("Removing bonds for atom: %s") % a->description()  );
a.cc:610:		a->removeAllBonds();
a.cc:619:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
a.cc:621:	    Atom_sp a = (*ni).second->getAtom();
a.cc:624:		a->resetFlags();
a.cc:634:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
a.cc:636:	    Atom_sp a = (*ni).second->getAtom();
a.cc:639:		if ( a->testAllFlags(SELECTED) ) res->addAtom(a);
a.cc:655:	this->clearAtomSelected();
a.cc:656:	this->removeAllBonds();
a.cc:657:	this->createBonds(false);
a.cc:664:	    span->setOnlyFollowRealBonds(constitutionOnly);
a.cc:665:	    ASSERTNOTNULL(this->_RootNode);
a.cc:666:	    ASSERTP(this->_RootNode.notnilp(),"Every fragment must have a root node");
a.cc:667:	    span->setTop(this->_RootNode->getAtom());
a.cc:668:	    while ( span->advance() )
a.cc:670:		Atom_sp a = span->getAtom();
a.cc:671:		a->turnOnFlags(SELECTED);
a.cc:672:		LOG(BF("Selected %s") % a->description()  );
a.cc:678:	this->removeAllBonds();
a.cc:682:	this->createBonds(true);
a.cc:683:	Residue_sp res = this->createResidueOfSelectedAtoms();
a.cc:684:	ASSERTP(res->contentSize()>0,"The residue is empty");
a.cc:699:	return this->_buildResidue(false);
a.cc:704:	Residue_sp residue = this->_buildResidue(true);
a.cc:705:	return _lisp->create<ConstitutionAtoms_O>(residue);
a.cc:713:	ss << "#S(" << this->className() << " ";
a.cc:714:	ss << this->_Properties->__repr__();
a.cc:725:	this->Base::__init__(exec,args,env,lisp);
a.cc:726:	core::Cons_sp props = env->lookup(lisp->internWithPackageName(ChemPkg,"props"))->as<core::Cons_O>();
a.cc:727:	core::Binder_sp kprops = env->lookup(lisp->internWithPackageName(ChemPkg,"kprops"))->as<core::Binder_O>();
a.cc:728:	this->_Properties = kprops;
a.cc:729:	this->_Text = "n/a";
a.cc:736:	this->Base::initialize();
a.cc:737:	this->_Properties = core::Binder_O::create();
a.cc:743:	return this->_Properties->size()>0; 
a.cc:753:	core::QDomNode_sp sub = text->childWithName("s");
a.cc:754:	this->_Text = core::trimWhiteSpace(sub->getData());
a.cc:755:	if ( this->_Text[0] != '(' )
a.cc:760:	core::StringInStream_sp sin = core::StringInStream_O::create(this->_Text,lisp);
a.cc:762:	core::Cons_sp block = reader->read(true,core::T_O::_nil)->as<core::Cons_O>();
a.cc:763:	sin->close();
a.cc:764:	LOG(BF("Parsed text block: %s\n") % this->_Text);
a.cc:765:	if ( block->isNil() )
a.cc:767:	    THROW(_lisp->create<core::LispError_O>("Error compiling code:\n"+this->_Text));
a.cc:769:	LOG(BF("About to evaluate CDText: %s") % block->__repr__() );
a.cc:771:	this->_Properties = core::Binder_O::createFromKeywordCons(result->as<core::Cons_O>(),validChemdrawKeywords,lisp);
a.cc:813:	this->Base::initialize();
a.cc:833:	string fileName = ofileName->get();
a.cc:836:	me->parseFromFileName(fileName);
a.cc:842:	string fileName = env->lookup(lisp->internWithPackageName(ChemPkg,"fileName"))->as<core::Str_O>()->get();
a.cc:844:	this->parseFromFileName(fileName);
a.cc:859:	CDFragment_sp frag = this->_NamedFragments.get(name,_lisp);
a.cc:861:	frag->addProperties(propertiesAsBinder);
a.cc:869:	if ( !kargs->contains(_kw_name)) 
a.cc:872:	    ss << "Properties for ChemDraw Fragments must have a (name) property, what was passed has: " << kargs->description();
a.cc:873:	    THROW(_lisp->create<core::LispError_O>(ss.str()));
a.cc:875:	string name = kargs->lookup(_kw_name)->as<core::Str_O>()->get();
a.cc:876:	if ( !this->_NamedFragments.contains(name) )
a.cc:880:	    THROW(_lisp->create<core::LispError_O>(ss.str()));
a.cc:882:	CDFragment_sp frag = this->_NamedFragments.get(name);
a.cc:883:	frag->addProperties(kargs);
a.cc:890:	if ( !xml->hasChildrenWithName("page") )
a.cc:892:	    THROW(_lisp->create<core::LispError_O>("Not a cdxml file" ));
a.cc:894:	core::QDomNode_sp page = xml->childWithName("page");
a.cc:896:	this->_NamedFragments.clear();
a.cc:897:	for ( it=page->begin_Children(); it!=page->end_Children(); it++ )
a.cc:900:	    if ( child->getLocalName() == "fragment" )
a.cc:903:		fragment->parseFromXml(child);
a.cc:904:		if ( fragment->interpret() )
a.cc:906:		    core::Binder_sp properties = fragment->getProperties();
a.cc:907:		    if ( !properties->contains(_lisp->internKeyword("name") ))
a.cc:909:			THROW(_lisp->create<core::LispError_O>("Every fragment must have a property(name:)"));
a.cc:911:		    core::Symbol_sp constitutionName = properties->lookup(_lisp->internKeyword("name"))->as<core::Symbol_O>();
a.cc:912:		    fragment->setConstitutionName(constitutionName);
a.cc:913:		    this->_NamedFragments.set(constitutionName,fragment);
a.cc:914:		    this->_AllFragments.append(fragment);
a.cc:918:	for ( it=page->begin_Children(); it!=page->end_Children(); it++ )
a.cc:921:	    if ( child->getLocalName() == "t" )
a.cc:924:		text->parseFromXml(child,_lisp);
a.cc:925:		if ( text->hasProperties() )
a.cc:927:		    LOG(BF("Found properties: %s") % text->__repr__() );
a.cc:928:		    core::Binder_sp properties = text->getProperties();
a.cc:929:		    if (!properties->contains(_lisp->internKeyword("name")) )
a.cc:931:			THROW(_lisp->create<core::LispError_O>("Every properties block must have a property(name:)"));
a.cc:933:		    core::Symbol_sp constitutionName = properties->lookup(_lisp->internKeyword("name"))->as<core::Symbol_O>();
a.cc:934:		    if ( !this->_NamedFragments.contains(constitutionName) )
a.cc:936:			THROW(_lisp->create<core::LispError_O>("Could not find fragment with name("+constitutionName->__repr__()+")"));
a.cc:938:		    CDFragment_sp fragment = this->_NamedFragments.get(constitutionName,_lisp);
a.cc:939:		    fragment->addProperties(properties);
a.cc:950:	for ( fi=this->_AllFragments.begin(); fi!=this->_AllFragments.end(); fi++ )
a.cc:964:	for ( fi=this->_NamedFragments.begin(); fi!=this->_NamedFragments.end(); fi++ )
a.cc:966:	    if ( namesOfSubSet->contains(fi->first) )
a.cc:968:		namesChosen->insert(fi->first);
a.cc:969:		core::Cons_sp n = core::Cons_O::create(fi->second,frags);
a.cc:973:	if ( namesChosen->size() != namesOfSubSet->size() )
a.cc:975:	    core::SymbolSet_sp diff = namesOfSubSet->relativeComplement(namesChosen);
a.cc:978:	    ss << diff->asString();
a.cc:979:	    THROW(_lisp->create<core::LispError_O>(ss.str()));
aggregate.cc:36:	return this->Base::__repr__();
aggregate.cc:56:	    archive->parse(fileName);
aggregate.cc:57:	    agg = downcast<Aggregate_O>(archive->get("aggregate"));
aggregate.cc:69:	this->Base::serialize(node);
aggregate.cc:78:	this->Base::archiveBase(node);
aggregate.cc:79:	node->needsFinalization();
aggregate.cc:86://	this->updateAtomIdMap();
aggregate.cc:93:	AtomIdToAtomMap_sp atomIdMap = _lisp->create<AtomIdToAtomMap_O>();
aggregate.cc:94:	atomIdMap->resize(this->_contents.size());
aggregate.cc:95:	for ( int mid = 0; mid<(int)this->_contents.size(); mid++ )
aggregate.cc:97:	    int numResidues = this->_contents[mid]->_contents.size();
aggregate.cc:98:	    atomIdMap->resize(mid,numResidues);
aggregate.cc:101:		int numAtoms = this->_contents[mid]->_contents[rid]->_contents.size();
aggregate.cc:102:		atomIdMap->resize(mid,rid,numAtoms);
aggregate.cc:106:		    atomIdMap->set(atomId,this->_contents[mid]->_contents[rid]->_contents[aid]->as<Atom_O>());
aggregate.cc:116:	int molId = atomId->moleculeId();
aggregate.cc:117:	if ( molId >=0 && molId <=(int)this->_contents.size() )
aggregate.cc:119:	    Molecule_sp molecule = this->_contents[molId]->as<Molecule_O>();
aggregate.cc:120:	    return molecule->atomWithAtomId(atomId);
aggregate.cc:122:	SIMPLE_ERROR(BF("Illegal moleculeId[%d] must be less than %d") % molId % this->_contents.size() );
aggregate.cc:129:	ASSERTF((int)this->_contents.size()==this->_AtomIdMap.numberOfMolecules(),
aggregate.cc:130:		BF("The AtomIdMap is out of sync with the Aggregate contents - wrong number of molecules - use updateAtomIdMap to correct this"));
aggregate.cc:131:	this->_AtomIdMap.throwIfInvalidMoleculeId(atomId,_lisp);
aggregate.cc:133:	ASSERTF((int)this->_contents[molId]->_contents.size()==this->_AtomIdMap.numberOfResidues(molId),
aggregate.cc:135:		   "- wrong number of residues in molecule[%d] - use updateAtomIdMap to correct this")
aggregate.cc:137:	this->_AtomIdMap.throwIfInvalidResidueId(atomId,_lisp);
aggregate.cc:139:	ASSERTF((int)this->_contents[molId]->_contents[resId]->_contents.size()==this->_AtomIdMap.numberOfAtoms(molId,resId),
aggregate.cc:141:		   "- wrong number of atoms in residue[%d]s in molecule[%d] - use updateAtomIdMap to correct this")
aggregate.cc:143:	this->_AtomIdMap.throwIfInvalidAtomId(atomId,_lisp);
aggregate.cc:144:	return this->_AtomIdMap[atomId];
aggregate.cc:155:	this->Base::initialize();
aggregate.cc:174://    rPNew->duplicate(this);	// *rPNew = *this;
aggregate.cc:175:	rPNew->eraseContents();
aggregate.cc:176:	for ( a=this->getContents().begin(); a!=this->getContents().end(); a++ )
aggregate.cc:179:	    rPNew->addMolecule(mol);
aggregate.cc:190:	for ( contentIterator a=this->begin_contents(); a!=this->end_contents(); a++ )
aggregate.cc:193:	    newAgg->addMolecule(mol->copy()->as<Molecule_O>());
aggregate.cc:195:	newAgg->copyRestraintsDontRedirectAtoms(this);
aggregate.cc:196:	newAgg->redirectRestraintAtoms();
aggregate.cc:207://    newAgg->duplicate(this);	// *newAgg = *this;
aggregate.cc:208:	for ( const_contentIterator a=this->begin_contents(); a!=this->end_contents(); a++ )
aggregate.cc:210:	    Molecule_sp mol = (*a)->as<Molecule_O>();
aggregate.cc:211:	    newAgg->addMatter(mol->copyDontRedirectAtoms());
aggregate.cc:213:	newAgg->copyRestraintsDontRedirectAtoms(this);
aggregate.cc:222:	for ( contentIterator a=this->begin_contents(); a!=this->end_contents(); a++ )
aggregate.cc:224:	    (*a)->redirectAtoms();
aggregate.cc:226:	this->redirectRestraintAtoms();
aggregate.cc:234:	if ( this->eq(obj) ) return true;
aggregate.cc:235:	if ( !obj->isOfClass<Aggregate_O>() ) return false;
aggregate.cc:236:	Aggregate_sp other = obj->as<Aggregate_O>();
aggregate.cc:237:	if ( other->getName() != this->getName() ) return false;
aggregate.cc:238:	if ( other->_contents.size() != this->_contents.size() ) return false;
aggregate.cc:240:	for ( tit=this->_contents.begin(), oit=other->_contents.begin();
aggregate.cc:241:	      tit!=this->_contents.end(); tit++, oit++ )
aggregate.cc:243:	    if ( ! (*tit)->equal(*oit) ) return false;
aggregate.cc:251:	if ( !obj->isOfClass<Aggregate_O>() ) 
aggregate.cc:255:	Aggregate_sp other = obj->as<Aggregate_O>();
aggregate.cc:256:	if ( other->_contents.size() != this->_contents.size() )
aggregate.cc:261:	for ( tit=this->_contents.begin(), oit=other->_contents.begin();
aggregate.cc:262:	      tit!=this->_contents.end(); tit++, oit++ )
aggregate.cc:264:	    (*tit)->transferCoordinates(*oit);
aggregate.cc:274:	me = this->sharedThis<Aggregate_O>();
aggregate.cc:278:	    if ( a->getId() == id ) {
aggregate.cc:306:	la.loopTopGoal(this->sharedThis<Aggregate_O>(),ATOMS);
aggregate.cc:309:	    va = a->getPosition();
aggregate.cc:310:	    vdwa = a->getVdwRadius();
aggregate.cc:312:		vb = (*oa)->getPosition();
aggregate.cc:313:		vdwb = (*oa)->getVdwRadius();
aggregate.cc:314:		vdiff = vb - va;
aggregate.cc:331:	atom = this->atomWithChimeraSpecification(spec);
aggregate.cc:347:	for ( mi=this->getContents().begin(); mi!= this->getContents().end(); mi++ )
aggregate.cc:350:	    if ( mol->getName() == chain )
aggregate.cc:352:		for ( ri = mol->getContents().begin(); ri!=mol->getContents().end(); ri++ )
aggregate.cc:355:		    if ( res->getFileSequenceNumber() == fileSequenceNumber )
aggregate.cc:357:			if ( res->hasAtomWithName(atomName) )
aggregate.cc:359:			    atom = res->atomWithName(atomName);
aggregate.cc:379:	for ( it=this->getContents().begin(); it!= this->getContents().end(); it++ ) {
aggregate.cc:382:		this->eraseContent(it);
aggregate.cc:386:	SIMPLE_ERROR( boost::format("Aggregate does not contain molecule: %s") % a->getName() ));
aggregate.cc:401:	    lb.loopTopAggregateGoal( this->sharedThis<Aggregate_O>(), ATOMS );
aggregate.cc:406:	    this->eraseContents();	// erase the old molecules
aggregate.cc:412:	    molecule->addMatter(res);
aggregate.cc:415:	    while ( spanner->advance() )
aggregate.cc:417:		Atom_sp a = spanner->getAtom();
aggregate.cc:419:		res->addAtom(a);
aggregate.cc:421:	    this->addMolecule(molecule);
aggregate.cc:430:	Atom_sp a = this->firstAtomWithName(name);
aggregate.cc:431:	Residue_sp res = a->containedByLock()->as<Residue_O>();
aggregate.cc:432:	Molecule_sp mol = res->containedByLock()->as<Molecule_O>();
aggregate.cc:439:	if ( matter->isAssignableTo<Molecule_O>() ) this->Base::addMatter(matter);
aggregate.cc:440:	if ( matter->isAssignableTo<Aggregate_O>())
aggregate.cc:442:	    for ( Matter_O::contentIterator it=matter->begin_contents(); it!=matter->end_contents(); it++ )
aggregate.cc:444:		this->Base::addMatter(*it);
aggregate.cc:457:	agg = this->sharedThis<Aggregate_O>();
aggregate.cc:463:	    if ( a->getName() == name ) {
aggregate.cc:484:	agg = this->sharedThis<Aggregate_O>();
aggregate.cc:492:	    xml->put("aggregate",this->sharedThis<Aggregate_O>());
aggregate.cc:493:	    xml->saveAs(fileName);
aggregate.cc:506://    mol = downcast<Molecule_O>(this->contentAt(0));
aggregate.cc:507:	mol = downcast<Molecule_O>(this->contentAt(0));
aggregate.cc:516:	ASSERTP(this->_contents.size()>0,"Aggregate_O::firstMoleculeName contains no molecules");
aggregate.cc:517:	c = this->contentAt(0);
aggregate.cc:522:	return mol->getName();
aggregate.cc:534:	lb.loopTopAggregateGoal( this->sharedThis<Aggregate_O>(), MOLECULES );
aggregate.cc:537:	    numberOfAtoms += lb.getMolecule()->numberOfAtoms();
aggregate.cc:552:	numberOfAtoms = this->numberOfAtoms();
aggregate.cc:555:	lb.loopTopAggregateGoal( this->sharedThis<Aggregate_O>(), ATOMS );
aggregate.cc:561:	    xd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:562:	    yd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:563:	    zd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:564:	    v = a->getPosition();
aggregate.cc:567:	    a->setPosition(v);
aggregate.cc:576:	    for ( af=atoms.begin();af!=atoms.end()-1;af++ ) {
aggregate.cc:578:		    vdiff = (*af)->getPosition()-(*an)->getPosition();
aggregate.cc:583:			_lisp->print(BF( "Aggregate_O::perturbAtomPositions>> Atoms are too close and being randomized!!!" ));
aggregate.cc:584:			xd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:585:			yd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:586:			zd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:587:			v = (*af)->getPosition();
aggregate.cc:590:			(*af)->setPosition(v);
aggregate.cc:591:			xd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:592:			yd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:593:			zd = (core::randomNumber01()*2.0-1.0)*dist;
aggregate.cc:594:			v = (*an)->getPosition();
aggregate.cc:597:			(*an)->setPosition(v);
aggregate.cc:602:			_lisp->print(BF( "Aggregate_O::perturbAtomPositions>> Atoms are close and being nudged out!!!" ));
aggregate.cc:604:			pos = (*af)->getPosition();
aggregate.cc:606:			(*af)->setPosition(pos);
aggregate.cc:607:			pos = (*an)->getPosition();
aggregate.cc:608:			pos = pos - vdiff;
aggregate.cc:609:			(*an)->setPosition(pos);
aggregate.cc:617:		_lisp->print(BF("MADE MORE THAN %d ADJUSTMENT CYCLES WHEN PERTURBING ATOMS") % MAX_ADJUST_CYCLES);
aggregate.cc:627:	rend->setFromMatter(this->sharedThis<Aggregate_O>());
alias.cc:15:	this->Base::initialize();
alias.cc:16://	this->_WeakFingerprint = _Nil<Fingerprint_O>();
alias.cc:22:	this->Base::archiveBase(node);
alias.cc:23:	node->attribute("MonomerAlias",this->_MonomerAlias);
alias.cc:24:	node->attribute("AtomAlias",this->_AtomAlias);
alias.cc:29:/*! \subpage script-functions
alias.cc:30: * alias 'monAlias 'atomAlias  -  Define an monomer/atom alias combo
alias.cc:62:	me->_MonomerAlias = monomerSym;
alias.cc:63:	me->_AtomAlias = atomSym;
alias.cc:71:	this->_MonomerAlias = translate::from_object<core::Symbol_sp>::convert(bargs->lookup(ChemPkg,"monomerSym"));
alias.cc:72:	this->_AtomAlias = translate::from_object<core::Symbol_sp>::convert(bargs->lookup(ChemPkg,"atomSym"));
alias.cc:81:	ASSERTF(this->_WeakFingerprint.use_count()!=0, BF("The _WeakFingerprint should never be NULL"));
alias.cc:82:	return this->_WeakFingerprint.lock();
alias.cc:90:	ss << "[Alias " << this->_MonomerAlias << "@" << this->_AtomAlias;
alias.cc:91:	ss << " monomerId("<<this->_MonomerId<<") atomId("<<this->_AtomId<<")";
alias.cc:99:	this->_MonomerId = alchemist->getMonomerIdForUniqueAlias(this->sharedThis<Alias_O>());
alias.cc:104:	this->_AtomId = alchemist->indexOfInterestingAtomWithAlias(this->_MonomerId,this->sharedThis<Alias_O>());
alias.cc:105:	LOG(BF("[Alias %s@%s] _MonomerId(%d) _AtomId(%d)") % this->_MonomerAlias->__repr__() % this->_AtomAlias->__repr__() % this->_MonomerId % this->_AtomId  );
alias.cc:111:	return alchemist->getUntransformedAtomPosition(this->_AtomId);
alias.cc:121:	if (!o->isOfClass<Alias_O>()) return false;
alias.cc:122:	Alias_sp a = o->as<Alias_O>();
alias.cc:123:	if ( this->_MonomerAlias != a->_MonomerAlias ) return false;
alias.cc:124:	if ( this->_AtomAlias != a->_AtomAlias ) return false;
angle.cc:11:// ----------------------------------------------------------------------
angle.cc:36:	obj->setup(a1,a2,a3);
angle.cc:43:	this->_a1 = a1;
angle.cc:44:	this->_a2 = a2;
angle.cc:45:	this->_a3 = a3;
angle.cc:52:        this->Base::archiveBase(node);
angle.cc:60:        this->Base::initialize();
angle.cc:67:	ss << this->className() << "["<<this->_a1->getName()<<"-"<<this->_a2->getName()<<"-"<<this->_a3->getName()<<"]";
arrayedMatter.cc:25:    this->Base::initialize();
arrayedMatter.cc:26:    this->_AtomLabel = "";
arrayedMatter.cc:27:    this->_Atom.reset();
arrayedMatter.cc:33:    node->attribute("name",this->_AtomLabel);
arrayedMatter.cc:34:    node->archiveWeakPointer("atom",this->_Atom);
arrayedMatter.cc:41:    this->_AtomLabel = a->getName();
arrayedMatter.cc:42:    this->_Atom = a;
arrayedMatter.cc:49:    for ( string::iterator it=this->_AtomLabel.begin();
arrayedMatter.cc:50:    	it !=this->_AtomLabel.end(); it++ )
arrayedMatter.cc:62:    ASSERT(this->_Atom.use_count()!=0);
arrayedMatter.cc:63:    this->_Atom.lock()->setPosition(h->getElement(idx));
arrayedMatter.cc:68:    ASSERT(this->_Atom.use_count()!=0);
arrayedMatter.cc:69:    h->setElement(idx,this->_Atom.lock()->getPosition());
arrayedMatter.cc:105:    this->Base::initialize();
arrayedMatter.cc:106:    this->_ResidueLabel = "";
arrayedMatter.cc:107:    this->_Residue.reset();
arrayedMatter.cc:108:    this->_SortedAtoms.clear();
arrayedMatter.cc:114:    node->attribute("label",this->_ResidueLabel);
arrayedMatter.cc:115:    node->archiveWeakPointer("residue",this->_Residue);
arrayedMatter.cc:116:    node->archiveVector0("sortedAtoms",this->_SortedAtoms);
arrayedMatter.cc:126:	return x->_AtomLabel <= y->_AtomLabel;
arrayedMatter.cc:131:    if ( res->getUniqueLabel() == "" )
arrayedMatter.cc:135:    this->_ResidueLabel = res->getUniqueLabel();
arrayedMatter.cc:136:    this->_Residue = res;
arrayedMatter.cc:138:    this->_SortedAtoms.clear();
arrayedMatter.cc:139:    for ( it=res->begin_atoms(); it!=res->end_atoms(); it++ )
arrayedMatter.cc:142:	Atom_sp a = (*it)->as<Atom_O>();
arrayedMatter.cc:143:	atomRef->setAtom(a);
arrayedMatter.cc:144:	this->_SortedAtoms.push_back(atomRef);
arrayedMatter.cc:147:    core::sort::quickSort(this->_SortedAtoms.begin(),
arrayedMatter.cc:148:		    this->_SortedAtoms.end(),orderer, _lisp);
arrayedMatter.cc:153:    return this->_SortedAtoms.size();
arrayedMatter.cc:160:    for ( core::Vector0<ArrayedAtom_O>::iterator it=this->_SortedAtoms.begin();
arrayedMatter.cc:161:    	it !=this->_SortedAtoms.end(); it++ )
arrayedMatter.cc:163:	hash += (*it)->calculateHash();
arrayedMatter.cc:172:    for ( core::Vector0<ArrayedAtom_O>::iterator it=this->_SortedAtoms.begin();
arrayedMatter.cc:173:    	it !=this->_SortedAtoms.end(); it++ )
arrayedMatter.cc:175:	(*it)->extractFromCoordinateArray(hash,start);
arrayedMatter.cc:178:    return this->_SortedAtoms.size();
arrayedMatter.cc:183:    for ( core::Vector0<ArrayedAtom_O>::iterator it=this->_SortedAtoms.begin();
arrayedMatter.cc:184:    	it !=this->_SortedAtoms.end(); it++ )
arrayedMatter.cc:186:	(*it)->writeToCoordinateArray(hash,start);
arrayedMatter.cc:189:    return this->_SortedAtoms.size();
arrayedMatter.cc:225:    this->Base::initialize();
arrayedMatter.cc:226:    this->_SortedResidues.clear();
arrayedMatter.cc:232:    node->archiveVector0("sortedResidues",this->_SortedResidues);
arrayedMatter.cc:233:    node->attribute("hash",this->_Hash);
arrayedMatter.cc:234:    node->attribute("numberOfAtoms",this->_NumberOfAtoms);
arrayedMatter.cc:243:	return x->_ResidueLabel <= y->_ResidueLabel;
arrayedMatter.cc:249:    this->_Molecule = mol;
arrayedMatter.cc:251:    this->_SortedResidues.clear();
arrayedMatter.cc:252:    for ( it=mol->begin_residues(); it!=mol->end_residues(); it++ )
arrayedMatter.cc:255:	Residue_sp res = (*it)->as<Residue_O>();
arrayedMatter.cc:256:	linearResidue->setResidue(res);
arrayedMatter.cc:257:	this->_SortedResidues.push_back(linearResidue);
arrayedMatter.cc:260:    core::sort::quickSort(this->_SortedResidues.begin(),
arrayedMatter.cc:261:		    this->_SortedResidues.end(),orderer,_lisp);
arrayedMatter.cc:262:    this->_Hash = this->calculateHash();
arrayedMatter.cc:263:    this->_NumberOfAtoms = this->getNumberOfAtoms();
arrayedMatter.cc:270:    for ( core::Vector0<ArrayedResidue_O>::iterator it=this->_SortedResidues.begin();
arrayedMatter.cc:271:    		it!=this->_SortedResidues.end(); it++ )
arrayedMatter.cc:273:	num += (*it)->getNumberOfAtoms();
arrayedMatter.cc:281:    for ( core::Vector0<ArrayedResidue_O>::iterator it=this->_SortedResidues.begin();
arrayedMatter.cc:282:    		it!=this->_SortedResidues.end(); it++ )
arrayedMatter.cc:284:	hash += (*it)->calculateHash();
arrayedMatter.cc:294:    uint numberOfAtoms = this->getNumberOfAtoms();
arrayedMatter.cc:297:    ca->setHash(this->_Hash);
arrayedMatter.cc:304:    if ( h->getHash() != this->_Hash )
arrayedMatter.cc:308:    if ( h->size() != this->getNumberOfAtoms() )
arrayedMatter.cc:313:    for ( core::Vector0<ArrayedResidue_O>::iterator it=this->_SortedResidues.begin();
arrayedMatter.cc:314:    		it!=this->_SortedResidues.end(); it++ )
arrayedMatter.cc:316:	start += (*it)->extractFromCoordinateArray(h,start);
arrayedMatter.cc:322:    if ( h->getHash() != this->_Hash )
arrayedMatter.cc:326:    if ( h->size() != this->getNumberOfAtoms() )
arrayedMatter.cc:331:    for ( core::Vector0<ArrayedResidue_O>::iterator it=this->_SortedResidues.begin();
arrayedMatter.cc:332:    		it!=this->_SortedResidues.end(); it++ )
arrayedMatter.cc:334:	start += (*it)->writeToCoordinateArray(h,start);
atom.cc:39: * :colorByElement true/false - if true overrides color; 
atom.cc:43: * :color type(GrColor)		- defines color  (default byelement)
atom.cc:44: * :renderStyle			- one of :none, :line, :ballAndStick or :cpk (default :none if it has bonds and :ball if it doesn't)
atom.cc:45: * :showLabel			- true or false (default false)
atom.cc:46: * :label			- Label to show (default "")
atom.cc:73:	{ "", -1 }
atom.cc:80:	{ "", -1 }
atom.cc:95:	node->archivePlainObject<Vector3>("anchorPos","AnchorPos",this->_AnchorPos);
atom.cc:367: *  return -1 if priority(a)<priority(b)
atom.cc:374:	if ( a->isNil() && b->isNil() ) return 0;
atom.cc:375:	if ( b->isNil() ) return 1;
atom.cc:376:	if ( a->isNil() ) return -1;
atom.cc:377:	if ( a->getRelativePriority()>b->getRelativePriority() ) return 1;
atom.cc:378:	if ( a->getRelativePriority()<b->getRelativePriority() ) return -1;
atom.cc:379:	if ( a->getName() > b->getName() ) return 1;
atom.cc:380:	if ( a->getName() < b->getName() ) return -1;
atom.cc:388:	if ( this->numberOfBonds() != 4 ) return undefinedConfiguration;
atom.cc:389:	core::Cons_sp neighborsByPriority = this->getNeighborsByRelativePriority();
atom.cc:390:	Atom_sp a4 = core::oCar(neighborsByPriority)->as<Atom_O>();
atom.cc:391:	Atom_sp a3 = neighborsByPriority->ocadr()->as<Atom_O>();
atom.cc:392:	Atom_sp a2 = neighborsByPriority->ocaddr()->as<Atom_O>();
atom.cc:393:	Atom_sp a1 = neighborsByPriority->ocadddr()->as<Atom_O>();
atom.cc:394:	Vector3 vme = this->getPosition();
atom.cc:395:	Vector3 v4 = a4->getPosition().sub(vme);
atom.cc:396:	Vector3 v3 = a3->getPosition().sub(vme);
atom.cc:397:	Vector3 v2 = a2->getPosition().sub(vme);
atom.cc:398:	Vector3 v1 = a1->getPosition().sub(vme);
atom.cc:424:	ConfigurationEnum config = this->calculateStereochemicalConfiguration();
atom.cc:453:	out << "Atom: " << this->getName();
atom.cc:455:	out << " id=" << this->getId();
atom.cc:456:	out << " typeStr=" << this->getTypeString();
atom.cc:457:	bonds = this->getBonds();
atom.cc:460:	    wtoa = (*b)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:462:	    if (wtoa.lock()->isNil()) {
atom.cc:466:		name = wtoa.lock()->getName();
atom.cc:467:		out << name << ":" << wtoa.lock()->getId()
atom.cc:472:	if ( !(this->getStereochemistryType() == undefinedCenter 
atom.cc:473:	       && this->getConfiguration() == undefinedConfiguration ) )
atom.cc:475:	    switch ( this->getStereochemistryType() )
atom.cc:478:	    	out << "undefinedStereochemistryType-";
atom.cc:481:		out << "proChiral-";
atom.cc:484:		out << "chiral-";
atom.cc:487:	    switch (this->getConfiguration())
atom.cc:510:	this->Base::initialize();
atom.cc:511:	this->copyAtom = Atom_O::_nil;
atom.cc:512:	this->flags = ATOM_NEEDS_MINIMIZER;
atom.cc:513:	this->_Mask = 0;
atom.cc:514:	this->tempInt = 0;
atom.cc:515:	this->_HintLP = false;
atom.cc:516:	this->_Element = element_Undefined;
atom.cc:517:	this->_Hybridization = hybridization_undefined;
atom.cc:518:	this->seenId = 0;
atom.cc:519:	this->_Alias = _Nil<core::Symbol_O>();
atom.cc:520:	this->_Ionization = 0; // neutral
atom.cc:521:	this->_Force.set(0.0,0.0,0.0);
atom.cc:523:	this->_AnchorRestraint.setIsDefined(false);
atom.cc:524:	this->_AnchorRestraint._AnchorPos.set(0.0,0.0,0.0);
atom.cc:526:	this->charge= 0;
atom.cc:527:	this->_RingMembershipCount = 0;
atom.cc:528:	this->type= 0;
atom.cc:529:	this->typeString= "";
atom.cc:530:	this->invalidateBackSpan();
atom.cc:531:	this->invalidateNextSpan();
atom.cc:532:	this->_MembershipAr1 = 0;
atom.cc:533:	this->_MembershipAr2 = 0;
atom.cc:534:	this->_MembershipAr3 = 0;
atom.cc:535:	this->_MembershipAr4 = 0;
atom.cc:536:	this->_MembershipAr5 = 0;
atom.cc:537:	this->_RelativePriority = 0;
atom.cc:538:	this->_Configuration = undefinedConfiguration;
atom.cc:539:	this->_StereochemistryType = undefinedCenter;
atom.cc:546:	if ( this->eq(obj) ) goto T;
atom.cc:547:	if ( obj->isOfClass<Atom_O>() )
atom.cc:549:	    Atom_sp other = obj->as<Atom_O>();
atom.cc:550:	    if ( other->getName() != this->getName() )
atom.cc:552:		LOG(BF("Atom names[ this->getName()=%s  other->getName()=%s ]  don't match!") % this->getName() % other->getName() );
atom.cc:555:	    if ( other->numberOfBonds() != this->numberOfBonds() )
atom.cc:557:		LOG(BF("Numbers of bonds don't match this->numberOfBonds()=%d  other->numberOfBonds()=%d!") % this->numberOfBonds() % other->numberOfBonds() );
atom.cc:564:	LOG(BF("atoms this(%s) =equal= other(%s)  equal==false") % this->description() % obj->description() );
atom.cc:567:	LOG(BF("atoms this(%s) =equal= other(%s)  equal==true") % this->description() % obj->description() );
atom.cc:573:	if ( !this->equal(obj) )
atom.cc:575:	    SIMPLE_ERROR(BF("This atom(%s) is not equal to %s so you cannot transfer coordinates")%this->description() % obj->description() );
atom.cc:577:	Atom_sp other = obj->as<Atom_O>();
atom.cc:578:	this->setPosition(other->getPosition());
atom.cc:588:	this->_Element = ss._Element;
atom.cc:589:	this->_Alias = ss._Alias;
atom.cc:590:	this->type = ss.type;
atom.cc:591:	this->typeString= ss.typeString;
atom.cc:592:	this->_Hybridization = ss._Hybridization;
atom.cc:593:	this->_HintLP = ss._HintLP;
atom.cc:594:	this->_selected = ss._selected;
atom.cc:595:	this->flags = ss.flags;
atom.cc:596:	this->_Mask = ss._Mask;
atom.cc:597:	this->position = ss.position;
atom.cc:598:	this->_Force = ss._Force;
atom.cc:600:	this->_AnchorRestraint = ss._AnchorRestraint;
atom.cc:602:	this->touched = ss.touched;
atom.cc:603:	this->charge = ss.charge;
atom.cc:604:	this->_RingMembershipCount = ss._RingMembershipCount;
atom.cc:605:	this->occupancy = ss.occupancy;
atom.cc:606:	this->tempFactor = ss.tempFactor;
atom.cc:607:	this->vdwRadius = ss.vdwRadius;
atom.cc:608:	this->covalentRadius = ss.covalentRadius;
atom.cc:609:	this->copyAtom = Atom_wp();
atom.cc:610:	this->tempInt = ss.tempInt;
atom.cc:611:	this->moeIndex = ss.moeIndex;
atom.cc:612:	this->moeType = ss.moeType;
atom.cc:613:	this->_Ionization = ss._Ionization;
atom.cc:614:	this->_MembershipAr1 = ss._MembershipAr1;
atom.cc:615:	this->_MembershipAr2 = ss._MembershipAr2;
atom.cc:616:	this->_MembershipAr3 = ss._MembershipAr3;
atom.cc:617:	this->_MembershipAr4 = ss._MembershipAr4;
atom.cc:618:	this->_MembershipAr5 = ss._MembershipAr5;
atom.cc:619:	this->_RelativePriority = ss._RelativePriority;
atom.cc:620:	this->_Configuration = ss._Configuration;
atom.cc:621:	this->_StereochemistryType = ss._StereochemistryType;
atom.cc:622:	this->_BackSpan = ss.lisp()->nil<Atom_O>();		// Is this a bad idea to access env in copy?
atom.cc:623:	this->_NextSpan = ss.lisp()->nil<Atom_O>();		// Is this a bad idea to access env in copy?
atom.cc:635:	this->_Configuration = conf;
atom.cc:637:	    % this->__repr__() % this->getConfigurationAsString() );
atom.cc:649:	Element element = elementFromName(this->getName());
atom.cc:651:	this->setElement(element);
atom.cc:658:	this->setElement(element);
atom.cc:664:	this->_Hybridization = hybridizationForString(h);
atom.cc:670:	h->setName(name);
atom.cc:671:	h->setElement(element_H);
atom.cc:672:	Residue_sp res = this->getResidueContainedBy();
atom.cc:673:	res->addAtom(h);
atom.cc:674:	this->bondTo(h,singleBond);
atom.cc:679:	return this->bonds[i]->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:684:	return this->bonds[i]->getOrder();
atom.cc:689:	return this->bonds.size();
atom.cc:694:	return this->bonds.size();
atom.cc:713:	if ( this->getElement() != element_C ) return core::Cons_O::_nil;
atom.cc:715:	if ( this->getIonization() != 0 ) return core::Cons_O::_nil;
atom.cc:716:	uint totalBondOrder = this->totalBondOrder();
atom.cc:718:	uint addHydrogens = 4 - totalBondOrder;
atom.cc:719:	string nameSuffix = this->getName().substr(1,9999);
atom.cc:722:	    core::Cons_sp one = core::Cons_O::create(_lisp->create<core::Str_O>("H"+nameSuffix),core::Cons_O::_nil,_lisp);
atom.cc:723:	    cons->setCdr(one);
atom.cc:725:	    return first->cdr();
atom.cc:731:	    core::Cons_sp one = core::Cons_O::create(_lisp->create<core::Str_O,string>(ss.str()),core::Cons_O::_nil,_lisp);
atom.cc:732:	    cons->setCdr(one);
atom.cc:735:	return first->cdr();
atom.cc:743:	core::Cons_sp names = this->createImplicitHydrogenNamesOnCarbon();
atom.cc:744:	if ( names->isNil() ) return;
atom.cc:745:	for ( core::Cons_sp cur = names; cur.notnilp(); cur = cur->cdr() )
atom.cc:747:	    this->_addHydrogenWithName(cur->car<core::Str_O>()->get());
atom.cc:766:	this->setPosition(v);
atom.cc:782:	xd = (core::randomNumber01()*2.0-1.0)*dist;
atom.cc:783:	yd = (core::randomNumber01()*2.0-1.0)*dist;
atom.cc:784:	zd = (core::randomNumber01()*2.0-1.0)*dist;
atom.cc:785:	v = this->getPosition();
atom.cc:788:	this->setPosition(v);
atom.cc:798:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) {
atom.cc:799:	    atom = (*b)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:815:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) {
atom.cc:816:	    atom = (*b)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:818:	    if ( bestAtom->isNil() )
atom.cc:837:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:839:	    if ( a.get() == (*b)->getOtherAtom(this->sharedThis<Atom_O>()).get() ) return *b;
atom.cc:846:	this->bonds.push_back(bond);
atom.cc:851:	this->bonds.push_back(bond);
atom.cc:859:	Atom_sp from = this->sharedThis<Atom_O>();
atom.cc:861:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:863:	    if ( (*b)->getOtherAtom(from) == to )
atom.cc:865:		SIMPLE_ERROR(BF("You tried to form a bond from[%s]-to[%s] but there is already one there!!") 
atom.cc:866:				   % this->__repr__() % to->__repr__() );
atom.cc:870:	this->bonds.push_back(bn);
atom.cc:871:	to.get()->bonds.push_back(bn);
atom.cc:881:	return this->bondTo(a,singleBond);
atom.cc:892:	s = this->getName()+":";
atom.cc:893:	sprintf( caIndex, "%d", this->moeIndex );
atom.cc:904:	    if ( x->getRelativePriority()<y->getRelativePriority() ) return true;
atom.cc:905:	    if ( x->getRelativePriority()>y->getRelativePriority() ) return false;
atom.cc:906:	    if ( x->getName()<y->getName() ) return true;
atom.cc:913:	LOG(BF("Ordering neighbors around(%s) by priority and name") % this->getName()  );
atom.cc:916:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) {
atom.cc:917:	    reversedNeighbors.push_back((*b)->getOtherAtom(this->sharedThis<Atom_O>()));
atom.cc:930:	    LOG(BF("    neighbor priority(%u) name(%s)") % (*ni)->getRelativePriority() % (*ni)->getName()  );
atom.cc:942:	    this->flags |= fl;
atom.cc:944:	    this->flags &= fl;
atom.cc:946:	    this->flags |= fl;
atom.cc:948:	    this->flags &= (~fl);
atom.cc:959:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) {
atom.cc:960:	    if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>())->getName() == name ) {
atom.cc:971:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) {
atom.cc:972:	    if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>())->getName() == name ) {
atom.cc:973:		return (*b)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:985:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) 
atom.cc:987:	    if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>())->getElement() == el ) 
atom.cc:989:		if ( (*b)->getOrder() == o ) return true;
atom.cc:999:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) 
atom.cc:1001:	    if ( (*b)->getOrder() == o) return true;
atom.cc:1012:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) 
atom.cc:1014:	    if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>())->getElement() == el ) 
atom.cc:1016:		if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>())->getHybridization() == hy ) return true;
atom.cc:1033:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ ) 
atom.cc:1035:	    a1 = Atom_sp((*b)->getTo());
atom.cc:1036:	    if ( a1->getElement() == el1 ) 
atom.cc:1038:		if ( a1->getHybridization() == hy1 ) 
atom.cc:1040:		    for ( b2=a1->bonds.begin();b2!=a1->bonds.end();b2++) 
atom.cc:1042:			a2 = Atom_sp((*b2)->getTo());
atom.cc:1043:			if ( a2 == this->sharedThis<Atom_O>() ) continue;
atom.cc:1044:			if ( a2->getElement() == el2 ) 
atom.cc:1046:			    if ( (*b2)->getTo().lock()->getHybridization() == hy2 ) return true;
atom.cc:1068:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1070:	    if ( (*b)->getOtherAtom(this->sharedThis<Atom_O>()) == a )
atom.cc:1072:		this->bonds.erase(b);
atom.cc:1077:	ss << "Trying to remove bond from atom(" << this->description()
atom.cc:1078:	   << ") but I can't find the to atom(" << a->description() << ")";
atom.cc:1086:	this->basicRemoveBondTo(a);
atom.cc:1087:	atemp = this->sharedThis<Atom_O>();
atom.cc:1088:	a->basicRemoveBondTo(atemp);
atom.cc:1096:	LOG(BF("Bond_O::removeAllBonds for %s") % this->description() );
atom.cc:1097:	atemp = this->sharedThis<Atom_O>();
atom.cc:1098:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1100:	    Atom_sp ato = (*b)->getOtherAtom(atemp);
atom.cc:1101:	    ato->basicRemoveBondTo(atemp);
atom.cc:1103:	this->bonds.erase(this->bonds.begin(),this->bonds.end());
atom.cc:1113:	this->position = (m)*this->position;
atom.cc:1126:	out << prefix << "atom " << this->getId() << " '";
atom.cc:1127:	out << this->getName() << "' '";
atom.cc:1128:	out << this->getElement() << "' '";
atom.cc:1129:	out << this->getHybridization() << "' '";
atom.cc:1130:	out << this->getTypeString() << "' ";
atom.cc:1131:	out << this->getCharge() << " " << 0.0 << " ;" << endl;
atom.cc:1137:	return hybridizationSymbolFromHybridization(this->getHybridization())->symbolName();
atom.cc:1142:	return atomicSymbolFromElement(this->getElement())->symbolName();
atom.cc:1147:	return symbolFromElement(this->getElement());
atom.cc:1154:	this->Base::serialize(snode);
atom.cc:1155:	snode->attributeIfNotDefault<ATOM_FLAGS>( "flags", this->flags, (unsigned long)0 );
atom.cc:1156:	snode->attributeSymbolEnumHiddenConverter( "element", this->_Element, _sym_elementToSymbolConverter);
atom.cc:1157:	snode->attributeSymbolEnumHiddenConverterIfNotDefault( "hybrid", this->_Hybridization, _sym_hybridizationToSymbolConverter,hybridization_sp3 );
atom.cc:1158:	snode->attributeSymbolIfNotNil( "alias", this->_Alias );
atom.cc:1159:	snode->attributeIfNotDefault<uint>( "priority", this->_RelativePriority, 0 );
atom.cc:1160:	snode->attributeIfNotDefault<bool>( "hintLP", this->_HintLP,false );
atom.cc:1161:	snode->attributeIfNotDefault<double>( "chg", this->charge, 0.0 );
atom.cc:1162:	snode->attributeSymbolEnumHiddenConverterIfNotDefault( "configuration", this->_Configuration, _sym_configurationEnumConverter, undefinedConfiguration  );
atom.cc:1163:	snode->attributeSymbolEnumHiddenConverterIfNotDefault( "stereochemistryType", this->_StereochemistryType, _sym_stereochemistryTypeConverter, undefinedCenter );
atom.cc:1164:	snode->attributeIfNotDefault<int>( "ion", this->_Ionization, 0 );
atom.cc:1165:	snode->attributeIfNotDefault<int>( "rings", this->_RingMembershipCount, 0 );
atom.cc:1166:	snode->attributeIfNotDefault<int>( "tempInt", this->tempInt, 0 );
atom.cc:1167:	snode->attributeIfNotDefault<string>( "type", this->typeString, "" );
atom.cc:1168:	snode->attributeIfNotDefault<int>( "ar1", this->_MembershipAr1, 0 );
atom.cc:1169:	snode->attributeIfNotDefault<int>( "ar2", this->_MembershipAr2, 0 );
atom.cc:1170:	snode->attributeIfNotDefault<int>( "ar3", this->_MembershipAr3, 0 );
atom.cc:1171:	snode->attributeIfNotDefault<int>( "ar4", this->_MembershipAr4, 0 );
atom.cc:1172:	snode->attributeIfNotDefault<int>( "ar5", this->_MembershipAr5, 0 );
atom.cc:1173:	snode->attributeIfNotDefault<uint>( "mask", this->_Mask, (unsigned int)(0) );
atom.cc:1174:	snode->archivePlainObjectIfDefined<Vector3>( "pos","Vector3",
atom.cc:1175:						    this->position.isDefined(), this->position );
atom.cc:1176:	LOG(BF("After pos archived Atom position@%p = %s") % &(this->position) % this->position.asString()  );
atom.cc:1177:	LOG(BF("Atom position = %s") % this->position.asString() );
atom.cc:1188:	this->Base::archiveBase(node);
atom.cc:1189:	node->attributeIfNotDefault<ATOM_FLAGS>( "flags", this->flags, (unsigned long)0 );
atom.cc:1190:	node->attributeSymbolEnumHiddenConverter( "element", this->_Element, _sym_elementToSymbolConverter);
atom.cc:1191:	node->attributeSymbolEnumHiddenConverterIfNotDefault( "hybrid", this->_Hybridization, _sym_hybridizationToSymbolConverter,hybridization_sp3 );
atom.cc:1192:	node->attributeSymbolIfNotNil( "alias", this->_Alias );
atom.cc:1193:	node->attributeIfNotDefault<uint>( "priority", this->_RelativePriority, 0 );
atom.cc:1194:	node->attributeIfNotDefault<bool>( "hintLP", this->_HintLP,false );
atom.cc:1195:	node->attributeIfNotDefault<double>( "chg", this->charge, 0.0 );
atom.cc:1196:	node->attributeEnumIfNotDefault<ConfigurationEnum>( "configuration", this->_Configuration, configurationEnum, undefinedConfiguration  );
atom.cc:1197:	node->attributeEnumIfNotDefault<StereochemistryType>( "stereochemistryType", this->_StereochemistryType, stereochemistryTypes, undefinedCenter );
atom.cc:1198:	node->attributeIfNotDefault<int>( "ion", this->_Ionization, 0 );
atom.cc:1199:	node->attributeIfNotDefault<int>( "rings", this->_RingMembershipCount, 0 );
atom.cc:1200:	node->attributeIfNotDefault<int>( "tempInt", this->tempInt, 0 );
atom.cc:1201:	node->attributeIfNotDefault<string>( "type", this->typeString, "" );
atom.cc:1202:	node->attributeIfNotDefault<int>( "ar1", this->_MembershipAr1, 0 );
atom.cc:1203:	node->attributeIfNotDefault<int>( "ar2", this->_MembershipAr2, 0 );
atom.cc:1204:	node->attributeIfNotDefault<int>( "ar3", this->_MembershipAr3, 0 );
atom.cc:1205:	node->attributeIfNotDefault<int>( "ar4", this->_MembershipAr4, 0 );
atom.cc:1206:	node->attributeIfNotDefault<int>( "ar5", this->_MembershipAr5, 0 );
atom.cc:1207:	node->attributeIfNotDefault<uint>( "mask", this->_Mask, (unsigned int)(0) );
atom.cc:1208:	node->archivePlainObjectIfDefined<Vector3>( "pos","Vector3",
atom.cc:1209:						    this->position.isDefined(), this->position );
atom.cc:1210:	LOG(BF("After pos archived Atom position@%p = %s") % &(this->position) % this->position.asString()  );
atom.cc:1211:	LOG(BF("Atom position = %s") % this->position.asString() );
atom.cc:1219:	this->position = angpos;
atom.cc:1226:	this->tempInt = i;
atom.cc:1231:	return this->tempInt;
atom.cc:1237:	if ( this->_Configuration == undefinedConfiguration )
atom.cc:1240:	} else if ( this->_Configuration == S_Configuration )
atom.cc:1243:	} else if ( this->_Configuration == R_Configuration )
atom.cc:1250:	if ( this->_StereochemistryType == undefinedCenter )
atom.cc:1253:	} else if ( this->_StereochemistryType == chiralCenter )
atom.cc:1256:	} else if ( this->_StereochemistryType == prochiralCenter )
atom.cc:1280:	bonds = this->getBonds();
atom.cc:1281:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1283:	    if ( me->atLowerAddressThan((*b)->getOtherAtom(me)))
atom.cc:1286:		switch ( (*b)->getOrder() ) {
atom.cc:1300:		    out << "--unknown--";
atom.cc:1302:		out << " " << me->getId() << " ";
atom.cc:1303:		out << (*b)->getOtherAtom(me)->getId() << " ;" << endl;
atom.cc:1313:	if ( this->isNil() ) return "nil";
atom.cc:1315:	if ( this->containedByValid() )
atom.cc:1319:	    if ( this->containedByValid() )
atom.cc:1321:		res = this->containedBy().lock()->as<Residue_O>();
atom.cc:1322:		if ( res->containedByValid() )
atom.cc:1324:		    mol = res->containedBy().lock()->as<Molecule_O>();
atom.cc:1327:	    string molName = (mol->isNil())?"":mol->getName();
atom.cc:1328:	    string resName = (res->isNil())?"":res->getName();
atom.cc:1329:	    ss << this->className() << ":" << molName << "@" << this << ":" << resName << "@" << this->name;
atom.cc:1332:	    ss << "(" << this->className() << " :invalidContainer! :name \"" << this->name << "@" << this << "\" )";
atom.cc:1340:	if ( this->isNil() )
atom.cc:1344:	ss << this->className() << "("<<this->getName();
atom.cc:1345:	if ( this->containerContainedBy.use_count() != 0 ) 
atom.cc:1347:	    if ( this->containedBy().lock()->isNil() )
atom.cc:1349:		ss<<"[residue-UNDEFINED-]";
atom.cc:1351:		ss <<"["<<this->getResidueContainedBy_const()->description()<<"]";
atom.cc:1355:	    ss << "[residue-NULL-]";
atom.cc:1357:	ss << "bonds[" << this->numberOfBonds() << "]";
atom.cc:1359://	ss << @"<<std::hex<<this<<std::dec<<"|USE("<<this->weakThis_const().use_count()<<")";
atom.cc:1373:	bonds = this->getBonds();
atom.cc:1374:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1377:	    if ( me->atLowerAddressThan( (*b)->getOtherAtom(me)))
atom.cc:1379:		if ( !(*b)->isInterResidueBond() ) {
atom.cc:1380:		    LOG(BF("Original bond: %s") % (*b)->description() );
atom.cc:1382:		    LOG(BF("Copy bond: %s") % bondCopy->description() );
atom.cc:1383:		    list->addBond(bondCopy);
atom.cc:1398:	bonds = this->getBonds();
atom.cc:1399:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1402:	    if ( me->atLowerAddressThan( (*b)->getOtherAtom(me)))
atom.cc:1404:		if ( (*b)->isInterResidueBond() ) {
atom.cc:1406:		    list->addBond(bondCopy);
atom.cc:1416:	bonds = this->getBonds();
atom.cc:1419:	    if ( (*b)->isInterResidueBond() ) {
atom.cc:1435:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1436:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1438:	    a2 = (*b)->getOtherAtom(me);
atom.cc:1441:		if ( o == (*b)->getOrder() ) {
atom.cc:1459:	    % this->getName()
atom.cc:1460:	    % aTarget->getName() );
atom.cc:1461:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1462:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1464:	    a2 = (*b)->getOtherAtom(me);
atom.cc:1465:	    LOG(BF("  looking at atom(%s)") % a2->getName() );
atom.cc:1484:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1485:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1487:	    a2 = (*b)->getOtherAtom(me);
atom.cc:1490:		return (*b)->getOrder();
atom.cc:1505:	LOG(BF("bonds array start = 0x%08x") % ((void*)&(this->bonds[0]))  );
atom.cc:1506:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1507:	for ( b=this->bonds.begin();b!=this->bonds.end() ; b++ )
atom.cc:1509:	    a2 = (*b)->getOtherAtom(me);
atom.cc:1513:	    if ( !(a2->isBondedToWithBondOrder(me,(*b)->getOrder())) )
atom.cc:1515:		_lisp->print(BF( "Atom_O::testConsistancy failed" ));
atom.cc:1526:	SIMPLE_ERROR(BF("Don't copy single atoms - bonds will be messed up"));
atom.cc:1541:	Atom_sp myself = this->sharedThis<Atom_O>();
atom.cc:1547:	    if ( (*b)->isAtom1(myself) )
atom.cc:1549:		Bond_sp bNew = (*b)->copyDontRedirectAtoms();
atom.cc:1550:		aNew->bonds.push_back(bNew);
atom.cc:1553:	this->copyAtom = aNew;
atom.cc:1554:	aNew->copyRestraintsDontRedirectAtoms(this);
atom.cc:1555:	LOG(BF("    copy atom== %s") % aNew->description());
atom.cc:1568:	LOG(BF("Redirecting bonds for %s") % this->description());
atom.cc:1571:	    (*b)->redirectAtoms();
atom.cc:1573:	this->redirectRestraintAtoms();
atom.cc:1583:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1584:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1586:	    vAtoms.push_back((*b)->getOtherAtom(me));
atom.cc:1595:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1596:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1598:	    list = core::Cons_O::create((*b)->getOtherAtom(me),list,_lisp);
atom.cc:1619:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1621:	    bl->addBond(*b);
atom.cc:1628:	return chem::maxTotalBondOrderForElement(this->getElement());
atom.cc:1637:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ ) 
atom.cc:1639:	    if ( (*b)->getOrder() == singleBond ) twice += 2;
atom.cc:1640:	    else if ((*b)->getOrder() == doubleBond ) twice += 4;
atom.cc:1641:	    else if ((*b)->getOrder() == aromaticBond ) twice += 3;
atom.cc:1642:	    else if ((*b)->getOrder() == tripleBond ) twice += 6;
atom.cc:1643:	    else if ((*b)->getOrder() == dashedSingleBond ) twice += 2;
atom.cc:1644:	    else if ((*b)->getOrder() == dashedDoubleBond ) twice += 4;
atom.cc:1649:	    SIMPLE_ERROR(BF("The total bond order for "+this->description()+" will not be a whole number"));
atom.cc:1660:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ ) {
atom.cc:1668:	return ((this->_Element!=element_H) && (this->_Element!=element_D) && (this->_Element!=element_T));
atom.cc:1676:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1677:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1679:	    if ( (*b)->getOtherAtom(me)->getElement() != element_H )
atom.cc:1681:		bl->addBond(*b);
atom.cc:1692:	return atomicNumberForElement(this->getElement());
atom.cc:1698:	return atomicWeightForElement(this->getElement());
atom.cc:1708:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:1709:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1711:	    Atom_sp other = (*b)->getOtherAtom(me);
atom.cc:1712:	    if ( other->getElement() == element_H ) hs++;
atom.cc:1724:            result = this->testAnyFlags(in3MemberRing);
atom.cc:1727:            result = this->testAnyFlags(in4MemberRing);
atom.cc:1730:            result = this->testAnyFlags(in5MemberRing);
atom.cc:1733:            result = this->testAnyFlags(in6MemberRing);
atom.cc:1736:            result = this->testAnyFlags(in7MemberRing);
atom.cc:1739:            result = this->testAnyFlags(in8MemberRing);
atom.cc:1745:	LOG(BF("Tested ring membership[%s]=%d of %s") % r % result % this->description() );
atom.cc:1752:	this->turnOffFlags(InRing);
atom.cc:1758:	LOG(BF("Setting %s in ring of size[%d]") % this->description() % r );
atom.cc:1761:            this->turnOnFlags(in3MemberRing);
atom.cc:1764:            this->turnOnFlags(in4MemberRing);
atom.cc:1767:            this->turnOnFlags(in5MemberRing);
atom.cc:1770:            this->turnOnFlags(in6MemberRing);
atom.cc:1773:            this->turnOnFlags(in7MemberRing);
atom.cc:1776:            this->turnOnFlags(in8MemberRing);
atom.cc:1792:	for (b=this->bonds.begin();b!=this->bonds.end(); b++ )
atom.cc:1794:	    bo = (*b)->getOrder();
atom.cc:1817:	if ( this->_BackSpan.use_count() == 0 )
atom.cc:1819:	    this->_BackSpan = _Nil<Atom_O>();
atom.cc:1821:	return this->_BackSpan.lock();
atom.cc:1827:	if ( this->_NextSpan.use_count() == 0 )
atom.cc:1829:	    this->_NextSpan = _Nil<Atom_O>();
atom.cc:1831:	return this->_NextSpan.lock();
atom.cc:1837:	core::Cons_sp localTree = _lisp->create<core::Cons_O>(incomingBond);
atom.cc:1840:	for ( VectorBond::iterator bi=this->bonds.begin(); bi!=this->bonds.end(); bi++ )
atom.cc:1842:	    Atom_sp neighborAtom = (*bi)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:1844:	    core::Cons_sp one = neighborAtom->_expandLocalSpanningTree(this->sharedThis<Atom_O>(),*bi,depth-1);
atom.cc:1845:	    tail->setCdr(one);
atom.cc:1853:	core::Cons_sp localTree = _lisp->create<core::Cons_O>(this->sharedThis<Atom_O>());
atom.cc:1856:	for ( VectorBond::iterator bi=this->bonds.begin(); bi!=this->bonds.end(); bi++ )
atom.cc:1858:	    Atom_sp neighborAtom = (*bi)->getOtherAtom(this->sharedThis<Atom_O>());
atom.cc:1859:	    core::Cons_sp one = neighborAtom->_expandLocalSpanningTree(this->sharedThis<Atom_O>(),*bi,depth-1);
atom.cc:1860:	    tail->setCdr(one);
atom.cc:1869:	return this->_StereochemistryType != undefinedCenter;
atom.cc:1876:	Vector3& pos=this->position;
atom.cc:1877:	this->position.set(pos.getX(),pos.getY(),pos.getZ()*-1.0);
atom.cc:1879:	Vector3& anchor = this->_AnchorRestraint._AnchorPos;
atom.cc:1880:	anchor.set(anchor.getX(),anchor.getY(),anchor.getZ()*-1.0);
atom.cc:1882:	this->invertStereochemistryOfRestraints();
atom.cc:1885:	ConfigurationEnum config = this->_Configuration;
atom.cc:1888:	    this->_Configuration = R_Configuration;
atom.cc:1891:	    this->_Configuration = S_Configuration;
atom.cc:1901:	return this->_Configuration;
atom.cc:1905:	ASSERTP(this->isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1906:	this->_ConfigurationInfo._HighestPriority = highest;
atom.cc:1907:	this->_ConfigurationInfo._HighPriority = high;
atom.cc:1908:	this->_ConfigurationInfo._LowPriority = low;
atom.cc:1909:	this->_ConfigurationInfo._LowestPriority = lowest;
atom.cc:1914:	ASSERTP(this->isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1915:	return this->_ConfigurationInfo._HighestPriority;
atom.cc:1920:	ASSERTP(this->isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1921:	return this->_ConfigurationInfo._HighPriority;
atom.cc:1926:	ASSERTP(this->isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1927:	return this->_ConfigurationInfo._LowPriority;
atom.cc:1932:	ASSERTP(this->isConfigurable(), "You cannot assign priorities to an unconfigurable atom");
atom.cc:1933:	return this->_ConfigurationInfo._LowestPriority;
atom.cc:1942:	ASSERTNOTNULL(this->containedBy());
atom.cc:1943:	containedBy = this->containedBy();
atom.cc:1944:	if ( containedBy.lock()->isNil() )
atom.cc:1958:	return this->containedByLock()->as<Residue_O>();
atom.cc:1963:	return this->containedByLock_const()->as<Residue_O>();
atom.cc:1983:    ss << this->description() << endl;
atom.cc:1984:    for ( VectorBond::const_iterator bi=this->bonds.begin(); bi!=this->bonds.end(); bi++ )
atom.cc:1986:	Atom_sp other = (*bi)->getOtherAtom(this->const_sharedThis<Atom_O>());
atom.cc:1989:	    other->_describeAtomRecursively(prefix+"  ",this->const_sharedThis<Atom_O>(),(*bi)->getOrder(),maxDepth-1,ss);
atom.cc:1998:    this->_describeAtomRecursively("",_Nil<Atom_O>(),noBond,maxDepth,ss);
atom.cc:2034:	x = core::randomNumber01()*dist*2.0-dist+this->position.getX();
atom.cc:2035:	y = core::randomNumber01()*dist*2.0-dist+this->position.getY();
atom.cc:2036:	z = core::randomNumber01()*dist*2.0-dist+this->position.getZ();
atom.cc:2037:	this->position.set(x,y,z);
atom.cc:2043:	if ( this->invalid() ) {
atom.cc:2044:	    SIMPLE_ERROR(boost::format("INVALID %s")% this->description());
atom.cc:2081:	ConstitutionAtom_sp ca = _lisp->create<ConstitutionAtom_O>(this->getName(),this->_Element,index);
atom.cc:2088:	Atom_sp me = this->sharedThis<Atom_O>();
atom.cc:2089:	for ( bi=this->bonds.begin(); bi!=this->bonds.end(); bi++ )
atom.cc:2091:	    ConstitutionBond_sp cb = (*bi)->asConstitutionBond(me,atomMap);
atom.cc:2092:	    consAtom->addConstitutionBond(cb);
atomGrid.cc:42:    this->Base::initialize();
atomGrid.cc:43:    this->xSize = 0;
atomGrid.cc:44:    this->ySize = 0;
atomGrid.cc:45:    this->zSize = 0;
atomGrid.cc:67:	me->buildGridWithinBoundingBox(matter,addRadius,gridResolution,boundingBox);
atomGrid.cc:71:        me->buildGrid(matter,addRadius,gridResolution);
atomGrid.cc:80:    Matter_sp matter = translate::from_object<Matter_sp>::convert(bargs->lookup(ChemPkg,"matter"));
atomGrid.cc:81:    double stepSize = translate::from_object<core::DoubleFloat_sp>::convert(bargs->lookup(ChemPkg,"gridResolution"))->get();
atomGrid.cc:82:    double addRadius = translate::from_object<core::DoubleFloat_sp>::convert(bargs->lookup(ChemPkg,"addRadius"))->get();
atomGrid.cc:83:    addon::BoundingBox_sp bbox = translate::from_object<addon::BoundingBox_sp>::convert(bargs->lookup(ChemPkg,"boundingBox"));
atomGrid.cc:86:        this->buildGridWithinBoundingBox(matter,addRadius,stepSize,bbox);
atomGrid.cc:89:        this->buildGrid(matter,addRadius,stepSize);
atomGrid.cc:99:    this->Base::archiveBase(node);
atomGrid.cc:100:    node->attribute("xSize",this->xSize);
atomGrid.cc:101:    node->attribute("ySize",this->ySize);
atomGrid.cc:102:    node->attribute("zSize",this->zSize);
atomGrid.cc:103:    node->attribute("ballRadius",this->ballRadius);
atomGrid.cc:104:    node->attribute("stepSize",this->stepSize);
atomGrid.cc:105:    node->attribute("xMin",this->xMin);
atomGrid.cc:106:    node->attribute("yMin",this->yMin);
atomGrid.cc:107:    node->attribute("zMin",this->zMin);
atomGrid.cc:108:    node->attribute("xMax",this->xMax);
atomGrid.cc:109:    node->attribute("yMax",this->yMax);
atomGrid.cc:110:    node->attribute("zMax",this->zMax);
atomGrid.cc:111:    if ( node->saving() )
atomGrid.cc:121:	it = this->grid.begin();
atomGrid.cc:128:		while (it!=this->grid.end() && *it )
atomGrid.cc:138:		if ( it == this->grid.end() ) done = true;
atomGrid.cc:142:	    while (it!=this->grid.end() && !*it )
atomGrid.cc:149:	    if ( it == this->grid.end() ) done = true;
atomGrid.cc:154:	node->setCharacters(sout.str());
atomGrid.cc:159:	sin.str(node->characters());
atomGrid.cc:160:	this->grid.resize(this->xSize*this->ySize*this->zSize,0);
atomGrid.cc:162:	it = this->grid.begin();
atomGrid.cc:178:	    size_t zzt = (it - this->grid.begin())+num;
atomGrid.cc:179:	    ASSERT_lt(zzt,this->grid.size()+1);
atomGrid.cc:194:    this->archiveBase(node);
atomGrid.cc:217:    xh = -9e99;
atomGrid.cc:218:    yh = -9e99;
atomGrid.cc:219:    zh = -9e99;
atomGrid.cc:224:	    diff = a->getPosition() - sphereCenter;
atomGrid.cc:227:	xl = MIN( xl, a->getPosition().getX() );
atomGrid.cc:228:	yl = MIN( yl, a->getPosition().getY() );
atomGrid.cc:229:	zl = MIN( zl, a->getPosition().getZ() );
atomGrid.cc:230:	xh = MAX( xh, a->getPosition().getX() );
atomGrid.cc:231:	yh = MAX( yh, a->getPosition().getY() );
atomGrid.cc:232:	zh = MAX( zh, a->getPosition().getZ() );
atomGrid.cc:234:    this->stepSize = step;
atomGrid.cc:235:    this->xMin = xl-GRID_PAD;
atomGrid.cc:236:    this->yMin = yl-GRID_PAD;
atomGrid.cc:237:    this->zMin = zl-GRID_PAD;
atomGrid.cc:238:    this->xMax = xh+GRID_PAD;
atomGrid.cc:239:    this->yMax = yh+GRID_PAD;
atomGrid.cc:240:    this->zMax = zh+GRID_PAD;
atomGrid.cc:241:    this->xSize = (int)floor((this->xMax-this->xMin)/step)+1;
atomGrid.cc:242:    this->ySize = (int)floor((this->yMax-this->yMin)/step)+1;
atomGrid.cc:243:    this->zSize = (int)floor((this->zMax-this->zMin)/step)+1;
atomGrid.cc:244:    this->grid.resize( this->xSize*this->ySize*this->zSize, false );
atomGrid.cc:249:#define	xIndex(ag,xPos) ((int)(floor(((xPos)-ag->xMin)/ag->stepSize)))
atomGrid.cc:250:#define	yIndex(ag,yPos) ((int)(floor(((yPos)-ag->yMin)/ag->stepSize)))
atomGrid.cc:251:#define	zIndex(ag,zPos) ((int)(floor(((zPos)-ag->zMin)/ag->stepSize)))
atomGrid.cc:252:#define	xIndexBounded(ag,xPos) (MIN(MAX(0,xIndex(ag,xPos)),ag->xSize-1))
atomGrid.cc:253:#define	yIndexBounded(ag,yPos) (MIN(MAX(0,yIndex(ag,yPos)),ag->ySize-1))
atomGrid.cc:254:#define	zIndexBounded(ag,zPos) (MIN(MAX(0,zIndex(ag,zPos)),ag->zSize-1))
atomGrid.cc:257:#define	gridIndex(gd,xi,yi,zi) (gd->xSize*(gd->ySize*(zi)+(yi))+(xi))
atomGrid.cc:260:#define	xPos(gd,xi) (gd->xMin+((xi)*gd->stepSize))
atomGrid.cc:261:#define	yPos(gd,yi) (gd->yMin+((yi)*gd->stepSize))
atomGrid.cc:262:#define	zPos(gd,zi) (gd->zMin+((zi)*gd->stepSize))
atomGrid.cc:279:    xBegin = xIndexBounded(this,pos.getX()-radius-1);
atomGrid.cc:280:    yBegin = yIndexBounded(this,pos.getY()-radius-1);
atomGrid.cc:281:    zBegin = zIndexBounded(this,pos.getZ()-radius-1);
atomGrid.cc:292:	    ip = this->grid.begin()+ gridIndex(this,xBegin,yi,zi);
atomGrid.cc:297:		xp = xp - pos.getX();
atomGrid.cc:298:		yp = yp - pos.getY();
atomGrid.cc:299:		zp = zp - pos.getZ();
atomGrid.cc:338:    this->grid.resize( this->xSize*this->ySize*this->zSize, false );
atomGrid.cc:340:    this->paint(container,addRadius);
atomGrid.cc:355:    this->ballRadius = addRadius;
atomGrid.cc:356:    this->defineMinMaxBox( container,
atomGrid.cc:361:    this->privateBuildGrid( container, addRadius, stepSize);
atomGrid.cc:373:    this->ballRadius = addRadius;
atomGrid.cc:374:    this->defineMinMaxBox( container,
atomGrid.cc:379:    this->privateBuildGrid( container, addRadius, stepSize );
atomGrid.cc:388:    ASSERT(bbox->isDefined());
atomGrid.cc:389:    this->stepSize = stepSize;
atomGrid.cc:390:    this->xMin = bbox->minCorner().getX();
atomGrid.cc:391:    this->yMin = bbox->minCorner().getY();
atomGrid.cc:392:    this->zMin = bbox->minCorner().getZ();
atomGrid.cc:393:    this->xMax = bbox->maxCorner().getX();
atomGrid.cc:394:    this->yMax = bbox->maxCorner().getY();
atomGrid.cc:395:    this->zMax = bbox->maxCorner().getZ();
atomGrid.cc:396:    this->xSize = (int)floor((this->xMax-this->xMin)/stepSize)+1;
atomGrid.cc:397:    this->ySize = (int)floor((this->yMax-this->yMin)/stepSize)+1;
atomGrid.cc:398:    this->zSize = (int)floor((this->zMax-this->zMin)/stepSize)+1;
atomGrid.cc:399:    this->privateBuildGrid( container, addRadius, stepSize );
atomGrid.cc:407:	if ( matter->isOfClass<Atom_O>() )
atomGrid.cc:409:	    Atom_sp a = matter->as<Atom_O>();
atomGrid.cc:410:	    a->modifyFlags( ATOMFLAG_OFF, ON_GRID|ATOM_FIXED );
atomGrid.cc:411:	    double vdw = vdwRadiusForElement(a->getElement());
atomGrid.cc:412:	    bool onGrid = this->paintAtom( a->getPosition(), vdw+pad);
atomGrid.cc:415:		a->modifyFlags( ATOMFLAG_ON, ON_GRID|ATOM_FIXED );
atomGrid.cc:423:		a->modifyFlags( ATOMFLAG_OFF, ON_GRID|ATOM_FIXED );
atomGrid.cc:424:		double vdw = vdwRadiusForElement(a->getElement());
atomGrid.cc:425:		bool onGrid = this->paintAtom( a->getPosition(), vdw+pad);
atomGrid.cc:428:		    a->modifyFlags( ATOMFLAG_ON, ON_GRID|ATOM_FIXED );
atomGrid.cc:443:_lisp->print(BF( "AtomGrid dump" ));
atomGrid.cc:444:_lisp->print(BF("  size= ( %d, %d, %d )") % this->xSize % this->ySize % this->zSize );
atomGrid.cc:445:_lisp->print(BF( "  min=(%lf, %lf, %lf)") % this->xMin % this->yMin % this->zMin );
atomGrid.cc:446:_lisp->print(BF( "  max=(%lf, %lf, %lf)") % this->xMax % this->yMax % this->zMax );
atomGrid.cc:447:_lisp->print(BF( "  ballRadius=%lf") % this->ballRadius );
atomGrid.cc:448:_lisp->print(BF( "  stepSize=%lf") % this->stepSize );
atomGrid.cc:449:_lisp->print(BF( "  grid Elements=%d") % (int)(this->grid.size()) );
atomGrid.cc:452:    for ( uint i=0; i<this->grid.size(); i++ ) {
atomGrid.cc:453:	if ( this->grid[i] ) iOn++;
atomGrid.cc:456:    _lisp->print(BF("  The grid has %d elements on and %d elements off") %	iOn % iOff );
atomGrid.cc:475:    polygon->setSurfaceNormal(vn);
atomGrid.cc:476:    polygon->addVertex(v1);
atomGrid.cc:477:    polygon->addVertex(v2);
atomGrid.cc:478:    polygon->addVertex(v3);
atomGrid.cc:479:    polygon->addVertex(v4);
atomGrid.cc:480:    dl->add(polygon);
atomGrid.cc:482:    dl->add(_lisp->create<addon::GrLine_O>(v1,v2,1));
atomGrid.cc:483:    dl->add(_lisp->create<addon::GrLine_O>(v2,v3,1));
atomGrid.cc:484:    dl->add(_lisp->create<addon::GrLine_O>(v3,v4,1));
atomGrid.cc:485:    dl->add(_lisp->create<addon::GrLine_O>(v4,v1,1));
atomGrid.cc:513:    gsize = this->grid.size();
atomGrid.cc:519:    v1.set(this->xMin, this->yMin, this->zMin );
atomGrid.cc:520:    v2.set(this->xMax, this->yMin, this->zMin );
atomGrid.cc:521:    result->add(O_GrColor::systemColor(_lisp->symbol(_kw_red)));
atomGrid.cc:522:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:523:    v1.set(this->xMin, this->yMin, this->zMin );
atomGrid.cc:524:    v2.set(this->xMin, this->yMax, this->zMin );
atomGrid.cc:525:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:526:    v1.set(this->xMin, this->yMin, this->zMin );
atomGrid.cc:527:    v2.set(this->xMin, this->yMin, this->zMax );
atomGrid.cc:528:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:530:    v1.set(this->xMax, this->yMax, this->zMax );
atomGrid.cc:531:    v2.set(this->xMax, this->yMax, this->zMin );
atomGrid.cc:532:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:533:    v1.set(this->xMax, this->yMax, this->zMax );
atomGrid.cc:534:    v2.set(this->xMin, this->yMax, this->zMax );
atomGrid.cc:535:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:536:    v1.set(this->xMax, this->yMax, this->zMax );
atomGrid.cc:537:    v2.set(this->xMax, this->yMin, this->zMax );
atomGrid.cc:538:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:540:    v1.set(this->xMax, this->yMin, this->zMin );
atomGrid.cc:541:    v2.set(this->xMax, this->yMax, this->zMin );
atomGrid.cc:542:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:543:    v1.set(this->xMax, this->yMin, this->zMin );
atomGrid.cc:544:    v2.set(this->xMax, this->yMin, this->zMax );
atomGrid.cc:545:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:547:    v1.set(this->xMin, this->yMax, this->zMin );
atomGrid.cc:548:    v2.set(this->xMax, this->yMax, this->zMin );
atomGrid.cc:549:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:550:    v1.set(this->xMin, this->yMax, this->zMin );
atomGrid.cc:551:    v2.set(this->xMin, this->yMax, this->zMax );
atomGrid.cc:552:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:554:    v1.set(this->xMin, this->yMin, this->zMax );
atomGrid.cc:555:    v2.set(this->xMax, this->yMin, this->zMax );
atomGrid.cc:556:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:557:    v1.set(this->xMin, this->yMin, this->zMax );
atomGrid.cc:558:    v2.set(this->xMin, this->yMax, this->zMax );
atomGrid.cc:559:    result->add(_lisp->create<addon::GrLine_O>(v1,v2,2));
atomGrid.cc:561:    RPGrColor color = O_GrColor::create(addon::Color_O::systemColor(_lisp->symbol(_kw_magenta)),_lisp);
atomGrid.cc:562:    result->add(color);
atomGrid.cc:563:    halfStep = this->stepSize/2.0;
atomGrid.cc:564:    for ( zi=0; zi!=this->zSize; zi++ ) {
atomGrid.cc:565:	LOG(BF("Rendering a Z-slice: %d") % (zi ) );
atomGrid.cc:566:	for ( yi=0; yi!=this->ySize; yi++ ) {
atomGrid.cc:567:	    for ( xi=0; xi!=this->xSize; xi++ ) {
atomGrid.cc:570:		if ( this->grid[gi] ) {
atomGrid.cc:572:		    gixm = gridIndex(this,xi-1,yi,zi);
atomGrid.cc:574:		    giym = gridIndex(this,xi,yi-1,zi);
atomGrid.cc:576:		    gizm = gridIndex(this,xi,yi,zi-1);
atomGrid.cc:578:		    xmin = xPos(this,xi)-halfStep;
atomGrid.cc:579:		    ymin = yPos(this,yi)-halfStep;
atomGrid.cc:580:		    zmin = zPos(this,zi)-halfStep;
atomGrid.cc:584:		    edge = (gixm>0 )?(!this->grid[gixm]):true;
atomGrid.cc:586:			this->renderSquare( result,
atomGrid.cc:587:						-1.0, 0.0, 0.0,
atomGrid.cc:593:		    edge = (gixp<gsize)?(!this->grid[gixp]):true;
atomGrid.cc:595:			this->renderSquare( result,
atomGrid.cc:602:		    edge = (giym>0)?(!this->grid[giym]):true;
atomGrid.cc:604:			this->renderSquare( result,
atomGrid.cc:605:						0.0, -1.0, 0.0,
atomGrid.cc:611:		    edge = (giyp<gsize)?(!this->grid[giyp]):true;
atomGrid.cc:613:			this->renderSquare( result,
atomGrid.cc:620:		    edge = (gizm>0)?(!this->grid[gizm]):true;
atomGrid.cc:622:			this->renderSquare( result,
atomGrid.cc:623:						0.0, 0.0, -1.0,
atomGrid.cc:629:		    edge = (gizp<gsize)?(!this->grid[gizp]):true;
atomGrid.cc:631:			this->renderSquare( result,
atomGrid.cc:650:    for ( uint i=0; i<this->grid.size(); i++ ) {
atomGrid.cc:651:	this->grid[i] = !this->grid[i];
atomGrid.cc:669:    LOG(BF( "collision test at: %d, %d, %d -->") % xi % yi % zi );
atomGrid.cc:670:    if ( xi<0 || xi>=this->xSize ) goto NOCOLLISION;
atomGrid.cc:671:    if ( yi<0 || yi>=this->ySize ) goto NOCOLLISION;
atomGrid.cc:672:    if ( zi<0 || zi>=this->zSize ) goto NOCOLLISION;
atomGrid.cc:676:    if ( this->grid[ii] ) goto COLLISION;
atomId.cc:16:	ss << "Mol["<<this->_Molecule;
atomId.cc:17:	ss << "]Res["<<this->_Residue;
atomId.cc:18:	ss << "]Atom["<<this->_Atom<<"]";
atomId.cc:53:	ai->_AtomId._Molecule = mol;
atomId.cc:54:	ai->_AtomId._Residue = res;
atomId.cc:55:	ai->_AtomId._Atom = atom;
atomId.cc:63:	node->attribute("Molecule",this->_AtomId._Molecule);
atomId.cc:64:	node->attribute("Residue",this->_AtomId._Residue);
atomId.cc:65:	node->attribute("Atom",this->_AtomId._Atom);
atomIdMap.cc:12:// ----------------------------------------------------------------------
atomIdMap.cc:20:	    .def("lookup-atom",&AtomIdToAtomMap_O::lookupAtom)
atomIdMap.cc:26:	return this->_AtomIdMap[atomId->_AtomId];
atomIdMap.cc:40:        this->Base::archiveBase(node);
atomIdMap.cc:49:        this->Base::initialize();
atomIdMap.cc:55:	this->_AtomIdMap.resize(numMols);
atomIdMap.cc:60:	this->_AtomIdMap.resize(mol,numRes);
atomIdMap.cc:65:	this->_AtomIdMap.resize(mol,res,numAtoms);
atomIdMap.cc:69:	this->_AtomIdMap[atomId] = atom;
atomIndexer.cc:28://    node->attribute("indexAll",this->_IndexAll);
atomIndexer.cc:29:    node->archiveVectorStrings("AtomNames",this->_Names);
atomIndexer.cc:36://    this->_IndexAll = false;
atomIndexer.cc:37:    if ( !this->containsAtomName(name) )
atomIndexer.cc:39:        int id = this->_Names.size();
atomIndexer.cc:40:        this->_Names.push_back(name);
atomIndexer.cc:53:    this->_Names.clear();
atomIndexer.cc:58:	    this->_Names.push_back(*it);
atomIndexer.cc:67:    LOG(BF("Setting from atom names: %s") % sl->asString().c_str()  );
atomIndexer.cc:68:    for ( it = sl->begin(); it!=sl->end(); it++ )
atomIndexer.cc:72:	    this->_Names.push_back(*it);
atomIndexer.cc:79:    LOG(BF("Appending atom names: %s") % sl->__repr__().c_str()  );
atomIndexer.cc:80:    for ( core::Cons_sp cur=sl; cur.notnilp(); cur=cur->cdr() )
atomIndexer.cc:82:        this->_Names.push_back(cur->car<core::Str_O>()->get());
atomIndexer.cc:93://    if ( this->_IndexAll ) return true;
atomIndexer.cc:94:    for ( mi=this->_Names.begin(); mi!=this->_Names.end(); mi++ )
atomIndexer.cc:111:    for ( mi=this->_Names.begin(); mi!=this->_Names.end(); mi++ )
atomIndexer.cc:128:    if ( this->_Names.size() > 0 )
atomIndexer.cc:130:        ss << *(this->_Names.begin());
atomIndexer.cc:131:	for ( mi=this->_Names.begin()+1; mi!=this->_Names.end(); mi++ )
atomIndexer.cc:142:    ss << "( " << this->className() << " " << this->asString() << " )";
atomIndexer.cc:150:    this->_IndexAll = b;
atomIndexer.cc:151:    if ( this->_IndexAll )
atomIndexer.cc:153:        this->_Names.clear();
atomIndexer.cc:171:    node->archiveSymbolMap("atomIndexers",this->_AtomIndexers);
atomIndexer.cc:177:    this->_AtomIndexers.set(nm,ai);
atomIndexer.cc:182:	return core::SymbolSet_O::create_fromKeysOfSymbolMap(this->_AtomIndexers,_lisp);
atomIndexer.cc:187:	return this->_AtomIndexers.contains(nm);
atomIndexer.cc:193:	return this->_AtomIndexers.get(name,_lisp);
atomIndexer.cc:199:	return this->_AtomIndexers.contains(name);
atomIndexer.cc:207:    this->_AtomIndexers.erase(nm);
atomReference.cc:37:	this->Base::initialize();
atomReference.cc:43:	this->Base::archiveBase(node);
atomReference.cc:67:	this->Base::initialize();
atomReference.cc:73:	this->Base::archiveBase(node);
atomReference.cc:74:	node->attribute("atom",this->_AtomAlias);
atomReference.cc:86:	me->_AtomAlias = alias;
atomReference.cc:94:	this->_AtomAlias = translate::from_object<string>::convert(bargs->lookup(ChemPkg,"alias"));
atomReference.cc:103:	if ( this->eq(o) ) return true;
atomReference.cc:104:	if ( this->_AtomAlias == o->as<AtomReference_O>()->_AtomAlias ) return true;
bond.cc:37:	bond->_WeakAtom1 = from;
bond.cc:38:	bond->_WeakAtom2 = to;
bond.cc:39:	bond->setOrder(o);
bond.cc:41:	    % bond->_WeakAtom1.lock()->description()
bond.cc:42:	    % bond->_WeakAtom2.lock()->description() );
bond.cc:49:	this->Base::initialize();
bond.cc:50:	this->order = singleBond;
bond.cc:52:	this->_WeakAtom1 = Atom_O::_nil;
bond.cc:53:	this->_WeakAtom2 = Atom_O::_nil;
bond.cc:60:	this->order = bb.order;
bond.cc:61:	this->_WeakAtom1 = bb._WeakAtom1;
bond.cc:62:	this->_WeakAtom2 = bb._WeakAtom2;
bond.cc:64:	    % this->_WeakAtom1.lock()->description()
bond.cc:65:	    % this->_WeakAtom2.lock()->description() );
bond.cc:71:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:72:	if (this->_WeakAtom1.lock().get()==a.get()) return true;
bond.cc:73:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:74:	if ( this->_WeakAtom2.lock().get()==a.get()) return false;
bond.cc:76:			   % a->__repr__() % this->_WeakAtom1.lock()->__repr__() % this->_WeakAtom2.lock()->__repr__() );
bond.cc:82:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:83:	return this->_WeakAtom1.lock();
bond.cc:88:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:89:	return this->_WeakAtom2.lock();
bond.cc:102:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:103:	this->_WeakAtom1 = this->_WeakAtom1.lock()->getCopyAtom();
bond.cc:104:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:105:	this->_WeakAtom2 = this->_WeakAtom2.lock()->getCopyAtom();
bond.cc:106:	this->_WeakAtom2.lock()->addBond(this->sharedThis<Bond_O>());
bond.cc:115://	Return true if this is an inter-residue bond
bond.cc:121:	Atom_sp a1 = this->_WeakAtom1.lock();
bond.cc:123:	LOG(BF("from atom = %s") % a1->description() );
bond.cc:124:	wfromCont = a1->getResidueContainedBy();
bond.cc:126:	if ( wfromCont.lock()->isNil() )
bond.cc:130:	Atom_sp a2 = this->_WeakAtom2.lock();
bond.cc:132:	wtoCont = a2->getResidueContainedBy();
bond.cc:134:	if ( wtoCont.lock()->isNil() )
bond.cc:156:	{ "", -1 }
bond.cc:171:	LOG(BF("archive direction = %s") % (node->loading()?"loading":"saving") ); //
bond.cc:172:	node->attributeSymbolEnumHiddenConverter("order",this->order,_sym_bondOrderToSymbolConverter);
bond.cc:173:	node->archiveSymbolMapIfDefined("properties",this->_Properties);
bond.cc:175:	if ( !node->loading() )
bond.cc:177:	    LOG(BF("before save this->_WeakAtom1 = %s") % this->_WeakAtom1.lock()->description() );
bond.cc:178:	    LOG(BF("before save this->_WeakAtom2 = %s") % this->_WeakAtom2.lock()->description() );
bond.cc:181:	node->archiveWeakPointer<Atom_O>( "a1", this->_WeakAtom1  );
bond.cc:182:	node->archiveWeakPointer<Atom_O>( "a2", this->_WeakAtom2 );
bond.cc:184:	if ( node->loading() )
bond.cc:186:	    LOG(BF("after load this->_WeakAtom1 = %s") % this->_WeakAtom1.lock()->description() );
bond.cc:187:	    LOG(BF("after load this->_WeakAtom2 = %s") % this->_WeakAtom2.lock()->description() );
bond.cc:206:	LOG(BF("archive direction = %s") % (node->loading()?"loading":"saving") ); //
bond.cc:207:	node->attributeSymbolEnumHiddenConverter("order",this->order,_sym_bondOrderToSymbolConverter);
bond.cc:208:	node->archiveSymbolMapIfDefined("properties",this->_Properties);
bond.cc:210:	if ( !node->loading() )
bond.cc:212:	    LOG(BF("before save this->_WeakAtom1 = %s") % this->_WeakAtom1.lock()->description() );
bond.cc:213:	    LOG(BF("before save this->_WeakAtom2 = %s") % this->_WeakAtom2.lock()->description() );
bond.cc:216:	node->archiveWeakPointer<Atom_O>( "a1", this->_WeakAtom1  );
bond.cc:217:	node->archiveWeakPointer<Atom_O>( "a2", this->_WeakAtom2 );
bond.cc:219:	if ( node->loading() )
bond.cc:221:	    LOG(BF("after load this->_WeakAtom1 = %s") % this->_WeakAtom1.lock()->description() );
bond.cc:222:	    LOG(BF("after load this->_WeakAtom2 = %s") % this->_WeakAtom2.lock()->description() );
bond.cc:236:	ss << "Properties for matter[" << this->__repr__() << "]"<<endl;
bond.cc:237:	for (core::SymbolMap<core::T_O>::const_iterator it=this->_Properties.begin();
bond.cc:238:	     it!=this->_Properties.end(); it++ )
bond.cc:240:	    ss << it->first->__repr__() << "-->" << it->second->__repr__() << endl;
bond.cc:249:	this->_Properties.erase(prop);
bond.cc:254:	this->_Properties.set(prop,val);
bond.cc:259:	this->_Properties.set(prop,_lisp->_boolean(true));
bond.cc:264:	if ( this->_Properties.count(prop) == 0 )
bond.cc:267:	    props << core::StringSet_O::create_fromKeysOfSymbolMap(this->_Properties,_lisp)->asString();
bond.cc:268:	    SIMPLE_ERROR(BF("You asked for an unknown property[%s] for matter[%s@%p] - the available properties are[%s]")
bond.cc:269:			       % prop->__repr__() % this->__repr__() % this % props.str()  );
bond.cc:271:	return this->_Properties.get(prop,_lisp);
bond.cc:276:	if ( this->_Properties.count(prop) == 0 )
bond.cc:280:	return this->_Properties.get(prop,_lisp);
bond.cc:285:	return ( this->_Properties.count(prop) != 0 );
bond.cc:292:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:293:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:294:	if ( atom.get() == this->_WeakAtom1.lock().get() ) return this->_WeakAtom2.lock();
bond.cc:295:	if ( atom.get() == this->_WeakAtom2.lock().get() ) return this->_WeakAtom1.lock();
bond.cc:296:	SIMPLE_ERROR(BF("Illegal getOtherAtom because from atom[%s] is not part of bond: %s") % atom->description() % this->description() );
bond.cc:302:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:303:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:304:	if ( this->_WeakAtom1.lock().get() == a.get() )
bond.cc:306:	    if ( this->_WeakAtom2.lock().get() == b.get() ) return true;
bond.cc:308:	if ( this->_WeakAtom2.lock().get() == a.get() )
bond.cc:310:	    if ( this->_WeakAtom1.lock().get() == b.get() ) return true;
bond.cc:320:	Atom_wp wa1 = this->_WeakAtom1;
bond.cc:322:	ss << wa1.lock()->description();
bond.cc:323:	ss << bondOrderToChar(this->order);
bond.cc:324:	Atom_wp wa2 = this->_WeakAtom2;
bond.cc:326:	ss << wa2.lock()->description();
bond.cc:333:	ASSERTF(from.get()==this->_WeakAtom1.lock().get()||from.get()==this->_WeakAtom2.lock().get(),BF("describeFrom failed because from atom[%s] is not part of bond: %s") % from->description() % this->description() );
bond.cc:336:	ss << from->description();
bond.cc:337:	ss << bondOrderToChar(this->order);
bond.cc:338:	Atom_sp a2 = this->getOtherAtom(from);
bond.cc:339:	ss << a2->description();
bond.cc:348:	ASSERTNOTNULL(this->_WeakAtom1);
bond.cc:349:	ASSERTNOTNULL(this->_WeakAtom2);
bond.cc:350:	if ( this->_WeakAtom1.lock()->isNil() ) return true;
bond.cc:351:	if ( this->_WeakAtom2.lock()->isNil() ) return true;
bond.cc:357:	if ( this->invalid(a) ) {
bond.cc:358:	    SIMPLE_ERROR(boost::format("INVALID %s")%this->description());
bond.cc:367:	Atom_sp fa =  this->_WeakAtom1.lock();
bond.cc:368:	Atom_sp ta = this->_WeakAtom2.lock();
bond.cc:381:	Atom_wp fc = fa->getCopyAtom();
bond.cc:383:	LOG(BF("    new from %s") % fc.lock()->description() );
bond.cc:384:	Atom_wp tc = ta->getCopyAtom();
bond.cc:386:	LOG(BF("    new   to %s") % tc.lock()->description() );
bond.cc:387:	this->_WeakAtom1 = fc;
bond.cc:388:	this->_WeakAtom2 = tc;
bond.cc:393:	Atom_sp a1 = this->_WeakAtom1.lock();
bond.cc:394:	Atom_sp a2 = this->_WeakAtom2.lock();
bond.cc:395:	a1->_addExistingBond(this->sharedThis<Bond_O>());
bond.cc:396:	a2->_addExistingBond(this->sharedThis<Bond_O>());
bond.cc:403:	Atom_sp to = this->getOtherAtom(from);
bond.cc:409:	ConstitutionAtomIndex0N index = fi->second;
bond.cc:410:	ConstitutionBond_sp cb = _lisp->create<ConstitutionBond_O>(this->getOrder(),index);
bond.cc:419:	return bondOrderToString(this->order);
bond.cc:426:	ASSERTNOTNULLP(this->fromAtom,"Bond_O::joinYourAtoms from atom is undefined!");
bond.cc:427:	ASSERTNOTNULLP(this->toAtom,"Bond_O::joinYourAtoms to atom is undefined!");
bond.cc:428:	this->fromAtom.lock()->bondTo(this->toAtom.lock(),this->order);
bond.cc:464:	    return "-unknown-";
bond.cc:491:	    return '-';
bond.cc:523:	this->Base::initialize();
bond.cc:524:	this->_Bonds.clear();
bond.cc:533:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ ) {
bond.cc:534:	    (*bi)->imposeYourself();
bond.cc:543:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ ) {
bond.cc:545:		this->_Bonds.erase(bi);
bond.cc:555:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
bond.cc:557:	    if ( (*bi)->isBondBetween(a,b) )
bond.cc:559:		this->_Bonds.erase(bi);
bond.cc:563:	SIMPLE_ERROR(BF("Could not find bond between %s and %s in bondList: %s") % a->description() % b->description() % this->description() );
bond.cc:570:	this->_Bonds.push_back(b);
bond.cc:579:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
bond.cc:581:	    bl->addBond(*bi);
bond.cc:592:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ ) {
bond.cc:593:	    ss << (*bi)->description() << "," << endl;
bond.cc:604:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ ) {
bond.cc:605:	    ss << (*bi)->describeOther(from) << "," << endl;
bond.cc:616:	node->orderedVector0(this->_Bonds);
bond.cc:628:	if ( node->saving() ) {
bond.cc:629:	    LOG(BF("About to save BondList with %d members") % this->size()  ); //
bond.cc:630:	    for ( ib=this->_Bonds.begin(); ib!=this->_Bonds.end(); ib++ ) {
bond.cc:633:		node->archiveSaveObjectAsChildAssignAutoUniqueId<Bond_O>(*ib);
bond.cc:639:	    this->_Bonds.clear();
bond.cc:642:	    for ( ic=node->begin_Children(); ic!=node->end_Children(); ic++ ) {
bond.cc:643:		(*ic)->archiveLoadObjectDirectly<Bond_O>(b);
bond.cc:645:		this->_Bonds.push_back(b);
bond.cc:664:	en.value(_sym_noBond, _lisp->intern("none"), singleBond );
bond.cc:665:	en.value(_sym_singleBond, _lisp->intern("s"), singleBond );
bond.cc:666:	en.value(_sym_doubleBond, _lisp->intern("d"), doubleBond );
bond.cc:667:	en.value(_sym_tripleBond, _lisp->intern("t"), tripleBond );
bond.cc:668:	en.value(_sym_aromaticBond, _lisp->intern("a"), aromaticBond );
bond.cc:669:	en.value(_sym_hydrogenBond, _lisp->intern("h"), hydrogenBond );
bond.cc:670:	en.value(_sym_virtualBond,_lisp->intern("v"),virtualBond);
bond.cc:671:	en.value(_sym_dashedSingleBond,_lisp->intern("ds"),dashedSingleBond);
bond.cc:672:	en.value(_sym_dashedDoubleBond,_lisp->intern("dd"),dashedDoubleBond);
calculatePosition.cc:16:    this->Base::initialize();
calculatePosition.cc:35:    me->_DistanceAtomName = distanceAtomName;
calculatePosition.cc:36:    me->_AngleAtomName = angleAtomName;
calculatePosition.cc:37:    me->_DihedralAtomName = dihedralAtomName;
calculatePosition.cc:38:    me->_Distance = distance;
calculatePosition.cc:39:    me->_AngleDegrees = angleDegrees;
calculatePosition.cc:40:    me->_DihedralDegrees = dihedralDegrees;
calculatePosition.cc:48:    this->Base::__init__(exec,args,env,lisp);
calculatePosition.cc:49:    this->_DistanceAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"distanceAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:50:    this->_AngleAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"angleAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:51:    this->_DihedralAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"dihedralAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:52:    this->_Distance = env->lookup(lisp->internWithPackageName(ChemPkg,"distance"))->as<core::DoubleFloat_O>()->get();
calculatePosition.cc:53:    this->_AngleDegrees = env->lookup(lisp->internWithPackageName(ChemPkg,"angleDegrees"))->as<core::DoubleFloat_O>()->get();
calculatePosition.cc:54:    this->_DihedralDegrees = env->lookup(lisp->internWithPackageName(ChemPkg,"dihedralDegrees"))->as<core::DoubleFloat_O>()->get();
calculatePosition.cc:62:    this->Base::initialize();
calculatePosition.cc:63:    this->_DistanceAtomName = "";
calculatePosition.cc:64:    this->_AngleAtomName = "";
calculatePosition.cc:65:    this->_DihedralAtomName = "";
calculatePosition.cc:71:    this->Base::archiveBase(node);
calculatePosition.cc:72:    node->attribute("DistanceAtomName",this->_DistanceAtomName);
calculatePosition.cc:73:    node->attribute("AngleAtomName",this->_AngleAtomName);
calculatePosition.cc:74:    node->attribute("DihedralAtomName",this->_DihedralAtomName);
calculatePosition.cc:75:    node->attribute("Distance",this->_Distance);
calculatePosition.cc:76:    node->attribute("AngleDegrees",this->_AngleDegrees);
calculatePosition.cc:77:    node->attribute("DihedralDegrees",this->_DihedralDegrees);
calculatePosition.cc:88:    if ( positionLookup->isOfClass<IterateFragmentCoordinateEntries_O>() )
calculatePosition.cc:90:	IterateFragmentCoordinateEntries_sp it = positionLookup->as<IterateFragmentCoordinateEntries_O>();
calculatePosition.cc:91:	posDistanceAtom = it->positionOfAtomWithName(this->_DistanceAtomName);
calculatePosition.cc:92:	posAngleAtom = it->positionOfAtomWithName(this->_AngleAtomName);
calculatePosition.cc:93:	posDihedralAtom = it->positionOfAtomWithName(this->_DihedralAtomName);
calculatePosition.cc:96:	if ( positionLookup->isOfClass<Residue_O>() )
calculatePosition.cc:98:	Residue_sp res = positionLookup->as<Residue_O>();
calculatePosition.cc:99:	posDistanceAtom = res->positionOfAtomWithName(this->_DistanceAtomName);
calculatePosition.cc:100:	posAngleAtom = res->positionOfAtomWithName(this->_AngleAtomName);
calculatePosition.cc:101:	posDihedralAtom = res->positionOfAtomWithName(this->_DihedralAtomName);
calculatePosition.cc:107:    LOG(BF(" distance(%lf)  distancePoint(%s)") % this->_Distance % posDistanceAtom.asString().c_str()  );
calculatePosition.cc:108:    LOG(BF(" angleDegrees(%lf)  anglePoint(%s)") % this->_AngleDegrees % posAngleAtom.asString().c_str()  );
calculatePosition.cc:109:    LOG(BF(" dihedralDegrees(%lf)  dihedralPoint(%s)") % this->_DihedralDegrees % posDihedralAtom.asString().c_str()  );
calculatePosition.cc:110:    pnt = buildUsingBondAngleDihedral(this->_Distance,posDistanceAtom,
calculatePosition.cc:111:			this->_AngleDegrees*0.0174533,posAngleAtom,
calculatePosition.cc:112:				      this->_DihedralDegrees*0.0174533,posDihedralAtom,_lisp);
calculatePosition.cc:125:    me->_FromAtomName = fromAtomName;
calculatePosition.cc:126:    me->_ToAtomName = toAtomName;
calculatePosition.cc:127:    me->_ExtendDistance = extendDistance;
calculatePosition.cc:135:    this->Base::__init__(exec,args,env,lisp);
calculatePosition.cc:136:    this->_FromAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"fromAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:137:    this->_ToAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"toAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:138:    this->_ExtendDistance = env->lookup(lisp->internWithPackageName(ChemPkg,"extendDistance"))->as<core::DoubleFloat_O>()->get();
calculatePosition.cc:146:    this->Base::initialize();
calculatePosition.cc:147:    this->_FromAtomName = "";
calculatePosition.cc:148:    this->_ToAtomName = "";
calculatePosition.cc:149:    this->_ExtendDistance = 0.0;
calculatePosition.cc:155:    this->Base::archiveBase(node);
calculatePosition.cc:156:    node->attribute("FromAtomName",this->_FromAtomName);
calculatePosition.cc:157:    node->attribute("ToAtomName",this->_ToAtomName);
calculatePosition.cc:158:    node->attribute("ExtendDistance",this->_ExtendDistance);
calculatePosition.cc:174:    if ( positionLookup->isOfClass<IterateFragmentCoordinateEntries_O>() )
calculatePosition.cc:176:	IterateFragmentCoordinateEntries_sp it = positionLookup->as<IterateFragmentCoordinateEntries_O>();
calculatePosition.cc:177:	posFromAtom = it->positionOfAtomWithName(this->_FromAtomName);
calculatePosition.cc:178:	posToAtom = it->positionOfAtomWithName(this->_ToAtomName);
calculatePosition.cc:179:	LOG(BF("Got atom positions from IterateFragmentCoordinateEntries with names (%s)-(%s)") % this->_FromAtomName.c_str() % this->_ToAtomName.c_str()  );
calculatePosition.cc:180:    } else if ( positionLookup->isOfClass<Residue_O>() )
calculatePosition.cc:182:	Residue_sp res = positionLookup->as<Residue_O>();
calculatePosition.cc:183:	posFromAtom = res->positionOfAtomWithName(this->_FromAtomName);
calculatePosition.cc:184:	posToAtom = res->positionOfAtomWithName(this->_ToAtomName);
calculatePosition.cc:185:	LOG(BF("Got atom positions from Residue with names (%s)-(%s)") % this->_FromAtomName.c_str() % this->_ToAtomName.c_str()  );
calculatePosition.cc:191:    LOG(BF(" fromAtom(%s)   -  toAtom(%s)") % posFromAtom.asString().c_str() % posToAtom.asString().c_str()  );
calculatePosition.cc:192:    LOG(BF(" extendDistance(%lf) ") % this->_ExtendDistance  );
calculatePosition.cc:201:    pnt = posToAtom.add(dir.multiplyByScalar(this->_ExtendDistance));
calculatePosition.cc:215:    me->_OriginAtomName = originAtomName;
calculatePosition.cc:216:    me->_ToAtomName = toAtomName;
calculatePosition.cc:217:    me->_ExtendDistance = extendDistance;
calculatePosition.cc:225:    this->Base::__init__(exec,args,env,lisp);
calculatePosition.cc:226:    this->_OriginAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"originAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:227:    this->_ToAtomName = env->lookup(lisp->internWithPackageName(ChemPkg,"toAtomName"))->as<core::Str_O>()->get();
calculatePosition.cc:228:    this->_ExtendDistance = env->lookup(lisp->internWithPackageName(ChemPkg,"extendDistance"))->as<core::DoubleFloat_O>()->get();
calculatePosition.cc:236:    this->Base::initialize();
calculatePosition.cc:237:    this->_OriginAtomName = "";
calculatePosition.cc:238:    this->_ToAtomName = "";
calculatePosition.cc:239:    this->_ExtendDistance = 0.0;
calculatePosition.cc:245:    this->Base::archiveBase(node);
calculatePosition.cc:246:    node->attribute("OriginAtomName",this->_OriginAtomName);
calculatePosition.cc:247:    node->attribute("ToAtomName",this->_ToAtomName);
calculatePosition.cc:248:    node->attribute("ExtendDistance",this->_ExtendDistance);
calculatePosition.cc:268:    if ( positionLookup->isOfClass<IterateFragmentCoordinateEntries_O>() )
calculatePosition.cc:270:	IterateFragmentCoordinateEntries_sp it = positionLookup->as<IterateFragmentCoordinateEntries_O>();
calculatePosition.cc:272:	posToAtom = it->positionOfAtomWithName(this->_ToAtomName);
calculatePosition.cc:273:	LOG(BF("Got atom positions from IterateFragmentCoordinateEntries with names (%s)-(%s)") % this->_OriginAtomName.c_str() % this->_ToAtomName.c_str()  );
calculatePosition.cc:274:    } else if ( positionLookup->isOfClass<Residue_O>() )
calculatePosition.cc:276:	Residue_sp res = positionLookup->as<Residue_O>();
calculatePosition.cc:277:	posOriginAtom = res->positionOfAtomWithName(this->_OriginAtomName);
calculatePosition.cc:278:	posToAtom = res->positionOfAtomWithName(this->_ToAtomName);
calculatePosition.cc:279:	LOG(BF("Got atom positions from Residue with names (%s)-(%s)") % this->_OriginAtomName.c_str() % this->_ToAtomName.c_str()  );
calculatePosition.cc:285:    LOG(BF(" originAtom(%s)   -  toAtom(%s)") % posOriginAtom.asString().c_str() % posToAtom.asString().c_str()  );
calculatePosition.cc:286:    LOG(BF(" extendDistance(%lf) ") % this->_ExtendDistance  );
calculatePosition.cc:295:    pnt = posToAtom.add(dir.multiplyByScalar(this->_ExtendDistance));
candoDatabase.cc:59:	this->Base::initialize();
candoDatabase.cc:60:	this->_Entities.clear();
candoDatabase.cc:61:	LOG(BF("initialized _Entities@%p") % &(this->_Entities)  );
candoDatabase.cc:62://    AllCandoDatabases.append(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:69:	for ( Entities::const_iterator it=this->_Entities.begin();
candoDatabase.cc:70:	      it!=this->_Entities.end(); it++ )
candoDatabase.cc:72://	    if ( it->second->isAssignableToByClassSID(classSID) )
candoDatabase.cc:73:	    if ( it->second->isAInstanceOf(mc) )
candoDatabase.cc:75:		result = _lisp->create<core::Cons_O>(it->second,result);
candoDatabase.cc:84:	Entities::const_iterator it = this->_Entities.find(name);
candoDatabase.cc:85:	if ( it == this->_Entities.end() ) return false;
candoDatabase.cc:86:	if ( it->second->isAInstanceOf(mc) ) return true;
candoDatabase.cc:92:	Entities::iterator it = this->_Entities.find(name);
candoDatabase.cc:93:	if ( it == this->_Entities.end() ) return false;
candoDatabase.cc:94:	if ( it->second->_class() == aclass) return true;
candoDatabase.cc:103:	return this->entitiesSubClassOfAsCons(af_findClass(Constitution_O::static_classSymbol()));
candoDatabase.cc:109:	return this->recognizesEntitySubClassOf(name,af_findClass(Stereoisomer_O::static_classSymbol()));
candoDatabase.cc:115:	this->_Entities.set(entity->getName(),entity);
candoDatabase.cc:116:	if ( entity->isAssignableTo<Constitution_O>() )
candoDatabase.cc:118:	    entity->as<Constitution_O>()->addStereoisomersToCandoDatabase(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:126:	return this->entitiesSubClassOfAsCons(af_findClass(RepresentedEntityNameSet_O::static_classSymbol()));
candoDatabase.cc:137:	return this->recognizesEntityOfClass(name,af_findClass(RepresentedEntityNameSet_O::static_classSymbol()));
candoDatabase.cc:143:	if ( this->_Entities.count(name) == 0 ) return false;
candoDatabase.cc:144:	Entity_sp entity = this->_Entities.get(name,_lisp);
candoDatabase.cc:145:	return entity->isAssignableTo<MonomerPack_O>();
candoDatabase.cc:158:	    return this->constitutionForNameOrPdb(name);
candoDatabase.cc:162:	    return this->getEntity(name);
candoDatabase.cc:166:	    return this->getFrameRecognizer(name);
candoDatabase.cc:168:	SIMPLE_ERROR(BF("Unknown CandoDatabase Resource("+resource+"/"+name->__repr__()+")"));
candoDatabase.cc:175:	this->_frameRecognizers.set(rec->getRecognizerName(),rec);
candoDatabase.cc:182:	rec = this->_frameRecognizers.contains(nm);
candoDatabase.cc:193:	if ( ref->getSelector() == "Constitution" )
candoDatabase.cc:195:	    return this->_Constitutions.getDefaultNil(ref->getName(),_lisp);
candoDatabase.cc:197:	if ( ref->getSelector() == "FrameRecognizer" )
candoDatabase.cc:199:	    return this->getFrameRecognizer(ref->getName());
candoDatabase.cc:201:	SIMPLE_ERROR(BF("Unknown ObjRef selector: "+ref->getSelector() ));
candoDatabase.cc:209:	return this->recognizesEntityOfClass(nm,af_findClass(EntityNameSet_O::static_classSymbol()));
candoDatabase.cc:214:	return this->getEntityOfClass(nm,af_findClass(EntityNameSet_O::static_classSymbol()))->as<EntityNameSet_O>();
candoDatabase.cc:221:	return this->getEntityOfClass(nm,af_findClass(RepresentedEntityNameSet_O::static_classSymbol()))->as<RepresentedEntityNameSet_O>();
candoDatabase.cc:228:	return this->_Entities.count(nm)>0;
candoDatabase.cc:233:	ASSERTF(this->_Entities.contains(nm),
candoDatabase.cc:234:		BF("CandoDatabase does not contain entity[%s] - available entities: %s")
candoDatabase.cc:235:		% nm->__repr__()
candoDatabase.cc:236:		% core::StringSet_O::create_fromKeysOfSymbolMap(this->_Entities,_lisp)->asString() );
candoDatabase.cc:237:	return this->_Entities.get(nm,_lisp);
candoDatabase.cc:243:	ASSERTF(this->_Entities.contains(nm),
candoDatabase.cc:244:		BF("CandoDatabase does not contain entity[%s] - available entities: %s")
candoDatabase.cc:245:		% nm->__repr__()
candoDatabase.cc:246:		% core::StringSet_O::create_fromKeysOfSymbolMap(this->_Entities,_lisp)->asString() );
candoDatabase.cc:247:	Entity_sp entity = this->_Entities.get(nm,_lisp);
candoDatabase.cc:248:	if ( entity->_class() != mc )
candoDatabase.cc:251:			       % nm->__repr__() % mc->className() % entity->className() );
candoDatabase.cc:258:	Entity_sp entity = this->getEntity(nm);
candoDatabase.cc:259:	return entity->expandedNameSet();
candoDatabase.cc:264:	core::SymbolSet_sp names = _lisp->create<core::SymbolSet_O>();
candoDatabase.cc:265:	for ( core::SymbolSet_O::const_iterator it=nm->begin(); it!= nm->end(); it++ )
candoDatabase.cc:267:	    Entity_sp entity = this->getEntity(*it);
candoDatabase.cc:268:	    names->insertSymbolSet(entity->expandedNameSet());
candoDatabase.cc:277:	LOG(BF("looking for(%s)") % nm->__repr__()  );
candoDatabase.cc:279:	if ( this->recognizesEntityNameSetName(nm) )
candoDatabase.cc:282:	    group = this->getEntityNameSet(nm);
candoDatabase.cc:283:	    return group->isFinalized();
candoDatabase.cc:298:	if ( this->isNil() )
candoDatabase.cc:305:	if ( !this->_Entities.contains(nm) )
candoDatabase.cc:307:	    LOG(BF("The namespace contains %d names: ") % this->_Entities.size()  );
candoDatabase.cc:308://        for ( core::StringMap<CandoDatabase_ODependent>::iterator it=this->_Entities.begin();
candoDatabase.cc:309:	    for ( core::SymbolMap<Entity_O>::iterator it=this->_Entities.begin();
candoDatabase.cc:310:		  it!=this->_Entities.end();
candoDatabase.cc:313:		LOG(BF("Namespace contains name: %s") % it->first->__repr__() );
candoDatabase.cc:317://    ASSERTP(this->_Entities.contains(nm),"CandoDatabase Environment does not contain: "+nm->__repr__());
candoDatabase.cc:318:	if ( this->_Entities.contains(nm) )
candoDatabase.cc:320:	    obj = this->_Entities.get(nm,_lisp);
candoDatabase.cc:321:	    names = obj->expandedNameSet();
candoDatabase.cc:335:	LOG(BF("Looking for name(%s)") % nm->__repr__()  );
candoDatabase.cc:336:	ASSERT(this->recognizesEntityName(nm));
candoDatabase.cc:337:	obj = this->getEntity(nm);
candoDatabase.cc:338:	ll = obj->expandedRepresentativeList();
candoDatabase.cc:347:	if ( !this->recognizesMonomerName(nm) )
candoDatabase.cc:348://    ASSERTNOTNULL(this->_Names);
candoDatabase.cc:349://    ASSERTvalue(this->_Entities.contains(nm), nm); // REMOVE
candoDatabase.cc:350:	if ( !this->_Entities.contains(nm) ) return false;
candoDatabase.cc:352:	obj = this->_Entities.get(nm,_lisp);
candoDatabase.cc:353:	if ( obj->isTerminalName() ) return true;
candoDatabase.cc:362:	this->Base::archiveBase(node);
candoDatabase.cc:363:	node->attribute("name",this->_Name);
candoDatabase.cc:364:	node->attributeIfNotDefault<string>("dateCreated",this->_DateCreated,"");
candoDatabase.cc:365:	node->attributeIfNotDefault<string>("dateUpdated",this->_DateUpdated,"");
candoDatabase.cc:366:	node->archiveSymbolMap( "entities", this->_Entities);
candoDatabase.cc:367:	node->archiveSymbolMap("frameRecognizers",this->_frameRecognizers);
candoDatabase.cc:368://	node->archiveMapOfObjectsSubClassOf( this->_MonomerCoordinates );
candoDatabase.cc:369:	node->needsFinalization();
candoDatabase.cc:378:	ASSERTP(this->_Entities.contains(name),"Could not find: "+name->__repr__()+" in Environment");
candoDatabase.cc:379:	obj = this->_Entities.get(name,_lisp);
candoDatabase.cc:380:	ASSERTP(obj->hasConstitution(), "The name: "+name->__repr__()+" is not part of a Constitution" );
candoDatabase.cc:381:	return obj->constitution();
candoDatabase.cc:387:	con = this->constitutionForNameOrPdb(name);
candoDatabase.cc:388:	return con->getName();
candoDatabase.cc:394:	ASSERTP(this->_Entities.contains(name), "Could not find name("+name->__repr__()+") in Environment");
candoDatabase.cc:395:	dep = this->_Entities.get(name,_lisp);
candoDatabase.cc:396:	ASSERTP(dep->isTerminalName(), "Asked for MonomerName of non-terminal name("+name->__repr__()+")");
candoDatabase.cc:397:	return dep->getName();
candoDatabase.cc:404:	ASSERTP(this->_Entities.contains(name), "Could not find name("+name->__repr__()+") in Environment");
candoDatabase.cc:405:	dep = this->_Entities.get(name,_lisp);
candoDatabase.cc:406:	ASSERTP(dep->isTerminalName(), "Asked for MonomerName of non-terminal name("+name->__repr__()+")");
candoDatabase.cc:408:	return si->getPdb();
candoDatabase.cc:427:	for ( susi=this->_Constitutions.begin();
candoDatabase.cc:428:	      susi!=this->_Constitutions.end(); susi++ ) {
candoDatabase.cc:429:	    monomers = susi->second->getMonomerNamesAsSymbolSet();
candoDatabase.cc:430:	    names->insertSymbolSet(monomers);
candoDatabase.cc:449:	for ( susi=this->_Constitutions.begin();
candoDatabase.cc:450:	      susi!=this->_Constitutions.end(); susi++ )
candoDatabase.cc:452:	    monomers = susi->second->getMonomerNamesAsStringList();
candoDatabase.cc:453:	    names->appendStringList(monomers);
candoDatabase.cc:467://    sum->setCandoDatabase(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:468://    this->_Names->fillFromConstitution(sum);
candoDatabase.cc:469://    sum->setCandoDatabase(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:470:	LOG(BF("Adding constitution(%s)") % sum->getName() );
candoDatabase.cc:471:	this->_Constitutions.set(sum->getName(),sum);
candoDatabase.cc:472:	LOG(BF("CandoDatabase_Entities_add(%s) a Constitution") % (sum)->getName().c_str()  );
candoDatabase.cc:473:	this->_Entities.addUnique((sum)->getName(), sum, _lisp);
candoDatabase.cc:475:	for ( si=(sum)->begin_Stereoisomers(); si!=(sum)->end_Stereoisomers(); si++ )
candoDatabase.cc:477:	    LOG(BF("CandoDatabase_Entities_add(%s) a MonomerName") % (*si)->getName().c_str()  );
candoDatabase.cc:478:	    if ( (*si)->getName() == "" )
candoDatabase.cc:480:		SIMPLE_ERROR(BF("While adding constitution(%s) a stereoisomer had a blank name!!") % sum->getName() );
candoDatabase.cc:482:	    this->_Entities.addUnique((*si)->getName(), (*si), _lisp );
candoDatabase.cc:483:	    LOG(BF("CandoDatabase_Entities_add(%s) a PdbName") % (*si)->getPdb().c_str()  );
candoDatabase.cc:484:	    if ( (*si)->getPdb() == "" )
candoDatabase.cc:486:		SIMPLE_ERROR(BF("While adding constitution(%s) a stereoisomer had a blank pdb name!!") % sum->getName() );
candoDatabase.cc:488:	    this->_Entities.addUnique((*si)->getPdb(), (*si), _lisp );
candoDatabase.cc:500:	LOG(BF("Adding couplingRule with name=%s to CandoDatabase") % (rule->getName().c_str() ) );
candoDatabase.cc:501:	this->couplingMap.insert(make_pair(rule->getName(),rule));
candoDatabase.cc:502:	this->couplings.push_back(rule);
candoDatabase.cc:512:	LOG(BF("Adding fragment with name=%s to CandoDatabase") % (frag->getName().c_str() ) );
candoDatabase.cc:513:	frag->setGlobal(true);
candoDatabase.cc:514:	if ( this->_CoreFragmentMap.count(frag->getName()) != 0 ) {
candoDatabase.cc:515:	    SIMPLE_ERROR(BF("The global fragment: ", frag->getName()," has already been defined"));
candoDatabase.cc:517:	this->_CoreFragmentMap[frag->getName()] = frag;
candoDatabase.cc:522:	if ( this->_CoreFragmentMap.count(nm) == 0 ) {
candoDatabase.cc:525:	return this->_CoreFragmentMap[nm];
candoDatabase.cc:533:	LOG(BF("Adding fragment with name=%s to CandoDatabase") % (frag->getName().c_str() ) );
candoDatabase.cc:534:	frag->setGlobal(true);
candoDatabase.cc:535:	if ( this->_FinishFragmentMap.count(frag->getName()) != 0 ) {
candoDatabase.cc:536:	    SIMPLE_ERROR(BF("The global fragment: ", frag->getName()," has already been defined"));
candoDatabase.cc:538:	this->_FinishFragmentMap[frag->getName()] = frag;
candoDatabase.cc:543:	if ( this->_FinishFragmentMap.count(nm) == 0 ) {
candoDatabase.cc:546:	return this->_FinishFragmentMap[nm];
candoDatabase.cc:554:	if ( this->recognizesEntityNameSetName(group->getName()) ) {
candoDatabase.cc:555:	    SIMPLE_ERROR(boost::format("You tried to create a group with a name that is already used: %s") % group->getName() );
candoDatabase.cc:557:	this->_SystemRepresentedEntityNameSets.set(group->getName(),group);
candoDatabase.cc:562:	this->_Entities.set(group->getName(),group);
candoDatabase.cc:563:	this->_UserMonomerPacks->set(group->getName(),group);
candoDatabase.cc:564:	this->_WeakLastUserMonomerPackToChange = group;
candoDatabase.cc:577:	names->clear();
candoDatabase.cc:578:	for ( mi=this->begin_Constitutions();
candoDatabase.cc:579:	      mi!=this->end_Constitutions(); mi++ ) {
candoDatabase.cc:581:	    for ( pi=cc->begin_Plugs(); pi!=cc->end_Plugs(); pi++ )
candoDatabase.cc:583:		couplingName = DirectionalCoupling_O::couplingName((*pi)->getName(), _lisp);
candoDatabase.cc:584:		LOG(BF("Adding couplingName: %s") % couplingName->__repr__() );
candoDatabase.cc:585:		names->insert(couplingName->__repr__());
candoDatabase.cc:603:// ---------------------------------------------------------------------
candoDatabase.cc:604:// ---------------------------------------------------------------------
candoDatabase.cc:605:// ---------------------------------------------------------------------
candoDatabase.cc:621:	context = mc->getContext();
candoDatabase.cc:622://    _lisp->print(BF("%s %u addMonomerCoordinates context:\n%s") % __FILE__% __LINE__ % context->asXmlString().c_str() );
candoDatabase.cc:623:	allContexts = context->getAllSpecificContexts();
candoDatabase.cc:624:	LOG(BF("There are %u specific contexts") % (allContexts->size() ) );
candoDatabase.cc:625://    _lisp->print(BF("%s %u There are %u specific contexts") % __FILE__% __LINE__ % allContexts->size() );
candoDatabase.cc:627:	for ( si=allContexts->begin(); si!=allContexts->end(); si++ )
candoDatabase.cc:629://        _lisp->print(BF("    %s %u Looking at specific contexts: %s") % __FILE__% __LINE__ % si->first.c_str() );
candoDatabase.cc:630:	    if ( si->second->allMonomersInDatabase(this->sharedThis<CandoDatabase_O>()) )
candoDatabase.cc:632://	    _lisp->print(BF("      %s %u  Adding it") % __FILE__ % __LINE__ );
candoDatabase.cc:633:		LOG(BF("Adding context: %s") % (si->first).c_str()  );
candoDatabase.cc:634:		this->_MonomerCoordinates.set(si->first,mc);
candoDatabase.cc:638://	    _lisp->print(BF("      %s %u  Ignoring it") % __FILE__ % __LINE__ );
candoDatabase.cc:653:	for ( it=this->begin_MonomerCoordinates(); it!=this->end_MonomerCoordinates(); it++ )
candoDatabase.cc:655:	    unique.insert(it->second);
candoDatabase.cc:660:	    cur->setCdr(one);
candoDatabase.cc:663:	return first->cdr();
candoDatabase.cc:672:	for ( it=this->begin_MonomerCoordinates(); it!=this->end_MonomerCoordinates(); it++ )
candoDatabase.cc:674:	    core::Cons_sp one = core::Cons_O::create(core::Str_O::create(it->first,_lisp),core::Cons_O::_nil);
candoDatabase.cc:675:	    cur->setCdr(one);
candoDatabase.cc:678:	return first->cdr();
candoDatabase.cc:686:	return this->_MonomerCoordinates.contains(key);
candoDatabase.cc:691:	if ( this->_MonomerCoordinates.contains(key) )
candoDatabase.cc:693:	    return this->_MonomerCoordinates.get(key);
candoDatabase.cc:702:	key = context->getKey();
candoDatabase.cc:703:	if ( this->_MonomerCoordinates.contains(key) )
candoDatabase.cc:705:	    return this->_MonomerCoordinates.get(key);
candoDatabase.cc:714:	key = context->getKey();
candoDatabase.cc:716:	foundIt = this->_MonomerCoordinates.contains(key);
candoDatabase.cc:726:	xml->put("candoDatabase",this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:727:	xml->saveAs(fn);
candoDatabase.cc:733:	SpecificContextSet_sp necessary = _lisp->create<SpecificContextSet_O>();
candoDatabase.cc:736:	    Alchemist_sp alchemist = alchemists->car<Alchemist_O>();
candoDatabase.cc:737:	    SpecificContextSet_sp one = alchemist->allSpecificMonomerContexts();
candoDatabase.cc:738:	    necessary->merge(one);
candoDatabase.cc:739:	    alchemists = alchemists->cdr();
candoDatabase.cc:741://    SpecificContextSet_sp necessary = scorer->allSpecificMonomerContexts();
candoDatabase.cc:742:	SpecificContextSet_sp available = this->allSpecificMonomerContexts();
candoDatabase.cc:743:	LOG(BF("There are %d necessary MonomerContexts") % necessary->size() );
candoDatabase.cc:744:	LOG(BF("There are %d available MonomerContexts") % available->size() );
candoDatabase.cc:745:	available->remove(necessary);
candoDatabase.cc:746:	LOG(BF("After removing necessary there are %d useless MonomerContexts") % available->size() );
candoDatabase.cc:748:	for ( it=available->begin(); it!=available->end(); it++ )
candoDatabase.cc:750:	    this->_MonomerCoordinates.remove(it->second->asString());
candoDatabase.cc:758:	available = this->allSpecificMonomerContexts();
candoDatabase.cc:759:	LOG(BF("Now there are %d available MonomerContexts") % available->size() );
candoDatabase.cc:760:	necessary->remove(available);
candoDatabase.cc:761:	LOG(BF("After removing available MonomerContexts from the necessary ones ther are %d missing") % necessary->size() );
candoDatabase.cc:762:	if ( necessary->size() > 0 )
candoDatabase.cc:769:	    for ( SpecificContextSet_O::iterator mt =necessary->begin(); mt!=necessary->end(); mt++ )
candoDatabase.cc:771:		serr << "  missing: " << (mt->second)->asString() << endl;
candoDatabase.cc:773:	    serr << "Total missing MonomerContexts: " << necessary->size() << endl;
candoDatabase.cc:784:	for ( mi=this->_MonomerCoordinates.begin(); mi!=this->_MonomerCoordinates.end(); mi++ )
candoDatabase.cc:786:	    uniqueMonomerCoordinates.insert(mi->second);
candoDatabase.cc:791:	    SpecificContextSet_sp one = (*si)->getContext()->getAllSpecificContexts();
candoDatabase.cc:792:	    all->merge(one);
candoDatabase.cc:805:	me->_Name = name;
candoDatabase.cc:806:	me->_frameRecognizers.clear();
candoDatabase.cc:807:	for ( core::Cons_sp cur = frameRecognizers; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:809:	    FrameRecognizer_sp fr = cur->car<FrameRecognizer_O>();
candoDatabase.cc:810:	    core::Symbol_sp name = fr->getRecognizerName();
candoDatabase.cc:811:	    me->_frameRecognizers.set(name,fr);
candoDatabase.cc:813://	    fr->setOwner(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:818:	me->_SystemRepresentedEntityNameSets.clear();
candoDatabase.cc:819:	for ( core::Cons_sp cur = monomerPacks; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:821:	    RepresentedEntityNameSet_sp group = cur->car<RepresentedEntityNameSet_O>();
candoDatabase.cc:822:	    me->_SystemRepresentedEntityNameSets.set(group->getName(),group);
candoDatabase.cc:826:	for ( core::Cons_sp cur = constitutions; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:828:	    Constitution_sp constitution = cur->car<Constitution_O>();
candoDatabase.cc:829:	    me->addEntity(constitution);
candoDatabase.cc:838:	this->_Name = translate::from_object<string>::convert(env->lookup(Package(),"name"));
candoDatabase.cc:839:	core::Cons_sp frameRecognizers = translate::from_object<core::Cons_O>::convert(env->lookup(Package(),"frameRecognizers"));
candoDatabase.cc:840:	this->_frameRecognizers.clear();
candoDatabase.cc:841:	for ( core::Cons_sp cur = frameRecognizers; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:843:	    FrameRecognizer_sp fr = cur->car<FrameRecognizer_O>();
candoDatabase.cc:844:	    core::Symbol_sp name = fr->getRecognizerName();
candoDatabase.cc:845:	    this->_frameRecognizers.set(name,fr);
candoDatabase.cc:846:	    fr->setOwner(this->sharedThis<CandoDatabase_O>());
candoDatabase.cc:850:	core::Cons_sp monomerPacks = translate::from_object<core::Cons_O>::convert(env->lookup(Package(),"representedEntityNameSets"));
candoDatabase.cc:851:	this->_SystemRepresentedEntityNameSets.clear();
candoDatabase.cc:852:	for ( core::Cons_sp cur = monomerPacks; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:854:	    RepresentedEntityNameSet_sp group = cur->car<RepresentedEntityNameSet_O>();
candoDatabase.cc:855:	    this->_SystemRepresentedEntityNameSets.set(group->getName(),group);
candoDatabase.cc:859:	core::Cons_sp constitutions =  translate::from_object<core::Cons_O>::convert(env->lookup(Pkg(),"constitutions"));
candoDatabase.cc:860:	for ( core::Cons_sp cur = constitutions; cur.notnilp(); cur = cur->cdr() )
candoDatabase.cc:862:	    Constitution_sp constitution = cur->car<Constitution_O>();
candoDatabase.cc:863:	    this->addEntity(constitution);
candoDatabaseDependent.cc:20:    this->Base::initialize();
candoDatabaseDependent.cc:37:    this->Base::archiveBase(node);
candoDatabaseDependent.cc:38:    node->needsFinalization();
candoDatabaseDependent.cc:48:    if ( !this->Base::loadFinalize(node) ) return false;
candoDatabaseDependent.cc:66:    core::Lisp_sp env = db->getEnvironment();
candoDatabaseDependent.cc:67:    this->setEnvironment(env);
candoDatabaseDependent.cc:72:    core::Lisp_sp env = this->getEnvironment();
candoDatabaseDependent.cc:73:    return env->hasCandoDatabase();
candoDatabaseDependent.cc:80:    core::Lisp_sp env = this->getEnvironment();
candoDatabaseReference.cc:23:    ref->_Reference = core::ObjRef_O::create(e,link);
candoDatabaseReference.cc:30:    this->Base::initialize();
candoDatabaseReference.cc:31:    this->_Reference = core::ObjRef_O::_nil;
candoDatabaseReference.cc:37:    this->Base::archiveBase(node);
candoDatabaseReference.cc:38:    if ( node->loading() )
candoDatabaseReference.cc:41:	node->attribute<string>("ref",refStr);
candoDatabaseReference.cc:42:	this->_Reference = core::ObjRef_O::create(_liO,,refStr);
candoDatabaseReference.cc:47:	node->attribute<string>("ref",refStr);
candoDatabaseReference.cc:56:    if ( this->isNil() )
candoDatabaseReference.cc:62:    core::T_sp res = this->_Reference->relativeTo(obj);
candoScript.cc:54:    this->Base::archiveBase(node);
candoScript.cc:55:    node->attribute("_MonomerId",this->_MonomerId);
candoScript.cc:56:    node->attribute("_GroupName",this->_GroupName);
candoScript.cc:57:    node->archiveObjectIfDefined("_MonomerAliases",this->_MonomerAliases);
candoScript.cc:58:    node->attributeIfNotDefault<string>("_Comment",this->_Comment,"");
candoScript.cc:73:    _sym_candoDatabase->defparameter(bdb);
candoScript.cc:84:    xml->setVerbosity(verbosity);
candoScript.cc:85:    xml->open(fileName);
candoScript.cc:86:    if ( xml->contains("candoDatabase") )
candoScript.cc:88:	core::T_sp obj = xml->get("candoDatabase");
candoScript.cc:89:	if (!obj->isOfClass<CandoDatabase_O>() )
candoScript.cc:93:        bdb = obj->as<CandoDatabase_O>();
candoScript.cc:94:    } else if ( xml->contains("only" ) )
candoScript.cc:96:	core::T_sp obj = xml->get("only");
candoScript.cc:97:	if (!obj->isOfClass<CandoDatabase_O>() )
candoScript.cc:101:        bdb = obj->as<CandoDatabase_O>();
candoScript.cc:116:    mon->setId(this->_MonomerId);
candoScript.cc:117:    mon->setGroupName(this->_GroupName);
candoScript.cc:118:    mon->setAliasesFromCons(this->_MonomerAliases);
candoScript.cc:127:    this->Base::archiveBase(node);
candoScript.cc:128:    node->attribute("_Monomer1Id",this->_Monomer1Id);
candoScript.cc:129:    node->attribute("_Coupling",this->_Coupling);
candoScript.cc:130:    node->archiveObject("_Monomer2",this->_Monomer2);
candoScript.cc:138:    return this->_Monomer2->createMonomer(bdb);
candoScript.cc:167:	uint verbosity = overbosity->get();
candoScript.cc:168:	LOG(BF("Opening file(%s)") % path->asString() );
candoScript.cc:169:	loadCandoDatabase(path->asString(),verbosity,_lisp);
candoScript.cc:180:- otherwise it loads the standard database.
candoScript.cc:193:	uint verbosity = overbosity->get();
candoScript.cc:195:	if ( loadSeed->isTrue() )
candoScript.cc:197:	    name << "seed_" << path->asString() << ".cxml";
candoScript.cc:200:	    name << "database_" << path->asString() << ".cxml";
candoScript.cc:202:	boost_filesystem::path filePath  = _lisp->bundle().getDatabasesDir() / name.str();
candoScript.cc:225:    boost_filesystem::path filePath  = _lisp->bundle().getDatabasesDir() / pathName->asString();
candoScript.cc:241:    cdb = args->car<CandoDatabase_O>();
candoScript.cc:261:    if ( bdb->isNil() )
candoScript.cc:265:    part = args->car<core::Str_O>()->get();
candoScript.cc:268:    for ( mit=bdb->begin_MonomerCoordinates_keyValue();
candoScript.cc:269:    		mit != bdb->end_MonomerCoordinates_keyValue(); mit++ )
candoScript.cc:271:	MonomerContext_sp context = mit->second->getContext();
candoScript.cc:272:	core::StringSet_sp allKeys = context->getAllSpecificKeys();
candoScript.cc:276:	for ( sit=allKeys->begin(); sit!=allKeys->end(); sit++ )
candoScript.cc:286:	    lisp->print(BF( "%s") % mit->second->getComment().c_str() );
candoScript.cc:287:	    lisp->print(BF("     Found %d times first: %s") %times % firstFind.c_str() );
candoScript.cc:308:    Plug_sp p = environ->lookup(ChemPkg,"plug")->as<Plug_O>();
candoScript.cc:324:    core::Cons_sp cur = bdb->constitutionsAsCons();
candoScript.cc:325:    for ( ; cur.notnilp(); cur = cur->cdr() )
candoScript.cc:327:	Constitution_sp con = core::oCar(cur)->as<Constitution_O>();
candoScript.cc:328:	string stereoisomers = con->getMonomerNamesAsStringList()->asString();
candoScript.cc:329:	lisp->print(BF(" Constitution: %12s -- %s") % con->getName()->__repr__() % stereoisomers );
candoScript.cc:358:    string virtualAtomName = kargs->getStringAndRemove("name");
candoScript.cc:359:    string constitutionName = kargs->getStringAndRemove("constitutionName");
candoScript.cc:360:    string fragmentName = kargs->getStringAndRemoveOrDefault("fragmentName","");
candoScript.cc:361:    CalculatePosition_sp calcPos= kargs->getAndRemove("position")->as<CalculatePosition_O>();
candoScript.cc:371:	for ( ci=bdb->begin_Constitutions();
candoScript.cc:372:	      ci!=bdb->end_Constitutions(); ci++ )
candoScript.cc:374:	    LOG(BF("Looking at constitution(%s)") % (*ci)->getName() );
candoScript.cc:375:	    if ( (*ci)->getName() == constitutionName )
candoScript.cc:378:		ConstitutionAtoms_sp res = (*ci)->getConstitutionAtoms();
candoScript.cc:379:		ConstitutionVirtualAtom_sp virt = _lisp->create<ConstitutionVirtualAtom_O>(virtualAtomName,calcPos);
candoScript.cc:380:		res->addConstitutionVirtualAtom(virt);
candoScript.cc:397:	for ( mi=bdb->begin_MonomerCoordinates(); 
candoScript.cc:398:	      mi!=bdb->end_MonomerCoordinates();
candoScript.cc:401:	    uniqueMonomerCoordinates.insert(mi->second);
candoScript.cc:408:	{ _BLOCK_TRACEF(BF("Checking MonomerCoordinates with context: %s") % (*ui)->getContext()->getKey().c_str() );
candoScript.cc:409:	    MonomerContext_sp context = (*ui)->getContext();
candoScript.cc:410:	    EntityNameSetBase_sp focus = context->getFocus();
candoScript.cc:411:	    string focusMonomerName = focus->getOnlyMonomerName();
candoScript.cc:413:	    Constitution_sp constitution = bdb->constitutionForNameOrPdb(focusMonomerName);
candoScript.cc:414:	    if ( constitution->getName() == constitutionName )
candoScript.cc:417:		    focus->getMonomerNamesAsString() % constitutionName );
candoScript.cc:423:	{ _BLOCK_TRACEF(BF("Checking MonomerCoordinates with context: %s") % (*si)->getContext()->getKey().c_str() );
candoScript.cc:432:		fragmentCoords = monCoords->getFragmentCoordinatesThatContainAtomWithName(calcPos->closestAtomName());
candoScript.cc:434:		    virtualAtomName % fragmentCoords->getFragmentName() );
candoScript.cc:436:		    virtualAtomName % calcPos->closestAtomName() );
candoScript.cc:439:		fragmentCoords = monCoords->getFragmentCoordinatesWithName(fragmentName);
candoScript.cc:440:		if ( fragmentCoords->isNil() )
candoScript.cc:448:		fragmentCoords->getFragmentName() );
candoScript.cc:449:	    if ( !fragmentCoords->addVirtualAtom(virtualAtomName,calcPos,lisp) )
candoScript.cc:453:    lisp->print(BF("Added virtual atom(%s) for constitution(%s)") % virtualAtomName % constitutionName );
candoScript.cc:456:        lisp->print(BF(" saw %d collisions") % collisions );
candoScript.cc:458:    lisp->print(BF(""));
candoScript.cc:473:Save the \sa{object} along with the system CandoDatabase to the \sa{filename} in Cando-XML format.
candoScript.cc:488:    if ( kargs->numberOfPositionalArguments()!=2 ) SIMPLE_ERROR(BF("You must provide the object and file name"));
candoScript.cc:489:    core::T_sp obj = kargs->getPositionalArgument(0)->as<core::T_O>();
candoScript.cc:490:    core::Str_sp fileName = kargs->getPositionalArgument(1)->as<core::Str_O>();
candoScript.cc:491:    int debugLevel = kargs->getIntAndRemoveOrDefault("verbosity",0);
candoScript.cc:493:    archive->setVerbosity(debugLevel);
candoScript.cc:495:    archive->putCandoDatabase(getCandoDatabase(_lisp));
candoScript.cc:497:    archive->put("only",obj);
candoScript.cc:498:    archive->saveAs(fileName->get());
candoScript.cc:499://    obj->saveXmlAs(fileName->get(),"only");
candoScript.cc:521:    boost_filesystem::path filePath(fileName->get());
candoScript.cc:545:    mol2WriteMatterToFileName(matter,path->asString());
candoScript.cc:564:    core::Symbol_sp resIdName = residueIdentifier->asOrNull<core::Symbol_O>();
candoScript.cc:565:    core::Fixnum_sp resIdSeqNum = residueIdentifier->asOrNull<core::Fixnum_O>();
candoScript.cc:571:        LOG(BF("Looking at residue with sequence number: %d") % res->getFileSequenceNumber()  );
candoScript.cc:575:	    LOG(BF("Checking if residue has name(%s) that matches(%s)") % res->getName().c_str() % resIdName->__repr__() );
candoScript.cc:576:	    if ( resIdName->identifierName()==res->getName() )
candoScript.cc:578:	        LOG(BF("Found residue with sequence name: %s") % resIdName->__repr__() );
candoScript.cc:580:	    } else if ( res->recognizesMonomerAlias(resIdName) )
candoScript.cc:582:	        LOG(BF("Found residue with Monomer alias: %s") % resIdName->__repr__() );
candoScript.cc:587:	    LOG(BF("Checking if residue has fileSequenceNumber(%d) that matches(%d)") % res->getFileSequenceNumber() % resIdSeqNum->get()  );
candoScript.cc:588:	    if ( (int)(res->getFileSequenceNumber()) == resIdSeqNum->get() )
candoScript.cc:590:	        LOG(BF("Found residue with sequence number: %s") % resIdSeqNum->get()  );
candoScript.cc:623:    if ( args->length()==3 ) 
candoScript.cc:625:        Aggregate_sp agg = args->listref<Aggregate_O>(0);
candoScript.cc:626:	core::Str_sp chain = args->listref<core::Str_O>(1);
candoScript.cc:627:	residueIdentifier = args->listref<core::T_O>(2);
candoScript.cc:628:	molecule = safe_downcast<Molecule_O>(agg->contentWithName(chain->get()));
candoScript.cc:629:    } else if ( args->length()==2 ) 
candoScript.cc:631:        molecule = args->listref<Molecule_O>(0);
candoScript.cc:632:	residueIdentifier = args->listref<core::T_O>(1);
candoScript.cc:638:    if ( res->isNil() )
candoScript.cc:641:	serr << "Molecule does not contain residue with identifier: " << residueIdentifier->__repr__().c_str() ;
candoScript.cc:672:    if ( args->length()==4 ) 
candoScript.cc:674:        Aggregate_sp agg = args->listref<Aggregate_O>(0);
candoScript.cc:675:	core::Str_sp chain = args->listref<core::Str_O>(1);
candoScript.cc:676:	residueIdentifier = args->listref<core::T_O>(2);
candoScript.cc:677:	atomName = args->listref<core::Str_O>(3);
candoScript.cc:678:	molecule = safe_downcast<Molecule_O>(agg->contentWithName(chain->get()));
candoScript.cc:679:    } else if ( args->length()==3 ) 
candoScript.cc:681:        molecule = args->listref<Molecule_O>(0);
candoScript.cc:682:	residueIdentifier = args->listref<core::T_O>(1);
candoScript.cc:683:	atomName = args->listref<core::Str_O>(2);
candoScript.cc:691:	if ( foundResidue->hasAtomWithName(atomName->get() ) )
candoScript.cc:693:	    LOG(BF("Found atom with name: %s") % atomName->get().c_str()  );
candoScript.cc:694:	    Vector3 pos = foundResidue->atomWithName(atomName->get())->getPosition();
candoScript.cc:696:	    v->setAll(pos.getX(),pos.getY(),pos.getZ());
candoScript.cc:699:	SIMPLE_ERROR(BF("Residue does not contain atom named: "+atomName->get()));
candoScript.cc:702:    serr << "Molecule does not contain residue with identifier: " << residueIdentifier->__repr__().c_str() ;
candoScript.cc:729:    newMon->_MonomerId = monomerId;
candoScript.cc:730:    newMon->_GroupName = groupName;
candoScript.cc:731:    newMon->_MonomerAliases = monomerAliases;
candoScript.cc:732:    newMon->_Comment = "";
candoScript.cc:733:    if ( comment.notnilp() ) newMon->_Comment = comment->get();
candoScript.cc:750:    newLink->_Monomer1Id = monomer1Id;
candoScript.cc:751:    newLink->_Coupling = coupling;
candoScript.cc:752:    newLink->_Monomer2 = monomer2;
candoScript.cc:778:    string distanceAtom = kargs->getStringAndRemoveOrDefault("distanceAtom","");
candoScript.cc:779:    string angleAtom = kargs->getStringAndRemoveOrDefault("angleAtom","");
candoScript.cc:780:    string dihedralAtom = kargs->getStringAndRemoveOrDefault("dihedralAtom","");
candoScript.cc:781:    double distance = kargs->getDoubleAndRemoveOrDefault("distance",0.0);
candoScript.cc:782:    double angleDegrees = kargs->getDoubleAndRemoveOrDefault("angleDegrees",0.0);
candoScript.cc:783:    double dihedralDegrees = kargs->getDoubleAndRemoveOrDefault("dihedralDegrees",0.0);
candoScript.cc:784:    core::T_sp positionLookup = kargs->getAndRemove("positionLookup");
candoScript.cc:790:    if ( positionLookup->isOfClass<IterateFragmentCoordinateEntries_O>() )
candoScript.cc:792:	IterateFragmentCoordinateEntries_sp it = positionLookup->as<IterateFragmentCoordinateEntries_O>();
candoScript.cc:793:	posDistanceAtom = it->positionOfAtomWithName(distanceAtom);
candoScript.cc:794:	posAngleAtom = it->positionOfAtomWithName(angleAtom);
candoScript.cc:795:	posDihedralAtom = it->positionOfAtomWithName(dihedralAtom);
candoScript.cc:796:    } else if ( positionLookup->isOfClass<Residue_O>() )
candoScript.cc:798:	Residue_sp res = positionLookup->as<Residue_O>();
candoScript.cc:799:	posDistanceAtom = res->positionOfAtomWithName(distanceAtom);
candoScript.cc:800:	posAngleAtom = res->positionOfAtomWithName(angleAtom);
candoScript.cc:801:	posDihedralAtom = res->positionOfAtomWithName(dihedralAtom);
candoScript.cc:830:    olig->setName(oligomerName);
candoScript.cc:833:    for ( core::Cons_sp p=parts; p.notnilp(); p=p->cdr() )
candoScript.cc:835:	OligomerPart_Base_sp oligPart = p->car<OligomerPart_Base_O>();
candoScript.cc:836:	MultiMonomer_sp mon = oligPart->createMonomer(bdb);
candoScript.cc:837:	olig->addMonomer(mon);
candoScript.cc:838:	monomerMap->extend(mon->getId(), mon);
candoScript.cc:839:	if ( oligPart->isOfClass<OligomerPart_Link_O>() )
candoScript.cc:842:	    core::Symbol_sp	mon1Id = link->_Monomer1Id;
candoScript.cc:843:	    core::Symbol_sp	mon2Id = link->_Monomer2->_MonomerId;
candoScript.cc:844:	    if ( !monomerMap->contains(mon1Id) ) SIMPLE_ERROR(BF("Unknown monomer id: %s")%mon1Id->__repr__());
candoScript.cc:845:	    if ( !monomerMap->contains(mon2Id) ) SIMPLE_ERROR(BF("Unknown monomer id: %s")%mon2Id->__repr__());
candoScript.cc:846:	    MultiMonomer_sp mon1 = monomerMap->lookup(mon1Id)->as<MultiMonomer_O>();
candoScript.cc:847:	    MultiMonomer_sp mon2 = monomerMap->lookup(mon2Id)->as<MultiMonomer_O>();
candoScript.cc:848:	    olig->couple(mon1,link->_Coupling,mon2);
chemInfo.cc:44:	case SABSingleBond: return "-";
chemInfo.cc:65:    this->Base::initialize();
chemInfo.cc:66:    this->_Matches = false;
chemInfo.cc:67:    this->_TagLookup.clear();
chemInfo.cc:68:    this->_ClosestMatch.clear();
chemInfo.cc:75:    this->Base::archiveBase(node);
chemInfo.cc:76:    node->attribute("matches",this->_Matches);
chemInfo.cc:77:    node->archiveMap("tags",this->_TagLookup);
chemInfo.cc:78:    node->archiveMapIfDefined("bestMatch",this->_ClosestMatch);
chemInfo.cc:85:    return this->_Matches;
chemInfo.cc:91:    ss << "( " << this->className();
chemInfo.cc:93:    for (core::StringMap<Atom_O>::const_iterator it=this->_TagLookup.begin(); it!=this->_TagLookup.end(); it++ )
chemInfo.cc:95:	ss << (BF(":tag \"%s\" :value %s ) ") % it->first % it->second->__repr__() );
chemInfo.cc:103:    this->_TagLookup.clear();
chemInfo.cc:108:    return this->_TagLookup.count(tag);
chemInfo.cc:113:    this->_TagLookup.set(tag,a);
chemInfo.cc:114:    if ( this->_TagLookup.size() > this->_ClosestMatch.size() )
chemInfo.cc:116:	this->_ClosestMatch = this->_TagLookup;
chemInfo.cc:123:	for ( core::StringMap<Atom_O>::iterator it=this->_TagLookup.begin(); it != this->_TagLookup.end(); it++ )
chemInfo.cc:125:	    if ( satoms.count(it->second))
chemInfo.cc:127:		SIMPLE_ERROR(BF("The ChemInfoMatch is invalid - the matching algorithm or the SMARTS pattern match gave tags with the same atoms: %s") % this->__repr__() );
chemInfo.cc:129:	    satoms.insert(it->second);
chemInfo.cc:135:    return this->_TagLookup.count(tag)>0;
chemInfo.cc:140:	if ( !this->hasAtomWithTag(tag) )
chemInfo.cc:144:	return this->getAtomWithTag(tag);
chemInfo.cc:150:    if ( this->_TagLookup.count(tag) == 0 )
chemInfo.cc:154:        serr << "Available tags(" << core::StringSet_O::create_fromKeysOfStringMap(this->_TagLookup,_lisp)->asString() << ")" <<endl;
chemInfo.cc:157:    return this->_TagLookup.get(tag);
chemInfo.cc:162:    this->_TagLookup.erase(tag);
chemInfo.cc:167:    for ( core::StringMap<Atom_O>::iterator it=this->_ClosestMatch.begin(); it != this->_ClosestMatch.end(); it++ )
chemInfo.cc:169:	_lisp->print(BF("  tag(%s) = %s") % it->first.c_str() % it->second->description().c_str() );
chemInfo.cc:176:    if ( !this->_Matches )
chemInfo.cc:181:    bound->set_oAtom(this->getAtomWithTag("1"));
chemInfo.cc:182:    bound->set_pAtom(this->getAtomWithTag("2"));
chemInfo.cc:183:    bound->set_qAtom(this->getAtomWithTag("3"));
chemInfo.cc:190:// ------- WildElementDict_O
chemInfo.cc:195:    this->Base::initialize();
chemInfo.cc:196:    this->_AtomWildCards.clear();
chemInfo.cc:203:    this->_AtomWildCards.set(name,maps);
chemInfo.cc:209:    if ( this->_AtomWildCards.count(wildName) == 0 ) {
chemInfo.cc:212:    this->_AtomWildCards.get(wildName)->insert(elementName);
chemInfo.cc:217:    if ( this->_AtomWildCards.count(name) == 0 ) return false;
chemInfo.cc:223:    if ( this->_AtomWildCards.count(name) == 0 ) {
chemInfo.cc:226:    if ( this->_AtomWildCards.get(name)->contains(element)!= 0 ) return true;
chemInfo.cc:236:    return (this->_AtomWildCards.count(name)!= 0);
chemInfo.cc:243:    return (this->_AtomWildCards.count(name)!= 0);
chemInfo.cc:253:    if ( node->saving() ) {
chemInfo.cc:255:	for ( i=this->_AtomWildCards.begin();
chemInfo.cc:256:		i!=this->_AtomWildCards.end(); i++ ) {
chemInfo.cc:257:	    child = node->createChildNode("Entry");
chemInfo.cc:258:	    child->addAttributeString("name",i->first);
chemInfo.cc:260:	    for ( si = i->second->begin(); si!=i->second->end(); si++ ) {
chemInfo.cc:263:	    child->setCharacters(sdata.str());
chemInfo.cc:267:	for ( ni=node->begin_Children(); ni!=node->end_Children(); ni++ ) {
chemInfo.cc:268:	    string name = (*ni)->getAttributeString("name");
chemInfo.cc:269:	    this->addWildName(name);
chemInfo.cc:271:	    (*ni)->getDataAsVectorOfStrings(entries);
chemInfo.cc:274:		this->addWildNameMap(name,*si);
chemInfo.cc:276:	    (*ni)->setRecognized(true);
chemInfo.cc:301:    this->Base::initialize();
chemInfo.cc:302:    this->_Code = "";
chemInfo.cc:303:    this->_Root = Root_O::_nil;
chemInfo.cc:304:    this->_CompilerMessage = "";
chemInfo.cc:309:    uint d = this->_Root->depth();
chemInfo.cc:318:    ASSERTNOTNULL(this->_Root);
chemInfo.cc:319:    this->_Root = Root_O::_nil;
chemInfo.cc:320:    this->_Code = code;
chemInfo.cc:323:    this->_Root = root;
chemInfo.cc:324:    ANN(this->_Root);
chemInfo.cc:325:    if ( root->isNil() )
chemInfo.cc:327:	this->_CompilerMessage = errors.str();
chemInfo.cc:330:    this->_CompilerMessage = "Successfully compiled SMARTS";
chemInfo.cc:338:    ASSERTNOTNULL(this->_Root);
chemInfo.cc:339:    ASSERTF(this->_Root.notnilp(),BF("Root must be defined to define tests"));
chemInfo.cc:340:    for ( core::Cons_sp cur = tests; cur.notnilp(); cur = cur->cddr()->as<core::Cons_O>() )
chemInfo.cc:342:	core::Symbol_sp testSymbol = cur->car<core::Symbol_O>();
chemInfo.cc:343:	core::Function_sp testCode = cur->ocadr()->as<core::Function_O>();
chemInfo.cc:346:	this->_Root->addTest(testSymbol,testCode);
chemInfo.cc:353:    this->_Code = code;
chemInfo.cc:356:    this->_Root = root;
chemInfo.cc:357:    if ( root->isNil() )
chemInfo.cc:360:	this->_CompilerMessage = serr.str();
chemInfo.cc:361:        LOG(BF("After unsuccessful compile this->_Root = %s") % this->_Root->description().c_str()  );
chemInfo.cc:364:    root->setElementWildCardDictionary(dict);
chemInfo.cc:366:    this->_CompilerMessage = "Successfully compiled Antechamber";
chemInfo.cc:367:    LOG(BF("After compile this->_Root = %s") % this->_Root->description().c_str()  );
chemInfo.cc:374:    ASSERTNOTNULL(this->_Root);
chemInfo.cc:375:    if ( this->_Root->isNil() )
chemInfo.cc:379:    LOG(BF("Starting ChemInfo::matches process with atom: %s") % a->description() );
chemInfo.cc:380:    LOG(BF("The local atom environment(depth=%d) is:\n%s") % this->depth() % a->localEnvironment(4) );
chemInfo.cc:381:    LOG(BF("The pattern to match is smarts[%s]") % this->_Code);
chemInfo.cc:382:    LOG(BF("The XML version of the pattern to match is:\n%s") % this->asXmlString() );
chemInfo.cc:383:    this->_Root->createNewMatch(_lisp);
chemInfo.cc:384:    if ( !this->_Root->matches(this->_Root,a) ) goto FAIL;
chemInfo.cc:387:    this->_Root->getMatch()->throwIfInvalid();
chemInfo.cc:388:    this->_Root->getMatch()->setMatches(true);
chemInfo.cc:392:    this->_Root->getMatch()->setMatches(false);
chemInfo.cc:400:    node->archiveObject("root",this->_Root);
chemInfo.cc:408:    ASSERTNOTNULL(this->_Root);
chemInfo.cc:409:    ASSERT(this->_Root.notnilp());
chemInfo.cc:410:    ASSERT(this->_Root->getMatch().notnilp());
chemInfo.cc:411:    return this->_Root->getMatch();
chemInfo.cc:449:    while ( p->type != noType ) {
chemInfo.cc:450:	if ( p->type == type ) return p->name;
chemInfo.cc:463:    while ( p->type != noType ) {
chemInfo.cc:464:	if ( p->name== name) return p->type;
chemInfo.cc:488:    LOG(BF("Node type = %s") % this->className() );
chemInfo.cc:489:    if ( this->isNil() )
chemInfo.cc:511:    if ( this->isNil() ) return "";
chemInfo.cc:526:    return this->matches(root,bond->getOtherAtom(from));
chemInfo.cc:543:    this->Base::initialize();
chemInfo.cc:544:    this->_Operator = logIdentity;
chemInfo.cc:545:    this->_Left = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:546:    this->_Right = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:552:	switch (this->_Operator)
chemInfo.cc:555:	    ss << this->_Left->asSmarts();
chemInfo.cc:558:	    ss << "!" << this->_Left->asSmarts();
chemInfo.cc:561:	    ss << this->_Left->asSmarts() << "&" << this->_Right->asSmarts();
chemInfo.cc:564:	    ss << this->_Left->asSmarts() << ";" << this->_Right->asSmarts();
chemInfo.cc:567:	    ss << this->_Left->asSmarts() << "," << this->_Right->asSmarts();
chemInfo.cc:577:    uint d = MAX(this->_Left->depth(),this->_Right->depth());
chemInfo.cc:585:    LOG(BF("Logical pattern: %s") % this->asSmarts() );
chemInfo.cc:586:    LOG(BF("Logical match for atom: %s") % atom->description() );
chemInfo.cc:587:    switch ( this->_Operator ) {
chemInfo.cc:589:	    LOG(BF("Identity no-op test") );
chemInfo.cc:590:	    if ( this->_Left->matches(root,atom)) goto SUCCESS;
chemInfo.cc:594:	    if ( !(this->_Left->matches(root,atom)) ) goto SUCCESS;
chemInfo.cc:598:	    if ( this->_Left->matches(root,atom) && this->_Right->matches(root,atom) ) goto SUCCESS;
chemInfo.cc:602:	    if ( this->_Left->matches(root,atom) && this->_Right->matches(root,atom) ) goto SUCCESS;
chemInfo.cc:607:	    bool leftMatch = this->_Left->matches(root,atom);
chemInfo.cc:610:	    bool rightMatch = this->_Right->matches(root,atom);
chemInfo.cc:617:	    err << "Unknown logical operator(" << this->_Operator << ")";
chemInfo.cc:632:    LOG(BF("Logical match for bond: %s") % bond->describeOther(from) );
chemInfo.cc:633:    switch ( this->_Operator ) {
chemInfo.cc:635:	    if ( this->_Left->matches(root,from,bond)) goto SUCCESS;
chemInfo.cc:638:	    if ( !(this->_Left->matches(root,from,bond)) ) goto SUCCESS;
chemInfo.cc:642:	    if ( this->_Left->matches(root,from,bond) && this->_Right->matches(root,from,bond) ) goto SUCCESS;
chemInfo.cc:645:	    if ( this->_Left->matches(root,from,bond) || this->_Right->matches(root,from,bond) ) goto SUCCESS;
chemInfo.cc:649:	    err << "Unknown logical operator(" << this->_Operator << ")";
chemInfo.cc:667:	{ "", -1 }
chemInfo.cc:673:    node->attributeEnum( "op", this->_Operator, logicalEnum );
chemInfo.cc:674:    node->archiveObject( "left", this->_Left );
chemInfo.cc:675:    node->archiveObjectIfDefined( "right", this->_Right );
chemInfo.cc:683:// --- TagSet  set a tag for the atom
chemInfo.cc:699: {"",-1}
chemInfo.cc:705:    this->Base::initialize();
chemInfo.cc:706://    this->_Bond = SABAnyBond;
chemInfo.cc:707:    this->_AtomTest = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:708:    this->_RingTag = "";
chemInfo.cc:715://	ss << sabToString(this->_Bond);
chemInfo.cc:716:	ss <<this->_AtomTest->asSmarts() << this->_RingTag;
chemInfo.cc:726:    LOG(BF("TagSet match for atom: %s") % atom->description());
chemInfo.cc:727:    if ( root->type() != chem::smartsRoot ) {
chemInfo.cc:731:    ASSERTNOTNULL(this->_AtomTest);
chemInfo.cc:732:    if ( !this->_AtomTest->matches(root,atom) )
chemInfo.cc:739:    smartsRoot->getMatch()->defineAtomTag( atom, this->_RingTag );
chemInfo.cc:740:    LOG(BF("RingTag (%s) defined atom: %s") % this->_RingTag.c_str() % atom->description().c_str()  );
chemInfo.cc:752://    node->attributeEnum( "bond", this->_Bond, bondEnum );
chemInfo.cc:753:    node->attribute("ringTag", this->_RingTag );
chemInfo.cc:754:    node->archiveObject("atomTest", this->_AtomTest);
chemInfo.cc:764:// ------ RingTest
chemInfo.cc:769:    this->Base::initialize();
chemInfo.cc:770:    this->_Bond = SABAnyBond;
chemInfo.cc:771:    this->_AtomTest = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:772:    this->_RingTag = "";
chemInfo.cc:780:    LOG(BF("RingTest match for atom: %s") % atom->description().c_str()  );
chemInfo.cc:781:    if ( root->type() != chem::smartsRoot ) {
chemInfo.cc:785:    ASSERTNOTNULL(this->_AtomTest);
chemInfo.cc:786:    if ( !this->_AtomTest->matches(root,atom) )
chemInfo.cc:795:    if ( !smartsRoot->getMatch()->recognizesAtomTag(this->_RingTag) )
chemInfo.cc:797:	SIMPLE_ERROR(BF("We are trying to test the atomTag ("+this->_RingTag+") but it doesn't exist!" ));
chemInfo.cc:800:    ringStartAtom = smartsRoot->getMatch()->getAtomWithTag(this->_RingTag);
chemInfo.cc:801:    LOG(BF("      checking if %s matches ringStart atom: %s") % atom->description().c_str() % ringStartAtom->description().c_str()  );
chemInfo.cc:819:    node->attributeEnum( "bond", this->_Bond, bondEnum );
chemInfo.cc:820:    node->attribute("ringTag", this->_RingTag );
chemInfo.cc:821:    node->archiveObject("atomTest", this->_AtomTest);
chemInfo.cc:829:// ------ ResidueTest
chemInfo.cc:834:    this->Base::initialize();
chemInfo.cc:835:    this->_Bond = SABAnyBond;
chemInfo.cc:836:    this->_AtomTest = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:837:    this->_RingTag = "";
chemInfo.cc:844:    ss << sabToString(this->_Bond)<<this->_AtomTest->asSmarts()<<this->_RingTag;
chemInfo.cc:853:    LOG(BF("ResidueTest match for atom: %s") % atom->description().c_str()  );
chemInfo.cc:854:    if ( root->type() != chem::smartsRoot ) {
chemInfo.cc:858:    ASSERTNOTNULL(this->_AtomTest);
chemInfo.cc:859:    if ( !this->_AtomTest->matches(root,atom) )
chemInfo.cc:868:    if ( !smartsRoot->getMatch()->recognizesAtomTag(this->_RingTag) )
chemInfo.cc:870:	SIMPLE_ERROR(BF("We are trying to test the atomTag ("+this->_RingTag+") but it doesn't exist!" ));
chemInfo.cc:873:    ringAtom = smartsRoot->getMatch()->getAtomWithTag(this->_RingTag);
chemInfo.cc:874:    LOG(BF("      checking if %s matches ringAtom: %s") % atom->description().c_str() % ringAtom->description().c_str()  );
chemInfo.cc:875:    if ( ! atom->containedByValid() )
chemInfo.cc:877:	SIMPLE_ERROR(BF("%s failed containedByValid()") % atom->description() );
chemInfo.cc:879:    if ( ! ringAtom->containedByValid() )
chemInfo.cc:881:	SIMPLE_ERROR(BF("%s failed containedByValid()") % ringAtom->description() );
chemInfo.cc:883:    LOG(BF("   atom->containedBy()->description() = %s") % atom->containedByLock()->description().c_str()  );
chemInfo.cc:884:    LOG(BF("   ringAtom->containedBy()->description() = %s") % ringAtom->containedByLock()->description().c_str()  );
chemInfo.cc:885:    if ( atom->containedByLock().get()  == ringAtom->containedByLock().get() )
chemInfo.cc:902:    node->attributeEnum( "bond", this->_Bond, bondEnum );
chemInfo.cc:903:    node->attribute("ringTag", this->_RingTag );
chemInfo.cc:904:    node->archiveObject("atomTest", this->_AtomTest);
chemInfo.cc:912:// ------ BondTest
chemInfo.cc:969:    this->Base::initialize();
chemInfo.cc:970:    this->_Bond = SABNoBond;
chemInfo.cc:971:    this->_AtomTest = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:978:    ss << "(" << sabToString(this->_Bond) << this->_AtomTest->asSmarts() << ")";
chemInfo.cc:987:    LOG(BF("Checking bond: %s") % bond->describeOther(from));
chemInfo.cc:989:    bo = bond->getOrder();
chemInfo.cc:990:    if ( !chem::_matchBondTypes(this->_Bond,bo,_lisp) ) goto FAIL;
chemInfo.cc:991:    if ( this->_AtomTest->matches(root,bond->getOtherAtom(from)) ) goto SUCCESS;
chemInfo.cc:1004:    node->attributeEnum( "bond", this->_Bond, bondEnum );
chemInfo.cc:1005:    node->archiveObject( "atomTest", this->_AtomTest );
chemInfo.cc:1013:// ------- AtomTest
chemInfo.cc:1017:    this->_Test = SAPNone;
chemInfo.cc:1018:    this->_IntArg = 0;
chemInfo.cc:1019:    this->_NumArg = 0;
chemInfo.cc:1020:    this->_StringArg = "";
chemInfo.cc:1027:    LOG(BF("AtomTest_O matching pattern: %s") % this->asSmarts() );
chemInfo.cc:1028:    switch ( this->_Test ) 
chemInfo.cc:1031:            if ( chem::_matchBondTypes((chem::BondEnum)this->_IntArg,bond->getOrder(),_lisp)) goto SUCCESS;
chemInfo.cc:1034:            if (!chem::_matchBondTypes((chem::BondEnum)this->_IntArg,bond->getOrder(),_lisp)) goto SUCCESS;
chemInfo.cc:1042:    if ( this->matches(root,bond->getOtherAtom(from)) ) goto SUCCESS;
chemInfo.cc:1058:    Element el = atom->getElement();
chemInfo.cc:1062:	return (atom->numberOfBonds()==3&&atom->getIonization()==0);
chemInfo.cc:1066:	if (atom->numberOfBonds()==2 && atom->getIonization()==0) return true;
chemInfo.cc:1068:	if ( atom->numberOfBonds()==3 && atom->getIonization()==1) return true;
chemInfo.cc:1074:	return (atom->numberOfBonds()==2)&&(atom->getIonization()==1);
chemInfo.cc:1083:    Element el = atom->getElement();
chemInfo.cc:1086:	// C-(x2)
chemInfo.cc:1087:	return (atom->numberOfBonds()==2&&atom->getIonization()==-1);
chemInfo.cc:1090:    {	// N-(x2)
chemInfo.cc:1091:	if (atom->numberOfBonds()==2 && atom->getIonization()==-1) return true;
chemInfo.cc:1093:	if ( atom->numberOfBonds()==3 && atom->getIonization()==0) return true;
chemInfo.cc:1098:	if ( atom->numberOfBonds()==3 && atom->getIonization()==0) return true;
chemInfo.cc:1104:	return (atom->numberOfBonds()==2)&&(atom->getIonization()==0);
chemInfo.cc:1116:    LOG(BF("AtomTest match for atom: %s") % atom->description().c_str()  ); //
chemInfo.cc:1117:    switch ( this->_Test ) {
chemInfo.cc:1123:	    % atom->getElementAsSymbol()->__repr__()
chemInfo.cc:1124:	    % this->_SymbolArg->__repr__() );
chemInfo.cc:1125:	if ( this->_SymbolArg == atom->getElementAsSymbol() && atom->isAromatic() ) goto SUCCESS;
chemInfo.cc:1129:	    % atom->getElementAsSymbol()->__repr__()
chemInfo.cc:1130:	    % this->_SymbolArg->__repr__() );
chemInfo.cc:1131:	if ( this->_SymbolArg == atom->getElementAsSymbol() ) goto SUCCESS;
chemInfo.cc:1135:	if ( !atom->isAromatic() ) goto SUCCESS;
chemInfo.cc:1139:	if ( atom->isAromatic() ) goto SUCCESS;
chemInfo.cc:1142:	LOG(BF("SAPLambda<%s> testing %s") % this->_SymbolArg->__repr__() % atom->description() );
chemInfo.cc:1143:	if ( root->evaluateTest(this->_SymbolArg,atom) ) goto SUCCESS;
chemInfo.cc:1146:	LOG(BF("SAPAtomicNumber(%d) == expecting(%d)") % atom->getAtomicNumber() % this->_IntArg );
chemInfo.cc:1147:	if ( this->_IntArg == atom->getAtomicNumber() ) goto SUCCESS;
chemInfo.cc:1150:	hc = atom->getBondedHydrogenCount();
chemInfo.cc:1151:	LOG(BF("SAPTotalHCount(%d) == expecting(%d)") % hc % this->_IntArg );
chemInfo.cc:1152:	LOG(BF("Checking total hydrogen count looking for(%d) got(%d)") % this->_IntArg % hc );
chemInfo.cc:1153:	if ( this->_IntArg == hc ) {
chemInfo.cc:1160:	LOG(BF("SAPRingTest looking for tag: %s") % this->_StringArg );
chemInfo.cc:1161:	if ( !root->getMatch()->recognizesAtomTag(this->_StringArg) )
chemInfo.cc:1164:			    +this->_StringArg+") but it doesn't exist!" ));
chemInfo.cc:1167:	ringStartAtom = root->getMatch()->getAtomWithTag(this->_StringArg);
chemInfo.cc:1169:	    % atom->description().c_str() % ringStartAtom->description().c_str()  ); //
chemInfo.cc:1177:	LOG(BF("SAPResidueTest looking for tag: %s") % this->_StringArg );
chemInfo.cc:1178:	if ( !root->getMatch()->recognizesAtomTag(this->_StringArg) )
chemInfo.cc:1181:			    +this->_StringArg+") but it doesn't exist!" ));
chemInfo.cc:1184:	ringStartAtom = root->getMatch()->getAtomWithTag(this->_StringArg);
chemInfo.cc:1186:	    % atom->description().c_str() % ringStartAtom->description().c_str()  ); //
chemInfo.cc:1187:	if ( atom->containedByLock().get() == ringStartAtom->containedByLock().get() )
chemInfo.cc:1194:	if ( this->matchesAm1BccX(atom) ) goto SUCCESS;
chemInfo.cc:1197:	if ( this->matchesAm1BccY(atom) ) goto SUCCESS;
chemInfo.cc:1204:	if ( this->_IntArg == atom->getIonization() ) goto SUCCESS;
chemInfo.cc:1208:	if (this->_IntArg == atom->getRingMembershipCount()) goto SUCCESS;
chemInfo.cc:1212:	if (atom->inRingSize(this->_IntArg)) goto SUCCESS;
chemInfo.cc:1220:	if (this->_IntArg == atom->getValence()) goto SUCCESS;
chemInfo.cc:1224:	LOG(BF("SAPDegree testing if atom->numberOfBonds(){%d} == this->_IntArg{%d}") % atom->numberOfBonds() % this->_IntArg );
chemInfo.cc:1225:	if (this->_IntArg == atom->numberOfBonds()) goto SUCCESS;
chemInfo.cc:1230:	for ( int i=0; i<atom->numberOfBonds(); i++ ) {
chemInfo.cc:1231:	    if ( chem::_matchBondTypes((chem::BondEnum)this->_IntArg,atom->bondedOrder(i),_lisp)) cnt++;
chemInfo.cc:1233:	if ( cnt == this->_NumArg ) goto SUCCESS;
chemInfo.cc:1237:	switch ( this->_IntArg ) {
chemInfo.cc:1239:	    if ( atom->getMembershipAr1() != 0 ) goto SUCCESS;
chemInfo.cc:1242:	    if ( atom->getMembershipAr2() != 0 ) goto SUCCESS;
chemInfo.cc:1245:	    if ( atom->getMembershipAr3() != 0 ) goto SUCCESS;
chemInfo.cc:1248:	    if ( atom->getMembershipAr4() != 0 ) goto SUCCESS;
chemInfo.cc:1251:	    if ( atom->getMembershipAr5() != 0 ) goto SUCCESS;
chemInfo.cc:1257:	if ( !atom->isInRing() ) goto SUCCESS;
chemInfo.cc:1261:	if ( atom->getElement() == element_O ) goto SUCCESS;
chemInfo.cc:1262:	if ( atom->getElement() == element_N ) goto SUCCESS;
chemInfo.cc:1263:	if ( atom->getElement() == element_F ) goto SUCCESS;
chemInfo.cc:1264:	if ( atom->getElement() == element_Cl ) goto SUCCESS;
chemInfo.cc:1265:	if ( atom->getElement() == element_Br ) goto SUCCESS;
chemInfo.cc:1269:	ss << "You must implement a test for: " << this->testName(this->_Test);
chemInfo.cc:1301:    switch ( this->_Test ) {
chemInfo.cc:1306:	ss << this->_SymbolArg->identifierName();
chemInfo.cc:1310:	string element = this->_SymbolArg->identifierName();
chemInfo.cc:1321:	ss << "<" << this->_SymbolArg->identifierName() << ">";
chemInfo.cc:1324:	ss << "#" << this->_IntArg;
chemInfo.cc:1327:	ss << "H" << this->_IntArg;
chemInfo.cc:1330:	ss << "?" << this->_StringArg;
chemInfo.cc:1333:	ss << "U" << this->_StringArg;
chemInfo.cc:1343:	ss << this->_IntArg;
chemInfo.cc:1347:	ss << "+" << this->_IntArg;
chemInfo.cc:1350:	ss << "R" << this->_IntArg;
chemInfo.cc:1353:	ss << "r" << this->_IntArg;
chemInfo.cc:1356:	ss << "v" << this->_IntArg;
chemInfo.cc:1360:	ss << "X" << this->_IntArg;
chemInfo.cc:1375:	ss << "{UnknownTest-" << this->testName(this->_Test) << "}";
chemInfo.cc:1422:	{ "", -1 }
chemInfo.cc:1427:    for ( uint i=0; testEnum[i]._Enum != -1; i++ )
chemInfo.cc:1434:    return "-unknownTest-";
chemInfo.cc:1440:    node->attributeEnum( "test", this->_Test, testEnum );
chemInfo.cc:1441:    node->attributeIfNotDefault( "int", this->_IntArg, 0 );
chemInfo.cc:1442:    node->attributeIfNotDefault( "num", this->_NumArg, 0 );
chemInfo.cc:1443:    node->attributeIfNotDefault<string>( "str", this->_StringArg, "" );
chemInfo.cc:1444:    node->attributeSymbolIfNotNil("sym",this->_SymbolArg);
chemInfo.cc:1454:// ------- Chain
chemInfo.cc:1459:    this->Base::initialize();
chemInfo.cc:1460:    this->_Head = BondMatchNode_O::_nil;
chemInfo.cc:1461:    this->_Tail = BondListMatchNode_O::_nil;
chemInfo.cc:1467:    if ( this->_Head.notnilp() ) ss << "(" << this->_Head->asSmarts() << ")";
chemInfo.cc:1468:    if ( this->_Tail.notnilp() ) ss << "(" << this->_Tail->asSmarts() << ")";
chemInfo.cc:1474:    if ( this->isNil() ) return 0;
chemInfo.cc:1475:    return (MAX(this->_Head->depth(),this->_Tail->depth()+1));
chemInfo.cc:1482:    LOG(BF("Chain_O matching pattern: %s") % this->asSmarts() );
chemInfo.cc:1483:    LOG(BF("There are %d neighbors bondList: %s") % neighbors->size() % neighbors->describeOthers(from) );
chemInfo.cc:1484:    for ( bi=neighbors->begin(); bi!=neighbors->end(); bi++ )
chemInfo.cc:1485:    { _BLOCK_TRACEF(BF("Checking neighbor for bond: %s") % (*bi)->describeOther(from) );
chemInfo.cc:1486:	if ( this->_Head->matches(root,from,*bi) )
chemInfo.cc:1489:	    Atom_sp other = (*bi)->getOtherAtom(from);
chemInfo.cc:1490:	    LOG(BF("The other atom: %s") % other->description() );
chemInfo.cc:1491:	    nextBonds = other->getBondList(); // handle new bonds
chemInfo.cc:1492:	    LOG(BF("The others bond list before removed from: %s") % nextBonds->describeOthers(other));
chemInfo.cc:1493:	    LOG(BF("Removing bond between %s and %s") % from->description() % other->description() );
chemInfo.cc:1494: 	    nextBonds->removeBondBetween(from,other); // (*bi)->getFrom().lock());
chemInfo.cc:1495:	    LOG(BF("The others bond list after removed from: %s") % nextBonds->describeOthers(other));
chemInfo.cc:1496:	    ASSERTNOTNULL(this->_Tail);
chemInfo.cc:1497:	    if ( this->_Tail.notnilp() )
chemInfo.cc:1499:		if ( this->_Tail->matches(root,other,nextBonds) ) goto SUCCESS;
chemInfo.cc:1518:    node->archiveObjectIfDefined("head",this->_Head);
chemInfo.cc:1519:    node->archiveObjectIfDefined("tail",this->_Tail);
chemInfo.cc:1526:// ------ Branch
chemInfo.cc:1530:    this->Base::initialize();
chemInfo.cc:1531:    this->_Left = BondListMatchNode_O::_nil;
chemInfo.cc:1532:    this->_Right = BondListMatchNode_O::_nil;
chemInfo.cc:1538:    if ( this->_Left.notnilp() ) ss << "(" << this->_Left->asSmarts() << ")";
chemInfo.cc:1539:    if ( this->_Right.notnilp() ) ss << "(" << this->_Right->asSmarts() << ")";
chemInfo.cc:1545:    if ( this->isNil() ) return 0;
chemInfo.cc:1546:    return (MAX(this->_Left->depth(),this->_Right->depth()));
chemInfo.cc:1555:    LOG(BF("Branch_O matching pattern: %s") % this->asSmarts() );
chemInfo.cc:1556:    LOG(BF("Neighbors bond list= %s") % neighbors->describeOthers(from));
chemInfo.cc:1557:    for ( bi=neighbors->begin(); bi!=neighbors->end(); bi++ )
chemInfo.cc:1558:    {_BLOCK_TRACEF(BF("Checking neighbors focusing on %s") % (*bi)->describeOther(from) );
chemInfo.cc:1560:	leftBondList->addBond(*bi);
chemInfo.cc:1562:	LOG(BF("Left bond list = %s") % leftBondList->describeOthers(from)  );
chemInfo.cc:1564:	LOG(BF("Right bond list after copy = %s") % rightBondList->describeOthers(from) );
chemInfo.cc:1565:	rightBondList->removeBond(*bi);
chemInfo.cc:1567:	LOG(BF("Right bond list after remove left = %s") % rightBondList->describeOthers(from) );
chemInfo.cc:1569:	if ( this->_Left->matches(root,from,leftBondList) )
chemInfo.cc:1572:	    ANN(this->_Right);
chemInfo.cc:1573:	    if ( this->_Right.notnilp() )
chemInfo.cc:1576:		if ( this->_Right->matches(root,from,rightBondList) ) {
chemInfo.cc:1602:    node->archiveObject("left",this->_Left);
chemInfo.cc:1603:    node->archiveObjectIfDefined("right",this->_Right);
chemInfo.cc:1618:// ------- AfterMatchBondTest
chemInfo.cc:1622:    this->_AtomTag1 = "";
chemInfo.cc:1623:    this->_AtomTag2 = "";
chemInfo.cc:1624:    this->_Bond = SABNoBond;
chemInfo.cc:1632:    node->attribute( "tag1", this->_AtomTag1 );
chemInfo.cc:1633:    node->attribute( "tag2", this->_AtomTag2 );
chemInfo.cc:1634:    node->attributeEnum( "bond", this->_Bond, bondEnum );
chemInfo.cc:1648:// -------- AntechamberFocusAtomMatch
chemInfo.cc:1652:    this->Base::initialize();
chemInfo.cc:1653:    this->_ResidueNames = ResidueList_O::_nil;
chemInfo.cc:1654:    this->_AtomicNumber = 0;
chemInfo.cc:1655:    this->_NumberOfAttachedAtoms = 0;
chemInfo.cc:1656:    this->_NumberOfAttachedHydrogens = 0;
chemInfo.cc:1657:    this->_NumberOfElectronWithdrawingGroups = 0;
chemInfo.cc:1658:    this->_AtomicProperty = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:1665:    node->archiveObjectIfDefined("residueNames",this->_ResidueNames);
chemInfo.cc:1666:    node->archiveObjectIfDefined("atomicProperty",this->_AtomicProperty);
chemInfo.cc:1667:    node->attribute("atomicNumber",this->_AtomicNumber);
chemInfo.cc:1668:    node->attribute("attachedAtoms",this->_NumberOfAttachedAtoms);
chemInfo.cc:1669:    node->attribute("attachedHs",this->_NumberOfAttachedHydrogens);
chemInfo.cc:1670:    node->attribute("attachedEWGs",this->_NumberOfElectronWithdrawingGroups);
chemInfo.cc:1682:    if ( this->_AtomicNumber >=0 ) {
chemInfo.cc:1683:	LOG(BF("Checking if atomic number(%d) == expected(%d)") % atom->getAtomicNumber() % this->_AtomicNumber  );
chemInfo.cc:1684:        if ( atom->getAtomicNumber() != this->_AtomicNumber ) goto FAIL;
chemInfo.cc:1686:    if ( this->_NumberOfAttachedAtoms >=0 ) {
chemInfo.cc:1687:	LOG(BF("Checking if number of bonds(%d) == expected(%d)") % atom->numberOfBonds() % this->_NumberOfAttachedAtoms );
chemInfo.cc:1688:        if ( atom->numberOfBonds() != this->_NumberOfAttachedAtoms ) goto FAIL;
chemInfo.cc:1690:    if ( this->_NumberOfAttachedHydrogens >=0 ){
chemInfo.cc:1691:	LOG(BF("Checking if number of attached hydrogens(%d) == expected(%d)") % atom->getBondedHydrogenCount() % this->_NumberOfAttachedHydrogens  );
chemInfo.cc:1692:        if ( atom->getBondedHydrogenCount() != this->_NumberOfAttachedHydrogens ) goto FAIL;
chemInfo.cc:1694:    if ( this->_NumberOfElectronWithdrawingGroups >=0 ) {
chemInfo.cc:1695:        if ( atom->numberOfBonds() != 1 ) {
chemInfo.cc:1698:        neighbor = atom->bondedNeighbor(0);
chemInfo.cc:1700:        for ( int i=0; i<neighbor->numberOfBonds(); i++ ) {
chemInfo.cc:1701:            nn = neighbor->bondedNeighbor(i);
chemInfo.cc:1702:            if ( nn->getElement() == element_N ) cnt++;
chemInfo.cc:1703:            if ( nn->getElement() == element_O ) cnt++;
chemInfo.cc:1704:            if ( nn->getElement() == element_F ) cnt++;
chemInfo.cc:1705:            if ( nn->getElement() == element_Cl ) cnt++;
chemInfo.cc:1706:            if ( nn->getElement() == element_Br ) cnt++;
chemInfo.cc:1708:	LOG(BF("Checking if number of electron withdrawing groups(%d) == expected(%d)") % cnt % this->_NumberOfElectronWithdrawingGroups );
chemInfo.cc:1709:        if ( cnt != this->_NumberOfElectronWithdrawingGroups ) goto FAIL;
chemInfo.cc:1711:    ANN(this->_AtomicProperty);
chemInfo.cc:1712:    if ( this->_AtomicProperty.notnilp() ) {
chemInfo.cc:1713:        if ( !this->_AtomicProperty->matches(root,atom) ) goto FAIL;
chemInfo.cc:1727:// ------- AntechamberBondTest
chemInfo.cc:1733:    dict = root->getElementWildCardDictionary();
chemInfo.cc:1738:        if ( dict->recognizesWildName(this->_Element) ) {
chemInfo.cc:1739:	    LOG(BF("Matching wildcard element has(%s) == expecting (%s)") % atom->getElementAsString().c_str() % this->_Element.c_str() );
chemInfo.cc:1740:            if ( !dict->recognizesWildNameElement(this->_Element,atom->getElementAsString() ) ) goto FAIL;
chemInfo.cc:1746:        LOG(BF("Trying to match regular element(%s) == expected(%s)") % atom->getElementAsString().c_str() % this->_Element.c_str() );
chemInfo.cc:1747:        if ( atom->getElementAsString() != this->_Element ) goto FAIL;
chemInfo.cc:1749:    LOG(BF("Trying to match number of bonds(%d) == expected(%d)") % atom->numberOfBonds() % this->_Neighbors );
chemInfo.cc:1750:    if ( this->_Neighbors >=0 ) {
chemInfo.cc:1751:        if ( atom->numberOfBonds() != this->_Neighbors ) goto FAIL;
chemInfo.cc:1753:    if ( this->_Tag != "" ) {
chemInfo.cc:1754:        root->getMatch()->defineAtomTag( atom, this->_Tag );
chemInfo.cc:1767:    if ( root->type() != antechamberRoot ) {
chemInfo.cc:1771:    if ( !this->matchBasic(acRoot,atom) ) goto FAIL;
chemInfo.cc:1772:    if ( this->_AtomProperties->matches(acRoot,atom) ) goto SUCCESS;
chemInfo.cc:1789:    if ( root->type() != chem::antechamberRoot ) {
chemInfo.cc:1792:            << "instead we have" << (unsigned long)(root.get()) << " of type: " << root->type();
chemInfo.cc:1796:    if ( !this->matchBasic(antechamberRoot,bond->getOtherAtom(from)) ) goto FAIL;
chemInfo.cc:1797:    ANN(this->_AtomProperties);
chemInfo.cc:1798:    if ( this->_AtomProperties.notnilp() )
chemInfo.cc:1800:        if ( !this->_AtomProperties->matches(antechamberRoot,from,bond) ) goto FAIL;
chemInfo.cc:1813:    this->Base::initialize();
chemInfo.cc:1814:    this->_Element = "";
chemInfo.cc:1815:    this->_Neighbors = 0;
chemInfo.cc:1816:    this->_AtomProperties.reset();
chemInfo.cc:1817:    this->_Tag = "";
chemInfo.cc:1818:    this->_AtomProperties = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:1826:    node->attribute("element",this->_Element);
chemInfo.cc:1827:    node->attribute("neighbors", this->_Neighbors );
chemInfo.cc:1828:    node->attribute("tag",this->_Tag);
chemInfo.cc:1829:    node->archiveObjectIfDefined("atomProps", this->_AtomProperties);
chemInfo.cc:1839:// ------- Root
chemInfo.cc:1843:    if ( this->isNil() )
chemInfo.cc:1845:	LOG(BF("this isNil - returning 0"));
chemInfo.cc:1848:    uint res = MAX(this->_FirstTest->depth(),this->_Chain->depth()+1);
chemInfo.cc:1856:    ss << this->_FirstTest->asSmarts() << "(" << this->_Chain->asSmarts() << ")";
chemInfo.cc:1865:    this->Base::initialize();
chemInfo.cc:1866:    this->_FirstTest = AtomOrBondMatchNode_O::_nil;
chemInfo.cc:1867:    this->_Chain = BondListMatchNode_O::_nil;
chemInfo.cc:1868:    this->_Match = ChemInfoMatch_O::_nil;
chemInfo.cc:1869:    this->_Tests = core::Binder_O::create();
chemInfo.cc:1875:    LOG(BF("Adding test<%s> with code: %s") % testSym->__repr__() % testCode->__repr__() );
chemInfo.cc:1876:    this->_Tests->extend(testSym,testCode);
chemInfo.cc:1882:    ASSERTF(testSym.notnilp(),BF("The test symbol was nil! - this should never occur"));
chemInfo.cc:1883:    LOG(BF("Looking up test with symbol<%s>") % testSym->__repr__() );
chemInfo.cc:1884:    core::Binder_O::iterator it = this->_Tests->find(testSym);
chemInfo.cc:1885:    if ( it == this->_Tests->end() )
chemInfo.cc:1887:	SIMPLE_ERROR(BF("Could not find named ChemInfo/Smarts test[%s] in Smarts object - available named tests are[%s]") % testSym->__repr__() % this->_Tests->allKeysAsString() );
chemInfo.cc:1889:    core::Function_sp testCode = this->_Tests->indexed_value(it->second)->as<core::Function_O>();
chemInfo.cc:1890:    ASSERTF(testCode.notnilp(),BF("testCode was nil - it should never be"));
chemInfo.cc:1893:    LOG(BF("evaluating test: %s") % exp->__repr__() );
chemInfo.cc:1895:    return res->isTrue();
chemInfo.cc:1904:    node->archiveObjectIfDefined("firstTest",this->_FirstTest);
chemInfo.cc:1905:    node->archiveObjectIfDefined("chain",this->_Chain);
chemInfo.cc:1906:    node->archiveObjectIfDefined("tests",this->_Tests);
chemInfo.cc:1908:    LOG(BF("After load chain=%s") % this->_Chain->description().c_str()  );
chemInfo.cc:1915:    LOG(BF("Root_O trying to match pattern: %s") % this->asSmarts() );
chemInfo.cc:1916:    return this->matches(root,bond->getOtherAtom(from));
chemInfo.cc:1927:    ANN(this->_FirstTest);
chemInfo.cc:1928:    if ( this->_FirstTest.notnilp() )
chemInfo.cc:1930:	LOG(BF("_FirstTest is notNil - testing"));
chemInfo.cc:1931:        if ( !this->_FirstTest->matches(root,atom) ) goto FAIL;
chemInfo.cc:1933:    ANN(this->_Chain);
chemInfo.cc:1934:    if ( this->_Chain.notnilp() )
chemInfo.cc:1936:	LOG(BF("_Chain is not Nil - testing "));
chemInfo.cc:1937://	nextBonds = atom->getHeavyAtomBondList();
chemInfo.cc:1938:	nextBonds = atom->getBondList();
chemInfo.cc:1939:        if ( !this->_Chain->matches(root,atom,nextBonds) ) goto FAIL;
chemInfo.cc:1964:    this->Base::archiveBase(node);
chemInfo.cc:1971:    this->archiveBase(node);
chemInfo.cc:1978:    return this->matches(root,bond->getOtherAtom(from));
chemInfo.cc:1987:    LOG(BF("SmartsRoot matching pattern: %s") % this->asSmarts() );
chemInfo.cc:1988:    LOG(BF("SmartsRoot match for atom: %s") % atom->description() );
chemInfo.cc:1989:    if ( !this->Root_O::matches(root,atom) ) goto FAIL;
chemInfo.cc:2001:    this->Base::initialize();
chemInfo.cc:2002:    this->_AssignType = "";
chemInfo.cc:2003:    this->_AfterMatchTests = RootMatchNode_O::_nil;
chemInfo.cc:2004:    this->_WildElementDictionary = WildElementDict_O::_nil;
chemInfo.cc:2010:    this->Base::archiveBase(node);
chemInfo.cc:2011:    node->attribute( "assignType", this->_AssignType );
chemInfo.cc:2012:    node->archiveObjectIfDefined( "afterMatchTests", this->_AfterMatchTests );
chemInfo.cc:2013:    node->archiveObjectIfDefined( "wildDict", this->_WildElementDictionary);
chemInfo.cc:2021:    this->archiveBase(node);
chemInfo.cc:2028:    return this->matches(root,bond->getOtherAtom(from));
chemInfo.cc:2041:    if ( !this->Base::matches(root, atom )) {
chemInfo.cc:2044:    ANN(this->_AfterMatchTests);
chemInfo.cc:2045:    if ( this->_AfterMatchTests.notnilp() )
chemInfo.cc:2047:        if ( !this->_AfterMatchTests->matches(root) ) {
chemInfo.cc:2051:    atom->setTypeString(this->_AssignType);
chemInfo.cc:2052:    LOG(BF("Matched and assigned type(%s)") % this->_AssignType.c_str() );
chemInfo.cc:2087:    sstr << e._code->compilerMessage() << endl;
chemInfo.cc:2103:    me->compileSmarts(smarts);
chemInfo.cc:2104:    me->defineTests(tests);
chemInfo.cc:2105:    if ( !me->compileSucceeded() )
chemInfo.cc:2107:	  SIMPLE_ERROR(BF("%s") % me->compilerMessage());
chemInfo.cc:2116:    core::Cons_sp tests = translate::from_object<core::Cons_O>::convert(bargs->lookup(Pkg(),"tests"));
chemInfo.cc:2117:    string smarts = translate::from_object<string>::convert(bargs->lookup(Pkg(),"smarts"));
chemInfo.cc:2118:    this->compileSmarts(smarts);
chemInfo.cc:2119:    this->defineTests(tests);
chemInfo.cc:2120:    if ( !this->compileSucceeded() )
chemInfo.cc:2122:	SIMPLE_ERROR(this->compilerMessage());
chemInfo.cc:2131:    return this->_Root->asSmarts();
chemPackage.cc:36://	    _lisp->usePackage(CorePkg);
chemPackage.cc:50:	    defNoWrapPackage(ChemPkg,"atomAliases", &core::prim_list ,_lisp->lisp());
chemPackage.cc:51:	    defNoWrapPackage(ChemPkg,"aliasAtoms", &core::prim_list ,_lisp->lisp());
chemPackage.cc:52:	    defNoWrapPackage(ChemPkg,"addPart", &core::prim_list ,_lisp->lisp());
chemPackage.cc:53:	    defNoWrapPackage(ChemPkg,"parts", &core::prim_list ,_lisp->lisp());
chemPackage.cc:54:	    defNoWrapPackage(ChemPkg,"monomerAlias", &core::prim_list ,_lisp->lisp());
chemPackage.cc:64:	    _lisp->defvar(_sym_candoDatabase,cdb);
chemPackage.cc:96:	return _sym_candoDatabase->symbolValue()->as<CandoDatabase_O>();
chemPackage.cc:121:	_lisp->installPackage(chemPkgP);
chemdraw.cc:51:	this->Base::initialize();
chemdraw.cc:52:	this->_Atom = Atom_O::_nil;
chemdraw.cc:58:	if ( node->hasChildrenWithName("t") )
chemdraw.cc:60:	    core::QDomNode_sp text = node->childWithName("t");
chemdraw.cc:61:	    if ( text->hasChildrenWithName("s") )
chemdraw.cc:63:		core::QDomNode_sp xmls = text->childWithName("s");
chemdraw.cc:64:		string name = xmls->getData();
chemdraw.cc:68:	return "C_"+node->getAttributeString("id");
chemdraw.cc:74:	vector<string> parts = core::split(this->getLabel(),"/");
chemdraw.cc:84:		if ( ionstr[i] == '-' ) ionization--;
chemdraw.cc:87:	LOG(BF("parsed[%s] into name[%s] ionization[%d]") % this->getLabel() % name % ionization );
chemdraw.cc:91:	this->_Id = xml->getAttributeInt("id");
chemdraw.cc:92:	this->_Label = this->_extractLabel(xml);
chemdraw.cc:93:	LOG(BF("Parsing CDNode with label: %s") % this->_Label);
chemdraw.cc:94:	this->_StereochemistryType = undefinedCenter;
chemdraw.cc:95:	this->_Configuration = undefinedConfiguration;
chemdraw.cc:96:	if ( xml->hasAttribute("Geometry") )
chemdraw.cc:98:	    this->_StereochemistryType = chiralCenter;
chemdraw.cc:99:	    string geometry = xml->getAttributeString("Geometry");
chemdraw.cc:100:	    if ( xml->hasAttribute("AS") )
chemdraw.cc:102:		string as = xml->getAttributeString("AS");
chemdraw.cc:106:		    this->_Configuration = S_Configuration;
chemdraw.cc:110:		    this->_Configuration = R_Configuration;
chemdraw.cc:125:	this->_Neighbors.push_back(bd);
chemdraw.cc:130:	this->bondTo(other,o);
chemdraw.cc:131:	other->bondTo(this->sharedThis<CDNode_O>(),o);
chemdraw.cc:137:	this->Base::initialize();
chemdraw.cc:138:	this->_BeginNode = CDNode_O::_nil;
chemdraw.cc:139:	this->_EndNode = CDNode_O::_nil;
chemdraw.cc:144:	switch ( this->_Order )
chemdraw.cc:161:	switch ( this->_Order )
chemdraw.cc:179:	this->_IdBegin = xml->getAttributeInt("B");
chemdraw.cc:180:	this->_IdEnd = xml->getAttributeInt("E");
chemdraw.cc:181:	string order = xml->getAttributeStringDefault("Order","1");
chemdraw.cc:182:	string display = xml->getAttributeStringDefault("Display","");
chemdraw.cc:187:		this->_Order = singleDashCDBond;
chemdraw.cc:190:		this->_Order = hashCDBond;
chemdraw.cc:193:		this->_Order = singleCDBond;
chemdraw.cc:197:	    if ( display == "Dash" ) this->_Order = doubleDashCDBond;
chemdraw.cc:200:	    this->_Order = doubleCDBond;
chemdraw.cc:203:	    this->_Order = tripleCDBond;
chemdraw.cc:206:	    this->_Order = dativeCDBond;
chemdraw.cc:209:	    this->_Order = unknownCDBond;
chemdraw.cc:216:	this->Base::initialize();
chemdraw.cc:217:	this->_ConstitutionName = _Nil<core::Symbol_O>();
chemdraw.cc:218:	this->_Nodes.clear();
chemdraw.cc:219:	this->_AtomsToNodes.clear();
chemdraw.cc:220:	this->_Bonds.clear();
chemdraw.cc:221:	this->_LargestId = -1;
chemdraw.cc:222:	this->_RootNode = CDNode_O::_nil;
chemdraw.cc:228:	Atom_sp fromAtom = fromNode->getAtom();
chemdraw.cc:229:	LOG(BF("From %s") % fromAtom->description() );
chemdraw.cc:231:	a->setContainedBy(Residue_O::_nil);
chemdraw.cc:232:	a->setName(name);
chemdraw.cc:233:	a->setElement(element_H);
chemdraw.cc:235:	fromAtom->bondTo(a,singleBond);
chemdraw.cc:237:	toNode->setAtom(a);
chemdraw.cc:238:	toNode->setLabel(name);
chemdraw.cc:239:	toNode->setId(this->_LargestId+1);
chemdraw.cc:240:	this->_LargestId++;
chemdraw.cc:241:	this->_Nodes[toNode->getId()] = toNode;
chemdraw.cc:242:	this->_AtomsToNodes[a] = toNode;
chemdraw.cc:244:	bond->setIdBegin(fromNode->getId());
chemdraw.cc:245:	bond->setIdEnd(toNode->getId());
chemdraw.cc:246:	bond->setBeginNode(fromNode);
chemdraw.cc:247:	bond->setEndNode(toNode);
chemdraw.cc:248:	bond->setOrder(singleCDBond);
chemdraw.cc:249:	this->_Bonds.push_back(bond);
chemdraw.cc:257:	this->_Nodes.clear();
chemdraw.cc:258:	this->_AtomsToNodes.clear();
chemdraw.cc:259:	for ( it=fragment->begin_Children(); it!=fragment->end_Children(); it++ )
chemdraw.cc:262:	    if ( child->getLocalName() == "n" )
chemdraw.cc:265:		node->parseFromXml(child);
chemdraw.cc:266:		int id = node->getId();
chemdraw.cc:267:		if ( id > this->_LargestId )
chemdraw.cc:268:		    this->_LargestId = id;
chemdraw.cc:269:		this->_Nodes[id] = node;
chemdraw.cc:270:		LOG(BF("Processed node label(%s)") % node->getLabel()  );
chemdraw.cc:273:	for ( it=fragment->begin_Children(); it!=fragment->end_Children(); it++ )
chemdraw.cc:276:	    if ( child->getLocalName() == "b" )
chemdraw.cc:279:		bond->parseFromXml(child);
chemdraw.cc:280:		uint idBegin = bond->getIdBegin();
chemdraw.cc:281:		uint idEnd = bond->getIdEnd();
chemdraw.cc:282:		ASSERT(this->_Nodes.count(idBegin)>0);
chemdraw.cc:283:		ASSERT(this->_Nodes.count(idEnd)>0);
chemdraw.cc:284:		CDNode_sp nodeBegin = this->_Nodes[idBegin];
chemdraw.cc:285:		CDNode_sp nodeEnd = this->_Nodes[idEnd];
chemdraw.cc:286:		bond->setBeginNode( nodeBegin );
chemdraw.cc:287:		bond->setEndNode( nodeEnd);
chemdraw.cc:288:		this->_Bonds.push_back(bond);
chemdraw.cc:290:		    % bond->getOrderAsString() % nodeBegin->getLabel() % nodeEnd->getLabel()  );
chemdraw.cc:299:	this->_Properties->addAllBindings(d);
chemdraw.cc:323:	// trim off white-space and put it in the _Properties
chemdraw.cc:326:	keyword = _lisp->internKeyword(trimKey);
chemdraw.cc:327:	obj = _lisp->create<core::Str_O>(trimValue);
chemdraw.cc:336:	return this->getProperties()->contains(key);
chemdraw.cc:342:	if ( this->hasProperty(key) )
chemdraw.cc:344:	    SIMPLE_ERROR(BF("You have already set the property(%s) it has the value(%s) and you are trying to set it with(%s)") % key->__repr__() % this->_Properties->lookup(key)->__repr__() % obj->__repr__()  );
chemdraw.cc:346:	LOG(BF("Setting variable(%s) class(%s) to %s") % key % obj->className() % obj->__repr__() );
chemdraw.cc:347:	this->_Properties->extend(key,obj);
chemdraw.cc:356:	for ( core::Binder_O::iterator mi=this->_Properties->begin(); mi!=this->_Properties->end(); mi++ )
chemdraw.cc:358:	    ss << mi->first->__repr__() << " classname(" << this->_Properties->indexed_value(mi->second)->className()
chemdraw.cc:359:	       << ") value=" << this->_Properties->indexed_value(mi->second)->__repr__() << endl;
chemdraw.cc:381:	if ( this->_Bonds.size() == 0 )
chemdraw.cc:386:	LOG(BF("Starting a new fragment, number of bonds = %d") % this->_Bonds.size() );
chemdraw.cc:389:	core::StringSet_sp allNames = _lisp->create<core::StringSet_O>();
chemdraw.cc:390:	this->_Properties = _lisp->create<core::Binder_O>();
chemdraw.cc:392:	    for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
chemdraw.cc:393:	    { _BLOCK_TRACEF(BF("Processing bond with order: %s") % (*bi)->getOrderAsString() );
chemdraw.cc:394:		LOG(BF("label Begin = %s") % ((*bi)->getBeginNode()->getLabel())  );
chemdraw.cc:395:		LOG(BF("label End   = %s") % ((*bi)->getEndNode()->getLabel())  );
chemdraw.cc:396:		allNames->insert((*bi)->getBeginNode()->getLabel());
chemdraw.cc:397:		allNames->insert((*bi)->getEndNode()->getLabel());
chemdraw.cc:399:		// Dative bonds must have form begin(XXX:)->end(YYY)
chemdraw.cc:402:		if ( (*bi)->getOrder() == dativeCDBond )
chemdraw.cc:404:		    string beginLabel = (*bi)->getBeginNode()->getLabel();
chemdraw.cc:405:		    string endLabel = (*bi)->getEndNode()->getLabel();
chemdraw.cc:408:		    this->_Properties->extend(_lisp->internKeyword(propertyStr),core::Str_O::create(valueStr,_lisp));
chemdraw.cc:410:		} else if ( (*bi)->getOrder() == hashCDBond )
chemdraw.cc:418:		    bool koBegin = this->_asKeyedObject((*bi)->getBeginNode()->getLabel(),kwBegin,objBegin);
chemdraw.cc:419:		    bool koEnd = this->_asKeyedObject((*bi)->getEndNode()->getLabel(),kwEnd,objEnd);
chemdraw.cc:430:			rootNode = (*bi)->getEndNode();
chemdraw.cc:437:								   + (*bi)->getBeginNode()->getLabel()
chemdraw.cc:438:								   + " - "
chemdraw.cc:439:								   + (*bi)->getEndNode()->getLabel()
chemdraw.cc:444:			rootNode = (*bi)->getBeginNode();
chemdraw.cc:446:		    if ( kwPart->isNil() )
chemdraw.cc:450:			serr << "On one side the label is ["<< (*bi)->getBeginNode()->getLabel() << "]"<<endl;
chemdraw.cc:451:			serr << "On the other side the label is ["<< (*bi)->getEndNode()->getLabel() << "]"<<endl;
chemdraw.cc:454:		    core::Symbol_sp sym = _lisp->intern(objPart->as<core::Str_O>()->get());
chemdraw.cc:455:		    this->_Properties->extend(kwPart,sym);
chemdraw.cc:456:		    this->_RootNode = rootNode;
chemdraw.cc:457:		    LOG(BF("Assigned rootNode: %s") % sym->__repr__() );
chemdraw.cc:461:		    LOG(BF("Doing nothing with bond type(%s)") % (*bi)->getOrderAsString()  );
chemdraw.cc:465:	ASSERTF(foundHashedBond,BF("There was no hashed bond for fragment containing the following atoms: %s") % allNames->asString() );
chemdraw.cc:466:	ASSERTF(this->_RootNode.notnilp(),BF("Read a fragment that did not have a _RootNode defined"));
chemdraw.cc:467:	this->createAtoms();
chemdraw.cc:470:	Residue_sp res = this->getEntireResidue();
chemdraw.cc:471:	core::Cons_sp carbons = res->allAtomsOfElementAsList(element_C);
chemdraw.cc:473:	    for ( core::Cons_sp cur = carbons; cur.notnilp(); cur=cur->cdr() )
chemdraw.cc:475:		Atom_sp c = cur->car<Atom_O>();
chemdraw.cc:476:		ASSERT(this->_AtomsToNodes.count(c)>0);
chemdraw.cc:477:		CDNode_sp fromNode = this->_AtomsToNodes[c];
chemdraw.cc:478:		core::Cons_sp hydrogens = c->createImplicitHydrogenNamesOnCarbon();
chemdraw.cc:479:		LOG(BF("Creating implicit hydrogens for %s named %s") % c->description() % hydrogens->__repr__()  );
chemdraw.cc:480:		for ( core::Cons_sp ih=hydrogens; ih.notnilp(); ih=ih->cdr() )
chemdraw.cc:482:		    string name = ih->car<core::Str_O>()->get();
chemdraw.cc:483:		    this->createImplicitHydrogen(fromNode,name);
chemdraw.cc:487:	Residue_sp everything = this->getEntireResidue();
chemdraw.cc:495:	    cip->defineStereochemicalConfigurationsForAllAtoms(everything);
chemdraw.cc:502:	ConstitutionAtoms_sp ca = this->asConstitutionAtoms();
chemdraw.cc:503:	this->setProperty(_lisp->internKeyword("constitutionAtoms"),ca);
chemdraw.cc:504:	Residue_sp builtResidue = ca->makeResidue();
chemdraw.cc:505:	this->setProperty(_lisp->internKeyword("builtResidue"),builtResidue);
chemdraw.cc:513:	a->setContainedBy(Residue_O::_nil);
chemdraw.cc:514:	n->setAtom(a);
chemdraw.cc:517:	n->getParsedLabel(name,ionization);
chemdraw.cc:518:	a->setName(name);
chemdraw.cc:519:	a->setIonization(ionization);
chemdraw.cc:520:	a->setElementFromName();
chemdraw.cc:521:	a->setStereochemistryType(n->_StereochemistryType);
chemdraw.cc:522:	a->setConfiguration(n->_Configuration);
chemdraw.cc:524:		     % a->__repr__() % a->getConfigurationAsString() );
chemdraw.cc:525:	ASSERT(elementIsRealElement(a->getElement()));
chemdraw.cc:536:	for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
chemdraw.cc:538:	    CDBondOrder o = ( (*bi)->getOrder() );
chemdraw.cc:542:		CDNode_sp n = (*bi)->getBeginNode();
chemdraw.cc:543:		if ( n->getAtom()->isNil() ) 
chemdraw.cc:545:		    Atom_sp a = this->createOneAtom(n);
chemdraw.cc:546:		    this->_AtomsToNodes[a] = n;
chemdraw.cc:548:		n = (*bi)->getEndNode();
chemdraw.cc:549:		if ( n->getAtom()->isNil() ) 
chemdraw.cc:551:		    Atom_sp a = this->createOneAtom(n);
chemdraw.cc:552:		    this->_AtomsToNodes[a] = n;
chemdraw.cc:561:	core::Binder_sp dict = this->getProperties();
chemdraw.cc:562:	if ( !dict->contains(s) )
chemdraw.cc:565:	    serr << "Fragment(" << this->getConstitutionName()->__repr__() << ") is missing property: " << s->__repr__() << endl;
chemdraw.cc:567:	    serr << dict->summaryOfContents() << endl;
chemdraw.cc:570:	return dict->lookup(s);
chemdraw.cc:575:	core::Binder_sp dict = this->getProperties();
chemdraw.cc:576:	if ( dict->contains(s) )
chemdraw.cc:578:	    return dict->lookup(s);
chemdraw.cc:586:	for ( CDBonds::iterator bi=this->_Bonds.begin();
chemdraw.cc:587:	      bi!=this->_Bonds.end(); bi++ )
chemdraw.cc:589://	    CDBondOrder o = ( (*bi)->getOrder() );
chemdraw.cc:590:	    BondOrder bo = (*bi)->getOrderAsBondOrder();
chemdraw.cc:591:	    Atom_sp a1 = (*bi)->getBeginNode()->getAtom();
chemdraw.cc:593:	    if ( a1->isNil() ) continue;
chemdraw.cc:594:	    Atom_sp a2 = (*bi)->getEndNode()->getAtom();
chemdraw.cc:596:	    if ( a2->isNil() ) continue;
chemdraw.cc:598:	    if ( selectedAtomsOnly && (!a1->testAllFlags(SELECTED) || !a2->testAllFlags(SELECTED)) )
chemdraw.cc:604:		LOG(BF("Creating a bond between %s and %s order: %s") % a1->description() % a2->description() % bondOrderToString(bo)  );
chemdraw.cc:605:		a1->bondTo(a2,bo);
chemdraw.cc:613:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
chemdraw.cc:615:	    Atom_sp a = (*ni).second->getAtom();
chemdraw.cc:618:		LOG(BF("Removing bonds for atom: %s") % a->description()  );
chemdraw.cc:619:		a->removeAllBonds();
chemdraw.cc:628:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
chemdraw.cc:630:	    Atom_sp a = (*ni).second->getAtom();
chemdraw.cc:633:		a->resetFlags();
chemdraw.cc:643:	for ( ni = this->_Nodes.begin(); ni!=this->_Nodes.end(); ni++ )
chemdraw.cc:645:	    Atom_sp a = (*ni).second->getAtom();
chemdraw.cc:648:		if ( a->testAllFlags(SELECTED) ) res->addAtom(a);
chemdraw.cc:664:	this->clearAtomSelected();
chemdraw.cc:665:	this->removeAllBonds();
chemdraw.cc:666:	this->createBonds(false);
chemdraw.cc:673:	    span->setOnlyFollowRealBonds(constitutionOnly);
chemdraw.cc:674:	    ASSERTNOTNULL(this->_RootNode);
chemdraw.cc:675:	    ASSERTP(this->_RootNode.notnilp(),"Every fragment must have a root node");
chemdraw.cc:676:	    span->setTop(this->_RootNode->getAtom());
chemdraw.cc:677:	    while ( span->advance() )
chemdraw.cc:679:		Atom_sp a = span->getAtom();
chemdraw.cc:680:		a->turnOnFlags(SELECTED);
chemdraw.cc:681:		LOG(BF("Selected %s") % a->description()  );
chemdraw.cc:687:	this->removeAllBonds();
chemdraw.cc:691:	this->createBonds(true);
chemdraw.cc:692:	Residue_sp res = this->createResidueOfSelectedAtoms();
chemdraw.cc:693:	ASSERTP(res->contentSize()>0,"The residue is empty");
chemdraw.cc:708:	return this->_buildResidue(false);
chemdraw.cc:713:	Residue_sp residue = this->_buildResidue(true);
chemdraw.cc:714:	return _lisp->create<ConstitutionAtoms_O>(residue);
chemdraw.cc:722:	ss << "#S(" << this->className() << " ";
chemdraw.cc:723:	ss << this->_Properties->__repr__();
chemdraw.cc:738:    me->_CDText._Properties = kprops;
chemdraw.cc:739:    me->_CDText._Text = "n/a";
chemdraw.cc:750:	this->Base::__init__(exec,args,env,lisp);
chemdraw.cc:751:	core::Cons_sp props = env->lookup(lisp->internWithPackageName(ChemPkg,"props"))->as<core::Cons_O>();
chemdraw.cc:752:	core::Binder_sp kprops = env->lookup(lisp->internWithPackageName(ChemPkg,"kprops"))->as<core::Binder_O>();
chemdraw.cc:753:	this->_Properties = kprops;
chemdraw.cc:754:	this->_Text = "n/a";
chemdraw.cc:763:	this->Base::initialize();
chemdraw.cc:764:	this->_Properties = core::Binder_O::create();
chemdraw.cc:770:	return this->_Properties->size()>0; 
chemdraw.cc:780:	core::QDomNode_sp sub = text->childWithName("s");
chemdraw.cc:781:	this->_Text = core::trimWhiteSpace(sub->getData());
chemdraw.cc:782:	if ( this->_Text[0] != '(' )
chemdraw.cc:787:	core::StringInStream_sp sin = core::StringInStream_O::create(this->_Text,lisp);
chemdraw.cc:790:	core::Cons_sp block = reader->read(true,core::T_O::_nil)->as<core::Cons_O>();
chemdraw.cc:792:	core::Cons_sp block = read_lisp_object(sin,true,core::T_O::_nil,false,_lisp)->as<core::Cons_O>();
chemdraw.cc:793:	sin->close();
chemdraw.cc:795:	LOG(BF("Parsed text block: %s\n") % this->_Text);
chemdraw.cc:796:	if ( block->isNil() )
chemdraw.cc:798:	    SIMPLE_ERROR(BF("Error compiling code:\n"+this->_Text));
chemdraw.cc:800:	LOG(BF("About to evaluate CDText: %s") % block->__repr__() );
chemdraw.cc:802:	this->_Properties = core::Binder_O::createFromKeywordCons(result->as<core::Cons_O>(),validChemdrawKeywords,lisp);
chemdraw.cc:846:	this->Base::initialize();
chemdraw.cc:865:    me->parseFromFileName(fileName);
chemdraw.cc:873:	string fileName = env->lookup(lisp->internWithPackageName(ChemPkg,"fileName"))->as<core::Str_O>()->get();
chemdraw.cc:875:	this->parseFromFileName(fileName);
chemdraw.cc:891:	CDFragment_sp frag = this->_NamedFragments.get(name,_lisp);
chemdraw.cc:893:	frag->addProperties(propertiesAsBinder);
chemdraw.cc:901:	if ( !kargs->contains(_kw_name) )
chemdraw.cc:904:	    ss << "Properties for ChemDraw Fragments must have a (name) property, what was passed has: " << kargs->description();
chemdraw.cc:907:	string name = kargs->lookup(_kw_name)->as<core::Str_O>()->get();
chemdraw.cc:908:	if ( !this->_NamedFragments.contains(name) )
chemdraw.cc:914:	CDFragment_sp frag = this->_NamedFragments.get(name);
chemdraw.cc:915:	frag->addProperties(kargs);
chemdraw.cc:922:	if ( !xml->hasChildrenWithName("page") )
chemdraw.cc:926:	core::QDomNode_sp page = xml->childWithName("page");
chemdraw.cc:928:	this->_NamedFragments.clear();
chemdraw.cc:929:	for ( it=page->begin_Children(); it!=page->end_Children(); it++ )
chemdraw.cc:932:	    if ( child->getLocalName() == "fragment" )
chemdraw.cc:935:		fragment->parseFromXml(child);
chemdraw.cc:936:		if ( fragment->interpret() )
chemdraw.cc:938:		    core::Binder_sp properties = fragment->getProperties();
chemdraw.cc:939:		    if ( !properties->contains(_lisp->internKeyword("name") ))
chemdraw.cc:943:		    core::Symbol_sp constitutionName = properties->lookup(_lisp->internKeyword("name"))->as<core::Symbol_O>();
chemdraw.cc:944:		    fragment->setConstitutionName(constitutionName);
chemdraw.cc:945:		    this->_NamedFragments.set(constitutionName,fragment);
chemdraw.cc:946:		    this->_AllFragments.append(fragment);
chemdraw.cc:950:	for ( it=page->begin_Children(); it!=page->end_Children(); it++ )
chemdraw.cc:953:	    if ( child->getLocalName() == "t" )
chemdraw.cc:956:		text->parseFromXml(child,_lisp);
chemdraw.cc:957:		if ( text->hasProperties() )
chemdraw.cc:959:		    LOG(BF("Found properties: %s") % text->__repr__() );
chemdraw.cc:960:		    core::Binder_sp properties = text->getProperties();
chemdraw.cc:961:		    if (!properties->contains(_lisp->internKeyword("name")) )
chemdraw.cc:965:		    core::Symbol_sp constitutionName = properties->lookup(_lisp->internKeyword("name"))->as<core::Symbol_O>();
chemdraw.cc:966:		    if ( !this->_NamedFragments.contains(constitutionName) )
chemdraw.cc:968:			SIMPLE_ERROR(BF("Could not find fragment with name("+constitutionName->__repr__()+")"));
chemdraw.cc:970:		    CDFragment_sp fragment = this->_NamedFragments.get(constitutionName,_lisp);
chemdraw.cc:971:		    fragment->addProperties(properties);
chemdraw.cc:980:	core::Cons_sp fragments = this->allFragmentsAsCons();
chemdraw.cc:981:	Aggregate_sp agg = _lisp->create<Aggregate_O>();
chemdraw.cc:982:	for ( core::Cons_sp cur = fragments; cur.notnilp(); cur=cur->cdr() )
chemdraw.cc:984:	    Molecule_sp mol = _lisp->create<Molecule_O>();
chemdraw.cc:985:	    CDFragment_sp frag = core::oCar(cur)->as<CDFragment_O>();
chemdraw.cc:986:	    Residue_sp res = frag->getEntireResidue();
chemdraw.cc:987:	    string name = frag->getProperty(_lisp->internKeyword("name"))->as<core::Symbol_O>()->symbolName();
chemdraw.cc:988:	    res->setName(name);
chemdraw.cc:989:	    mol->setName(name);
chemdraw.cc:990:	    mol->addMatter(res);
chemdraw.cc:991:	    agg->addMatter(mol);
chemdraw.cc:1000:	for ( fi=this->_AllFragments.begin(); fi!=this->_AllFragments.end(); fi++ )
chemdraw.cc:1014:	for ( fi=this->_NamedFragments.begin(); fi!=this->_NamedFragments.end(); fi++ )
chemdraw.cc:1016:	    if ( namesOfSubSet->contains(fi->first) )
chemdraw.cc:1018:		namesChosen->insert(fi->first);
chemdraw.cc:1019:		core::Cons_sp n = core::Cons_O::create(fi->second,frags,_lisp);
chemdraw.cc:1023:	if ( namesChosen->size() != namesOfSubSet->size() )
chemdraw.cc:1025:	    core::SymbolSet_sp diff = namesOfSubSet->relativeComplement(namesChosen);
chemdraw.cc:1028:	    ss << diff->asString();
chimera.cc:22:	string residueInfo = spec.substr(residueStart,atomNameStart-residueStart-1);
cipPrioritizer.cc:27:    return a->getAtomicNumber();
cipPrioritizer.cc:36:    void setCipPrioritizer(CipPrioritizer_sp p) { this->prior = p;};
cipPrioritizer.cc:46:	if ( prior->getP(x) <= prior->getP(y) ) return true;
cipPrioritizer.cc:59:	vector<int>&	xv = prior->getS(x);
cipPrioritizer.cc:60:	vector<int>&	yv = prior->getS(y);
cipPrioritizer.cc:70:		res = -1;
cipPrioritizer.cc:90:	    res = -1;
cipPrioritizer.cc:101:        int order = this->cmpByS(x,y);
cipPrioritizer.cc:112:    this->Base::initialize();
cipPrioritizer.cc:117:    ASSERT_lessThan(a->getRelativePriority(),this->_p.size());
cipPrioritizer.cc:118:    return this->_p[a->getRelativePriority()];
cipPrioritizer.cc:124:    if ( ! ( a->getRelativePriority() < this->_s.size() ) )
cipPrioritizer.cc:128:	LOG(BF("Bad priority for atom: %s") % a->description().c_str()  );
cipPrioritizer.cc:129:	LOG(BF("   priority value = %d") % a->getRelativePriority()  );
cipPrioritizer.cc:131:    ASSERT_lessThan(a->getRelativePriority(),this->_s.size());
cipPrioritizer.cc:132:    return this->_s[a->getRelativePriority()];
cipPrioritizer.cc:138: * partition the atoms between cBegin and cEnd-1 into classes based on orderFn
cipPrioritizer.cc:146:	if ( orderer.cmpByS(atoms[i-1],atoms[i])!=0 )
cipPrioritizer.cc:159:    prior->assignCahnIngoldPrelogPriorityToAtomsRelativePriority(matter);
cipPrioritizer.cc:178:    // in an equivalence class is assigned the priority of the -1 of the 
cipPrioritizer.cc:194:    { _BLOCK_TRACE("Stage 1 - setting initial priorities");
cipPrioritizer.cc:195:	this->_p.clear();
cipPrioritizer.cc:201:	    if ( a->isOfClass<VirtualAtom_O>() ) continue;
cipPrioritizer.cc:202:	    a->setRelativePriority(mAtoms.size());
cipPrioritizer.cc:204:	    this->_p.push_back(atomicNumber(a));
cipPrioritizer.cc:208:	byP.setCipPrioritizer(this->sharedThis<CipPrioritizer_O>());
cipPrioritizer.cc:215:	int pcur = -1;
cipPrioritizer.cc:219:	    uint idx = a->getRelativePriority();
cipPrioritizer.cc:220:	    if (pcur != this->_p[idx])
cipPrioritizer.cc:223:		pcur = this->_p[idx];
cipPrioritizer.cc:233:	    ss << "Atom: " << (*mit)->getName();
cipPrioritizer.cc:234:	    ss << " priority: " << this->getP((*mit));
cipPrioritizer.cc:236:	    if ( cidx < (int)(C.size()) && mit-mAtoms.begin() == C[cidx] )
cipPrioritizer.cc:240:	    ss << " C-class: " << cidx-1;
cipPrioritizer.cc:260:	    this->_s.clear();
cipPrioritizer.cc:261:	    this->_s.resize(mAtoms.size());
cipPrioritizer.cc:269:		    for ( vector<Bond_sp>::iterator bi=myatom->bonds_begin();
cipPrioritizer.cc:270:				 bi!=myatom->bonds_end(); bi++ )
cipPrioritizer.cc:273:			if ( (*bi)->getOrder() == singleBond ) bondOrder = 1;
cipPrioritizer.cc:274:			if ( (*bi)->getOrder() == doubleBond ) bondOrder = 2;
cipPrioritizer.cc:275:			if ( (*bi)->getOrder() == tripleBond ) bondOrder = 3;
cipPrioritizer.cc:278:			    mys.push_back(this->_p[(*bi)->getOtherAtom(myatom)->getRelativePriority()]);
cipPrioritizer.cc:287:		    this->_s[myatom->getRelativePriority()] = mys;
cipPrioritizer.cc:291:	    { _BLOCK_TRACEF(BF("STAGE2 results - there are %d classes")% C.size() );
cipPrioritizer.cc:299:		for ( zit=this->_s[(*ait)->getRelativePriority()].begin();
cipPrioritizer.cc:300:			    zit!=this->_s[(*ait)->getRelativePriority()].end();
cipPrioritizer.cc:305:		LOG(BF("  reverse sorted priorities of neighbors of %s - %s") % (*ait)->getName().c_str() % ss.str().c_str()  );
cipPrioritizer.cc:326:		    if ( classIndex == C.size()-1 )
cipPrioritizer.cc:333:		    LOG(BF("Looking at class (%u)-(%u)") % classBegin % classEnd  );
cipPrioritizer.cc:339:			    LOG(BF("Pushing back atom(use_count=%d): %s") % a.use_count() % a->description().c_str()  );
cipPrioritizer.cc:347:			byS.setCipPrioritizer(this->sharedThis<CipPrioritizer_O>());
cipPrioritizer.cc:354:			    LOG(BF("    %s") % (*ssi)->description().c_str() );
cipPrioritizer.cc:367:    sz << "After sort S[" << iiS-S.begin() << "].atom("<<(*iiS)->getName();
cipPrioritizer.cc:370:    for ( zit=this->_s[(*iiS)->getRelativePriority()].begin();
cipPrioritizer.cc:371:		zit!=this->_s[(*iiS)->getRelativePriority()].end();
cipPrioritizer.cc:383:		    LOG(BF("Replacing mAtoms from (%u)-(%u) with S") % classBegin % classEnd );
cipPrioritizer.cc:419:	    { _BLOCK_TRACEF(BF("Stage 5 - there are now %d classes") % newC.size());
cipPrioritizer.cc:433:		    if ( classIndex == C.size()-1 )
cipPrioritizer.cc:443:			this->_p[a->getRelativePriority()] = classIndex;
cipPrioritizer.cc:469:	    uint relPriority = this->_p[(*ai)->getRelativePriority()];
cipPrioritizer.cc:470:	    (*ai)->setRelativePriority(relPriority);
cipPrioritizer.cc:471:	    LOG(BF("Assigned to atom: %s priority: %d") % (*ai)->getName().c_str() % relPriority  );
cipPrioritizer.cc:479:    return p2->getRelativePriority() < p1->getRelativePriority();
cipPrioritizer.cc:484:    return p1->getName() < p2->getName();
cipPrioritizer.cc:491:    this->assignCahnIngoldPrelogPriorityToAtomsRelativePriority(molOrAgg);
cipPrioritizer.cc:497:	if ( a->isOfClass<VirtualAtom_O>() ) continue;
cipPrioritizer.cc:498:	Residue_sp res = a->getResidueContainedBy();
cipPrioritizer.cc:499:	if ( a->numberOfBonds() == 4 )
cipPrioritizer.cc:503:	    for ( vector<Bond_sp>::iterator bi = a->bonds_begin(); bi!=a->bonds_end(); bi++ )
cipPrioritizer.cc:505:		priority.push_back((*bi)->getOtherAtom(a));
cipPrioritizer.cc:515:		if ( (*pi)->getRelativePriority() != prevPriority )
cipPrioritizer.cc:519:		prevPriority = (*pi)->getRelativePriority();
cipPrioritizer.cc:525:		if ( a->getStereochemistryType() != chiralCenter )
cipPrioritizer.cc:527:		    a->setStereochemistryType(chiralCenter);
cipPrioritizer.cc:528:		    a->setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:535:		a->setStereochemistryType(prochiralCenter);
cipPrioritizer.cc:536:		a->setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:540:	    a->setConfiguration(undefinedConfiguration);
cipPrioritizer.cc:541:	    a->setStereochemistryType(undefinedCenter);
complexRestraints.cc:51:    this->Base::initialize();
complexRestraints.cc:57:    this->Base::archiveBase(node);
complexRestraints.cc:105:    node->attribute( "Configuration",this->_Configuration);
complexRestraints.cc:106://    node->attribute( "Priority1AtomOnAtomX",this->_Priority1AtomOnAtomX);
complexRestraints.cc:107://    node->attribute( "Priority2AtomOnAtomX",this->_Priority2AtomOnAtomX);
complexRestraints.cc:108:    node->attribute( "PiAtomX",this->_PiAtomX);
complexRestraints.cc:109://    node->attribute( "Priority1AtomOnAtomY",this->_Priority1AtomOnAtomY);
complexRestraints.cc:110://    node->attribute( "Priority2AtomOnAtomY",this->_Priority2AtomOnAtomY);
complexRestraints.cc:111:    node->attribute( "PiAtomY",this->_PiAtomY);
complexRestraints.cc:123:    me->_Configuration = config;
complexRestraints.cc:124:    if ( me->_Configuration != "E" && me->_Configuration != "Z" )
complexRestraints.cc:128:    if ( piAtoms->length() != 2 )
complexRestraints.cc:132:    me->_PiAtomX = piAtoms->car<core::Str_O>()->get();
complexRestraints.cc:133:    me->_PiAtomY = piAtoms->cadr<core::Str_O>()->get();
complexRestraints.cc:141:    this->_Configuration = env->lookup(Pkg(),"config")->as<core::Str_O>()->get();
complexRestraints.cc:142:    core::Cons_sp piAtoms = env->lookup(Pkg(),"piAtoms")->as<core::Cons_O>();
complexRestraints.cc:143:    if ( this->_Configuration != "E" && this->_Configuration != "Z" )
complexRestraints.cc:147:    if ( piAtoms->length() != 2 )
complexRestraints.cc:151:    this->_PiAtomX = piAtoms->car<core::Str_O>()->get();
complexRestraints.cc:152:    this->_PiAtomY = piAtoms->cadr<core::Str_O>()->get();
complexRestraints.cc:163:    dih->setAtomA(p1X);
complexRestraints.cc:164:    dih->setAtomB(pX);
complexRestraints.cc:165:    dih->setAtomC(pY);
complexRestraints.cc:166:    dih->setAtomD(p1Y);
complexRestraints.cc:167:    dih->setParameters(min,max,weight);
complexRestraints.cc:168:    residue->addRestraint(dih);
complexRestraints.cc:187:    string config = this->_Configuration;
complexRestraints.cc:188:    Atom_sp pX  = residue->atomWithName(this->getPiAtomX());
complexRestraints.cc:189:    Atom_sp pY  = residue->atomWithName(this->getPiAtomY());
complexRestraints.cc:191:    Atom_sp p1X = pX->highestPriorityNeighborThatIsnt(pY);
complexRestraints.cc:192:    Atom_sp p2X = pX->lowestPriorityNeighborThatIsnt(pY);
complexRestraints.cc:197:    Atom_sp p1Y = pY->highestPriorityNeighborThatIsnt(pX);
complexRestraints.cc:198:    Atom_sp p2Y = pY->lowestPriorityNeighborThatIsnt(pX);
complexRestraints.cc:203:    if ( pX->numberOfBonds() < 2 || pX->numberOfBonds() > 3  )
complexRestraints.cc:206:	ss << "Dihedral restraints X atom: " << this->_PiAtomX;
complexRestraints.cc:207:	ss << " must have between 2 and 3 bonds - it has " << pX->numberOfBonds();
complexRestraints.cc:208:	SIMPLE_ERROR(BF("Dihedral restraints Y atom: %s") % this->_PiAtomY );
complexRestraints.cc:209:	ss << " must have between 2 and 3 bonds - it has " << pY->numberOfBonds();
complexRestraints.cc:212:    double transMin = -170.0;
complexRestraints.cc:215:    double cisMax = -10.0;
complexRestraints.cc:219:	this->fillOneDihedralRestraint(residue,p1X,pX,pY,p1Y,cisMin,cisMax,weight);
complexRestraints.cc:222:	    this->fillOneDihedralRestraint(residue,p1X,pX,pY,p2Y,transMin,transMax,weight);
complexRestraints.cc:226:	    this->fillOneDihedralRestraint(residue,p2X,pX,pY,p1Y,transMin,transMax,weight);
complexRestraints.cc:228:	if ( p2X.notnilp() && p2Y->notNil() )
complexRestraints.cc:230:	    this->fillOneDihedralRestraint(residue,p2X,pX,pY,p2Y,cisMin,cisMax,weight);
complexRestraints.cc:234:	this->fillOneDihedralRestraint(residue,p1X,pX,pY,p1Y,transMin,transMax,weight);
complexRestraints.cc:237:	    this->fillOneDihedralRestraint(residue,p1X,pX,pY,p2Y,cisMin,cisMax,weight);
complexRestraints.cc:241:	    this->fillOneDihedralRestraint(residue,p2X,pX,pY,p1Y,cisMin,cisMax,weight);
complexRestraints.cc:243:	if ( p2X.notnilp() && p2Y->notNil() )
complexRestraints.cc:245:	    this->fillOneDihedralRestraint(residue,p2X,pX,pY,p2Y,transMin,transMax,weight);
complexRestraints.cc:249:	THROW(_lisp->create<core::ContentException_O>("Illegal Pi bond configuration: "+config+" must be E or Z"));
complexRestraints.cc:277:	bool success = RestrainedExoCyclicAtom_O::_AtomExoToSixMemberedRing->compileSmarts("[*]9[*]1[*]2[*]3[*]4[*]5[*]6[?9]");
complexRestraints.cc:287:    this->_ExoCyclicAtomName = "";
complexRestraints.cc:288:    this->_Axial = true;
complexRestraints.cc:306://    this->Base::oldLispInitialize(kargs,env);
complexRestraints.cc:314:    this->Base::archiveBase(node);
complexRestraints.cc:315:    node->attribute("exoCyclicAtomName",this->_ExoCyclicAtomName);
complexRestraints.cc:316:    node->attribute("axial",this->_Axial);
complexRestraints.cc:324:    this->lazyInitializeSmarts();
complexRestraints.cc:325:    if ( !residue->hasAtomWithName(this->_ExoCyclicAtomName) )
complexRestraints.cc:327:	SIMPLE_ERROR(boost::format("Residue(%s) doesn't have atom with name(%s)") % residue->description() % this->_ExoCyclicAtomName );
complexRestraints.cc:329:    Atom_sp exoCyclicAtom = residue->atomWithName(this->_ExoCyclicAtomName);
complexRestraints.cc:330:    RestrainedExoCyclicAtom_O::_AtomExoToSixMemberedRing->matches(exoCyclicAtom);
complexRestraints.cc:331:    ChemInfoMatch_sp match = RestrainedExoCyclicAtom_O::_AtomExoToSixMemberedRing->getMatch();
complexRestraints.cc:332:    if ( !match->matches() )
complexRestraints.cc:334:	SIMPLE_ERROR(boost::format("In residue(%s) the atom with name(%s) is not exo-cyclic to a six-membered ring") % residue->description() % this->_ExoCyclicAtomName );
complexRestraints.cc:336:    Atom_sp a1 = match->tag("1");
complexRestraints.cc:337:    Atom_sp a2 = match->tag("2");
complexRestraints.cc:338:    Atom_sp a3 = match->tag("3");
complexRestraints.cc:339:    Atom_sp a4 = match->tag("4");
complexRestraints.cc:340:    Atom_sp a5 = match->tag("5");
complexRestraints.cc:341:    Atom_sp a6 = match->tag("6");
confSearchDatabase.cc:33:    this->Base::initialize();
confSearchDatabase.cc:34:    this->_EnergyCutOff = 5.0; // kCal/mole
confSearchDatabase.cc:35:    this->setRmsCutOff(0.1);
confSearchDatabase.cc:36:    this->enableDisplayProgress();
confSearchDatabase.cc:42:    this->SuperposableConformationCollection_O::clearEntries();
confSearchDatabase.cc:56:    if ( this->numberOfEntries() == 0 )
confSearchDatabase.cc:58:        this->SuperposableConformationCollection_O::addEntry(entry);
confSearchDatabase.cc:62:    firstEntry = this->getEntry(0);
confSearchDatabase.cc:63:    lowestEnergy = firstEntry->getData()->getDouble("energy");
confSearchDatabase.cc:64:    newEnergy = entry->getData()->getDouble("energy");
confSearchDatabase.cc:65:    if ( newEnergy-lowestEnergy > this->_EnergyCutOff )
confSearchDatabase.cc:69:    for ( SuperposableConformationCollection_O::entryIterator ei=this->begin_Entries(); ei!=this->end_Entries(); ei++ )
confSearchDatabase.cc:71:        if ( (*ei)->getData()->getDouble("energy") > newEnergy )
confSearchDatabase.cc:73:	    this->_Entries.insert(ei,entry);
confSearchDatabase.cc:77:    this->_Entries.append(entry);
confSearchDatabase.cc:91:    this->Base::archiveBase(node);
confSearchDatabase.cc:92:    node->attribute( "EnergyCutOff", this->_EnergyCutOff );
confSearchDatabase.cc:93:    node->attribute( "DisplayProgress", this->_DisplayProgress );
confSearchDatabase.cc:111:    if ( this->numberOfEntries() <= 0 ) return;
confSearchDatabase.cc:114:    firstEntry = this->firstEntry();
confSearchDatabase.cc:115:    superposer = _lisp->create<SuperposeEngine_O>();
confSearchDatabase.cc:116:    this->setEntryCoordinatesAsFixedWithinSuperposeEngine(firstEntry,superposer);
confSearchDatabase.cc:121:    firstEntry->writeCoordinatesToMatter(this->_Matter);
confSearchDatabase.cc:122:    firstEntry->getData()->setDouble("energyWrtFirst",0.0);
confSearchDatabase.cc:123:    firstEntry->getData()->setDouble("rmsWrtFirst",0.0);
confSearchDatabase.cc:124:    energy = firstEntry->getData()->getDouble("energy");
confSearchDatabase.cc:133:    uint highIndex = this->_Entries.size()-1;
confSearchDatabase.cc:135:    double lowestEnergy = (*(this->_Entries.begin()))->getData()->getDouble("energy");
confSearchDatabase.cc:137:    for ( i=1,ei=this->begin_Entries()+1; ei!=this->end_Entries(); i++,ei++ )
confSearchDatabase.cc:139:        energy = (*ei)->getData()->getDouble("energy");
confSearchDatabase.cc:141:	double deltaEnergy = energy-lowestEnergy;
confSearchDatabase.cc:142:		// If delta > this->_EnergyCutOff then throw this and following
confSearchDatabase.cc:144:	if ( deltaEnergy > this->_EnergyCutOff )
confSearchDatabase.cc:146:	    lastUsefulEntry = i-1;
confSearchDatabase.cc:149:        this->setEntryCoordinatesAsMoveableWithinSuperposeEngine(*ei,superposer);
confSearchDatabase.cc:150:	transform = superposer->superpose();
confSearchDatabase.cc:151:	rms = superposer->rootMeanSquareDifference();
confSearchDatabase.cc:152:	(*ei)->getData()->setDouble("energyWrtFirst",deltaEnergy);
confSearchDatabase.cc:153:	(*ei)->getData()->setDouble("rmsWrtFirst",rms);
confSearchDatabase.cc:154:        (*ei)->writeCoordinatesToMatter(this->_Matter);
confSearchDatabase.cc:155:	this->_Matter->applyTransformToAtoms(transform);
confSearchDatabase.cc:156:	(*ei)->extractCoordinatesFromMatter(this->_Matter);
confSearchDatabase.cc:157:	if ( this->_DisplayProgress)
confSearchDatabase.cc:159:	    _lisp->print(BF("CONFSEARCH: Entry %d  energy(%lf) rms(%lf)") % i% energy % rms );
confSearchDatabase.cc:163:    if ( lastUsefulEntry < this->_Entries.size()-1 )
confSearchDatabase.cc:165:	if ( this->_DisplayProgress )
confSearchDatabase.cc:167:	    _lisp->print(BF( "CONFSEARCH: Trimming search entry table to %d elements") % (lastUsefulEntry+1) );
confSearchDatabase.cc:170:	this->_Entries.resize(lastUsefulEntry+1);
conformationCollection.cc:37:    this->Base::initialize();
conformationCollection.cc:38:    this->_Data = _lisp->create<addon::ObjectDictionary_O>();
conformationCollection.cc:39:    this->_AllCoordinates = _lisp->create<addon::CoordinateArray_O>();
conformationCollection.cc:47:    node->archiveWeakPointer( "ConformationCollection",
conformationCollection.cc:48:   		 this->_WeakConformationCollection );
conformationCollection.cc:49:    node->archiveObject("AllCoordinates", this->_AllCoordinates );
conformationCollection.cc:50:    node->archiveObject("Data",this->_Data);
conformationCollection.cc:51:    if ( node->loading() )
conformationCollection.cc:54:	LOG(BF("allCoords =%s") % (this->_AllCoordinates->asXmlString().c_str() ) );
conformationCollection.cc:58:	LOG(BF("allCoords =%s") % (this->_AllCoordinates->asXmlString().c_str() ) );
conformationCollection.cc:69:    this->_WeakConformationCollection = s;
conformationCollection.cc:70:    ca = _lisp->create<addon::CoordinateArray_O>(s->numberOfAllAtoms());
conformationCollection.cc:71:    this->_AllCoordinates = ca;
conformationCollection.cc:78:    LOG(BF("setAllCoordinates:%s") % (ac->asXmlString().c_str() ) );
conformationCollection.cc:80:    this->_AllCoordinates = ac;
conformationCollection.cc:90:    sl = this->getConformationCollection();
conformationCollection.cc:91:    for ( ai=sl->begin_AllAtoms(),ci=this->_AllCoordinates->begin(); ai!=sl->end_AllAtoms(); ai++, ci++ )
conformationCollection.cc:93:        (*ai)->setPosition(*ci);
conformationCollection.cc:104:    this->_Status->addMessage("extractCoordinatesFromMatter");
conformationCollection.cc:107:    sl = this->getConformationCollection();
conformationCollection.cc:110:    addon::CoordinateArray_sp coords = sl->_extractCoordinateArray(matter);
conformationCollection.cc:112:    this->_AllCoordinates = coords;
conformationCollection.cc:118:    this->Base::initialize();
conformationCollection.cc:119:    this->_Matter = Matter_O::_nil;
conformationCollection.cc:120:    this->_AllAtoms.clear();
conformationCollection.cc:121:    this->_Data = _lisp->create<addon::ObjectDictionary_O>();
conformationCollection.cc:122:    this->clearEntries();
conformationCollection.cc:128:    this->_Entries.clear();
conformationCollection.cc:138:    this->_Status->addMessage("extractCoordinatesFromMatter");
conformationCollection.cc:142:    addon::CoordinateArray_sp coords = _lisp->create<addon::CoordinateArray_O>(this->numberOfAllAtoms());
conformationCollection.cc:144:    for ( ai=this->begin_AllAtoms(),ci=coords->begin(); ai!=this->end_AllAtoms(); ai++, ci++ )
conformationCollection.cc:146:        LOG(BF("Getting position of %s") % (*ai)->description().c_str()  );
conformationCollection.cc:147:        *ci = (*ai)->getPosition();
conformationCollection.cc:158:    this->_Matter = matter;
conformationCollection.cc:159:    this->_AllAtoms.clear();
conformationCollection.cc:164:	this->_AllAtoms.insert(a);
conformationCollection.cc:173:    this->_Entries.append(entry);
conformationCollection.cc:185:    matter = orig->getMatter();
conformationCollection.cc:186:    ASSERTP(matter==this->getMatter(),"The Matter objects must match");
conformationCollection.cc:187:    for ( si=orig->begin_Entries(); si!=orig->end_Entries(); si++ )
conformationCollection.cc:189:        (*si)->writeCoordinatesToMatter(matter);
conformationCollection.cc:190:	entry = this->createEntry();
conformationCollection.cc:191:	entry->extractCoordinatesFromMatter(matter);
conformationCollection.cc:192:        this->addEntry(entry);
conformationCollection.cc:204:    matter = orig->getMatter();
conformationCollection.cc:205:    ASSERTP(matter==this->getMatter(),"The Matter objects must match");
conformationCollection.cc:206:    for ( si=orig->begin_Entries(); si!=orig->end_Entries(); si++ )
conformationCollection.cc:208:    	entryStage = (*si)->getLastCompleteEntryStage();
conformationCollection.cc:209:        entryStage->writeCoordinatesToMatter(matter);
conformationCollection.cc:210:	entry = this->createEntry();
conformationCollection.cc:211:	entry->extractCoordinatesFromMatter(matter);
conformationCollection.cc:212:        this->addEntry(entry);
conformationCollection.cc:223:    matter = orig->getMatter();
conformationCollection.cc:224:    ASSERTP(matter==this->getMatter(),"The Matter objects must match");
conformationCollection.cc:225:    for ( si=orig->begin_Entries(); si!=orig->end_Entries(); si++ )
conformationCollection.cc:227:        ASSERTP((*si)->hasSelectedStage(),"Entry missing selected stage");
conformationCollection.cc:228:    	entryStage = (*si)->getSelectedStage();
conformationCollection.cc:229:        entryStage->writeCoordinatesToMatter(matter);
conformationCollection.cc:230:	entry = this->createEntry();
conformationCollection.cc:231:	entry->extractCoordinatesFromMatter(matter);
conformationCollection.cc:232:        this->addEntry(entry);
conformationCollection.cc:247:    node->archiveObject( "Matter", this->_Matter );
conformationCollection.cc:248:    node->archiveOrderedSet( "AllAtoms", this->_AllAtoms );
conformationCollection.cc:249:    node->archiveVector0( "Entries", this->_Entries );
conformationCollection.cc:250:    node->archiveObjectIfDefined( "Data", this->_Data );
conformationCollection.cc:257:    this->archiveBase(node);
conformationCollection.cc:275:    frames = _lisp->create<addon::FrameList_O>();
conformationCollection.cc:276:    matter = this->getMatter();
conformationCollection.cc:277:    for ( si=this->begin_Entries(); si!=this->end_Entries(); si++ )
conformationCollection.cc:279:        (*si)->writeCoordinatesToMatter(matter);
conformationCollection.cc:280:	dlMatter = _lisp->create<GrPickableMatter_O>();
conformationCollection.cc:281:	dlMatter->setName(_lisp->internKeyword("gaussianMinimized"));
conformationCollection.cc:282:	dlMatter->setFromMatter(matter);
conformationCollection.cc:283:	frames->append(dlMatter);
conformationCollection.cc:300:    xml = _lisp->create<core::XmlSaveArchive_O>();
conformationCollection.cc:301:    xml->put("ConformationCollection",this->sharedThis<ConformationCollection_O>());
conformationCollection.cc:302:    xml->saveAs(fn);
conformationCollection.cc:310:    for ( i=0,ei=this->_Entries.begin(); ei!=this->_Entries.end(); ei++,i++ )
conformationCollection.cc:325:    ASSERT_lessThan(i,this->_Entries.size());
conformationCollection.cc:327:    e = this->_Entries[i];
conformationCollection.cc:333:    ASSERT(this->_Entries.size() > 0 );
conformationCollection.cc:334:    return this->_Entries[0];
conformationCollection.cc:341:    entry->setConformationCollection(this->sharedThis<ConformationCollection_O>());
conformationExplorer.cc:45:	this->Base::initialize();
conformationExplorer.cc:46:	this->_Binder = _lisp->create<core::Binder_O>();
conformationExplorer.cc:47:	this->_FinalCoordinates = _lisp->create<addon::CoordinateArray_O>();
conformationExplorer.cc:48:	this->_WeakConformationExplorerEntry = ConformationExplorerEntry_O::_nil;
conformationExplorer.cc:49:	this->_Complete = true;
conformationExplorer.cc:50:	this->_EnergyKCal = 0.0;
conformationExplorer.cc:51:	this->_ExternalInterfaceName = "";
conformationExplorer.cc:52:	this->_Model = "";
conformationExplorer.cc:53:	this->_StageName = "undefStage";
conformationExplorer.cc:60:	ASSERTNOTNULL(this->_WeakConformationExplorerEntry);
conformationExplorer.cc:61:	entry = this->_WeakConformationExplorerEntry.lock();
conformationExplorer.cc:71:	explorer = this->getConformationExplorer();
conformationExplorer.cc:72:	superposer->setFixedPoints(explorer->_getSuperposeAtomIndices(), this->_FinalCoordinates );
conformationExplorer.cc:79:	explorer = this->getConformationExplorer();
conformationExplorer.cc:80:	superposer->setMoveablePoints(explorer->_getSuperposeAtomIndices(), this->_FinalCoordinates );
conformationExplorer.cc:88:	explorer = this->getConformationExplorer();
conformationExplorer.cc:89:	superposer->setFixedAllPoints(this->_FinalCoordinates);
conformationExplorer.cc:96:	explorer = this->getConformationExplorer();
conformationExplorer.cc:97:	superposer->setMoveableAllPoints(this->_FinalCoordinates);
conformationExplorer.cc:105:	ASSERTNOTNULL(this->_WeakConformationExplorerEntry);
conformationExplorer.cc:106:	entry = this->getConformationExplorerEntry();
conformationExplorer.cc:107:	return entry->getConformationExplorer();
conformationExplorer.cc:113:	SuperposeEngine_sp superposer = _lisp->create<SuperposeEngine_O>();
conformationExplorer.cc:114:	entryStage->setSuperposableCoordinatesAsFixedWithinSuperposeEngine(superposer);
conformationExplorer.cc:115:	this->setSuperposableCoordinatesAsMoveableWithinSuperposeEngine(superposer);
conformationExplorer.cc:116:	Matrix transform = superposer->superpose();
conformationExplorer.cc:117:	this->_FinalCoordinates->transform(transform);
conformationExplorer.cc:133:	explorer = this->getConformationExplorer();
conformationExplorer.cc:134:	dlAll = _lisp->create<addon::DisplayList_O>();
conformationExplorer.cc:135:	dlAll->setName(_lisp->internKeyword(this->_StageName));
conformationExplorer.cc:138:	    matter = explorer->getMatter();
conformationExplorer.cc:139:	    this->writeCoordinatesToMatter(matter);
conformationExplorer.cc:140:	    dlMatter = _lisp->create<GrPickableMatter_O>();
conformationExplorer.cc:141:	    dlMatter->setFromMatter(matter);
conformationExplorer.cc:142:	    dlMatter->setName(_lisp->internKeyword("molFrame"));
conformationExplorer.cc:143:	    dlAll->append(dlMatter);
conformationExplorer.cc:145:	    core::SymbolVector_sp sv = dlMatter->getFullName();
conformationExplorer.cc:146:	    LOG(BF("At time of creation dlMatter fullName=%s") % sv->__repr__() );
conformationExplorer.cc:152:	    addon::DisplayList_sp prims = _lisp->create<addon::DisplayList_O>();
conformationExplorer.cc:153:	    prims->setName(_lisp->internKeyword("superposeAtoms"));
conformationExplorer.cc:154:	    addon::GrSpheres_sp sphereList = _lisp->create<addon::GrSpheres_O>();
conformationExplorer.cc:155:	    for ( ii=explorer->superposeAtomIndices_begin(); ii!=explorer->superposeAtomIndices_end(); ii++ )
conformationExplorer.cc:157:		sphereList->appendSphere(explorer->_getAtomAtIndex(*ii)->getPosition(),0.2,addon::Color_O::yellow(_lisp));
conformationExplorer.cc:159:	    prims->append(sphereList);
conformationExplorer.cc:160:	    dlAll->append(prims);
conformationExplorer.cc:165:	sinfo << "Stage name: "<< this->_StageName << endl;
conformationExplorer.cc:166:	sinfo << "Based on stage: "<< this->_BasedOnStageName << endl;
conformationExplorer.cc:167:	sinfo << "Is complete: " << this->_Complete << endl;
conformationExplorer.cc:169:	      << this->_EnergyKCal << endl;
conformationExplorer.cc:170:	sinfo << "Generated by package: " << this->_ExternalInterfaceName << endl;
conformationExplorer.cc:171:	sinfo << "Model: " << this->_Model << endl;
conformationExplorer.cc:173:	if ( this->getBinder()->contains(_sym_convergence))
conformationExplorer.cc:175:	    sinfo << this->getBinder()->lookup(_sym_convergence)->as<core::Str_O>()->get();
conformationExplorer.cc:178:	dlAll->append(info);
conformationExplorer.cc:179:	addon::Render_sp dlDict = this->getBinder()->rendered(opts);
conformationExplorer.cc:180:	dlAll->append(dlDict);
conformationExplorer.cc:192:	node->attribute("StageName",this->_StageName);
conformationExplorer.cc:193:	node->attributeIfNotDefault<string>("BasedOnStageName",this->_BasedOnStageName,"");
conformationExplorer.cc:194:	node->attributeIfNotDefault<string>("ExternalInterfaceName",this->_ExternalInterfaceName,"");
conformationExplorer.cc:195:	node->attributeIfNotDefault<string>("Model",this->_Model,"");
conformationExplorer.cc:196:	node->attributeIfNotDefault("EnergyKCal",this->_EnergyKCal,0.0);
conformationExplorer.cc:197:	node->attributeIfNotDefault("Complete",this->_Complete,true);
conformationExplorer.cc:198:	node->archiveWeakPointer( "ConformationExplorerEntry",
conformationExplorer.cc:199:				  this->_WeakConformationExplorerEntry );
conformationExplorer.cc:200:	node->archiveObject("AllCoordinates", this->_FinalCoordinates );
conformationExplorer.cc:201:	node->archiveObject("Binder",this->_Binder);
conformationExplorer.cc:212:	this->_WeakConformationExplorerEntry = s;
conformationExplorer.cc:213:	explorer = this->getConformationExplorer();
conformationExplorer.cc:214:	ca = addon::CoordinateArray_O::create(explorer->numberOfAllAtoms(),_lisp);
conformationExplorer.cc:215:	this->_FinalCoordinates = ca;
conformationExplorer.cc:222:	LOG(BF("setFinalCoordinates:%s") % (ac->asXmlString().c_str() ) );
conformationExplorer.cc:224:	this->_FinalCoordinates = ac;
conformationExplorer.cc:233:	explorer = this->getConformationExplorer();
conformationExplorer.cc:234:	idx = explorer->indexOfAtom(atom);
conformationExplorer.cc:235:	ASSERTNOTNULL(this->_FinalCoordinates);
conformationExplorer.cc:236:	ASSERT(this->_FinalCoordinates->size() == explorer->numberOfAllAtoms());
conformationExplorer.cc:237:	this->_FinalCoordinates->setElement(idx,pos);
conformationExplorer.cc:246:	sl = this->getConformationExplorer();
conformationExplorer.cc:247:	for ( ai=sl->begin_AllAtoms(),ci=this->_FinalCoordinates->begin(); ai!=sl->end_AllAtoms(); ai++, ci++ )
conformationExplorer.cc:249:	    (*ai)->setPosition(*ci);
conformationExplorer.cc:260:	sl = this->getConformationExplorer();
conformationExplorer.cc:263:	addon::CoordinateArray_sp coords = sl->_extractCoordinateArray(matter);
conformationExplorer.cc:265:	this->_FinalCoordinates = coords;
conformationExplorer.cc:289:	this->Base::initialize();
conformationExplorer.cc:290:	this->_Binder = _lisp->create<core::Binder_O>();
conformationExplorer.cc:291:	this->_UniqueEntryIndex = -1;
conformationExplorer.cc:298:	node->archiveWeakPointer( "ConformationExplorer",
conformationExplorer.cc:299:				  this->_WeakConformationExplorer );
conformationExplorer.cc:300:	node->archiveVector0("Stages", this->_Stages);
conformationExplorer.cc:301:	node->archiveObjectIfDefined("SelectedStage",this->_SelectedStage);
conformationExplorer.cc:302:	node->archiveObject("Binder",this->_Binder);
conformationExplorer.cc:303:	node->attributeIfNotDefault("uidx",this->_UniqueEntryIndex,-1);
conformationExplorer.cc:309:	if ( !this->hasSelectedStage() )
conformationExplorer.cc:313:	return this->_SelectedStage;
conformationExplorer.cc:319:	stageEntry = stage->getConformationExplorerEntry();
conformationExplorer.cc:321:	this->_SelectedStage = stage;
conformationExplorer.cc:328:	ASSERTF(!this->hasEntryStageWithName(name),
conformationExplorer.cc:331:	stage->setConformationExplorerEntry(this->sharedThis<ConformationExplorerEntry_O>());
conformationExplorer.cc:332:	stage->setStageName(name);
conformationExplorer.cc:333:	this->_Stages.push_back(stage);
conformationExplorer.cc:341:	this->_WeakConformationExplorer = s;
conformationExplorer.cc:349:	if ( this->_Stages.size() == 0 ) return "";
conformationExplorer.cc:350:	return this->_Stages[this->_Stages.size()-1]->getStageName();
conformationExplorer.cc:357:	ASSERTP(this->_Stages.size()>0,"There must be at least one complete stage");
conformationExplorer.cc:358:	int idx = this->_Stages.size()-1;
conformationExplorer.cc:359:	return this->_Stages[idx];
conformationExplorer.cc:366:	lastStage = this->getLastCompleteEntryStage();
conformationExplorer.cc:367:	return( lastStage->getStageName() == stageName );
conformationExplorer.cc:374:	lastStage = this->getLastEntryStage();
conformationExplorer.cc:375:	if ( lastStage->isComplete() )
conformationExplorer.cc:377:	    if ( lastStage->getStageName() != stageName )
conformationExplorer.cc:379:		newStage = this->createEntryStage(stageName);
conformationExplorer.cc:380:		newStage->setComplete(false);
conformationExplorer.cc:389:	    newStage->setStageName(stageName);
conformationExplorer.cc:390:	    newStage->setComplete(false);
conformationExplorer.cc:398:	ASSERTP(this->_Stages.size()>0,"There must be at least one complete stage");
conformationExplorer.cc:399:	int idx = this->_Stages.size()-1;
conformationExplorer.cc:400:	if ( this->_Stages[idx]->isComplete() )
conformationExplorer.cc:402:	    return this->_Stages[idx];
conformationExplorer.cc:405:	idx--;
conformationExplorer.cc:406:	if ( this->_Stages[idx]->isComplete() )
conformationExplorer.cc:408:	    return this->_Stages[idx];
conformationExplorer.cc:422:	for ( si=this->_Stages.begin(); si!=this->_Stages.end(); si++ )
conformationExplorer.cc:424:	    if ( (*si)->getStageName() == key ) return true;
conformationExplorer.cc:433:	for ( si=this->_Stages.begin(); si!=this->_Stages.end(); si++ )
conformationExplorer.cc:435:	    if ( (*si)->getStageName() == key )
conformationExplorer.cc:451:	dlAll = _lisp->create<addon::DisplayList_O>();
conformationExplorer.cc:452:	dlAll->setName(_lisp->internKeyword("stages"));
conformationExplorer.cc:453:	LOG(BF("Rendering %d stages")%this->_Stages.size());
conformationExplorer.cc:454:	for ( si=this->_Stages.begin(); si!=this->_Stages.end(); si++ )
conformationExplorer.cc:455:	{_BLOCK_TRACEF(BF("Rendering stage: %s")%(*si)->getStageName());
conformationExplorer.cc:456:	    if ( (*si)->isComplete() )
conformationExplorer.cc:459:		dlStage = (*si)->rendered(opts);
conformationExplorer.cc:460:		dlAll->append(dlStage);
conformationExplorer.cc:475:	for ( it=this->begin_Stages(); it!=this->end_Stages(); it++ )
conformationExplorer.cc:477:	    stageNames->insert((*it)->getStageName());
conformationExplorer.cc:484:	this->Base::initialize();
conformationExplorer.cc:485:	this->_Matter = Matter_O::_nil;
conformationExplorer.cc:486:	this->_AllAtoms.clear();
conformationExplorer.cc:487:	this->_Binder = _lisp->create<core::Binder_O>();
conformationExplorer.cc:488:	this->clearEntries();
conformationExplorer.cc:489:	this->_SuperposeAtomIndices = core::IntArray_O::create();
conformationExplorer.cc:495:	this->_Entries.clear();
conformationExplorer.cc:503:	ASSERT_lessThan(i,this->_AllAtoms.size());
conformationExplorer.cc:504:	return this->_AllAtoms[i];
conformationExplorer.cc:514:	this->_Status->addMessage("extractCoordinatesFromMatter");
conformationExplorer.cc:518:	uint numberOfAtoms = agg->numberOfAtoms();
conformationExplorer.cc:519:	addon::CoordinateArray_sp coords = _lisp->create<addon::CoordinateArray_O>(numberOfAtoms);
conformationExplorer.cc:522:	for ( ai=this->begin_AllAtoms(),ci=coords->begin(); ai!=this->end_AllAtoms(); ai++, ci++ )
conformationExplorer.cc:524:	    LOG(BF("Getting position of ATOM(%d) %s") % aidx % (*ai)->description().c_str() );
conformationExplorer.cc:525:	    if ( !(*ai)->isContainedBy(agg) )
conformationExplorer.cc:527:		SIMPLE_ERROR(BF("You asked a ConformationExplorer to extract coordinates from the Matter(%s) but the ConformationExplorer atom(%s) is not contained within that Matter")%agg->description()%(*ai)->description());
conformationExplorer.cc:531:		LOG(BF("You asked a ConformationExplorer to extract coordinates from the Matter(%s) and the ConformationExplorer atom(%s) IS contained within that Matter")%agg->description()%(*ai)->description());
conformationExplorer.cc:534:	    *ci = (*ai)->getPosition();
conformationExplorer.cc:547:	this->_Matter = matter;
conformationExplorer.cc:548:	this->_AllAtoms.clear();
conformationExplorer.cc:553:	    this->_AllAtoms.insert(a);
conformationExplorer.cc:562:	entry->setConformationExplorer(this->sharedThis<ConformationExplorer_O>());
conformationExplorer.cc:563:	this->_Entries.append(entry);
conformationExplorer.cc:572:	for ( si=this->begin_Entries(); si!=this->end_Entries(); si++ )
conformationExplorer.cc:575:	    cur->setCdr(newCons);
conformationExplorer.cc:578:	return first->cdr();
conformationExplorer.cc:592:	if ( !node->loading() )
conformationExplorer.cc:594:	    ASSERTNOTNULL(this->_Matter);
conformationExplorer.cc:596:	node->archiveObject( "Matter", this->_Matter );
conformationExplorer.cc:597:	node->archiveVector0( "Entries", this->_Entries );
conformationExplorer.cc:598:	node->archiveOrderedSet( "AllAtoms", this->_AllAtoms );
conformationExplorer.cc:599:	node->archiveObject( "SuperposeAtomIndices", this->_SuperposeAtomIndices );
conformationExplorer.cc:600:	node->archiveObjectIfDefined( "Binder", this->_Binder );
conformationExplorer.cc:617:	addon::DisplayList_sp dlAll = _lisp->create<addon::DisplayList_O>();
conformationExplorer.cc:619:	frames = _lisp->create<addon::FrameList_O>();
conformationExplorer.cc:620:	frames->setName(_lisp->internKeyword("conformation"));
conformationExplorer.cc:622:	if ( this->numberOfEntries() == 0 )
conformationExplorer.cc:625:	    ASSERTNOTNULL(this->_Matter);
conformationExplorer.cc:626:	    if ( this->_Matter.notnilp() )
conformationExplorer.cc:629:		dlEntry = this->_Matter->rendered(opts);
conformationExplorer.cc:631:		frames->append(dlEntry);
conformationExplorer.cc:635:	    LOG(BF("FLAG! There are %d entries") % this->_Entries.size());
conformationExplorer.cc:636:	    for ( si=this->begin_Entries(); si!=this->end_Entries(); si++ )
conformationExplorer.cc:638:		dlEntry = (*si)->rendered(opts);
conformationExplorer.cc:639:		LOG(BF("The name of the Frame entry is[%s]") % dlEntry->getName()->__repr__() );
conformationExplorer.cc:640:		frames->append(dlEntry);
conformationExplorer.cc:644:	dlAll->append(frames);
conformationExplorer.cc:646:	dlAll->append(this->_Binder->rendered(opts));
conformationExplorer.cc:656:	ASSERTNOTNULL(this->_SuperposeAtomIndices);
conformationExplorer.cc:657:	this->_SuperposeAtomIndices->clear();
conformationExplorer.cc:666:	ASSERTNOTNULL(this->_SuperposeAtomIndices);
conformationExplorer.cc:667:	for ( idx=0,ai=this->begin_AllAtoms(); ai!=this->end_AllAtoms(); idx++,ai++ )
conformationExplorer.cc:671:		this->_SuperposeAtomIndices->append(idx);
conformationExplorer.cc:675:	SIMPLE_ERROR(BF("You cannot add superpose atom: "+a->description()+" because it isn't in the ConformationCollection"));
conformationExplorer.cc:682:	this->clearSuperposeAtoms();
conformationExplorer.cc:685:	    this->addSuperposeAtom(*ai);
conformationExplorer.cc:693:	ASSERTNOTNULL(this->_SuperposeAtomIndices);
conformationExplorer.cc:694:	this->clearSuperposeAtoms();
conformationExplorer.cc:695:	for ( idx=0,ai=this->begin_AllAtoms(); ai!=this->end_AllAtoms(); idx++,ai++ )
conformationExplorer.cc:697:	    if ( (*ai)->getElement() != element_H )
conformationExplorer.cc:699:		this->_SuperposeAtomIndices->append(idx);
conformationExplorer.cc:710:	ASSERTNOTNULL(this->_SuperposeAtomIndices);
conformationExplorer.cc:711:	for ( si=this->_SuperposeAtomIndices->begin();si!=this->_SuperposeAtomIndices->end(); si++ )
conformationExplorer.cc:713:	    a = this->_AllAtoms[*si];
conformationExplorer.cc:722:	return this->_SuperposeAtomIndices->size();
conformationExplorer.cc:734:	    xStage = x->getEntryStage(this->_StageName);
conformationExplorer.cc:735:	    yStage = y->getEntryStage(this->_StageName);
conformationExplorer.cc:736:	    core::T_sp xValue = xStage->getBinder()->lookup(this->_KeyName);
conformationExplorer.cc:737:	    core::T_sp yValue = yStage->getBinder()->lookup(this->_KeyName);
conformationExplorer.cc:738:	    if ( xValue->operator<(yValue) ) return true;
conformationExplorer.cc:751:	core::sort::quickSort(this->_Entries.begin(), this->_Entries.end(), comparer,_lisp);
conformationExplorer.cc:764:	xml = _lisp->create<core::XmlSaveArchive_O>();
conformationExplorer.cc:765:	xml->put("ConformationExplorer",this->sharedThis<ConformationExplorer_O>());
conformationExplorer.cc:766:	xml->saveAs(fn);
conformationExplorer.cc:774:	for ( i=0,ei=this->_Entries.begin(); ei!=this->_Entries.end(); ei++,i++ )
conformationExplorer.cc:789:	ASSERT_lessThan(i,this->_Entries.size());
conformationExplorer.cc:791:	e = this->_Entries[i];
conformationExplorer.cc:797:	ASSERT(this->_Entries.size() > 0 );
conformationExplorer.cc:798:	return this->_Entries[0];
conformationExplorer.cc:808:	entry->setConformationExplorer(this->sharedThis<ConformationExplorer_O>());
conformationExplorer.cc:809:	entry->_UniqueEntryIndex = this->numberOfEntries();
conformationExplorer.cc:822:	for ( ei=this->begin_Entries(); ei!=this->end_Entries(); ei++ )
conformationExplorer.cc:824:	    if ( !(*ei)->hasEntryStageWithName(stageKey) )
conformationExplorer.cc:850:	uint numSuperposeAtoms = this->numberOfSuperposeAtoms();
conformationExplorer.cc:858:	    for ( ei=this->begin_Entries(); ei!=this->end_Entries(); ei++, entryIndex++ )
conformationExplorer.cc:860:		if ( (*ei)->hasEntryStageWithName(stageName) )
conformationExplorer.cc:862:		    stage = (*ei)->getEntryStage(stageName);
conformationExplorer.cc:871:	    superposer = _lisp->create<SuperposeEngine_O>();
conformationExplorer.cc:872:	    matterConf = this->_extractCoordinateArray(matter);
conformationExplorer.cc:873:	    superposer->setFixedPoints(this->_SuperposeAtomIndices,matterConf);
conformationExplorer.cc:876:	    for ( ei=this->begin_Entries(); ei!=this->end_Entries(); ei++, entryIndex++ )
conformationExplorer.cc:878:		if ( (*ei)->hasEntryStageWithName(stageName) )
conformationExplorer.cc:880:		    stage = (*ei)->getEntryStage(stageName);
conformationExplorer.cc:881:		    stage->setSuperposableCoordinatesAsMoveableWithinSuperposeEngine(superposer);
conformationExplorer.cc:882:		    superposer->superpose();
conformationExplorer.cc:883:		    rms = superposer->rootMeanSquareDifference();
conformationExplorer.cc:904:	uint idx = match->getClosestMatchIndex();
conformationExplorer.cc:905:	return this->getEntry(idx);
conformationExplorer.cc:910:	uint idx = match->getClosestMatchIndex();
conformationExplorer.cc:911:	ConformationExplorerEntry_sp e = this->getEntry(idx);
conformationExplorer.cc:912:	ConformationExplorerEntryStage_sp s = e->getEntryStage(match->getMatchStageName());
conformationExplorer.cc:921:	ss << this->Base::__str__();
conformationExplorer.cc:922:	ss << "#ConformationExplorerEntries: " << this->_Entries.size() << endl;
conformationExplorer.cc:925:	for ( ei=this->_Entries.begin(); ei!=this->_Entries.end(); ei++ )
conformationExplorer.cc:927:	    core::StringSet_sp oneEntryStageNames = (*ei)->getEntryStageNames();
conformationExplorer.cc:928:	    stageNames->insertStringSet(oneEntryStageNames);
conformationExplorer.cc:930:	ss << "EntryStageNames: %s\n", stageNames->asString().c_str();
conformationExplorer.cc:942:	match->setMatches(false);
conformationExplorer.cc:943:	match->setMatchStageName(stageKey);
conformationExplorer.cc:944:	bool gotBest = this->findMostSimilarConformationEntryStageWithStageName(matter,stageKey,bestRms,bestStage,bestIndex);
conformationExplorer.cc:953:	    match->setMatches(true);
conformationExplorer.cc:955:	match->setClosestMatchRms(bestRms);
conformationExplorer.cc:956:	match->setClosestMatchIndex(bestIndex);
conformationExplorer.cc:964:	return this->_AllAtoms.indexOf(atom,_lisp);
conformationExplorer.cc:971:	if ( !this->hasStageNameInAllEntries(stageName) )
conformationExplorer.cc:975:	if ( this->_Entries.size() == 0 )
conformationExplorer.cc:979:	if ( this->_Entries.size() < 2 ) return;
conformationExplorer.cc:980:	ConformationExplorer_O::entryIterator first = this->_Entries.begin();
conformationExplorer.cc:981:	ConformationExplorerEntryStage_sp firstEntryStage = (*first)->getEntryStage(stageName);
conformationExplorer.cc:984:	for ( ; rest!=this->end_Entries(); rest++ )
conformationExplorer.cc:986:	    ConformationExplorerEntryStage_sp entryStage = (*rest)->getEntryStage(stageName);
conformationExplorer.cc:987:	    (entryStage)->alignCoordinatesTo(firstEntryStage);
conformationExplorer.cc:999:	    ConformationExplorerEntryStage_sp xStage = x->getEntryStage(this->_StageName);
conformationExplorer.cc:1000:	    ConformationExplorerEntryStage_sp yStage = y->getEntryStage(this->_StageName);
conformationExplorer.cc:1001:	    return xStage->getEnergyKCal()<yStage->getEnergyKCal();
conformationExplorer.cc:1010:	core::sort::quickSort(this->_Entries.begin(),this->_Entries.end(),order,_lisp);
conformationExplorer.cc:1015:	this->_Matches = false;
constitution.cc:38:      me->_Name = name;
constitution.cc:39:      me->_Comment = comment;
constitution.cc:40:      me->_MetaConstitution = metaConstitution;
constitution.cc:41:      me->_ConstitutionAtoms = constitutionAtoms;
constitution.cc:43://      me->_ConstitutionAtoms->setOwner(me);
constitution.cc:44:      me->_StereoInformation = stereoInformation;
constitution.cc:46://      me->_StereoInformation->setOwner(me);
constitution.cc:47:      me->_StereoInformation->validate();
constitution.cc:50://	  plugs->setOwnerOfAllEntries(me);
constitution.cc:51:	  me->_PlugsByName.clear();
constitution.cc:52:	  for ( ; plugs.notnilp(); plugs = plugs->cdr() )
constitution.cc:54:	      Plug_sp p = plugs->car<Plug_O>();
constitution.cc:55:	      _BLOCK_TRACEF(BF("Adding plug[%s]") % p->getName() );
constitution.cc:56:	      if ( me->_PlugsByName.count(p->getName())>0 )
constitution.cc:58:		  SIMPLE_ERROR(BF("There is already a plug named: %s") %p->getName()->__repr__() );
constitution.cc:60:	      core::Symbol_sp key = p->getName();
constitution.cc:61:	      ASSERTF(!key->isKeywordSymbol(),BF("Don't use keyword symbols for plug names"));
constitution.cc:62:	      me->_PlugsByName.set(p->getName(),p);
constitution.cc:67://	  topologies->setOwnerOfAllEntries(me);
constitution.cc:68:	  me->_Topologies.clear();
constitution.cc:69:	  for ( ; topologies.notnilp(); topologies = topologies->cdr() )
constitution.cc:71:	      Topology_sp t = topologies->car<Topology_O>();
constitution.cc:72:	      _BLOCK_TRACEF(BF("Adding topology[%s]@%p") % t->getName() % (void*)(t.get()) );
constitution.cc:73:	      if ( me->_Topologies.count(t->getName())>0 )
constitution.cc:75:		  SIMPLE_ERROR(BF("There is already a topology named: "+t->getName()->__repr__() ));
constitution.cc:77:	      me->_Topologies.set(t->getName(),t);
constitution.cc:87:    this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(ChemPkg,"name"));
constitution.cc:88:    this->_Comment = translate::from_object<string>::convert(env->lookup(ChemPkg,"comment"));
constitution.cc:89:    this->_MetaConstitution = translate::from_object<core::Symbol_O>::convert(env->lookup(ChemPkg,"metaConstitution"));
constitution.cc:90:    this->_ConstitutionAtoms = translate::from_object<ConstitutionAtoms_O>::convert(env->lookup(ChemPkg,"constitutionAtoms"));
constitution.cc:91:    this->_ConstitutionAtoms->setOwner(this->sharedThis<Constitution_O>());
constitution.cc:92:    this->_StereoInformation = translate::from_object<StereoInformation_O>::convert(env->lookup(ChemPkg,"stereoInformation"));
constitution.cc:93:    this->_StereoInformation->setOwner(this->sharedThis<Constitution_O>());
constitution.cc:94:    this->_StereoInformation->validate();
constitution.cc:96:	core::Cons_sp c = translate::from_object<core::Cons_O>::convert(env->lookup(ChemPkg,"plugs"));
constitution.cc:97:	c->setOwnerOfAllEntries(this->sharedThis<Constitution_O>());
constitution.cc:98:	this->_PlugsByName.clear();
constitution.cc:99:	for ( ; c.notnilp(); c = c->cdr() )
constitution.cc:101:	    Plug_sp p = c->car<Plug_O>();
constitution.cc:102:	    _BLOCK_TRACEF(BF("Adding plug[%s]") % p->getName() );
constitution.cc:103:	    if ( this->_PlugsByName.count(p->getName())>0 )
constitution.cc:105:		SIMPLE_ERROR(BF("There is already a plug named: "+p->getName()->__repr__() ));
constitution.cc:107:	    core::Symbol_sp key = p->getName();
constitution.cc:108:	    ASSERTF(!key->isKeywordSymbol(),BF("Don't use keyword symbols for plug names"));
constitution.cc:109:	    this->_PlugsByName.set(p->getName(),p);
constitution.cc:113:	core::Cons_sp c = translate::from_object<core::Cons_O>::convert(env->lookup(ChemPkg,"topologies"));
constitution.cc:114:	c->setOwnerOfAllEntries(this->sharedThis<Constitution_O>());
constitution.cc:115:	this->_Topologies.clear();
constitution.cc:116:	for ( ; c.notnilp(); c = c->cdr() )
constitution.cc:118:	    Topology_sp t = c->car<Topology_O>();
constitution.cc:119:	    _BLOCK_TRACEF(BF("Adding topology[%s]@%p") % t->getName() % (void*)(t.get()) );
constitution.cc:120:	    if ( this->_Topologies.count(t->getName())>0 )
constitution.cc:122:		SIMPLE_ERROR(BF("There is already a topology named: "+t->getName()->__repr__() ));
constitution.cc:124:	    this->_Topologies.set(t->getName(),t);
constitution.cc:134:	for ( stereoisomerIterator si=this->begin_Stereoisomers(); 
constitution.cc:135:	      si!=this->end_Stereoisomers(); si++ )
constitution.cc:137:	    db->addEntity(*si);
constitution.cc:156:    residueConstitution = res->getConstitution();
constitution.cc:157:    stereoisomerConstitution = getCandoDatabase(_lisp)->constitutionForNameOrPdb(stereoisomerName);
constitution.cc:159:    if (!residueConstitution->isSameAs(stereoisomerConstitution)) {
constitution.cc:160:	LOG(BF("residueConstitution = %s")%residueConstitution->__repr__());
constitution.cc:163:					 % residueConstitution->getName() % stereoisomerName % stereoisomerConstitution->getName() );
constitution.cc:166:    fullName = bdb->getMonomerNameForNameOrPdb(stereoisomerName);
constitution.cc:167:    pdbName = bdb->getPdbNameForNameOrPdb(stereoisomerName);
constitution.cc:168:    res->setName(fullName->identifierName());
constitution.cc:169:    res->setPdbName(pdbName->identifierName());
constitution.cc:175:    si = this->_StereoInformation->getStereoisomer(stereoisomerName);
constitution.cc:177:    for (sci=si->_Configurations_begin();sci!=si->_Configurations_end();sci++){
constitution.cc:178:	aa = res->atomWithName((*sci)->getAtomName());
constitution.cc:179:	LOG(BF("Setting the configuration of atom(%s) to(%s)") % aa->description().c_str() % (*sci)->getConfiguration().c_str()  ); //
constitution.cc:180:	if ( (*sci)->getConfiguration() == "S" ) {
constitution.cc:181:	    aa->setConfiguration( S_Configuration );
constitution.cc:182:	} else if ( (*sci)->getConfiguration() == "R" ) {
constitution.cc:183:	    aa->setConfiguration( R_Configuration );
constitution.cc:192:    for ( tpi=this->_StereoInformation->begin_ComplexRestraints(); 
constitution.cc:193:    		tpi!=this->_StereoInformation->end_ComplexRestraints(); tpi++ )
constitution.cc:195:	(*tpi)->fillRestraints(res);
constitution.cc:201:    return this->_StereoInformation->recognizesNameOrPdb(nm);
constitution.cc:208:    RepresentativeList_sp allRepresentatives  = _lisp->create<RepresentativeList_O>();
constitution.cc:209:    for (si=this->begin_Stereoisomers(); si!=this->end_Stereoisomers(); si++)
constitution.cc:211:	RepresentativeList_sp oneList = (*si)->expandedRepresentativeList();
constitution.cc:212:	allRepresentatives->extend(oneList);
constitution.cc:225:    for ( ti=this->_Topologies.begin(); ti!=this->_Topologies.end(); ti++ ) 
constitution.cc:227:	plug = (ti->second)->provideMissingRingClosingPlug(mon);
constitution.cc:230:	    if ( plug->recognizesRingClosingMate(mate->getName()) )
constitution.cc:232:		candidateTopologies.insert(ti->second);
constitution.cc:240:	ss << "In Constitution(" << this->constitutionName() << " MetaConstitution(" << this->getMetaConstitutionName() << ")" << endl;
constitution.cc:241:	ss << "there are more than one topologies that match the current monomer environment: " << mon->description() << endl;
constitution.cc:254:	return this->_StereoInformation->pdbFromNameOrPdb(nm);
constitution.cc:260:	return this->_StereoInformation->getMonomerNamesAsStringList();
constitution.cc:264:    return this->_StereoInformation->getMonomerNamesAsSymbolSet();
constitution.cc:268:	return this->_StereoInformation->getPdbNamesAsStringList();
constitution.cc:277:    LOG(BF("Looking for Stereoisomer with name(%s)") % stereoisomerName->__repr__() );
constitution.cc:278:    for (si=this->begin_Stereoisomers(); si!=this->end_Stereoisomers(); si++)
constitution.cc:280:	LOG(BF("Looking at stereoisomer name(%s)") % (*si)->getName()->__repr__() );
constitution.cc:281:	if ( (*si)->getName() == stereoisomerName )
constitution.cc:294:    LOG(BF("Looking for Stereoisomer with name(%s)") % stereoisomerName->__repr__() );
constitution.cc:295:    for (si=this->begin_Stereoisomers(); si!=this->end_Stereoisomers(); si++)
constitution.cc:297:	LOG(BF("Looking at stereoisomer name(%s)") % (*si)->getName()->__repr__() );
constitution.cc:298:	if ( (*si)->getName() == stereoisomerName )
constitution.cc:310:core::Cons_sp Constitution_O::stereoisomersAsCons() { return this->_StereoInformation->stereoisomersAsCons(); };
constitution.cc:311:core::Cons_sp Constitution_O::topologiesAsCons() { return this->_Topologies.asCons(_lisp); };
constitution.cc:312:core::Cons_sp Constitution_O::plugsAsCons() { return this->_PlugsByName.asCons(_lisp); };
constitution.cc:317:    for ( mi=this->_PlugsByName.begin(); mi!=this->_PlugsByName.end(); mi++ )
constitution.cc:319:	if ( mi->second->hasMates() )
constitution.cc:321:	    first = core::Cons_O::create(mi->second,first,_lisp);
constitution.cc:329:    return this->_StereoInformation->begin_Stereoisomers();
constitution.cc:333:    return this->_StereoInformation->end_Stereoisomers();
constitution.cc:338:    return this->_StereoInformation->begin_Stereoisomers();
constitution.cc:342:    return this->_StereoInformation->end_Stereoisomers();
constitution.cc:351:    Residue_sp res = this->_ConstitutionAtoms->makeResidue();
constitution.cc:353://    res->setOwner(this->sharedThis<Constitution_O>());
constitution.cc:354:    this->makeResidueConsistentWithStereoisomerNamed(res,stereoisomerName);
constitution.cc:361:    ASSERTNOTNULL(this->_StereoInformation);
constitution.cc:362:    return this->_StereoInformation->nameFromNameOrPdb(nm);
constitution.cc:370:    ss << this->className() << "[";
constitution.cc:372:    if ( this->_Name.use_count() == 0 ) ss << "--UNDEFINED--";
constitution.cc:373:    else ss << this->_Name->__repr__();
constitution.cc:383:    for ( pi=this->_PlugsByName.begin(); pi!=this->_PlugsByName.end(); pi++ )
constitution.cc:385:	ss->insert(pi->first);
constitution.cc:398:    for ( ti=this->_Topologies.begin(); ti!=this->_Topologies.end(); ti++ )
constitution.cc:400:	LOG(BF("Looking for plug[%s]@%p in topology[%s]") % name->__repr__() % name.get() % ti->second->description());
constitution.cc:401:	if ( ti->second->hasPlugNamed(name) )
constitution.cc:403:	    LOG(BF("Found the plug[%s]") % name->__repr__() );
constitution.cc:404:	    temp = ti->second->getNumberOfPlugs();
constitution.cc:409:		tres = ti->second;
constitution.cc:412:		LOG(BF("Did not find the plug[%s]") % name->__repr__() );
constitution.cc:419:        LOG(BF("simplest topology is named: %s") % tres->getName()->__repr__()  );
constitution.cc:422:        LOG(BF("there is no topology that has the plug[%s]") % name->__repr__() );
constitution.cc:433:	ASSERTF(this->_Topologies.contains(name),BF("There is no topology with name[%s] in constitution[%s]") % name->__repr__() % this->getName()->__repr__() );
constitution.cc:434:	return this->_Topologies.get(name,_lisp);
constitution.cc:447:    for ( ti=this->_Topologies.begin(); ti!=this->_Topologies.end(); ti++ ) 
constitution.cc:449:	LOG(BF("Checking topology(%s)")% ti->first->__repr__() );
constitution.cc:450:	if ( ti->second->matchesMonomerEnvironment(mon) ) 
constitution.cc:452:	    return ti->second;
constitution.cc:465:    for ( ti=this->_Topologies.begin(); ti!=this->_Topologies.end(); ti++ ) {
constitution.cc:466:	if ( ti->second->matchesContext(cont) ) {
constitution.cc:467:	    return ti->second;
constitution.cc:483://    group->setName(this->getName());
constitution.cc:484:    for (si=this->begin_Stereoisomers(); si!=this->end_Stereoisomers(); si++){
constitution.cc:485:	group->addMonomerName((*si)->getName());
constitution.cc:505:    this->defineCouplingInOutVector(in,out);
constitution.cc:519:    this->defineCouplingInOutVector(in,out);
constitution.cc:537:    this->defineCouplingInOutVector(in,out);
constitution.cc:557:    this->defineCouplingInOutVector(in,out);
constitution.cc:573:    link->setIn(in);
constitution.cc:574:    link->setOut(out);
constitution.cc:575:    this->links.push_back(link);
constitution.cc:588:    this->defineCouplingOutVector(out);
constitution.cc:602:    this->defineCouplingOutVector(out);
constitution.cc:618:    this->defineCouplingOutVector(out);
constitution.cc:635:    link->setIn("");
constitution.cc:636:    link->setOut(out);
constitution.cc:637:    this->links.push_back(link);
constitution.cc:650:    cm->dump();
constitution.cc:653:    for ( i=this->links.begin(); i!= this->links.end(); i++ ) {
constitution.cc:655:    LOG(BF("----------  To constitution coupling map") ); //
constitution.cc:656:    (*i)->dump();
constitution.cc:659:	if ( (*i)->matchesTopology(cm) ) {
constitution.cc:677:    this->Base::initialize();
constitution.cc:678:    this->_Comment = "";
constitution.cc:679:    this->_Name = _Nil<core::Symbol_O>();
constitution.cc:680:    this->_ConstitutionAtoms = _lisp->create<ConstitutionAtoms_O>();
constitution.cc:681:    this->_StereoInformation = _lisp->create<StereoInformation_O>();
constitution.cc:694:    this->Base::archiveBase(node);
constitution.cc:696:    node->attribute("name",this->_Name);
constitution.cc:698:    if ( node->loading() )
constitution.cc:700:	if ( node->hasAttribute("name") )
constitution.cc:702:	    node->attribute("name",this->_Name);
constitution.cc:705:	    node->attribute("_key",this->_Name);
constitution.cc:709:	node->attribute("name",this->_Name);
constitution.cc:712:    node->attributeIfNotDefault<string>("comment",this->_Comment,"");
constitution.cc:713:    node->attributeSymbolIfNotNil("metaConstitution",this->_MetaConstitution);
constitution.cc:714:    node->archiveObject("constitutionAtoms",this->_ConstitutionAtoms);
constitution.cc:715:    node->archiveObject("stereoInformation", this->_StereoInformation );
constitution.cc:716:    node->archiveSymbolMap( "constitutionPlugs", this->_PlugsByName );
constitution.cc:717:    node->archiveSymbolMap( "topologies", this->_Topologies );
constitution.cc:718://    node->archiveMap( "fragments", this->_Fragments );
constitution.cc:719://    node->archiveMap( "frames", this->_Frames );
constitutionAtoms.cc:36:	me->_BondOrder = order;
constitutionAtoms.cc:37:	me->_AtomIndex = index;
constitutionAtoms.cc:44:	this->_AtomIndex = UndefinedUnsignedInt;
constitutionAtoms.cc:45:	this->_BondOrder = noBond;
constitutionAtoms.cc:51:	this->Base::archiveBase(node);
constitutionAtoms.cc:52:	node->attribute("ai",this->_AtomIndex);
constitutionAtoms.cc:53:	node->attributeSymbolEnumHiddenConverter("bo",this->_BondOrder,_sym_bondOrderToSymbolConverter);
constitutionAtoms.cc:82:	ConstitutionAtom_sp ta = lisp->create<ConstitutionAtom_O>();
constitutionAtoms.cc:83:	ta->_AtomName = name;
constitutionAtoms.cc:84:	ta->_Element = element;
constitutionAtoms.cc:85:	ta->_AtomIndex = index;
constitutionAtoms.cc:91:	this->_AtomName = "";
constitutionAtoms.cc:92:	this->_AtomIndex = UndefinedUnsignedInt;
constitutionAtoms.cc:99:	this->Base::archiveBase(node);
constitutionAtoms.cc:100:	node->attribute("atomName",this->_AtomName);
constitutionAtoms.cc:101:	node->attribute("ci",this->_AtomIndex);
constitutionAtoms.cc:102:	node->attributeSymbolEnumHiddenConverter("element",this->_Element,_sym_elementToSymbolConverter);
constitutionAtoms.cc:103:	node->archiveVector0("bonds",this->_Bonds);
constitutionAtoms.cc:110:	ss << "( " << this->className() << " ";
constitutionAtoms.cc:111:	ss << " :atomName \"" << this->_AtomName << "\"";
constitutionAtoms.cc:112:	ss << " :element " << symbolFromElement(this->_Element);
constitutionAtoms.cc:113:	ss << " :atomIndex " << this->_AtomIndex << " )";
constitutionAtoms.cc:139:	ConstitutionVirtualAtom_sp ta = lisp->create<ConstitutionVirtualAtom_O>();
constitutionAtoms.cc:140:	ta->_AtomName = name;
constitutionAtoms.cc:141:	ta->_AtomIndex = index;
constitutionAtoms.cc:142:	ta->_CalculatePositionCode = code;
constitutionAtoms.cc:149:	ConstitutionVirtualAtom_sp ta = lisp->create<ConstitutionVirtualAtom_O>();
constitutionAtoms.cc:150:	ta->_AtomName = name;
constitutionAtoms.cc:151:	ta->_AtomIndex = UndefinedUnsignedInt;
constitutionAtoms.cc:152:	ta->_CalculatePositionCode = code;
constitutionAtoms.cc:158:	this->Base::initialize();
constitutionAtoms.cc:164:	this->Base::archiveBase(node);
constitutionAtoms.cc:183:	    .def("constitution-atoms-index",&ConstitutionAtoms_O::index)
constitutionAtoms.cc:196:	    .def("constitution-atoms-index",&ConstitutionAtoms_O::index)
constitutionAtoms.cc:211:	    for ( it=residue->begin_atoms(); it!=residue->end_atoms(); it++, index++ )
constitutionAtoms.cc:213:		Atom_sp atom = (*it)->as<Atom_O>();
constitutionAtoms.cc:214:		ConstitutionAtom_sp catom = atom->asConstitutionAtom(index);
constitutionAtoms.cc:215:		catoms->_Atoms.append(catom);
constitutionAtoms.cc:221:	    for ( it=residue->begin_atoms(); it!=residue->end_atoms(); it++, index++ )
constitutionAtoms.cc:223:		Atom_sp atom = (*it)->as<Atom_O>();
constitutionAtoms.cc:224:		ConstitutionAtom_sp catom = catoms->_Atoms[index];
constitutionAtoms.cc:225:		atom->defineConstitutionAtomBonding(catom,atomToIndexMap);
constitutionAtoms.cc:234:	ConstitutionAtomIndex0N nextIndex = this->_Atoms.size();
constitutionAtoms.cc:235:	ca->_AtomIndex = nextIndex;
constitutionAtoms.cc:236:	this->_Atoms.append(ca);
constitutionAtoms.cc:242:	ASSERTF(idx>=0&&idx<(int)(this->_Atoms.size()),BF("index[%d] out of range") % idx );
constitutionAtoms.cc:243:	ConstitutionAtom_sp& ca = this->_Atoms[(uint)idx];
constitutionAtoms.cc:244:	ASSERTF(idx==ca->_AtomIndex,BF("A mismatch has occured between the index[%d] in the ConstitutionAtoms array and the ConstitutionAtom index[%d] - these have to match or we can't quickly look up atoms by their index") % idx % ca->_AtomIndex );
constitutionAtoms.cc:250:	core::StringSet_sp ss = _lisp->create<core::StringSet_O>();
constitutionAtoms.cc:251:	for ( core::Vector0<ConstitutionAtom_O>::const_iterator ci=this->_Atoms.begin();
constitutionAtoms.cc:252:	      ci!=this->_Atoms.end(); ci++ )
constitutionAtoms.cc:254:	    ss->insert((*ci)->_AtomName);
constitutionAtoms.cc:261:	this->_NetCharge = 0.0;
constitutionAtoms.cc:267:	this->Base::archiveBase(n);
constitutionAtoms.cc:268:	n->attribute("netCharge",this->_NetCharge);
constitutionAtoms.cc:269:	n->archiveVector0("atoms",this->_Atoms);
constitutionAtoms.cc:276:	for ( core::Vector0<ConstitutionAtom_O>::const_iterator ci=this->_Atoms.begin();
constitutionAtoms.cc:277:	      ci!=this->_Atoms.end(); ci++ )
constitutionAtoms.cc:279:	    if ( (*ci)->_AtomName == nm ) return *ci;
constitutionAtoms.cc:287:	return this->_Atoms[id];
constitutionAtoms.cc:292:	for ( int idx=0; idx<(int)this->_Atoms.size(); idx++ )
constitutionAtoms.cc:294:	    const ConstitutionAtom_sp& atom = this->_Atoms[idx];
constitutionAtoms.cc:295:	    if ( atom->_AtomName == name ) return idx;
constitutionAtoms.cc:302:	Residue_sp res = _lisp->create<Residue_O>();
constitutionAtoms.cc:303:	res->setNetCharge(this->_NetCharge);
constitutionAtoms.cc:305:	atoms.resize(this->_Atoms.size());
constitutionAtoms.cc:306:	res->resizeContents(this->_Atoms.size());
constitutionAtoms.cc:307:	for ( core::Vector0<ConstitutionAtom_O>::const_iterator ci=this->_Atoms.begin();
constitutionAtoms.cc:308:	      ci!=this->_Atoms.end(); ci++ )
constitutionAtoms.cc:310:	    Atom_sp atom = _lisp->create<Atom_O>();
constitutionAtoms.cc:311:	    atom->setName((*ci)->_AtomName);
constitutionAtoms.cc:312:	    atom->setElement((*ci)->_Element);
constitutionAtoms.cc:313:	    atom->setId((*ci)->_AtomIndex);
constitutionAtoms.cc:314:	    atoms[(*ci)->_AtomIndex] = atom;
constitutionAtoms.cc:315:	    res->putMatter((*ci)->_AtomIndex,atom);
constitutionAtoms.cc:317:	for ( core::Vector0<ConstitutionAtom_O>::const_iterator ci=this->_Atoms.begin();
constitutionAtoms.cc:318:	      ci!=this->_Atoms.end(); ci++ )
constitutionAtoms.cc:320:	    ASSERT_lt((*ci)->_AtomIndex,(int)atoms.size());
constitutionAtoms.cc:321:	    Atom_sp fromAtom = atoms[(*ci)->_AtomIndex];
constitutionAtoms.cc:322:	    for ( core::Vector0<ConstitutionBond_O>::const_iterator bi=(*ci)->_Bonds.begin(); bi!=(*ci)->_Bonds.end(); bi++ )
constitutionAtoms.cc:325:		if ( (*bi)->_AtomIndex < (*ci)->_AtomIndex ) continue;
constitutionAtoms.cc:326:		ASSERT_lt((*bi)->_AtomIndex,(int)atoms.size());
constitutionAtoms.cc:327:		Atom_sp toAtom = atoms[(*bi)->_AtomIndex];
constitutionAtoms.cc:328:		BondOrder order = (*bi)->_BondOrder;
constitutionAtoms.cc:329:		fromAtom->bondTo(toAtom,order);
coordSys.cc:47:    Vector3 c2xo = coord->getX();
coordSys.cc:53:	    this->_RotZ = acos(cosXy);
coordSys.cc:55:	    this->_RotZ = -acos(cosXy);
coordSys.cc:57:	LOG(BF("this->_RotZ = %lf degrees") % this->_RotZ/DEGTORAD  );
coordSys.cc:62:        mrotz.rightHandedRotationZ(-this->_RotZ);
coordSys.cc:66:	    this->_RotY = acos(cosC2x);
coordSys.cc:68:	    this->_RotY = -acos(cosC2x);
coordSys.cc:70:	LOG(BF("this->_RotY = %lf degrees") % this->_RotY/DEGTORAD  );
coordSys.cc:72:        mroty.rightHandedRotationY(-this->_RotY);
coordSys.cc:74:	Vector3 c2y = mrotz.multiplyByVector3(coord->getY());
coordSys.cc:78:            this->_RotX = acos(c3y.dotProduct(labY));
coordSys.cc:80:	    this->_RotX = -acos(c3y.dotProduct(labY));
coordSys.cc:82:	LOG(BF("this->_RotX = %lf degrees") % this->_RotX/DEGTORAD  );
coordSys.cc:83:	Vector3 trans = coord->getOrigin();
coordSys.cc:92:	    this->_RotZZ = acos(cosXy);
coordSys.cc:94:	    this->_RotZZ = -acos(cosXy);
coordSys.cc:96:	LOG(BF("this->_RotZZ = %lf degrees") % this->_RotZZ/DEGTORAD  );
coordSys.cc:100:        mrotz.rightHandedRotationZ(-this->_RotZZ);
coordSys.cc:107:	    this->_RotYY = acos(cosC2x);
coordSys.cc:109:	    this->_RotYY = -acos(cosC2x);
coordSys.cc:111:	LOG(BF("this->_RotYY = %lf degrees") % this->_RotYY/DEGTORAD  );
coordSys.cc:112:        this->_Distance = trans.length();
coordSys.cc:113:	LOG(BF("this->_Distance = %lf") % this->_Distance  );
coordSys.cc:118://	// Calculate RotZ, the angle around the Z-axis I need to rotate X into the lab XY-plane
coordSys.cc:122://    node = labZ.crossProduct(coord->getZ());
coordSys.cc:125://    LOG(BF("coordX = {%lf,%lf,%lf}") % coord->getX().getX() % coord->getX().getY() % coord->getX().getZ()  );
coordSys.cc:126://    LOG(BF("coordY = {%lf,%lf,%lf}") % coord->getY().getX() % coord->getY().getY() % coord->getY().getZ()  );
coordSys.cc:127://    LOG(BF("coordZ = {%lf,%lf,%lf}") % coord->getZ().getX() % coord->getZ().getY() % coord->getZ().getZ()  );
coordSys.cc:128://    cosRotY = labZ.dotProduct(coord->getZ());
coordSys.cc:133://	gamma = 0.0; // If the labZ and coord->getZ() are parallel or anti-parallel then gamma=
coordSys.cc:138://        alpha = labX.angleToVectorAboutNormal(coord->getX(),labZ);
coordSys.cc:146://	gamma = nodeNorm.angleToVectorAboutNormal(coord->getX(),coord->getZ());
coordSys.cc:157://    translate = coord->getOrigin();
coordSys.cc:184://    this->_RotX = alpha;
coordSys.cc:185://    this->_RotY = beta;
coordSys.cc:186://    this->_RotZ = gamma;
coordSys.cc:187://    this->_Distance = distance;
coordSys.cc:188://    this->_RotZZ = theta;
coordSys.cc:189://    this->_RotYY = phi;
coordSys.cc:196:    ss << prefix << "RotX  = " << this->_RotX/0.0174533 << " deg" << endl;
coordSys.cc:197:    ss << prefix << "RotY  = " << this->_RotY/0.0174533 << " deg" << endl;
coordSys.cc:198:    ss << prefix << "RotZ  = " << this->_RotZ/0.0174533 << " deg" << endl;
coordSys.cc:199:    ss << prefix << "RotYY = " << this->_RotYY/0.0174533 << " deg" << endl;
coordSys.cc:200:    ss << prefix << "RotZZ = " << this->_RotZZ/0.0174533 << " deg" << endl;
coordSys.cc:201:    ss << prefix << "Dist  = " << this->_Distance << " A" << endl;
coordSys.cc:211:	ss << this->_RotX/0.0174533 << " ";
coordSys.cc:212:	ss << this->_RotY/0.0174533 << " " ;
coordSys.cc:213:	ss << this->_RotZ/0.0174533 << " " ;
coordSys.cc:214:	ss << this->_RotYY/0.0174533 << " ";
coordSys.cc:215:	ss << this->_RotZZ/0.0174533 << " ";
coordSys.cc:216:	ss << this->_Distance;
coordSys.cc:226:    toCanonical = start->matrixToCanonical();
coordSys.cc:227:    transformedDest = dest->copy();
coordSys.cc:228:    transformedDest->transformWithMatrix(toCanonical);
coordSys.cc:229:    this->defineForCoordinateSystem(transformedDest);
coordSys.cc:234:    this->_RotX = g->getRotX();
coordSys.cc:235:    this->_RotY = g->getRotY();
coordSys.cc:236:    this->_RotZ = g->getRotZ();
coordSys.cc:237:    this->_RotYY = g->getRotYY();
coordSys.cc:238:    this->_RotZZ = g->getRotZZ();
coordSys.cc:239:    this->_Distance = g->getDistance();
coordSys.cc:244:    n->attribute("RotX",this->_RotX );
coordSys.cc:245:    n->attribute("RotY",this->_RotY );
coordSys.cc:246:    n->attribute("RotZ",this->_RotZ );
coordSys.cc:247:    n->attribute("Dist",this->_Distance );
coordSys.cc:248:    n->attribute("RotYY",this->_RotYY );
coordSys.cc:249:    n->attribute("RotZZ",this->_RotZZ );
coordSys.cc:257:    c = _lisp->create<CoordinateSystem_O>();
coordSys.cc:258:    mt = this->matrixFromCanonical();
coordSys.cc:259:    c->transformWithMatrix(mt);
coordSys.cc:267:    Matrix mRotYY; mRotYY.rightHandedRotationY(this->_RotYY);
coordSys.cc:268:    Matrix mRotZZ; mRotZZ.rightHandedRotationZ(this->_RotZZ);
coordSys.cc:279:    Matrix mX; mX.rightHandedRotationX(this->_RotX);
coordSys.cc:280:    Matrix mY; mY.rightHandedRotationY(this->_RotY);
coordSys.cc:281:    Matrix mZ; mZ.rightHandedRotationZ(this->_RotZ);
coordSys.cc:282:    Vector3 vTrans = this->getDirection();
coordSys.cc:283:    vTrans = vTrans.multiplyByScalar(this->_Distance);
coordSys.cc:295:    c = this->getCoordinateSystem();
coordSys.cc:296:    return c->matrixToCanonical();
coordSys.cc:308:	// Calculate Gamma, the angle around the Z-axis I need to rotate X into the lab XY-plane
coordSys.cc:312:    node = labZ.crossProduct(coord->getZ());
coordSys.cc:315:    LOG(BF("coordX = {%lf,%lf,%lf}") % (coord->getX().getX()) % (coord->getX().getY()) % (coord->getX().getZ() ) );
coordSys.cc:316:    LOG(BF("coordY = {%lf,%lf,%lf}") % (coord->getY().getX()) % (coord->getY().getY()) % (coord->getY().getZ() ) );
coordSys.cc:317:    LOG(BF("coordZ = {%lf,%lf,%lf}") % (coord->getZ().getX()) % (coord->getZ().getY()) % (coord->getZ().getZ() ) );
coordSys.cc:318:    cosBeta = labZ.dotProduct(coord->getZ());
coordSys.cc:323:	gamma = 0.0; // If the labZ and coord->getZ() are parallel or anti-parallel then gamma=
coordSys.cc:328:        alpha = labX.angleToVectorAboutNormal(coord->getX(),labZ);
coordSys.cc:336:	gamma = nodeNorm.angleToVectorAboutNormal(coord->getX(),coord->getZ());
coordSys.cc:347:    translate = coord->getOrigin();
coordSys.cc:374:    this->_Alpha = alpha;
coordSys.cc:375:    this->_Beta = beta;
coordSys.cc:376:    this->_Gamma = gamma;
coordSys.cc:377:    this->_Distance = distance;
coordSys.cc:378:    this->_Theta = theta;
coordSys.cc:379:    this->_Phi = phi;
coordSys.cc:385:    ss << "Alpha = " << this->_Alpha/0.0174533 << endl;
coordSys.cc:386:    ss << "Beta = " << this->_Beta/0.0174533 << endl;
coordSys.cc:387:    ss << "Gamma = " << this->_Gamma/0.0174533 << endl;
coordSys.cc:388:    ss << "Phi = " << this->_Phi/0.0174533 << endl;
coordSys.cc:389:    ss << "Theta = " << this->_Theta/0.0174533 << endl;
coordSys.cc:390:    ss << "Distance = " << this->_Distance << endl;
coordSys.cc:399:    toCanonical = start->matrixToCanonical();
coordSys.cc:400:    transformedDest = dest->copy();
coordSys.cc:401:    transformedDest->transformWithMatrix(toCanonical);
coordSys.cc:402:    this->defineForCoordinateSystem(transformedDest);
coordSys.cc:407:    n->attribute("Alpha",this->_Alpha );
coordSys.cc:408:    n->attribute("Beta",this->_Beta );
coordSys.cc:409:    n->attribute("Gamma",this->_Gamma );
coordSys.cc:410:    n->attribute("Dist",this->_Distance );
coordSys.cc:411:    n->attribute("Phi",this->_Phi );
coordSys.cc:412:    n->attribute("Theta",this->_Theta );
coordSys.cc:422:    c = _lisp->create<CoordinateSystem_O>();
coordSys.cc:423:    mt = this->matrixFromCanonical();
coordSys.cc:424:    c->transformWithMatrix(mt);
coordSys.cc:431:    Matrix mD; mD.rightHandedRotationZ(this->_Alpha);
coordSys.cc:432:    Matrix mC; mC.rightHandedRotationX(this->_Beta);
coordSys.cc:433:    Matrix mB; mB.rightHandedRotationZ(this->_Gamma);
coordSys.cc:434:    Matrix mPhi; mPhi.rightHandedRotationZ(this->_Phi);
coordSys.cc:435:    Matrix mTheta; mTheta.rightHandedRotationX(this->_Theta);
coordSys.cc:436:    Vector3 vTrans; vTrans.set(0.0,0.0,this->_Distance);
coordSys.cc:450:    c = this->getCoordinateSystem();
coordSys.cc:451:    return c->matrixToCanonical();
coordSys.cc:461:    this->Base::initialize();
coordSys.cc:462:    this->canonical();
coordSys.cc:469:    this->origin = orig.origin;
coordSys.cc:470:    this->x = orig.x;
coordSys.cc:471:    this->y = orig.y;
coordSys.cc:472:    this->z = orig.z;
coordSys.cc:485://	one unit along this ones X-axis
coordSys.cc:491:    mt.atColRowPut( 0, 0, this->x.getX() );
coordSys.cc:492:    mt.atColRowPut( 0, 1, this->x.getY() );
coordSys.cc:493:    mt.atColRowPut( 0, 2, this->x.getZ() );
coordSys.cc:495:    mt.atColRowPut( 1, 0, this->y.getX() );
coordSys.cc:496:    mt.atColRowPut( 1, 1, this->y.getY() );
coordSys.cc:497:    mt.atColRowPut( 1, 2, this->y.getZ() );
coordSys.cc:499:    mt.atColRowPut( 2, 0, this->z.getX() );
coordSys.cc:500:    mt.atColRowPut( 2, 1, this->z.getY() );
coordSys.cc:501:    mt.atColRowPut( 2, 2, this->z.getZ() );
coordSys.cc:503:    m.translate(&(this->origin));
coordSys.cc:517://	X-axis will be transformed to 1,0,0
coordSys.cc:523:    m.atRowColPut( 0, 0, this->x.getX() );
coordSys.cc:524:    m.atRowColPut( 0, 1, this->x.getY() );
coordSys.cc:525:    m.atRowColPut( 0, 2, this->x.getZ() );
coordSys.cc:527:    m.atRowColPut( 1, 0, this->y.getX() );
coordSys.cc:528:    m.atRowColPut( 1, 1, this->y.getY() );
coordSys.cc:529:    m.atRowColPut( 1, 2, this->y.getZ() );
coordSys.cc:531:    m.atRowColPut( 2, 0, this->z.getX() );
coordSys.cc:532:    m.atRowColPut( 2, 1, this->z.getY() );
coordSys.cc:533:    m.atRowColPut( 2, 2, this->z.getZ() );
coordSys.cc:535:    vt = this->origin.multiplyByScalar(-1.0);
coordSys.cc:555:    this->origin = Vector3(0.0,0.0,0.0);
coordSys.cc:556:    this->x = Vector3(1.0,0.0,0.0);
coordSys.cc:557:    this->y = Vector3(0.0,1.0,0.0);
coordSys.cc:558:    this->z = Vector3(0.0,0.0,1.0);
coordSys.cc:567://	the x axis is along (ax-aorigin)
coordSys.cc:573:    vo = aorigin->getPosition();
coordSys.cc:575:    vx = (ax->getPosition() - vo).normalized(_lisp);
coordSys.cc:577:    vxy = (axy->getPosition() - vo).normalized(_lisp);
coordSys.cc:583:    this->origin = vo;
coordSys.cc:584:    this->x = vx;
coordSys.cc:585:    this->y = vy;
coordSys.cc:586:    this->z = vz;
coordSys.cc:595://	the x axis is along (ax-aorigin)
coordSys.cc:613:    this->origin = vo;
coordSys.cc:614:    this->x = vx;
coordSys.cc:615:    this->y = vy;
coordSys.cc:616:    this->z = vz;
coordSys.cc:624://	the x axis is along (ax-aorigin)
coordSys.cc:651:    this->origin = vo;
coordSys.cc:652:    this->x = vx;
coordSys.cc:653:    this->y = vy;
coordSys.cc:654:    this->z = vz;
coordSys.cc:662://	the x axis is along (ax-aorigin)
coordSys.cc:668:    this->origin = vo;
coordSys.cc:669:    this->x.set(1.0,0.0,0.0);
coordSys.cc:670:    this->y.set(0.0,1.0,0.0);
coordSys.cc:671:    this->z.set(0.0,0.0,1.0);
coordSys.cc:680://	of the X-axis and Y-axis.  The Z-axis is calculated from
coordSys.cc:681://	the cross-product of xDir and yDir.
coordSys.cc:689:    this->origin = orig;
coordSys.cc:690:    this->x = xDir.normalized(_lisp);
coordSys.cc:691:    this->y = yDir.normalized(_lisp);
coordSys.cc:692:    vzt = (this->x).crossProduct(this->y);
coordSys.cc:693:    this->z = vzt.normalized(_lisp);
coordSys.cc:701://	of the X-axis and a vector in the XY plane.
coordSys.cc:702://	The Z-axis is calculated from the cross-product of xDir and xyPlane.
coordSys.cc:710:    this->origin = orig;
coordSys.cc:711:    this->x = xDir.normalized(_lisp);
coordSys.cc:713:    vzt = (this->x).crossProduct(vxy);
coordSys.cc:714:    this->z = vzt.normalized(_lisp);
coordSys.cc:715:    vyt = (this->z).crossProduct(this->x);
coordSys.cc:716:    this->y = vyt.normalized(_lisp);
coordSys.cc:723://	of the Z-axis and a vector in the XZ plane.
coordSys.cc:724://	The Y-axis is calculated from the cross-product of xDir and xyPlane.
coordSys.cc:732:    this->origin = orig;
coordSys.cc:733:    this->z = zDir.normalized(_lisp);
coordSys.cc:735:    vyt = (this->z).crossProduct(vxz);
coordSys.cc:736:    this->y = vyt.normalized(_lisp);
coordSys.cc:737:    vxt = (this->y).crossProduct(this->z);
coordSys.cc:738:    this->x = vxt.normalized(_lisp);
coordSys.cc:748://	of the X-axis and Z-axis.  The Y-axis is calculated from
coordSys.cc:749://	the cross-product of xDir and zDir.
coordSys.cc:757:    this->origin = orig;
coordSys.cc:758:    this->x = xDir.normalized(_lisp);
coordSys.cc:759:    this->z = zDir.normalized(_lisp);
coordSys.cc:760:    vyt = (this->z).crossProduct(this->x);
coordSys.cc:761:    this->y = vyt.normalized(_lisp);
coordSys.cc:769:x = core::randomNumber01()*RANGE - (RANGE/2.0);
coordSys.cc:770:y = core::randomNumber01()*RANGE - (RANGE/2.0);
coordSys.cc:771:z = core::randomNumber01()*RANGE - (RANGE/2.0);
coordSys.cc:772:    this->origin.set(x,y,z);
coordSys.cc:774:	x = core::randomNumber01()*2.0-1.0;
coordSys.cc:775:	y = core::randomNumber01()*2.0-1.0;
coordSys.cc:776:	z = core::randomNumber01()*2.0-1.0;
coordSys.cc:777:	this->x.set(x,y,z);
coordSys.cc:778:	if ( this->x.length() > 0.00001 ) break;
coordSys.cc:780:    this->x = this->x.normalized(_lisp);
coordSys.cc:782:	x = core::randomNumber01()*2.0-1.0;
coordSys.cc:783:	y = core::randomNumber01()*2.0-1.0;
coordSys.cc:784:	z = core::randomNumber01()*2.0-1.0;
coordSys.cc:785:	this->y.set(x,y,z);
coordSys.cc:786:	if ( this->y.length() > 0.00001 ) break;
coordSys.cc:788:    this->z = this->x.crossProduct(this->y);
coordSys.cc:789:    this->z = this->z.normalized(_lisp);
coordSys.cc:790:    this->y = this->z.crossProduct(this->x);
coordSys.cc:796:    this->origin = c->getOrigin();
coordSys.cc:797:    this->x = c->getX();
coordSys.cc:798:    this->y = c->getY();
coordSys.cc:799:    this->z = c->getZ();
coordSys.cc:805:    this->origin.set(0.0,0.0,0.0);
coordSys.cc:806:    this->x.set(1.0,0.0,0.0);
coordSys.cc:807:    this->y.set(0.0,1.0,0.0);
coordSys.cc:808:    this->z.set(0.0,0.0,1.0);
coordSys.cc:826:    m1 = this->matrixToCanonical();
coordSys.cc:827:    m2 = cs->matrixFromCanonical();
coordSys.cc:843:    vox = m*(this->x + this->origin);
coordSys.cc:844:    voy = m*(this->y + this->origin);
coordSys.cc:845:    voz = m*(this->z + this->origin);
coordSys.cc:846:    this->origin = m*this->origin;
coordSys.cc:847:    this->x = vox - this->origin;
coordSys.cc:848:    this->y = voy - this->origin;
coordSys.cc:849:    this->z = voz - this->origin;
coordSys.cc:861:    vox = (*m)*(this->x + this->origin);
coordSys.cc:862:    voy = (*m)*(this->y + this->origin);
coordSys.cc:863:    voz = (*m)*(this->z + this->origin);
coordSys.cc:864:    this->origin = (*m)*this->origin;
coordSys.cc:865:    this->x = vox - this->origin;
coordSys.cc:866:    this->y = voy - this->origin;
coordSys.cc:867:    this->z = voz - this->origin;
coordSys.cc:884:    line = xmlLine( XML_RED, (int)width, this->origin,
coordSys.cc:885:				this->origin+this->x*axisLength );
coordSys.cc:886:    graalphacs->addChild(line);
coordSys.cc:887:    line = xmlLine( XML_GREEN, (int)width, this->origin,
coordSys.cc:888:				this->origin+this->y*axisLength );
coordSys.cc:889:    graalphacs->addChild(line);
coordSys.cc:890:    line = xmlLine( XML_BLUE, (int)width, this->origin,
coordSys.cc:891:				this->origin+this->z*axisLength );
coordSys.cc:892:    graalphacs->addChild(line);
coordSys.cc:907:    _lisp->print(BF("origin: ( %lf, %lf, %lf )") %	this->origin.getX()% this->origin.getY() % this->origin.getZ() );
coordSys.cc:908:    _lisp->print(BF("x-axis: ( %lf, %lf, %lf )") %	this->x.getX()% this->x.getY() % this->x.getZ() );
coordSys.cc:909:    _lisp->print(BF("y-axis: ( %lf, %lf, %lf )") %	this->y.getX()% this->y.getY() % this->y.getZ() );
coordSys.cc:910:    _lisp->print(BF("z-axis: ( %lf, %lf, %lf )") %	this->z.getX()% this->z.getY() % this->z.getZ() );
coordSys.cc:916:    node->archivePlainObject<Vector3>( "origin", "Vector", this->origin );
coordSys.cc:917:    node->archivePlainObject<Vector3>( "x", "Vector", this->x );
coordSys.cc:918:    node->archivePlainObject<Vector3>( "y", "Vector", this->y );
coordSys.cc:919:    node->archivePlainObject<Vector3>( "z", "Vector", this->z );
coordSys.cc:934:    if ( !this->origin.sameAs(c->getOrigin()) ) return false;
coordSys.cc:935:    if ( !this->x.sameAs(c->getX()) ) return false;
coordSys.cc:936:    if ( !this->y.sameAs(c->getY()) ) return false;
coordSys.cc:937:    if ( !this->z.sameAs(c->getZ()) ) return false;
coordSys.cc:944:    uint idxOrigin = lines->appendVertex(this->origin,addon::Color_O::white(_lisp));
coordSys.cc:945:    uint idxX = lines->appendVertex(this->origin+this->x,addon::Color_O::red(_lisp));
coordSys.cc:946:    uint idxY = lines->appendVertex(this->origin+this->y,addon::Color_O::green(_lisp));
coordSys.cc:947:    uint idxZ = lines->appendVertex(this->origin+this->z,addon::Color_O::blue(_lisp));
coordSys.cc:948:    lines->appendLine(idxOrigin,idxX);
coordSys.cc:949:    lines->appendLine(idxOrigin,idxY);
coordSys.cc:950:    lines->appendLine(idxOrigin,idxZ);
coordSys.cc:952:    prims->append(lines);
coordSys.cc:959:    ss << "Origin: " << this->origin.asString() << endl;
coordSys.cc:960:    ss << "xdir: " << this->x.asString() << endl;
coordSys.cc:961:    ss << "ydir: " << this->y.asString() << endl;
coordSys.cc:962:    ss << "zdir: " << this->z.asString() << endl;
coordSys.cc:970:    transformToCanonical = this->matrixToCanonical();
coupling.cc:31:    this->Base::initialize();
coupling.cc:32:    this->_WeakOligomer = Oligomer_O::_nil;
coupling.cc:33:    this->_HasError = false;
coupling.cc:34:    this->_StatusMessage.str("");
coupling.cc:35:    this->_Selected = false;
coupling.cc:40:    LOG(BF("checking if coupling(%s) contains monomer: %s") % this->description().c_str() % mon->description().c_str() );
coupling.cc:41:    LOG(BF("About to check monomer1: %s") % this->getMonomer1()->description().c_str() );
coupling.cc:42:    if ( mon == this->getMonomer1() ) { return true; };
coupling.cc:43:    LOG(BF("About to check out monomer: %s") % this->getMonomer2()->description().c_str() );
coupling.cc:44:    if ( mon == this->getMonomer2() ) { return true; };
coupling.cc:53:    this->Base::archiveBase(node);
coupling.cc:54:    node->archiveWeakPointer("oligomer",this->_WeakOligomer );
coupling.cc:55:    node->attribute("hasError", this->_HasError );
coupling.cc:56:    node->attribute("statusMessage", this->_StatusMessage);
coupling.cc:63:    this->_WeakOligomer = o->sharedThis<Oligomer_O>();
coupling.cc:69:    this->_WeakOligomer = Oligomer_O::_nil;
coupling.cc:74:    ASSERTNOTNULL(this->_WeakOligomer);
coupling.cc:75:    return this->_WeakOligomer.lock();
coupling.cc:97:	string sname = name->identifierName();
coupling.cc:98:	LOG(BF("couplingName symbol[%s]  identifierName[%s]") % name->__repr__() % sname );
coupling.cc:103:	return lisp->intern(rest,name->getPackage());
coupling.cc:111:	ss << DirectionalCoupling_O::couplingName(name,lisp)->identifierName();
coupling.cc:112:	return lisp->intern(ss.str(),name->getPackage());
coupling.cc:121:    ss << DirectionalCoupling_O::couplingName(name,lisp)->identifierName();
coupling.cc:122:    return lisp->intern(ss.str(),name->getPackage());
coupling.cc:136:	ss << DirectionalCoupling_O::couplingName(name,lisp)->identifierName();
coupling.cc:137:	return lisp->intern(ss.str(),name->getPackage());
coupling.cc:152:    this->Base::initialize();
coupling.cc:153:    this->_InMonomer = Monomer_O::_nil;
coupling.cc:154:    this->_OutMonomer = Monomer_O::_nil;
coupling.cc:155:    this->_Name = _Nil<core::Symbol_O>();
coupling.cc:165:    this->_InMonomer = Monomer_O::_nil;
coupling.cc:171:    this->_OutMonomer = Monomer_O::_nil;
coupling.cc:179:    this->setHasError(false);
coupling.cc:180:    this->statusMessageStream().str("");
coupling.cc:181:    ANN(this->_InMonomer);
coupling.cc:182:    if ( this->_InMonomer.lock()->isNil() )
coupling.cc:184:        this->setHasError(true);
coupling.cc:185:	this->statusMessageStream() << "InMonomer is NULL" << endl;
coupling.cc:187:    ANN(this->_OutMonomer);
coupling.cc:188:    if ( this->_OutMonomer.lock()->isNil() )
coupling.cc:190:        this->setHasError(true);
coupling.cc:191:	this->statusMessageStream() << "OutMonomer is NULL" << endl;
coupling.cc:199:    ANN(this->_InMonomer);
coupling.cc:200:    if ( this->_InMonomer.lock()->isNil() )
coupling.cc:205:    mon = this->_InMonomer.lock();
coupling.cc:206:    LOG(BF("InMonomer is: %s") % mon->description().c_str()  );
coupling.cc:207:    if ( !mon->hasCouplingWithPlugName(DirectionalCoupling_O::outPlugName(this->getName(),_lisp)))
coupling.cc:212:    if ( !mon->hasMatchingPlugNameAndCoupling(DirectionalCoupling_O::outPlugName(this->getName(),_lisp),
coupling.cc:213:    					this->sharedThis<DirectionalCoupling_O>() ) )
coupling.cc:218:    ASSERTNOTNULL(this->_OutMonomer);
coupling.cc:219:    if ( this->_OutMonomer.lock()->isNil() )
coupling.cc:224:    mon = this->_OutMonomer.lock();
coupling.cc:225:    LOG(BF("OutMonomer is: %s") % mon->description().c_str()  );
coupling.cc:226:    if ( !mon->hasCouplingWithPlugName(DirectionalCoupling_O::inPlugName(this->getName(),_lisp)))
coupling.cc:231:    if ( !mon->hasMatchingPlugNameAndCoupling(DirectionalCoupling_O::inPlugName(this->getName(),_lisp),
coupling.cc:232:    					this->sharedThis<DirectionalCoupling_O>() ) )
coupling.cc:239:    THROW(_lisp->create<core::ContentException_O>(boost::format("Bad coupling %s") % this->sharedThis<DirectionalCoupling_O>()->description() ));
coupling.cc:246:    this->Base::archiveBase(node);
coupling.cc:247:    node->attribute("name", this->_Name );
coupling.cc:248:    node->archiveWeakPointer("inMonomer", this->_InMonomer );
coupling.cc:249:    node->archiveWeakPointer("outMonomer", this->_OutMonomer );
coupling.cc:257:    ASSERTNOTNULL(this->_OutMonomer);
coupling.cc:259:    return this->_OutMonomer.lock() == mon;
coupling.cc:266:    ASSERTNOTNULLP(this->_InMonomer,
coupling.cc:267:    	"InMonomer is NULL for coupling: "+this->description());
coupling.cc:268:    return this->_InMonomer.lock();
coupling.cc:273:    ASSERTNOTNULLP(this->_InMonomer,
coupling.cc:274:    	"InMonomer is NULL for coupling: "+this->description());
coupling.cc:275:    return this->_InMonomer.lock();
coupling.cc:281:    ASSERTNOTNULLP(this->_OutMonomer,
coupling.cc:282:    	"OutMonomer is NULL for coupling: "+this->description());
coupling.cc:283:    return this->_OutMonomer.lock();
coupling.cc:288:    ASSERTNOTNULLP(this->_OutMonomer,
coupling.cc:289:    	"OutMonomer is NULL for coupling: "+this->description());
coupling.cc:290:    return this->_OutMonomer.lock();
coupling.cc:296: * inPlugNames for couplings are the out-plugs for monomers
coupling.cc:300:    return DirectionalCoupling_O::outPlugName(this->_Name,_lisp);
coupling.cc:305: * inPlugNames for couplings are the out-plugs for monomers
coupling.cc:309:    return DirectionalCoupling_O::inPlugName(this->_Name,_lisp);
coupling.cc:317:ss << "DirectionalCoupling( "<< this->getName()->__repr__();
coupling.cc:321:    ANN(this->_InMonomer);
coupling.cc:322:    if ( this->_InMonomer.lock()->isNil())
coupling.cc:324:	ss << "-NULL_Monomer-";
coupling.cc:327:	ss << this->getInMonomer_const()->description();
coupling.cc:329:    ss << "->";
coupling.cc:330:    ANN(this->_OutMonomer);
coupling.cc:331:    if ( this->_OutMonomer.lock()->isNil() )
coupling.cc:333:	ss << "-NULL_Monomer-";
coupling.cc:336:	ss << this->getOutMonomer_const()->description();
coupling.cc:347:    this->_Name = DirectionalCoupling_O::couplingName(nm,_lisp);
coupling.cc:348:    ANN(this->_InMonomer);
coupling.cc:349:    if ( this->_InMonomer.lock().notnilp() )
coupling.cc:351:	this->_InMonomer.lock()->fixPlugNameForCoupling(this->sharedThis<DirectionalCoupling_O>());
coupling.cc:353:    ANN(this->_OutMonomer);
coupling.cc:354:    if ( this->_OutMonomer.lock().notnilp() )
coupling.cc:356:	this->_OutMonomer.lock()->fixPlugNameForCoupling(this->sharedThis<DirectionalCoupling_O>());
coupling.cc:364:    this->_InMonomer = m->sharedThis<Monomer_O>();
coupling.cc:365:    LOG(BF("Setting in monomer to (%s)") % m->description().c_str()  );
coupling.cc:371:    this->_OutMonomer = m->sharedThis<Monomer_O>();
coupling.cc:372:    LOG(BF("Setting out monomer to (%s)") % m->description().c_str()  );
coupling.cc:379:    this->setInMonomer_NoSignal(m);
coupling.cc:385:    this->setOutMonomer_NoSignal(m);
coupling.cc:396:    if ( mon == this->getInMonomer() ) return InSide;
coupling.cc:397:    if ( mon == this->getOutMonomer() ) return OutSide;
coupling.cc:408:    if ( mon == this->getInMonomer() ) { return this->getOutMonomer(); };
coupling.cc:410:    if ( mon == this->getOutMonomer() ) { return this->getInMonomer(); };
coupling.cc:412:    THROW(_lisp->create<core::ContentException_O>(boost::format("Monomer is not in coupling %s") % mon->description()));
coupling.cc:427:    if ( this->getHasError() ) return;
coupling.cc:428:    min = this->getInMonomer();
coupling.cc:429:    mout = this->getOutMonomer();
coupling.cc:430:    if ( min->getHasError() ) return;
coupling.cc:431:    if ( mout->getHasError() ) return;
coupling.cc:434:    minPlug = min->getPlugNamed(this->getInMonomerPlugName())->as<PlugWithMates_O>();
coupling.cc:435:    moutPlug = mout->getPlugNamed(this->getOutMonomerPlugName())->as<PlugWithMates_O>();
coupling.cc:444:    weakInRes = min->getTemporaryResidue();
coupling.cc:448:    weakOutRes = mout->getTemporaryResidue();
coupling.cc:454:    inB0 = inResidue->atomWithName(minPlug->getB0());
coupling.cc:455:    outB0 = outResidue->atomWithName(moutPlug->getB0());
coupling.cc:456:    b = inB0->bondTo(outB0,singleBond);
coupling.cc:457:    if ( moutPlug->getB1() != "" ) {
coupling.cc:458:	outB1 = outResidue->atomWithName(moutPlug->getB1());
coupling.cc:459:	if ( minPlug->getB1() != "" ) {
coupling.cc:460:	    inB1 = inResidue->atomWithName(minPlug->getB1());
coupling.cc:464:	    b = inB1->bondTo(outB1,singleBond);
coupling.cc:470:	    b = inB0->bondTo(outB1,singleBond);
coupling.cc:472:    } else if ( minPlug->getB1() != "" ) {
coupling.cc:476:	b = inB1->bondTo(outB0,singleBond);
coupling.cc:484:    if ( this->_InMonomer.lock() == mon ) {
coupling.cc:485:	core::Symbol_sp plugName = this->getInMonomerPlugName();
coupling.cc:486:	ASSERT(this->_InMonomer.lock().notnilp());
coupling.cc:487:	return this->_InMonomer.lock()->getPlugNamed(plugName);
coupling.cc:489:    core::Symbol_sp plugName = this->getOutMonomerPlugName();
coupling.cc:490:    ASSERT(this->_OutMonomer.lock().notnilp());
coupling.cc:491:    return this->_OutMonomer.lock()->getPlugNamed(plugName);
coupling.cc:496:    if ( this->_InMonomer.lock() == mon ) {
coupling.cc:497:	core::Symbol_sp plugName = this->getOutMonomerPlugName();
coupling.cc:498:	ASSERT(this->_OutMonomer.lock().notnilp());
coupling.cc:499:	return this->_OutMonomer.lock()->getPlugNamed(plugName);
coupling.cc:501:    core::Symbol_sp plugName = this->getInMonomerPlugName();
coupling.cc:502:    ASSERT(this->_InMonomer.lock().notnilp());
coupling.cc:503:    return this->_InMonomer.lock()->getPlugNamed(plugName);
coupling.cc:516:    this->setInMonomer_NoSignal(sin);
coupling.cc:517:    this->setOutMonomer_NoSignal(sout);
coupling.cc:518:    me = this->sharedThis<DirectionalCoupling_O>();
coupling.cc:519:    core::Symbol_sp inMonomerPlugName = DirectionalCoupling_O::outPlugName(this->getName(),_lisp);
coupling.cc:520:    core::Symbol_sp outMonomerPlugName = DirectionalCoupling_O::inPlugName(this->getName(),_lisp);
coupling.cc:521:    sin->addCoupling(inMonomerPlugName,me);
coupling.cc:522:    sout->addCoupling(outMonomerPlugName,me);
coupling.cc:534:    this->Base::initialize();
coupling.cc:535:    this->_Monomer1 = Monomer_O::_nil;
coupling.cc:536:    this->_Monomer2 = Monomer_O::_nil;
coupling.cc:537:    this->_Plug1 = _Nil<core::Symbol_O>();
coupling.cc:538:    this->_Plug2 = _Nil<core::Symbol_O>();
coupling.cc:544:    this->Base::archiveBase(node);
coupling.cc:545:    node->attribute("plug1", this->_Plug1);
coupling.cc:546:    node->attribute("plug2", this->_Plug2);
coupling.cc:547:    node->archiveWeakPointer("monomer1", this->_Monomer1 );
coupling.cc:548:    node->archiveWeakPointer("monomer2", this->_Monomer2 );
coupling.cc:556:    string name = "ringCoupling["+this->_Plug1->identifierName()+">"+this->_Plug2->identifierName()+"]";
coupling.cc:557:    return _lisp->intern(name,this->_Plug1->getPackage());
coupling.cc:563:    this->_Monomer1 = mon;
coupling.cc:568:    ASSERTNOTNULLP(this->_Monomer1,
coupling.cc:569:    	"InMonomer is NULL for coupling: "+this->description());
coupling.cc:570:    return this->_Monomer1.lock();
coupling.cc:575:    ASSERTNOTNULLP(this->_Monomer1,
coupling.cc:576:    	"InMonomer is NULL for coupling: "+this->description());
coupling.cc:577:    return this->_Monomer1.lock();
coupling.cc:583:    this->_Monomer2 = mon;
coupling.cc:588:    ASSERTNOTNULLP(this->_Monomer2,
coupling.cc:589:    	"Monomer2 is NULL for coupling: "+this->description());
coupling.cc:590:    return this->_Monomer2.lock();
coupling.cc:595:    ASSERTNOTNULLP(this->_Monomer2,
coupling.cc:596:    	"Monomer2 is NULL for coupling: "+this->description());
coupling.cc:597:    return this->_Monomer2.lock();
coupling.cc:603:    if ( mon == this->getMonomer1() ) { return this->getMonomer2(); };
coupling.cc:605:    if ( mon == this->getMonomer2() ) { return this->getMonomer1(); };
coupling.cc:607:    THROW(_lisp->create<core::ContentException_O>(boost::format("Monomer is not in coupling %s" ) % mon->description()));
coupling.cc:614:    this->setHasError(false);
coupling.cc:615:    this->statusMessageStream().str("");
coupling.cc:616:    ANN(this->_Monomer1);
coupling.cc:617:    if ( this->_Monomer1.lock()->isNil() )
coupling.cc:619:        this->setHasError(true);
coupling.cc:620:	this->statusMessageStream() << "Monomer1 is NULL" << endl;
coupling.cc:622:    ANN(this->_Monomer2);
coupling.cc:623:    if ( this->_Monomer2.lock()->isNil() )
coupling.cc:625:        this->setHasError(true);
coupling.cc:626:	this->statusMessageStream() << "Monomer2 is NULL" << endl;
coupling.cc:634:    ANN(this->_Monomer1);
coupling.cc:635:    if ( this->_Monomer1.lock()->isNil() )
coupling.cc:640:    mon = this->_Monomer1.lock();
coupling.cc:641:    LOG(BF("Monomer1 is: %s") % mon->description().c_str()  );
coupling.cc:642:    if ( !mon->hasCouplingWithPlugName(DirectionalCoupling_O::outPlugName(this->getPlug1(),_lisp)))
coupling.cc:647:    if ( !mon->hasMatchingPlugNameAndCoupling(DirectionalCoupling_O::outPlugName(this->getPlug1(),_lisp),
coupling.cc:648:    					this->sharedThis<RingCoupling_O>() ) )
coupling.cc:653:    ASSERTNOTNULL(this->_Monomer2);
coupling.cc:654:    if ( this->_Monomer2.lock()->isNil() )
coupling.cc:659:    mon = this->_Monomer2.lock();
coupling.cc:660:    LOG(BF("Monomer2 is: %s") % mon->description().c_str()  );
coupling.cc:661:    if ( !mon->hasCouplingWithPlugName(DirectionalCoupling_O::outPlugName(this->getPlug2(),_lisp)))
coupling.cc:666:    if ( !mon->hasMatchingPlugNameAndCoupling(DirectionalCoupling_O::outPlugName(this->getPlug2(),_lisp),
coupling.cc:667:    					this->sharedThis<RingCoupling_O>() ) )
coupling.cc:674:    THROW(_lisp->create<core::ContentException_O>(boost::format("Bad coupling %s" ) % this->sharedThis<RingCoupling_O>()->description() ));
coupling.cc:680:    this->_Plug1 = p;
coupling.cc:685:    this->_Plug2 = p;
coupling.cc:690:    return DirectionalCoupling_O::outPlugName(this->_Plug1,_lisp);
coupling.cc:694:    return DirectionalCoupling_O::outPlugName(this->_Plug2,_lisp);
coupling.cc:700:ss << "RingCoupling( "<< this->getName()->__repr__();
coupling.cc:704:    ANN(this->_Monomer1);
coupling.cc:705:    if ( this->_Monomer1.lock()->isNil())
coupling.cc:707:	ss << "-NULL_Monomer-";
coupling.cc:710:	ss << this->getMonomer1_const()->description();
coupling.cc:712:    ss << "->";
coupling.cc:713:    ANN(this->_Monomer2);
coupling.cc:714:    if ( this->_Monomer2.lock()->isNil() )
coupling.cc:716:	ss << "-NULL_Monomer-";
coupling.cc:719:	ss << this->getMonomer2_const()->description();
coupling.cc:734:    if ( this->getHasError() ) return;
coupling.cc:735:    mon1 = this->getMonomer1();
coupling.cc:736:    mon2 = this->getMonomer2();
coupling.cc:737:    if ( mon1->getHasError() ) return;
coupling.cc:738:    if ( mon2->getHasError() ) return;
coupling.cc:741:    mon1Plug = mon1->getPlugNamed(this->getPlug1())->as<PlugWithMates_O>();
coupling.cc:742:    mon2Plug = mon2->getPlugNamed(this->getPlug2())->as<PlugWithMates_O>();
coupling.cc:751:    weakInRes = mon1->getTemporaryResidue();
coupling.cc:755:    weakOutRes = mon2->getTemporaryResidue();
coupling.cc:761:    inB0 = inResidue->atomWithName(mon1Plug->getB0());
coupling.cc:762:    outB0 = outResidue->atomWithName(mon2Plug->getB0());
coupling.cc:763:    b = inB0->bondTo(outB0,singleBond);
coupling.cc:764:    if ( mon2Plug->getB1() != "" ) {
coupling.cc:765:	outB1 = outResidue->atomWithName(mon2Plug->getB1());
coupling.cc:766:	if ( mon1Plug->getB1() != "" ) {
coupling.cc:767:	    inB1 = inResidue->atomWithName(mon1Plug->getB1());
coupling.cc:771:	    b = inB1->bondTo(outB1,singleBond);
coupling.cc:777:	    b = inB0->bondTo(outB1,singleBond);
coupling.cc:779:    } else if ( mon1Plug->getB1() != "" ) {
coupling.cc:783:	b = inB1->bondTo(outB0,singleBond);
elements.cc:289:	if ( ai->_Valid )
elements.cc:291:	    elementFromAtomicSymbol[ai->_AtomicSymbol] = ai->_ElementEnum;
elements.cc:292:	    if ( ai->_Valid && ai->_RealElement )
elements.cc:294:		if ( ai->_AtomicSymbol.size() == 2 )
elements.cc:296:		    twoCharacterElementNames.insert(ai->_AtomicSymbol);
elements.cc:297:		} else if ( ai->_AtomicSymbol.size() == 1 )
elements.cc:299:		    oneCharacterElementNames.insert(ai->_AtomicSymbol);
elements.cc:313:	if ( ai->_Valid )
elements.cc:315:	    core::Symbol_sp sym = _lisp->internKeyword(ai->_AtomicSymbol);
elements.cc:316:	    elementConverter->addSymbolEnumPair(sym,_lisp->intern(ai->_AtomicSymbol),ai->_ElementEnum);
elements.cc:319:    _lisp->hiddenBinder()->extend(_sym_elementToSymbolConverter,elementConverter);
elements.cc:327:	core::Symbol_sp sym = _lisp->internKeyword(hi->_HybridizationSymbol);
elements.cc:328:	hybridizationConverter->addSymbolEnumPair(sym,_lisp->intern(hi->_HybridizationSymbol),hi->_HybridizationEnum);
elements.cc:330:    _lisp->hiddenBinder()->extend(_sym_hybridizationToSymbolConverter,hybridizationConverter);
elements.cc:336:    core::IntegerKeyObjectDictionary_sp dict = _lisp->create<core::IntegerKeyObjectDictionary_O>();
elements.cc:337:    _lisp->defvar(elementColors,dict);
elements.cc:338:    dict->set(element_C,addon::Color_O::systemColor(addon::_kw_cyan));
elements.cc:339:    dict->set(element_H,addon::Color_O::systemColor(addon::_kw_white));
elements.cc:340:    dict->set(element_O,addon::Color_O::systemColor(addon::_kw_red));
elements.cc:341:    dict->set(element_N,addon::Color_O::systemColor(addon::_kw_blue));
elements.cc:342:    dict->set(element_S,addon::Color_O::systemColor(addon::_kw_yellow));
elements.cc:343:    dict->set(element_P,addon::Color_O::systemColor(addon::_kw_yellow));
elements.cc:344:    dict->set(element_Undefined,addon::Color_O::systemColor(addon::_kw_magenta));
elements.cc:354:    core::SymbolToEnumConverter_sp elementConverter = _lisp->hiddenBinder()->lookup(_sym_elementToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:355:    return elementConverter->symbolForEnum<Element>(element);
elements.cc:363:    core::SymbolToEnumConverter_sp hybridizationConverter = _lisp->hiddenBinder()->lookup(_sym_hybridizationToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:364:    return hybridizationConverter->symbolForEnum<Hybridization>(hybridization);
elements.cc:379:    core::SymbolToEnumConverter_sp elementConverter = _lisp->hiddenBinder()->lookup(_sym_elementToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:380:    return elementConverter->enumForSymbol<Element>(sym);
elements.cc:385:    core::SymbolToEnumConverter_sp hybridizationConverter = _lisp->hiddenBinder()->lookup(_sym_hybridizationToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:386:    return hybridizationConverter->enumForSymbol<Hybridization>(sym);
elements.cc:392:    core::SymbolToEnumConverter_sp hybridizationConverter = _lisp->hiddenBinder()->lookup(_sym_hybridizationToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:393:    return hybridizationConverter->enumForSymbol<Hybridization>(_lisp->intern(sym));
elements.cc:399:    core::SymbolToEnumConverter_sp hybridizationConverter = _lisp->hiddenBinder()->lookup(_sym_hybridizationToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:400:    return hybridizationConverter->symbolForEnum<Hybridization>(h);
elements.cc:405:    core::SymbolToEnumConverter_sp elementConverter = _lisp->hiddenBinder()->lookup(_sym_elementToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:406:    return elementConverter->symbolForEnum<Element>(h);
elements.cc:438:    core::SymbolToEnumConverter_sp elementConverter = _lisp->hiddenBinder()->lookup(_sym_elementToSymbolConverter)->as<core::SymbolToEnumConverter_O>();
elements.cc:439:    Element element = elementConverter->enumForSymbol<Element>(sym);
energyAnchorRestraint.cc:24:    this->_Atom1.reset();
energyAnchorRestraint.cc:34:    node->attribute("ka",this->term.ka);
energyAnchorRestraint.cc:35:    node->attribute("xa",this->term.xa);
energyAnchorRestraint.cc:36:    node->attribute("ya",this->term.ya);
energyAnchorRestraint.cc:37:    node->attribute("za",this->term.za);
energyAnchorRestraint.cc:38:    node->attribute("I1",this->term.I1);
energyAnchorRestraint.cc:39:    node->archiveObject("a1",this->_Atom1);
energyAnchorRestraint.cc:41:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyAnchorRestraint.cc:42:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyAnchorRestraint.cc:43:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyAnchorRestraint.cc:53:    node->addAttributeString("atomName",this->_Atom1->getName());
energyAnchorRestraint.cc:54:    node->addAttributeInt("I1",this->term.I1);
energyAnchorRestraint.cc:55:    node->addAttributeDoubleScientific("ka",this->term.ka);
energyAnchorRestraint.cc:56:    node->addAttributeDoubleScientific("xa",this->term.xa);
energyAnchorRestraint.cc:57:    node->addAttributeDoubleScientific("ya",this->term.ya);
energyAnchorRestraint.cc:58:    node->addAttributeDoubleScientific("za",this->term.za);
energyAnchorRestraint.cc:61:    xml->addAttributeBool("calcForce",this->_calcForce );
energyAnchorRestraint.cc:62:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyAnchorRestraint.cc:63:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyAnchorRestraint.cc:65:    node->addChild(xml);
energyAnchorRestraint.cc:73:    this->term.ka = xml->getAttributeDouble("ka");
energyAnchorRestraint.cc:74:    this->term.I1 = xml->getAttributeInt("I1");
energyAnchorRestraint.cc:75:    this->term.xa = xml->getAttributeDouble("xa");
energyAnchorRestraint.cc:76:    this->term.ya = xml->getAttributeDouble("ya");
energyAnchorRestraint.cc:77:    this->term.za = xml->getAttributeDouble("za");
energyAnchorRestraint.cc:78:    this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->term.I1)->atom();
energyAnchorRestraint.cc:107:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAnchorRestraint.cc:118:    this->_Terms.push_back(r);
energyAnchorRestraint.cc:149:// -----------------------
energyAnchorRestraint.cc:152:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x=cri->term.x;}
energyAnchorRestraint.cc:154:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition->element(ii+of);}
energyAnchorRestraint.cc:163:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyAnchorRestraint.cc:167:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyAnchorRestraint.cc:173:    if ( this->isEnabled() ) {
energyAnchorRestraint.cc:175:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAnchorRestraint.cc:181:	for ( vector<EnergyAnchorRestraint>::iterator cri=this->_Terms.begin();
energyAnchorRestraint.cc:182:		    cri!=this->_Terms.end(); cri++ ) {
energyAnchorRestraint.cc:214:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyAnchorRestraint.cc:220:// -----------------------
energyAnchorRestraint.cc:226:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyAnchorRestraint.cc:228:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyAnchorRestraint.cc:232:#define	ANCHOR_RESTRAINT_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyAnchorRestraint.cc:241:	if ( this->isEnabled() ) {
energyAnchorRestraint.cc:243:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAnchorRestraint.cc:249:	    for ( i=0,cri=this->_Terms.begin();
energyAnchorRestraint.cc:250:			cri!=this->_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:252:		    if ( this->_Debug_NumberOfAnchorRestraintTermsToCalculate > 0 ) {
energyAnchorRestraint.cc:253:			if ( i>= this->_Debug_NumberOfAnchorRestraintTermsToCalculate ) {
energyAnchorRestraint.cc:264:		    cri->_calcForce = calcForce;
energyAnchorRestraint.cc:265:		    cri->_calcDiagonalHessian = calcDiagonalHessian;
energyAnchorRestraint.cc:266:		    cri ->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyAnchorRestraint.cc:269:		    #define	EVAL_SET(var,val)	{ cri->eval.var=val;};
energyAnchorRestraint.cc:281:		    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyAnchorRestraint.cc:282:		    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyAnchorRestraint.cc:283:		    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyAnchorRestraint.cc:307://------------------
energyAnchorRestraint.cc:313:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyAnchorRestraint.cc:315:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyAnchorRestraint.cc:328:	if ( this->isEnabled() ) {
energyAnchorRestraint.cc:331:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAnchorRestraint.cc:337:	    for ( i=0,cri=this->_Terms.begin();
energyAnchorRestraint.cc:338:			cri!=this->_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:371:    this->_BeyondThresholdTerms.clear();
energyAnchorRestraint.cc:376://------------------
energyAnchorRestraint.cc:382:#define	ANCHOR_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyAnchorRestraint.cc:384:#define	ANCHOR_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyAnchorRestraint.cc:397:	if ( this->isEnabled() ) {
energyAnchorRestraint.cc:400:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAnchorRestraint.cc:406:	    for ( i=0,cri=this->_Terms.begin();
energyAnchorRestraint.cc:407:			cri!=this->_Terms.end(); cri++,i++ ) {
energyAnchorRestraint.cc:411:		if ( AnchorDeviation>this->_ErrorThreshold ) {
energyAnchorRestraint.cc:415://		    info<< a1->getAbsoluteIdPath() << " ";
energyAnchorRestraint.cc:417:		    info << a1->getName() << " ";
energyAnchorRestraint.cc:419:		    this->_BeyondThresholdTerms.push_back(*cri);
energyAnchorRestraint.cc:450:    this->Base::initialize();
energyAnchorRestraint.cc:451:    this->setErrorThreshold(0.2);
energyAnchorRestraint.cc:458:    this->Base::archiveBase(node);
energyAngle.cc:27:    this->_Atom1.reset();
energyAngle.cc:28:    this->_Atom2.reset();
energyAngle.cc:29:    this->_Atom3.reset();
energyAngle.cc:40://    node->archiveObject("_Term",this->_Term);
energyAngle.cc:41://    node->attribute("_Type1",this->_Type1);
energyAngle.cc:42://    node->attribute("_Type2",this->_Type2);
energyAngle.cc:43://    node->attribute("_Type3",this->_Type3);
energyAngle.cc:44://    node->attribute("_K3",this->_K3);
energyAngle.cc:45://    node->attribute("_K4",this->_K4);
energyAngle.cc:46://    node->attribute("_Ub_k",this->_Ub_k);
energyAngle.cc:47://    node->attribute("_Ub_len",this->_Ub_len);
energyAngle.cc:48:    node->attribute("kt",this->term.kt);
energyAngle.cc:49:    node->attribute("t0",this->term.t0);
energyAngle.cc:50:    node->attribute("I1",this->term.I1);
energyAngle.cc:51:    node->attribute("I2",this->term.I2);
energyAngle.cc:52:    node->attribute("I3",this->term.I3);
energyAngle.cc:53:    node->archiveObject("a1",this->_Atom1);
energyAngle.cc:54:    node->archiveObject("a2",this->_Atom2);
energyAngle.cc:55:    node->archiveObject("a3",this->_Atom3);
energyAngle.cc:57:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyAngle.cc:58:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyAngle.cc:59:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyAngle.cc:69://    this->_Term = term;
energyAngle.cc:70://    this->_Type1 = term->_Type1;
energyAngle.cc:71://    this->_Type2 = term->_Type2;
energyAngle.cc:72://    this->_Type3 = term->_Type3;
energyAngle.cc:73:    this->term.t0 = term->_AngRad;
energyAngle.cc:74:    this->term.kt = term->getK2_kCalPerRadianSquared()*scale;
energyAngle.cc:75://    this->_K3 = term->_K3;
energyAngle.cc:76://    this->_K4 = term->_K4;
energyAngle.cc:77://    this->_Ub_k = term->_Ub_k;
energyAngle.cc:78://    this->_Ub_len = term->_Ub_len;
energyAngle.cc:79:    this->_Atom1 = ea1->atom();
energyAngle.cc:80:    this->_Atom2 = ea2->atom();
energyAngle.cc:81:    this->_Atom3 = ea3->atom();
energyAngle.cc:82:    this->term.I1 = ea1->coordinateIndexTimes3();
energyAngle.cc:83:    this->term.I2 = ea2->coordinateIndexTimes3();
energyAngle.cc:84:    this->term.I3 = ea3->coordinateIndexTimes3();
energyAngle.cc:92:    this->_Type1 = ea1->_Atom->getTypeString();
energyAngle.cc:93:    this->_Type2 = ea2->_Atom->getTypeString();
energyAngle.cc:94:    this->_Type3 = ea3->_Atom->getTypeString();
energyAngle.cc:102:    pos1 = this->_Atom1->getPosition();
energyAngle.cc:103:    pos2 = this->_Atom2->getPosition();
energyAngle.cc:104:    pos3 = this->_Atom3->getPosition();
energyAngle.cc:115:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyAngle.cc:116:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyAngle.cc:117:    node->addAttributeString("atom3Name",this->_Atom3->getName());
energyAngle.cc:118://    node->addAttributeString("atom1Type",this->_Type1 );
energyAngle.cc:119://    node->addAttributeString("atom2Type",this->_Type2 );
energyAngle.cc:120://    node->addAttributeString("atom3Type",this->_Type3 );
energyAngle.cc:121:    node->addAttributeInt("I1",this->term.I1);
energyAngle.cc:122:    node->addAttributeInt("I2",this->term.I2);
energyAngle.cc:123:    node->addAttributeInt("I3",this->term.I3);
energyAngle.cc:124:    node->addAttributeDoubleScientific("kt",this->term.kt);
energyAngle.cc:125:    node->addAttributeDoubleScientific("t0",this->term.t0);
energyAngle.cc:128:    xml->addAttributeBool("calcForce",this->_calcForce );
energyAngle.cc:129:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyAngle.cc:130:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyAngle.cc:132:    node->addChild(xml);
energyAngle.cc:140:    int i1 = xml->getAttributeInt("idx1");
energyAngle.cc:141:    int i2 = xml->getAttributeInt("idx2");
energyAngle.cc:142:    int i3 = xml->getAttributeInt("idx3");
energyAngle.cc:143:    this->_Atom1 = atomTable->findEnergyAtomWithCoordinateIndex(i1)->atom();
energyAngle.cc:144:    this->_Atom2 = atomTable->findEnergyAtomWithCoordinateIndex(i2)->atom();
energyAngle.cc:145:    this->_Atom3 = atomTable->findEnergyAtomWithCoordinateIndex(i3)->atom();
energyAngle.cc:146:    this->term.kt = xml->getAttributeDouble("kt");
energyAngle.cc:147:    this->term.t0 = xml->getAttributeDouble("t0");
energyAngle.cc:148:    this->term.I1 = xml->getAttributeInt("I1");
energyAngle.cc:149:    this->term.I2 = xml->getAttributeInt("I2");
energyAngle.cc:150:    this->term.I3 = xml->getAttributeInt("I3");
energyAngle.cc:179:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAngle.cc:205:    this->_Terms.push_back(term);
energyAngle.cc:221:    for (eai=this->_Terms.begin();eai!=this->_Terms.end();eai++)
energyAngle.cc:223:	as1 = atomLabel(eai->_Atom1);
energyAngle.cc:224:	as2 = atomLabel(eai->_Atom2);
energyAngle.cc:225:	as3 = atomLabel(eai->_Atom3);
energyAngle.cc:235:	_lisp->print(BF("TERM 2ANG %-9s - %-9s - %-9s %8.2lf %8.2lf")
energyAngle.cc:239:			    % eai->term.kt
energyAngle.cc:240:			    % core::degrees(eai->term.t0) );
energyAngle.cc:260:#define	ANGLE_SET_PARAMETER(x)	{x=ai->term.x;}
energyAngle.cc:262:#define	ANGLE_SET_POSITION(x,ii,of)	{x=nvPosition->element(ii+of);}
energyAngle.cc:269:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyAngle.cc:273:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyAngle.cc:279:    if ( this->isEnabled() ) {
energyAngle.cc:281:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAngle.cc:289:	for ( vector<EnergyAngle>::iterator ai=this->_Terms.begin();
energyAngle.cc:290:		    ai!=this->_Terms.end(); ai++ )
energyAngle.cc:312:    if ( this->_DebugEnergy ) 
energyAngle.cc:315:	LOG_ENERGY(BF("%s {\n")% this->className());
energyAngle.cc:325:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyAngle.cc:335:#define ANGLE_SET_PARAMETER(x)	{x=ai->term.x;}
energyAngle.cc:337:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyAngle.cc:339:#define ANGLE_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyAngle.cc:349:    if ( this->isEnabled() ) 
energyAngle.cc:352:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAngle.cc:362:	for ( i=0,ai=this->_Terms.begin();
energyAngle.cc:363:		    ai!=this->_Terms.end(); ai++,i++ ) {
energyAngle.cc:365:		if ( this->_Debug_NumberOfTermsToCalculate > 0 ) {
energyAngle.cc:366:		    if ( i>= this->_Debug_NumberOfTermsToCalculate ) {
energyAngle.cc:377:		prob._Atom1 = ai->_Atom1;
energyAngle.cc:378:		prob._Atom2 = ai->_Atom2;
energyAngle.cc:379:		prob._Atom3 = ai->_Atom3;
energyAngle.cc:383:		ai->_calcForce = calcForce;
energyAngle.cc:384:		ai->_calcDiagonalHessian = calcDiagonalHessian;
energyAngle.cc:385:		ai->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyAngle.cc:387:		#define	EVAL_SET(var,val)	{ ai->eval.var=val;};
energyAngle.cc:390:	    if ( this->_DebugEnergy ) 
energyAngle.cc:422:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyAngle.cc:423:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyAngle.cc:424:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyAngle.cc:425:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyAngle.cc:426:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyAngle.cc:427:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyAngle.cc:428:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyAngle.cc:429:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyAngle.cc:430:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyAngle.cc:434:    if ( this->_DebugEnergy ) 
energyAngle.cc:436:	LOG_ENERGY(BF("%s }\n")% this->className());
energyAngle.cc:463:#define ANGLE_SET_PARAMETER(x)	{x=ai->term.x;}
energyAngle.cc:465:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyAngle.cc:475:	if ( this->isEnabled() ) {
energyAngle.cc:478:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAngle.cc:487:	    for ( i=0,ai=this->_Terms.begin();
energyAngle.cc:488:			ai!=this->_Terms.end(); ai++,i++ ) {
energyAngle.cc:489:		LOG(BF("ai->term.kt = %le") % ai->term.kt  );
energyAngle.cc:490:		LOG(BF("ai->term.t0 = %le") % ai->term.t0  );
energyAngle.cc:492:		LOG(BF("ai->x1 = %le") % pos->element(ai->term.I1 ) );
energyAngle.cc:493:		LOG(BF("ai->y1 = %le") % pos->element(ai->term.I1+1 ) );
energyAngle.cc:494:		LOG(BF("ai->z1 = %le") % pos->element(ai->term.I1+2 ) );
energyAngle.cc:495:		LOG(BF("ai->x2 = %le") % pos->element(ai->term.I2 ) );
energyAngle.cc:496:		LOG(BF("ai->y2 = %le") % pos->element(ai->term.I2+1 ) );
energyAngle.cc:497:		LOG(BF("ai->z2 = %le") % pos->element(ai->term.I2+2 ) );
energyAngle.cc:498:		LOG(BF("ai->x3 = %le") % pos->element(ai->term.I3 ) );
energyAngle.cc:499:		LOG(BF("ai->y3 = %le") % pos->element(ai->term.I3+1 ) );
energyAngle.cc:500:		LOG(BF("ai->z3 = %le") % pos->element(ai->term.I3+2 ) );
energyAngle.cc:530:    this->_BeyondThresholdTerms.clear();
energyAngle.cc:540:#define ANGLE_SET_PARAMETER(x)	{x=ai->term.x;}
energyAngle.cc:542:#define ANGLE_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyAngle.cc:552:	if ( this->isEnabled() ) {
energyAngle.cc:555:#pragma GCC diagnostic ignored "-Wunused-variable"
energyAngle.cc:565:	    for ( i=0,ai=this->_Terms.begin();
energyAngle.cc:566:			ai!=this->_Terms.end(); ai++,i++ ) {
energyAngle.cc:568:		if ( fabs(AngleDeviation)/t0 > this->_ErrorThreshold ) {
energyAngle.cc:574://		    info<< a1->getAbsoluteIdPath() << " ";
energyAngle.cc:575://		    info<< a2->getAbsoluteIdPath() << " ";
energyAngle.cc:576://		    info<< a3->getAbsoluteIdPath() << " ";
energyAngle.cc:578:		    info<<"threshold " << this->_ErrorThreshold << " Atoms(";
energyAngle.cc:579:		    info << a1->getName() << " ";
energyAngle.cc:580:		    info << a2->getName() << " ";
energyAngle.cc:581:		    info << a3->getName() << ") ";
energyAngle.cc:583:		    this->_BeyondThresholdTerms.push_back(*ai);
energyAngle.cc:615:    this->Base::initialize();
energyAngle.cc:616:    this->setErrorThreshold(0.2);
energyAngle.cc:622:    this->Base::archiveBase(node);
energyAtomTable.cc:34:	this->defineForAtom(forceField,atom,coordinateIndex);
energyAtomTable.cc:40:    this->setupBase(a1,coordinateIndex);
energyAtomTable.cc:41:    this->_TypeIndex = forceField->getNonbondDb()->findTypeIndex(a1->getTypeString());
energyAtomTable.cc:42:    this->_Charge = a1->getCharge();
energyAtomTable.cc:47:    this->Base::archive(node);
energyAtomTable.cc:56:    path = this->_Atom->getIdPath(parent);
energyAtomTable.cc:57:    node->addAttributeString("storagePath",path);
energyAtomTable.cc:58:    node->addAttributeString("atomName",this->_Atom->getName());
energyAtomTable.cc:59:    node->addAttributeInt("coordinateIndex",this->_CoordinateIndex);
energyAtomTable.cc:60:    node->addAttributeDoubleScientific("x",this->_Atom->getPosition().getX());
energyAtomTable.cc:61:    node->addAttributeDoubleScientific("y",this->_Atom->getPosition().getY());
energyAtomTable.cc:62:    node->addAttributeDoubleScientific("z",this->_Atom->getPosition().getZ());
energyAtomTable.cc:63:    node->addAttributeDoubleScientific("fx",this->_Atom->getForce().getX());
energyAtomTable.cc:64:    node->addAttributeDoubleScientific("fy",this->_Atom->getForce().getY());
energyAtomTable.cc:65:    node->addAttributeDoubleScientific("fz",this->_Atom->getForce().getZ());
energyAtomTable.cc:76:    LOG(BF("parsing xml with localName=%s") % xml->getLocalName().c_str() );
energyAtomTable.cc:77:    path = xml->getAttributeString("storagePath");
energyAtomTable.cc:78:    this->_Atom = downcast<chem::Atom_O>(parent->getContentForIdPath(path));
energyAtomTable.cc:79:    ASSERTNOTNULL(this->_Atom);
energyAtomTable.cc:80:    this->_CoordinateIndex = xml->getAttributeInt("coordinateIndex");
energyAtomTable.cc:81:    x = xml->getAttributeDouble("x");
energyAtomTable.cc:82:    y = xml->getAttributeDouble("y");
energyAtomTable.cc:83:    z = xml->getAttributeDouble("z");
energyAtomTable.cc:85:    this->_Atom->setPosition(v);
energyAtomTable.cc:86:    fx = xml->getAttributeDouble("fx");
energyAtomTable.cc:87:    fy = xml->getAttributeDouble("fy");
energyAtomTable.cc:88:    fz = xml->getAttributeDouble("fz");
energyAtomTable.cc:90:    this->_Atom->setForce(v);
energyAtomTable.cc:98:    res = this->atom()->getResidueContainedBy()->as<Residue_O>();
energyAtomTable.cc:100:    ss << ":"<<res->getId()<<"@"<<this->atom()->getName();
energyAtomTable.cc:108:	map<Atom_sp,uint>::iterator it = this->_AtomTableIndices.find(a);
energyAtomTable.cc:109:	if ( it == this->_AtomTableIndices.end() )
energyAtomTable.cc:111:	    SIMPLE_ERROR(BF("Could not find atom[%s] in AtomTable") % a->__repr__() );
energyAtomTable.cc:113:	return &this->_Atoms[it->second];
energyAtomTable.cc:118:	int coordinateIndex = this->getNumberOfAtoms()*3;
energyAtomTable.cc:120:	ea._Charge = charge->value_in_unit_asReal(units::_sym_elementaryCharge->symbolValue()->as<units::Unit_O>());
energyAtomTable.cc:121:	ea._Mass = mass->value_in_unit_asReal(units::_sym_daltons->symbolValue()->as<units::Unit_O>());
energyAtomTable.cc:123:	this->add(ea);
energyAtomTable.cc:131:    if ( node->loading() )
energyAtomTable.cc:133:        this->_Atoms.clear();
energyAtomTable.cc:135:        for (vi=node->begin_Children(); vi!=node->end_Children(); vi++ )
energyAtomTable.cc:139:	    this->_Atoms.push_back(ea);
energyAtomTable.cc:140:	    (*vi)->setRecognized(true);
energyAtomTable.cc:146:        for ( eai=this->_Atoms.begin(); eai!=this->_Atoms.end(); eai++ )
energyAtomTable.cc:148:	    child = node->createChildNode("EnergyAtom");
energyAtomTable.cc:149:	    eai->archive(child);
energyAtomTable.cc:181:    for ( eai=this->_Atoms.begin(); eai!=this->_Atoms.end(); eai++ ) {
energyAtomTable.cc:182:	as1 = atomLabel(eai->atom());
energyAtomTable.cc:183:	str1 = eai->atom()->getTypeString();
energyAtomTable.cc:184:	_lisp->print(BF("(TERM 0ATOM %-9s %-9s :charge %8.5lf :mass %8.5lf :typeIndex %d)")
energyAtomTable.cc:187:			    % eai->_Charge
energyAtomTable.cc:188:			    % eai->_Mass
energyAtomTable.cc:189:			    % eai->_TypeIndex );
energyAtomTable.cc:196:	this->_Atoms.clear();
energyAtomTable.cc:197:	this->_AtomTableIndices.clear();
energyAtomTable.cc:207:		if ( a1->isAssignableTo<VirtualAtom_O>() ) 
energyAtomTable.cc:209:		    LOG(BF("Skipping virtual atom[%s]") % a1->__repr__() );
energyAtomTable.cc:212:		LOG(BF("Setting atom[%s] in AtomTable[%d]") % a1->__repr__() % idx );
energyAtomTable.cc:213:		this->_AtomTableIndices[a1] = idx;
energyAtomTable.cc:218:		    while ( span->advance() )
energyAtomTable.cc:220:			bonded = span->getAtom();
energyAtomTable.cc:222:			int backCount = bonded->getBackCount();
energyAtomTable.cc:223:			LOG(BF("Looking at atom[%s] at remove[%d]") % bonded->__repr__() % backCount );
energyAtomTable.cc:227:			    LOG(BF("Hit remove of 4 - terminating spanning loop"));
energyAtomTable.cc:231:			ea._AtomsAtRemove[backCount-1].insert(bonded);
energyAtomTable.cc:234:		this->_Atoms.push_back(ea);
energyAtomTable.cc:245:			ss << " " << (*si)->__repr__();
energyChiralRestraint.cc:30:    this->_Atom1.reset();
energyChiralRestraint.cc:31:    this->_Atom2.reset();
energyChiralRestraint.cc:32:    this->_Atom3.reset();
energyChiralRestraint.cc:33:    this->_Atom4.reset();
energyChiralRestraint.cc:44:    node->attribute("K",this->term.K);
energyChiralRestraint.cc:45:    node->attribute("CO",this->term.CO);
energyChiralRestraint.cc:46:    node->attribute("I1",this->term.I1);
energyChiralRestraint.cc:47:    node->attribute("I2",this->term.I2);
energyChiralRestraint.cc:48:    node->attribute("I3",this->term.I3);
energyChiralRestraint.cc:49:    node->attribute("I4",this->term.I4);
energyChiralRestraint.cc:50:    node->archiveObject("a1",this->_Atom1);
energyChiralRestraint.cc:51:    node->archiveObject("a2",this->_Atom2);
energyChiralRestraint.cc:52:    node->archiveObject("a3",this->_Atom3);
energyChiralRestraint.cc:53:    node->archiveObject("a4",this->_Atom4);
energyChiralRestraint.cc:55:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyChiralRestraint.cc:56:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyChiralRestraint.cc:57:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyChiralRestraint.cc:68:    ss << this->_Atom1->description() << "-";
energyChiralRestraint.cc:69:    ss << this->_Atom2->description() << "-";
energyChiralRestraint.cc:70:    ss << this->_Atom3->description() << "-";
energyChiralRestraint.cc:71:    ss << this->_Atom4->description() ;
energyChiralRestraint.cc:73:    ss << " eval.Energy=" << this->eval.Energy;
energyChiralRestraint.cc:86:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyChiralRestraint.cc:87:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyChiralRestraint.cc:88:    node->addAttributeString("atom3Name",this->_Atom3->getName());
energyChiralRestraint.cc:89:    node->addAttributeString("atom4Name",this->_Atom4->getName());
energyChiralRestraint.cc:90:    node->addAttributeInt("I1",this->term.I1);
energyChiralRestraint.cc:91:    node->addAttributeInt("I2",this->term.I2);
energyChiralRestraint.cc:92:    node->addAttributeInt("I3",this->term.I3);
energyChiralRestraint.cc:93:    node->addAttributeInt("I4",this->term.I4);
energyChiralRestraint.cc:94:    node->addAttributeDoubleScientific("K",this->term.K);
energyChiralRestraint.cc:97:    xml->addAttributeBool("calcForce",this->_calcForce );
energyChiralRestraint.cc:98:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyChiralRestraint.cc:99:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyChiralRestraint.cc:101:    node->addChild(xml);
energyChiralRestraint.cc:109:    this->term.K = xml->getAttributeDouble("K");
energyChiralRestraint.cc:110:    this->term.I1 = xml->getAttributeInt("I1");
energyChiralRestraint.cc:111:    this->term.I2 = xml->getAttributeInt("I2");
energyChiralRestraint.cc:112:    this->term.I3 = xml->getAttributeInt("I3");
energyChiralRestraint.cc:113:    this->term.I4 = xml->getAttributeInt("I4");
energyChiralRestraint.cc:114:    this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->term.I1)->atom();
energyChiralRestraint.cc:115:    this->_Atom2 = at->findEnergyAtomWithCoordinateIndex(this->term.I2)->atom();
energyChiralRestraint.cc:116:    this->_Atom3 = at->findEnergyAtomWithCoordinateIndex(this->term.I3)->atom();
energyChiralRestraint.cc:117:    this->_Atom4 = at->findEnergyAtomWithCoordinateIndex(this->term.I4)->atom();
energyChiralRestraint.cc:151:#pragma GCC diagnostic ignored "-Wunused-variable"
energyChiralRestraint.cc:163:    this->_Terms.push_back(e);
energyChiralRestraint.cc:190:// -----------------------
energyChiralRestraint.cc:194:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x=cri->term.x;}
energyChiralRestraint.cc:196:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition->element(ii+of);}
energyChiralRestraint.cc:205:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyChiralRestraint.cc:209:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyChiralRestraint.cc:215:    if ( this->isEnabled() ) {
energyChiralRestraint.cc:217:#pragma GCC diagnostic ignored "-Wunused-variable"
energyChiralRestraint.cc:222:	for ( vector<EnergyChiralRestraint>::iterator cri=this->_Terms.begin();
energyChiralRestraint.cc:223:		    cri!=this->_Terms.end(); cri++ ) {
energyChiralRestraint.cc:245:    if ( this->_DebugEnergy ) 
energyChiralRestraint.cc:248:	LOG_ENERGY(BF("%s {\n")% this->className());
energyChiralRestraint.cc:258:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyChiralRestraint.cc:264:// -----------------------
energyChiralRestraint.cc:271:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyChiralRestraint.cc:273:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyChiralRestraint.cc:277:#define	CHIRAL_RESTRAINT_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyChiralRestraint.cc:286:    if ( this->isEnabled() ) {
energyChiralRestraint.cc:288:#pragma GCC diagnostic ignored "-Wunused-variable"
energyChiralRestraint.cc:294:	for ( i=0,cri=this->_Terms.begin();
energyChiralRestraint.cc:295:		    cri!=this->_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:297:		if ( this->_Debug_NumberOfChiralRestraintTermsToCalculate > 0 ) {
energyChiralRestraint.cc:298:		    if ( i>= this->_Debug_NumberOfChiralRestraintTermsToCalculate ) {
energyChiralRestraint.cc:309:		cri->_calcForce = calcForce;
energyChiralRestraint.cc:310:		cri->_calcDiagonalHessian = calcDiagonalHessian;
energyChiralRestraint.cc:311:		cri ->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyChiralRestraint.cc:314:		#define	EVAL_SET(var,val)	{ cri->eval.var=val;};
energyChiralRestraint.cc:318:	    if ( this->_DebugEnergy ) {
energyChiralRestraint.cc:355:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyChiralRestraint.cc:356:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyChiralRestraint.cc:357:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyChiralRestraint.cc:358:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyChiralRestraint.cc:359:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyChiralRestraint.cc:360:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyChiralRestraint.cc:361:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyChiralRestraint.cc:362:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyChiralRestraint.cc:363:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyChiralRestraint.cc:364:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyChiralRestraint.cc:365:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyChiralRestraint.cc:366:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyChiralRestraint.cc:370:    if ( this->_DebugEnergy ) 
energyChiralRestraint.cc:372:	LOG_ENERGY(BF("%s }\n")% this->className());
energyChiralRestraint.cc:394://------------------
energyChiralRestraint.cc:400:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyChiralRestraint.cc:402:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyChiralRestraint.cc:415:	if ( this->isEnabled() ) {
energyChiralRestraint.cc:418:#pragma GCC diagnostic ignored "-Wunused-variable"
energyChiralRestraint.cc:424:	    for ( i=0,cri=this->_Terms.begin();
energyChiralRestraint.cc:425:			cri!=this->_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:458:    this->_BeyondThresholdTerms.clear();
energyChiralRestraint.cc:463://------------------
energyChiralRestraint.cc:470:#define	CHIRAL_RESTRAINT_SET_PARAMETER(x)	{x = cri->term.x;}
energyChiralRestraint.cc:472:#define	CHIRAL_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyChiralRestraint.cc:485:    if ( this->isEnabled() ) {
energyChiralRestraint.cc:488:#pragma GCC diagnostic ignored "-Wunused-variable"
energyChiralRestraint.cc:494:	LOG(BF("Entering checking loop, there are %d terms") % this->_Terms.end()-this->_Terms.begin() );
energyChiralRestraint.cc:495:	for ( i=0,cri=this->_Terms.begin();
energyChiralRestraint.cc:496:		    cri!=this->_Terms.end(); cri++,i++ ) {
energyChiralRestraint.cc:511:		info << a1->getName() << " ";
energyChiralRestraint.cc:512:		info << a2->getName() << " ";
energyChiralRestraint.cc:513:		info << a3->getName() << " ";
energyChiralRestraint.cc:514:		info << a4->getName() << ")";
energyChiralRestraint.cc:517:		this->_BeyondThresholdTerms.push_back(*cri);
energyChiralRestraint.cc:550:    this->Base::initialize();
energyChiralRestraint.cc:551:    this->setErrorThreshold(0.2);
energyChiralRestraint.cc:558:    this->Base::archiveBase(node);
energyComponent.cc:44:    this->Base::initialize();
energyComponent.cc:45:    this->enable();
energyComponent.cc:46:    this->zeroEnergy();
energyComponent.cc:47:    this->disableDebug();
energyComponent.cc:48:    this->setScale(1.0);
energyComponent.cc:49:    this->setDebug_NumberOfTermsToCalculate(-1);
energyComponent.cc:55:    this->_TotalEnergy = 0.0;
energyComponent.cc:61:    this->Base::archiveBase(node);
energyComponent.cc:62:    node->attribute("_Enabled",this->_Enabled);
energyComponent.cc:63:    node->attribute("_Scale",this->_Scale);
energyComponent.cc:64:    node->attribute("_ErrorThreshold",this->_ErrorThreshold);
energyComponent.cc:65:    node->attribute("_DebugEnergy",this->_DebugEnergy);
energyComponent.cc:66:    node->attribute("_TotalEnergy",this->_TotalEnergy);
energyComponent.cc:67:    node->attribute("_Debug_NumberOfTermsToCalculate",this->_Debug_NumberOfTermsToCalculate);
energyComponent.cc:68:    node->attribute("_Scale",this->_Scale);
energyComponent.cc:76:	    return this->_DebugLog.str();
energyComponent.cc:78:	    return this->className()+"-no_log";
energyComponent.cc:86:    if ( this->isEnabled() ) 
energyComponent.cc:88:	ss<<this->className();
energyComponent.cc:90:	if ( this->_Debug_NumberOfTermsToCalculate < 0 ) {
energyComponent.cc:94:	    ss<<this->_Debug_NumberOfTermsToCalculate<<")";
energyComponent.cc:106:    ss<< this->className();
energyComponent.cc:107:    ss << " energy: " << this->getEnergy() << endl;
energyDihedral.cc:27:    this->_Atom1.reset();
energyDihedral.cc:28:    this->_Atom2.reset();
energyDihedral.cc:29:    this->_Atom3.reset();
energyDihedral.cc:30:    this->_Atom4.reset();
energyDihedral.cc:40://    node->attribute("_Type1",this->_Type1);
energyDihedral.cc:41://    node->attribute("_Type2",this->_Type2);
energyDihedral.cc:42://    node->attribute("_Type3",this->_Type3);
energyDihedral.cc:43://    node->attribute("_Type4",this->_Type4);
energyDihedral.cc:44:    node->attribute("_Proper",this->_Proper);
energyDihedral.cc:45:    node->attribute("_PhaseRad",this->_PhaseRad);
energyDihedral.cc:46:    node->attribute("sinPhase",this->term.sinPhase);
energyDihedral.cc:47:    node->attribute("cosPhase",this->term.cosPhase);
energyDihedral.cc:48:    node->attribute("V",this->term.V);
energyDihedral.cc:49:    node->attribute("DN",this->term.DN);
energyDihedral.cc:50:    node->attribute("IN",this->term.IN);
energyDihedral.cc:51:    node->attribute("I1",this->term.I1);
energyDihedral.cc:52:    node->attribute("I2",this->term.I2);
energyDihedral.cc:53:    node->attribute("I3",this->term.I3);
energyDihedral.cc:54:    node->attribute("I4",this->term.I4);
energyDihedral.cc:55:    node->archiveObject("a1",this->_Atom1);
energyDihedral.cc:56:    node->archiveObject("a2",this->_Atom2);
energyDihedral.cc:57:    node->archiveObject("a3",this->_Atom3);
energyDihedral.cc:58:    node->archiveObject("a4",this->_Atom4);
energyDihedral.cc:60:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyDihedral.cc:61:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyDihedral.cc:62:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyDihedral.cc:76:    sinNPhiCosNPhi(n-1,&sinNm1Phi,&cosNm1Phi,sinPhi,cosPhi);
energyDihedral.cc:78:    *cosNPhi = cosPhi*cosNm1Phi-sinPhi*sinNm1Phi;
energyDihedral.cc:85://    this->_Term = term;
energyDihedral.cc:86:    this->_Proper = true;
energyDihedral.cc:87://    this->_Type1 = term->_T1;
energyDihedral.cc:88://    this->_Type2 = term->_T2;
energyDihedral.cc:89://    this->_Type3 = term->_T3;
energyDihedral.cc:90://    this->_Type4 = term->_T4;
energyDihedral.cc:91:    this->_Atom1 = ea1->atom();
energyDihedral.cc:92:    this->_Atom2 = ea2->atom();
energyDihedral.cc:93:    this->_Atom3 = ea3->atom();
energyDihedral.cc:94:    this->_Atom4 = ea4->atom();
energyDihedral.cc:95:    this->_PhaseRad = ffterm->getPhaseRad(n);
energyDihedral.cc:96:    this->term.sinPhase = sin(this->_PhaseRad);
energyDihedral.cc:97:    this->term.cosPhase = cos(this->_PhaseRad);
energyDihedral.cc:98:    this->term.V = ffterm->getV_kCal(n)*scale;
energyDihedral.cc:99:    this->term.DN = n;
energyDihedral.cc:100:    this->term.IN = n;
energyDihedral.cc:101:    this->term.I1 = ea1->coordinateIndexTimes3();
energyDihedral.cc:102:    this->term.I2 = ea2->coordinateIndexTimes3();
energyDihedral.cc:103:    this->term.I3 = ea3->coordinateIndexTimes3();
energyDihedral.cc:104:    this->term.I4 = ea4->coordinateIndexTimes3();
energyDihedral.cc:111:    pos1 = this->_Atom1->getPosition();
energyDihedral.cc:112:    pos2 = this->_Atom2->getPosition();
energyDihedral.cc:113:    pos3 = this->_Atom3->getPosition();
energyDihedral.cc:114:    pos4 = this->_Atom4->getPosition();
energyDihedral.cc:123:    pos1 = this->_Atom1->getPosition();
energyDihedral.cc:124:    pos2 = this->_Atom2->getPosition();
energyDihedral.cc:125:    pos3 = this->_Atom3->getPosition();
energyDihedral.cc:126:    pos4 = this->_Atom4->getPosition();
energyDihedral.cc:128:    dev = 1.0+cos(this->term.DN*phi-this->_PhaseRad);
energyDihedral.cc:135://    this->_Term = term;
energyDihedral.cc:136:    this->_Proper = false;
energyDihedral.cc:137://    this->_Type1 = term->_T1;
energyDihedral.cc:138://    this->_Type2 = term->_T2;
energyDihedral.cc:139://    this->_Type3 = term->_T3;
energyDihedral.cc:140://    this->_Type4 = term->_T4;
energyDihedral.cc:141:    this->_Atom1 = ea1->atom();
energyDihedral.cc:142:    this->_Atom2 = ea2->atom();
energyDihedral.cc:143:    this->_Atom3 = ea3->atom();
energyDihedral.cc:144:    this->_Atom4 = ea4->atom();
energyDihedral.cc:145:    this->term.DN = n;
energyDihedral.cc:146:    this->term.IN = n;
energyDihedral.cc:147:    this->term.V = term->getV_kCal(n)*scale;
energyDihedral.cc:148:    this->_PhaseRad = term->getPhaseRad(n);
energyDihedral.cc:149:    this->term.cosPhase = cos(this->_PhaseRad);
energyDihedral.cc:150:    this->term.sinPhase = sin(this->_PhaseRad);
energyDihedral.cc:151:    this->term.I1 = ea1->coordinateIndexTimes3();
energyDihedral.cc:152:    this->term.I2 = ea2->coordinateIndexTimes3();
energyDihedral.cc:153:    this->term.I3 = ea3->coordinateIndexTimes3();
energyDihedral.cc:154:    this->term.I4 = ea4->coordinateIndexTimes3();
energyDihedral.cc:160:    this->_Proper = true;
energyDihedral.cc:161://    this->_Type1 = ea1->_Atom->getTypeString();
energyDihedral.cc:162://    this->_Type2 = ea2->_Atom->getTypeString();
energyDihedral.cc:163:/    this->_Type3 = ea3->_Atom->getTypeString();
energyDihedral.cc:164:    this->_Type4 = ea4->_Atom->getTypeString();
energyDihedral.cc:174:    node->addAttributeBool("proper",this->_Proper );
energyDihedral.cc:175:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyDihedral.cc:176:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyDihedral.cc:177:    node->addAttributeString("atom3Name",this->_Atom3->getName());
energyDihedral.cc:178:    node->addAttributeString("atom4Name",this->_Atom4->getName());
energyDihedral.cc:179://    node->addAttributeString("atom1Type",this->_Type1 );
energyDihedral.cc:180://    node->addAttributeString("atom2Type",this->_Type2 );
energyDihedral.cc:181://    node->addAttributeString("atom3Type",this->_Type3 );
energyDihedral.cc:182://    node->addAttributeString("atom4Type",this->_Type4 );
energyDihedral.cc:183:    node->addAttributeInt("I1",this->term.I1);
energyDihedral.cc:184:    node->addAttributeInt("I2",this->term.I2);
energyDihedral.cc:185:    node->addAttributeInt("I3",this->term.I3);
energyDihedral.cc:186:    node->addAttributeInt("I4",this->term.I4);
energyDihedral.cc:187:    node->addAttributeDoubleScientific("DN",this->term.DN);
energyDihedral.cc:188:    node->addAttributeInt("IN",this->term.IN);
energyDihedral.cc:189:    node->addAttributeDoubleScientific("V",this->term.V);
energyDihedral.cc:190:    node->addAttributeDoubleScientific("PhaseRad",this->_PhaseRad);
energyDihedral.cc:193:    xml->addAttributeBool("calcForce",this->_calcForce );
energyDihedral.cc:194:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyDihedral.cc:195:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyDihedral.cc:197:    node->addChild(xml);
energyDihedral.cc:205:    this->term.I1 = xml->getAttributeInt("I1");
energyDihedral.cc:206:    this->term.I2 = xml->getAttributeInt("I2");
energyDihedral.cc:207:    this->term.I3 = xml->getAttributeInt("I3");
energyDihedral.cc:208:    this->term.I4 = xml->getAttributeInt("I4");
energyDihedral.cc:209:    this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->term.I1)->atom();
energyDihedral.cc:210:    this->_Atom2 = at->findEnergyAtomWithCoordinateIndex(this->term.I2)->atom();
energyDihedral.cc:211:    this->_Atom3 = at->findEnergyAtomWithCoordinateIndex(this->term.I3)->atom();
energyDihedral.cc:212:    this->_Atom4 = at->findEnergyAtomWithCoordinateIndex(this->term.I4)->atom();
energyDihedral.cc:213:    this->term.DN = xml->getAttributeDouble("DN");
energyDihedral.cc:214:    this->term.IN = xml->getAttributeInt("IN");
energyDihedral.cc:215:    this->term.V = xml->getAttributeDouble("V");
energyDihedral.cc:216:    this->_PhaseRad = xml->getAttributeDouble("PhaseRad");
energyDihedral.cc:217:    this->_Proper = xml->getAttributeBool("proper");
energyDihedral.cc:252:#pragma GCC diagnostic ignored "-Wunused-variable"
energyDihedral.cc:267:    this->_Terms.push_back(term);
energyDihedral.cc:284:    for (edi=this->_Terms.begin();edi!=this->_Terms.end();edi++)
energyDihedral.cc:286:	if ( edi->term.V == 0.0 ) continue;
energyDihedral.cc:287:	if ( edi->_Proper ) {
energyDihedral.cc:292:	as1 = atomLabel(edi->_Atom1);
energyDihedral.cc:293:	as2 = atomLabel(edi->_Atom2);
energyDihedral.cc:294:	as3 = atomLabel(edi->_Atom3);
energyDihedral.cc:295:	as4 = atomLabel(edi->_Atom4);
energyDihedral.cc:296:	if ( edi->_Proper ) {
energyDihedral.cc:323:	_lisp->print(BF("TERM 3DIH %s %-9s - %-9s - %-9s - %-9s %8.2lf %8.2lf %2.0lf")
energyDihedral.cc:329:			% edi->term.V
energyDihedral.cc:330:			% edi->_PhaseRad
energyDihedral.cc:331:			% edi->term.DN);
energyDihedral.cc:350:// -----------------------
energyDihedral.cc:353:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di->term.x;}
energyDihedral.cc:355:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=nvPosition->element(ii+of);}
energyDihedral.cc:362:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyDihedral.cc:366:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyDihedral.cc:371:    if ( this->isEnabled() ) {
energyDihedral.cc:373:#pragma GCC diagnostic ignored "-Wunused-variable"
energyDihedral.cc:384:	for ( vector<EnergyDihedral>::iterator di=this->_Terms.begin();
energyDihedral.cc:385:		    di!=this->_Terms.end(); di++ ) {
energyDihedral.cc:406:    if ( this->_DebugEnergy ) 
energyDihedral.cc:409:	LOG_ENERGY(BF("%s {\n")% this->className());
energyDihedral.cc:418:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyDihedral.cc:424:// -----------------------
energyDihedral.cc:429:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di->term.x;}
energyDihedral.cc:431:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyDihedral.cc:433:#define	DIHEDRAL_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyDihedral.cc:443:    if ( this->isEnabled() ) 
energyDihedral.cc:446:#pragma GCC diagnostic ignored "-Wunused-variable"
energyDihedral.cc:458:	for ( i=0,di=this->_Terms.begin();
energyDihedral.cc:459:		    di!=this->_Terms.end(); di++,i++ ) {
energyDihedral.cc:461:		if ( this->_Debug_NumberOfDihedralTermsToCalculate > 0 ) {
energyDihedral.cc:462:		    if ( i>= this->_Debug_NumberOfDihedralTermsToCalculate ) {
energyDihedral.cc:471:	       problem._Atom1 = di->_Atom1;
energyDihedral.cc:472:	       problem._Atom2 = di->_Atom2;
energyDihedral.cc:473:	       problem._Atom3 = di->_Atom3;
energyDihedral.cc:474:	       problem._Atom4 = di->_Atom4;
energyDihedral.cc:481:		di->_calcForce = calcForce;
energyDihedral.cc:482:		di->_calcDiagonalHessian = calcDiagonalHessian;
energyDihedral.cc:483:		di->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyDihedral.cc:485:		#define	EVAL_SET(var,val)	{ di->eval.var=val;};
energyDihedral.cc:489:	    if ( this->_DebugEnergy ) 
energyDihedral.cc:533:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyDihedral.cc:534:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyDihedral.cc:535:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyDihedral.cc:536:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyDihedral.cc:537:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyDihedral.cc:538:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyDihedral.cc:539:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyDihedral.cc:540:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyDihedral.cc:541:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyDihedral.cc:542:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyDihedral.cc:543:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyDihedral.cc:544:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyDihedral.cc:548:    if ( this->_DebugEnergy ) 
energyDihedral.cc:550:	LOG_ENERGY(BF("%s }\n")% this->className());
energyDihedral.cc:572://------------------
energyDihedral.cc:577:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di->term.x;}
energyDihedral.cc:579:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyDihedral.cc:591:	if ( this->isEnabled() ) {
energyDihedral.cc:594:#pragma GCC diagnostic ignored "-Wunused-variable"
energyDihedral.cc:686:	    for ( i=0,di=this->_Terms.begin();
energyDihedral.cc:687:			di!=this->_Terms.end(); di++,i++ ) {
energyDihedral.cc:703:    this->_BeyondThresholdTerms.clear();
energyDihedral.cc:708://------------------
energyDihedral.cc:714:#define	DIHEDRAL_SET_PARAMETER(x)	{x=di->term.x;}
energyDihedral.cc:716:#define	DIHEDRAL_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyDihedral.cc:727:	if ( this->isEnabled() ) {
energyDihedral.cc:730:#pragma GCC diagnostic ignored "-Wunused-variable"
energyDihedral.cc:742:	    for ( i=0,di=this->_Terms.begin();
energyDihedral.cc:743:			di!=this->_Terms.end(); di++,i++ ) {
energyDihedral.cc:745:		if ( fabs(DihedralDeviation)>this->_ErrorThreshold) {
energyDihedral.cc:752://		    info<< a1->getAbsoluteIdPath() << " ";
energyDihedral.cc:753://		    info<< a2->getAbsoluteIdPath() << " ";
energyDihedral.cc:754://		    info<< a3->getAbsoluteIdPath() << " ";
energyDihedral.cc:755://		    info<< a4->getAbsoluteIdPath() << " ";
energyDihedral.cc:757:		    info<<"threshold " << this->_ErrorThreshold;
energyDihedral.cc:758:		    info << a1->getName() << " ";
energyDihedral.cc:759:		    info << a2->getName() << " ";
energyDihedral.cc:760:		    info << a3->getName() << " ";
energyDihedral.cc:761:		    info << a4->getName() << " ";
energyDihedral.cc:765:		    this->_BeyondThresholdTerms.push_back(ed);
energyDihedral.cc:796:    this->Base::initialize();
energyDihedral.cc:797:    this->setErrorThreshold(3.0);
energyDihedral.cc:803:    this->Base::archiveBase(node);
energyFixedNonbond.cc:17:    this->_FixedAtom.reset();
energyFixedNonbond.cc:29:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyFixedNonbond.cc:30:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyFixedNonbond.cc:31:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyFixedNonbond.cc:47:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyFixedNonbond.cc:48:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyFixedNonbond.cc:49:    node->addAttributeInt("I1",this->I1);
energyFixedNonbond.cc:50:    node->addAttributeInt("I2",this->I2);
energyFixedNonbond.cc:51:    node->addAttributeBool("is14",this->_Is14);
energyFixedNonbond.cc:52:    node->addAttributeString("atom1Type",this->_Atom1->getTypeString());
energyFixedNonbond.cc:53:    node->addAttributeString("atom2Type",this->_Atom2->getTypeString());
energyFixedNonbond.cc:54:    node->addAttributeDoubleScientific("RStar",this->_RStar);
energyFixedNonbond.cc:55:    node->addAttributeDoubleScientific("A",this->_A);
energyFixedNonbond.cc:56:    node->addAttributeDoubleScientific("C",this->_C);
energyFixedNonbond.cc:57:    node->addAttributeDoubleScientific("Charge1",this->_Charge1);
energyFixedNonbond.cc:58:    node->addAttributeDoubleScientific("Charge2",this->_Charge2);
energyFixedNonbond.cc:59://    vdiff = this->_Atom1->_Atom->getPosition() - this->_Atom2->_Atom->getPosition();
energyFixedNonbond.cc:61://    node->addAttributeDouble("_r",diff,5,2);
energyFixedNonbond.cc:64:    xml->addAttributeBool("calcForce",this->_calcForce );
energyFixedNonbond.cc:65:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyFixedNonbond.cc:66:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyFixedNonbond.cc:68:    node->addChild(xml);
energyFixedNonbond.cc:70:    node->addAttributeDoubleScientific("dA",this->dA);
energyFixedNonbond.cc:71:    node->addAttributeDoubleScientific("dC",this->dC);
energyFixedNonbond.cc:72:    node->addAttributeDoubleScientific("dQ1Q2",this->dQ1Q2);
energyFixedNonbond.cc:85:    this->dA = xml->getAttributeDouble("dA");
energyFixedNonbond.cc:86:    this->dC = xml->getAttributeDouble("dC");
energyFixedNonbond.cc:87:    this->dQ1Q2 = xml->getAttributeDouble("dQ1Q2");
energyFixedNonbond.cc:88:    this->_RStar = xml->getAttributeDouble("RStar");
energyFixedNonbond.cc:89:    this->_A = xml->getAttributeDouble("A");
energyFixedNonbond.cc:90:    this->_C = xml->getAttributeDouble("C");
energyFixedNonbond.cc:91:    this->_Charge1 = xml->getAttributeDouble("Charge1");
energyFixedNonbond.cc:92:    this->_Charge2 = xml->getAttributeDouble("Charge2");
energyFixedNonbond.cc:93:    this->I1 = xml->getAttributeInt("I1");
energyFixedNonbond.cc:94:    this->I2 = xml->getAttributeInt("I2");
energyFixedNonbond.cc:95:    this->_Is14 = xml->getAttributeBool("is14");
energyFixedNonbond.cc:96:    this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->I1)->_Atom;
energyFixedNonbond.cc:97:    this->_Atom2 = at->findEnergyAtomWithCoordinateIndex(this->I2)->_Atom;
energyFixedNonbond.cc:134:#pragma GCC diagnostic ignored "-Wunused-variable"
energyFixedNonbond.cc:152:    this->_MobileAtomTable = atomTable;
energyFixedNonbond.cc:153:    this->_NonbondCrossTermTable = crossTerms;
energyFixedNonbond.cc:164:    this->Base::zeroEnergy();
energyFixedNonbond.cc:165:    this->_EnergyElectrostatic = 0.0;
energyFixedNonbond.cc:166:    this->_EnergyVdw = 0.0;
energyFixedNonbond.cc:173:    e = this->getVdwEnergy();
energyFixedNonbond.cc:174:    e += this->getElectrostaticEnergy();
energyFixedNonbond.cc:185:    entry._FixedCharge = fa->getCharge();
energyFixedNonbond.cc:188:        entry._FixedType = nonbondDb->findTypeIndexOrThrow(fa->getTypeString());
energyFixedNonbond.cc:192:	serr << "Unknown type("<<fa->getTypeString()<<") for fixed atom: " << fa->description() << endl;
energyFixedNonbond.cc:197:    entry._FixedPosition = fa->getPosition();
energyFixedNonbond.cc:198:    this->_Terms.push_back(entry);
energyFixedNonbond.cc:209:    for ( eni=this->_Terms.begin();
energyFixedNonbond.cc:210:	    eni!=this->_Terms.end(); eni++ ) 
energyFixedNonbond.cc:212:	as1 = atomLabel(eni->_FixedAtom);
energyFixedNonbond.cc:213:	_lisp->print(BF( "TERM 6FIXED_NONBOND %-9s") % as1.c_str() );
energyFixedNonbond.cc:240:	displayIn->clear();
energyFixedNonbond.cc:241:	color = O_GrColor::systemColor(_lisp->symbol(_kw_yellow));
energyFixedNonbond.cc:242:	displayIn->add(color);
energyFixedNonbond.cc:244:    for ( eni=this->_Terms.begin();
energyFixedNonbond.cc:245:	    eni!=this->_Terms.end(); eni++ )
energyFixedNonbond.cc:247:	ia1 = eni->I1;
energyFixedNonbond.cc:248:	ia2 = eni->I2;
energyFixedNonbond.cc:249:	x1 = pos->element(ia1+0);
energyFixedNonbond.cc:250:	y1 = pos->element(ia1+1);
energyFixedNonbond.cc:251:	z1 = pos->element(ia1+2);
energyFixedNonbond.cc:252:	x2 = pos->element(ia2+0);
energyFixedNonbond.cc:253:	y2 = pos->element(ia2+1);
energyFixedNonbond.cc:254:	z2 = pos->element(ia2+2);
energyFixedNonbond.cc:255:	cutoff = eni->_RStar*scaleSumOfVdwRadii;
energyFixedNonbond.cc:257:	dx = x1-x2;
energyFixedNonbond.cc:258:	dy = y1-y2;
energyFixedNonbond.cc:259:	dz = z1-z2;
energyFixedNonbond.cc:264:	    LOG(BF("Atom1 = %s") % eni->_Atom1->description().c_str()  );
energyFixedNonbond.cc:265:	    LOG(BF("Atom2 = %s") % eni->_Atom2->description().c_str()  );
energyFixedNonbond.cc:271:		displayIn->add(line);
energyFixedNonbond.cc:293:    if ( this->_DebugEnergy ) 
energyFixedNonbond.cc:296:	LOG_ENERGY(BF("%s {\n")% this->className());
energyFixedNonbond.cc:298:    if ( this->_Terms.size() == 0 ) return;
energyFixedNonbond.cc:299:    ASSERTNOTNULL(this->_MobileAtomTable);
energyFixedNonbond.cc:300:    ASSERT(this->_MobileAtomTable.notnilp());
energyFixedNonbond.cc:301:    ASSERTNOTNULL(this->_NonbondCrossTermTable);
energyFixedNonbond.cc:302:    ASSERT(this->_NonbondCrossTermTable.notnilp());
energyFixedNonbond.cc:312:    bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyFixedNonbond.cc:318:    // -----------------------
energyFixedNonbond.cc:324:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi->x;}
energyFixedNonbond.cc:326:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyFixedNonbond.cc:328:#define	FNONBOND_EFEEL_ENERGY_ACCUMULATE(e) {this->_EnergyElectrostatic +=(e);}
energyFixedNonbond.cc:330:#define	FNONBOND_EFVDW_ENERGY_ACCUMULATE(e) {this->_EnergyVdw+=(e);}
energyFixedNonbond.cc:341:    if ( this->isEnabled() ) 
energyFixedNonbond.cc:348:#pragma GCC diagnostic ignored "-Wunused-variable"
energyFixedNonbond.cc:358:		uint fixedNonbondAtoms = this->_Terms.size();
energyFixedNonbond.cc:359:		uint mobileNonbondAtoms = this->_MobileAtomTable->getNumberOfAtoms();
energyFixedNonbond.cc:363:		    FixedNonbondRestraint& fixedAtomEntry = this->_Terms[ifixed];
energyFixedNonbond.cc:367:		    double fixedChargeMultiplier = fixedAtomEntry._FixedCharge * this->getElectrostaticScale() / this->_DielectricConstant * ELECTROSTATIC_MODIFIER;
energyFixedNonbond.cc:368:		    uint fixedTypeMajorIndex = this->_NonbondCrossTermTable->typeMajorIndex(fixedAtomEntry._FixedType);
energyFixedNonbond.cc:371:			EnergyAtom& mobileAtomEntry = this->_MobileAtomTable->energyAtomEntry(imobile);
energyFixedNonbond.cc:375:			FFNonbondCrossTerm crossTerm = this->_NonbondCrossTermTable->nonbondCrossTerm(crossTermIndex);
energyFixedNonbond.cc:376:			double dA = crossTerm._A*this->getVdwScale();
energyFixedNonbond.cc:377:			double dC = crossTerm._C*this->getVdwScale();
energyFixedNonbond.cc:389:			    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyFixedNonbond.cc:390:			    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyFixedNonbond.cc:391:			    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyFixedNonbond.cc:394:			if ( this->_DebugEnergy ) 
energyFixedNonbond.cc:425:    LOG_ENERGY(BF( "          Vdw energy = %lf\n")% (double)this->_EnergyVdw);
energyFixedNonbond.cc:426:    LOG_ENERGY(BF( "Electrostatic energy = %lf\n")% (double)this->_EnergyElectrostatic);
energyFixedNonbond.cc:427:    LOG_ENERGY(BF("%s }\n")% this->className() );
energyFixedNonbond.cc:450://------------------
energyFixedNonbond.cc:457:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi->x;}
energyFixedNonbond.cc:459:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyFixedNonbond.cc:473:	if ( this->isEnabled() ) {
energyFixedNonbond.cc:476:#pragma GCC diagnostic ignored "-Wunused-variable"
energyFixedNonbond.cc:482:	    for ( i=0,nbi=this->_Terms.begin();
energyFixedNonbond.cc:483:			nbi!=this->_Terms.end(); nbi++,i++ ) {
energyFixedNonbond.cc:503:    this->_BeyondThresholdTerms.clear();
energyFixedNonbond.cc:508://------------------
energyFixedNonbond.cc:513:#define	FNONBOND_SET_PARAMETER(x)	{x=nbi->x;}
energyFixedNonbond.cc:515:#define	FNONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyFixedNonbond.cc:529:    if ( this->isEnabled() ) 
energyFixedNonbond.cc:532:#pragma GCC diagnostic ignored "-Wunused-variable"
energyFixedNonbond.cc:542:	    uint fixedNonbondAtoms = this->_Terms.size();
energyFixedNonbond.cc:543:	    uint mobileNonbondAtoms = this->_MobileAtomTable->getNumberOfAtoms();
energyFixedNonbond.cc:547:		FixedNonbondRestraint& fixedAtomEntry = this->_Terms[ifixed];
energyFixedNonbond.cc:551:		double fixedChargeMultiplier = fixedAtomEntry._FixedCharge * this->getElectrostaticScale() / this->_DielectricConstant * ELECTROSTATIC_MODIFIER;
energyFixedNonbond.cc:552:		uint fixedTypeMajorIndex = this->_NonbondCrossTermTable->typeMajorIndex(fixedAtomEntry._FixedType);
energyFixedNonbond.cc:555:		    EnergyAtom& mobileAtomEntry = this->_MobileAtomTable->energyAtomEntry(imobile);
energyFixedNonbond.cc:559:		    FFNonbondCrossTerm crossTerm = this->_NonbondCrossTermTable->nonbondCrossTerm(crossTermIndex);
energyFixedNonbond.cc:560:		    double dA = crossTerm._A*this->getVdwScale();
energyFixedNonbond.cc:561:		    double dC = crossTerm._C*this->getVdwScale();
energyFixedNonbond.cc:563:		    if ( NonbondDistance < this->_ErrorThreshold ) 
energyFixedNonbond.cc:569:	//		info<< a1->getAbsoluteIdPath() << " ";
energyFixedNonbond.cc:570:	//		info<< af->getAbsoluteIdPath() << " ";
energyFixedNonbond.cc:572:			info<<"threshold " << this->_ErrorThreshold;
energyFixedNonbond.cc:573:			info << a1->getName() << " ";
energyFixedNonbond.cc:574:			info << af->getName() << " ";
energyFixedNonbond.cc:580:			this->_BeyondThresholdTerms.push_back(bt);
energyFixedNonbond.cc:616:    this->Base::initialize();
energyFixedNonbond.cc:617:    this->setErrorThreshold(1.0);
energyFixedNonbond.cc:618:    this->setDielectricConstant(80.0);
energyFixedNonbond.cc:619:    this->setVdwScale(1.0);
energyFixedNonbond.cc:620:    this->setElectrostaticScale(1.0);
energyFixedNonbond.cc:621:    this->_MobileAtomTable = AtomTable_O::_nil;
energyFixedNonbond.cc:622:    this->_NonbondCrossTermTable = FFNonbondCrossTermTable_O::_nil;
energyFixedNonbond.cc:629:    this->Base::archiveBase(node);
energyFunction.cc:92:	rel = (fabs(numVal-analVal)/avg);
energyFunction.cc:105:    bool ok = secondaryAmide->compileSmarts("[$(N1(C2)(~[#1]3)~C4(=O5)C6)]");
energyFunction.cc:248:    this->Base::initialize();
energyFunction.cc:249:    this->_NonbondCrossTermTable = FFNonbondCrossTermTable_O::_nil;
energyFunction.cc:250:    this->_AtomTable = AtomTable_O::create();
energyFunction.cc:251:    this->_Stretch = EnergyStretch_O::create();
energyFunction.cc:253:    this->_Angle = EnergyAngle_O::create();
energyFunction.cc:254:    this->_Dihedral = EnergyDihedral_O::create();
energyFunction.cc:255:    this->_Nonbond = EnergyNonbond_O::create();
energyFunction.cc:256:    this->_ChiralRestraint = EnergyChiralRestraint_O::create();
energyFunction.cc:257:    this->_AnchorRestraint = EnergyAnchorRestraint_O::create();
energyFunction.cc:258:    this->_ImproperRestraint = EnergyImproperRestraint_O::create();
energyFunction.cc:259:    this->_FixedNonbondRestraint = EnergyFixedNonbondRestraint_O::create();
energyFunction.cc:261:    this->setName("");
energyFunction.cc:262:    this->_Message = "";
energyFunction.cc:263:    this->useDefaultSettings();
energyFunction.cc:278:	    me->defineForMatter(matter,forceField);
energyFunction.cc:292:    Matter_sp matter = env->lookup(_lisp->internWithPackageName(ChemPkg,"matter"))->as<Matter_O>();
energyFunction.cc:293:    ForceField_sp forceField = env->lookup(_lisp->internWithPackageName(ChemPkg,"forceField"))->as<ForceField_O>();
energyFunction.cc:298:	    this->defineForMatter(matter,forceField);
energyFunction.cc:310:    ASSERTNOTNULL(this->_Stretch);
energyFunction.cc:311:    ASSERTNOTNULL(this->_Stretch);
energyFunction.cc:312:    ASSERT(this->_Stretch.notnilp());
energyFunction.cc:313:    this->_Stretch->initialize();
energyFunction.cc:315:    ASSERTNOTNULL(this->_Angle);
energyFunction.cc:316:    ASSERT(this->_Angle.notnilp());
energyFunction.cc:317:    ASSERTNOTNULL(this->_Dihedral);
energyFunction.cc:318:    ASSERT(this->_Dihedral.notnilp());
energyFunction.cc:319:    ASSERTNOTNULL(this->_Nonbond);
energyFunction.cc:320:    ASSERT(this->_Nonbond.notnilp());
energyFunction.cc:321:    ASSERTNOTNULL(this->_ChiralRestraint);
energyFunction.cc:322:    ASSERT(this->_ChiralRestraint.notnilp());
energyFunction.cc:323:    ASSERTNOTNULL(this->_AnchorRestraint);
energyFunction.cc:324:    ASSERT(this->_AnchorRestraint.notnilp());
energyFunction.cc:325:    ASSERTNOTNULL(this->_ImproperRestraint);
energyFunction.cc:326:    ASSERT(this->_ImproperRestraint.notnilp());
energyFunction.cc:327:    ASSERTNOTNULL(this->_FixedNonbondRestraint);
energyFunction.cc:328:    ASSERT(this->_FixedNonbondRestraint.notnilp());
energyFunction.cc:329:    this->_Angle->initialize();
energyFunction.cc:330:    this->_Dihedral->initialize();
energyFunction.cc:331:    this->_Nonbond->initialize();
energyFunction.cc:332:    this->_ChiralRestraint->initialize();
energyFunction.cc:333:    this->_AnchorRestraint->initialize();
energyFunction.cc:334:    this->_ImproperRestraint->initialize();
energyFunction.cc:335:    this->_FixedNonbondRestraint->initialize();
energyFunction.cc:337:    this->_ChiralRestraintWeight = DefaultChiralRestraintWeight;
energyFunction.cc:338:    this->_ChiralRestraintOffset = DefaultChiralRestraintOffset;
energyFunction.cc:339:    this->_AnchorRestraintWeight = DefaultAnchorRestraintWeight;
energyFunction.cc:340:    this->_RestrainSecondaryAmides = true;
energyFunction.cc:351:    node->attribute("_Name",this->_Name);
energyFunction.cc:352:    node->archiveObject("_Matter",this->_Matter);
energyFunction.cc:353:    node->archiveObject("_AtomTable",this->_AtomTable );
energyFunction.cc:354://    node->archiveSharedObject<Dumb_StretchComponent>("_Stretch","StretchTerms",this->_Stretch);
energyFunction.cc:355://    node->archiveSharedObject<Dumb_AngleComponent>("_Angle","AngleTerms",this->_Angle);
energyFunction.cc:356://    node->archiveSharedObject<Dumb_DihedralComponent>("_Dihedral","DihedralTerms",this->_Dihedral);
energyFunction.cc:357://    node->archiveSharedObject<Dumb_ImproperRestraintComponent>("_ImproperRestraint","ImproperRestraintTerms",this->_ImproperRestraint);
energyFunction.cc:358://    node->archiveSharedObject<Dumb_ChiralRestraintComponent>("_ChiralRestraint","ChiralRestraintTerms",this->_ChiralRestraint);
energyFunction.cc:359://    node->archiveSharedObject<Dumb_AnchorRestraintComponent>("_AnchorRestraint","AnchorRestraintTerms",this->_AnchorRestraint);
energyFunction.cc:360://    node->archiveSharedObject<Dumb_NonbondComponent>("_Nonbond","NonbondTerms",this->_Nonbond);
energyFunction.cc:361:    node->archiveObject("_Stretch",this->_Stretch);
energyFunction.cc:363:    node->archiveObject("_Angle",this->_Angle);
energyFunction.cc:364:    node->archiveObject("_Dihedral",this->_Dihedral);
energyFunction.cc:365:    node->archiveObject("_Nonbond",this->_Nonbond);
energyFunction.cc:366:    node->archiveObject("_ImproperRestraint",this->_ImproperRestraint);
energyFunction.cc:367:    node->archiveObject("_ChiralRestraint",this->_ChiralRestraint);
energyFunction.cc:368:    node->archiveObject("_AnchorRestraint",this->_AnchorRestraint);
energyFunction.cc:369:    node->archiveObject("_FixedNonbondRestraint",this->_FixedNonbondRestraint);
energyFunction.cc:371:    node->attribute("_ChiralRestraintWeight",this->_ChiralRestraintWeight);
energyFunction.cc:372:    node->attribute("_ChiralRestraintOffset",this->_ChiralRestraintOffset);
energyFunction.cc:373:    node->attribute("_AnchorRestraintWeight",this->_AnchorRestraintWeight);
energyFunction.cc:374:    node->attribute("_TotalEnergy",this->_TotalEnergy);
energyFunction.cc:375:    node->archiveString("_Message",this->_Message);
energyFunction.cc:376:    node->attribute("_DielectricConstant",this->_DielectricConstant);
energyFunction.cc:385:    return this->_AtomTable->getNVectorSize();
energyFunction.cc:391:    return this->_Dihedral->getEnergy();
energyFunction.cc:396:    return this->_ImproperRestraint->getEnergy();
energyFunction.cc:411:	bool onval = val->isTrue();
energyFunction.cc:413:	if ( onval ) this->getNonbondComponent()->enable();
energyFunction.cc:414:	else	this->getNonbondComponent()->disable();
energyFunction.cc:419:	bool onval = val->isTrue();
energyFunction.cc:421:	if ( onval ) this->getAnchorRestraintComponent()->enable();
energyFunction.cc:422:	else	this->getAnchorRestraintComponent()->disable();
energyFunction.cc:426:	SIMPLE_ERROR(BF("Unknown EnergyFunction setOption keyword[%s]") % option->__repr__() );
energyFunction.cc:446:	core::Symbol_sp option = core::oCar(options)->as<core::Symbol_O>();
energyFunction.cc:447:	options = options->cdr();
energyFunction.cc:449:	options = options->cdr();
energyFunction.cc:450:	this->setOption(option,val);
energyFunction.cc:457:// ------------------------------------------------------------------------
energyFunction.cc:458:// ------------------------------------------------------------------------
energyFunction.cc:459:// ------------------------------------------------------------------------
energyFunction.cc:460:// ------------------------------------------------------------------------
energyFunction.cc:461:// ------------------------------------------------------------------------
energyFunction.cc:473:	string	getError() { return "FiniteDifferenceMismatch"; } //  @"+this->functionName()+" term:("+this->termName+")";
energyFunction.cc:484:	double eLow = this->func argLow;\
energyFunction.cc:485:	double eHigh = this->func argHigh;\
energyFunction.cc:486:	double numForce = -(eHigh-eLow)/(delta);\
energyFunction.cc:492:	double eLow = this->func argLow;\
energyFunction.cc:493:	double eMiddle = this->func argMiddle;\
energyFunction.cc:494:	double eHigh = this->func argHigh;\
energyFunction.cc:495:	double numHessian = (eHigh+eLow-2.0*eMiddle)/(((delta)/2.0)*((delta)/2.0));\
energyFunction.cc:501:	double eMM = this->func argMM;\
energyFunction.cc:502:	double eMP = this->func argMP;\
energyFunction.cc:503:	double ePM = this->func argPM;\
energyFunction.cc:504:	double ePP = this->func argPP;\
energyFunction.cc:505:	double numHessian = ((ePP-ePM)-(eMP-eMM))/(delta*delta);\
energyFunction.cc:519:    _lisp->profiler().timer(core::timerPreconditioner).start();
energyFunction.cc:520:    _lisp->profiler().timer(core::timerPreconditionerSetup).start();
energyFunction.cc:522:    m->fill(0.0);
energyFunction.cc:524:    this->_Stretch->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:526:    this->_Angle->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:527:    this->_Dihedral->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:529://    this->_Nonbond->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:530:    this->_ChiralRestraint->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:531:    this->_AnchorRestraint->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:532:    this->_ImproperRestraint->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:533://    this->_FixedNonbondRestraint->setupHessianPreconditioner(nvPosition, m );
energyFunction.cc:536:    _lisp->profiler().timer(core::timerPreconditionerSetup).stop();
energyFunction.cc:537:    _lisp->profiler().timer(core::timerPreconditioner).stop();
energyFunction.cc:575:        force->setElement((i)+(o),(v)+force->getElement((i)+(o)));\
energyFunction.cc:584:	    hessian->addToElement((i1)+(o1),(i2)+(o2),v);\
energyFunction.cc:587:	    hdvec->addToElement((i1)+(o1),v*dvec->element((i2)+(o2)));\
energyFunction.cc:588:	    hdvec->addToElement((i2)+(o2),v*dvec->element((i1)+(o1)));\
energyFunction.cc:597:	    hessian->addToElement((i1)+(o1),(i2)+(o2),v);\
energyFunction.cc:600:	    hdvec->addToElement((i1)+(o1),v*dvec->element((i1)+(o1)));\
energyFunction.cc:611:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyFunction.cc:621:    if ( hasForce && force->size() < pos->size() ) {
energyFunction.cc:633:    _lisp->profiler().pushTimerStates();
energyFunction.cc:637:	if ( hasForce ) force->zero();
energyFunction.cc:638:	if ( hasHessian ) hessian->zero();
energyFunction.cc:641:	    hdvec->zero();	// Zero the result
energyFunction.cc:645:	_lisp->profiler().timer(core::timerEnergy).start();
energyFunction.cc:647:	_lisp->profiler().timer(core::timerBondAngleDihedral).start();
energyFunction.cc:652:	_lisp->profiler().timer(core::timerBond).start();
energyFunction.cc:653:        this->_Stretch->evaluateAll( pos, calcForce, force,
energyFunction.cc:657:	_lisp->profiler().timer(core::timerBond).stop();
energyFunction.cc:659:	_lisp->profiler().timer(core::timerAngle).start();
energyFunction.cc:660:        this->_Angle->evaluateAll( pos, calcForce, force,
energyFunction.cc:664:	_lisp->profiler().timer(core::timerAngle).stop();
energyFunction.cc:666:	_lisp->profiler().timer(core::timerDihedral).start();
energyFunction.cc:667:        this->_Dihedral->evaluateAll( pos, calcForce, force,
energyFunction.cc:671:	_lisp->profiler().timer(core::timerDihedral).stop();
energyFunction.cc:672:	_lisp->profiler().timer(core::timerBondAngleDihedral).stop();
energyFunction.cc:674:	_lisp->profiler().timer(core::timerNonbond).start();
energyFunction.cc:675:        this->_Nonbond->evaluateAll( pos, calcForce, force,
energyFunction.cc:677:	_lisp->profiler().timer(core::timerNonbond).stop();
energyFunction.cc:679:	_lisp->profiler().timer(core::timerImproperRestraint).start();
energyFunction.cc:680:        this->_ImproperRestraint->evaluateAll( pos, calcForce, force,
energyFunction.cc:682:	_lisp->profiler().timer(core::timerImproperRestraint).stop();
energyFunction.cc:684:	_lisp->profiler().timer(core::timerChiralRestraint).start();
energyFunction.cc:685:        this->_ChiralRestraint->evaluateAll( pos, calcForce, force,
energyFunction.cc:687:	_lisp->profiler().timer(core::timerChiralRestraint).stop();
energyFunction.cc:689:	_lisp->profiler().timer(core::timerAnchorRestraint).start();
energyFunction.cc:690:        this->_AnchorRestraint->evaluateAll( pos, calcForce, force,
energyFunction.cc:692:	_lisp->profiler().timer(core::timerAnchorRestraint).stop();
energyFunction.cc:694:	_lisp->profiler().timer(core::timerFixedNonbondRestraint).start();
energyFunction.cc:695:        this->_FixedNonbondRestraint->evaluateAll( pos, calcForce, force,
energyFunction.cc:697:	_lisp->profiler().timer(core::timerFixedNonbondRestraint).stop();
energyFunction.cc:699:	this->_TotalEnergy = this->_Stretch->getEnergy();
energyFunction.cc:701:	this->_TotalEnergy += this->_Angle->getEnergy();
energyFunction.cc:702:	this->_TotalEnergy += this->_Dihedral->getEnergy();
energyFunction.cc:703:	this->_TotalEnergy += this->_Nonbond->getEnergy();
energyFunction.cc:704:	this->_TotalEnergy += this->_ImproperRestraint->getEnergy();
energyFunction.cc:705:	this->_TotalEnergy += this->_ChiralRestraint->getEnergy();
energyFunction.cc:706:	this->_TotalEnergy += this->_AnchorRestraint->getEnergy();
energyFunction.cc:707:	this->_TotalEnergy += this->_FixedNonbondRestraint->getEnergy();
energyFunction.cc:710:	_lisp->profiler().timer(core::timerEnergy).stop();
energyFunction.cc:713:        _lisp->profiler().popTimerStates();
energyFunction.cc:716:    _lisp->profiler().popTimerStates();
energyFunction.cc:719:    return this->_TotalEnergy;
energyFunction.cc:726:    ss << boost::format("Stretch(%lf)") % this->_Stretch->getEnergy() << endl;
energyFunction.cc:728:    ss << boost::format("Angle(%lf)") % this->_Angle->getEnergy() << endl;
energyFunction.cc:729:    ss << boost::format("Dihedral(%lf)") % this->_Dihedral->getEnergy() << endl;
energyFunction.cc:730:    ss << boost::format("Nonbond(%lf)") % this->_Nonbond->getEnergy() << endl;
energyFunction.cc:731:    ss << boost::format("ChiralRestraint(%lf)") % this->_ChiralRestraint->getEnergy() << endl;
energyFunction.cc:732:    ss << boost::format("ImproperRestraint(%lf)") % this->_ImproperRestraint->getEnergy() << endl;
energyFunction.cc:733:    ss << boost::format("AnchorRestraint(%lf)") % this->_AnchorRestraint->getEnergy() << endl;
energyFunction.cc:734:    ss << boost::format("FixedNonbondRestraint(%lf)") % this->_FixedNonbondRestraint->getEnergy() << endl;
energyFunction.cc:750:        this->_Stretch->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:752:        this->_Angle->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:753:        this->_Dihedral->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:754:        this->_Nonbond->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:755:        this->_ImproperRestraint->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:756:        this->_ChiralRestraint->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:757:        this->_AnchorRestraint->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:758:        this->_FixedNonbondRestraint->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:772:    NVector_sp pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:773:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:774:    return this->compareAnalyticalAndNumericalForceAndHessianTermByTerm(pos);
energyFunction.cc:794:    pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:795:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:797:    fails += this->_Stretch->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:799:    fails += this->_Angle->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:800:    fails += this->_Dihedral->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:801:    fails += this->_Nonbond->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:802:    fails += this->_ImproperRestraint->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:803:    fails += this->_ChiralRestraint->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:804:    fails += this->_AnchorRestraint->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:805:    fails += this->_FixedNonbondRestraint->checkForBeyondThresholdInteractions(info,pos);
energyFunction.cc:808:    this->_Message = info.str();
energyFunction.cc:816:// ------------------------------------------------------------------------
energyFunction.cc:817:// ------------------------------------------------------------------------
energyFunction.cc:818:// ------------------------------------------------------------------------
energyFunction.cc:828:    ss << this->_Stretch->enabledAsString();
energyFunction.cc:830:    ss << this->_Angle->enabledAsString();
energyFunction.cc:831:    ss << this->_Dihedral->enabledAsString();
energyFunction.cc:832:    ss << this->_Nonbond->enabledAsString();
energyFunction.cc:833:    ss << this->_ImproperRestraint->enabledAsString();
energyFunction.cc:834:    ss << this->_ChiralRestraint->enabledAsString();
energyFunction.cc:835:    ss << this->_AnchorRestraint->enabledAsString();
energyFunction.cc:836:    ss << this->_FixedNonbondRestraint->enabledAsString();
energyFunction.cc:866:    energy = this->evaluateAll(pos,
energyFunction.cc:890:    energy = this->evaluateAll(pos,calcForce, rawGrad, false, false, dummyMatrix,
energyFunction.cc:910:    energy = this->evaluateAll( pos,
energyFunction.cc:927:    pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:928:    force = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:929:    hessian = FullLargeSquareMatrix_O::create(_lisp,this->getNVectorSize(),SymmetricDiagonalLower);
energyFunction.cc:930:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:931:    energy = this->evaluateAll(pos, true, force,
energyFunction.cc:947:    x = pos->element(i);
energyFunction.cc:948:    pos->setElement(i,x-deltaDiv2);
energyFunction.cc:949:    ylow = this->evaluateEnergy(pos);
energyFunction.cc:950:    pos->setElement(i,x+deltaDiv2);
energyFunction.cc:951:    yhigh = this->evaluateEnergy(pos);
energyFunction.cc:952:    pos->setElement(i,x);
energyFunction.cc:953:    fval = (yhigh-ylow)/delta;
energyFunction.cc:963:        x = pos->element(i);
energyFunction.cc:964:    	pos->setElement(i,x-delta);
energyFunction.cc:965:	fxmh = this->evaluateEnergy(pos);
energyFunction.cc:966:	pos->setElement(i,x+delta);
energyFunction.cc:967:	fxph = this->evaluateEnergy(pos);
energyFunction.cc:968:	pos->setElement(i,x);
energyFunction.cc:969:	fx = this->evaluateEnergy(pos);
energyFunction.cc:970:	f2 = (fxph+fxmh-2.0*(fx))/(delta*delta);
energyFunction.cc:973:	x = pos->element(i);
energyFunction.cc:974:	y = pos->element(j);
energyFunction.cc:975:	pos->setElement(i,x+deltaDiv2);
energyFunction.cc:976:	pos->setElement(j,y+deltaDiv2);
energyFunction.cc:977:	fpipj = this->evaluateEnergy(pos);
energyFunction.cc:978:	pos->setElement(i,x+deltaDiv2);
energyFunction.cc:979:	pos->setElement(j,y-deltaDiv2);
energyFunction.cc:980:	fpimj = this->evaluateEnergy(pos);
energyFunction.cc:981:	pos->setElement(i,x-deltaDiv2);
energyFunction.cc:982:	pos->setElement(j,y+deltaDiv2);
energyFunction.cc:983:	fmipj = this->evaluateEnergy(pos);
energyFunction.cc:984:	pos->setElement(i,x-deltaDiv2);
energyFunction.cc:985:	pos->setElement(j,y-deltaDiv2);
energyFunction.cc:986:	fmimj = this->evaluateEnergy(pos);
energyFunction.cc:987:	pos->setElement(i,x);
energyFunction.cc:988:	pos->setElement(j,y);
energyFunction.cc:993:	fp = (fpipj-fpimj)/delta;
energyFunction.cc:994:	fm = (fmipj-fmimj)/delta;
energyFunction.cc:997:	f2 = (fp-fm)/delta;
energyFunction.cc:1013:    for (i=0; i<pos->size(); i++ ) {
energyFunction.cc:1014:	fval = -this->calculateNumericalDerivative(pos,delta,i);
energyFunction.cc:1015:	numForce->setElement(i,fval);
energyFunction.cc:1027:    if ( hessian->columns() != pos->size() || hessian->rows()!=pos->size() ) {
energyFunction.cc:1030:    hessian->zero();
energyFunction.cc:1031:    for ( c=0; c<pos->size(); c++ ) {
energyFunction.cc:1032:	fval = this->calculateNumericalSecondDerivative(pos,delta,c,c);
energyFunction.cc:1033:	hessian->setElement(c,c,fval);
energyFunction.cc:1036:    for ( c=0; c<pos->size(); c++ ) {
energyFunction.cc:1037:	for ( r=0; r<pos->size(); r++ ) {
energyFunction.cc:1039:	        fval = this->calculateNumericalSecondDerivative(pos,delta,c,r);
energyFunction.cc:1040:	        hessian->setElement(c,r,fval);
energyFunction.cc:1051: * If there is a mis-match then dump the EnergyFunction into the result.
energyFunction.cc:1062:    report = _lisp->create<ForceMatchReport_O>();
energyFunction.cc:1064:    numForce = NVector_O::create(pos->size(),_lisp);
energyFunction.cc:1065:    this->evaluateNumericalForce(pos,numForce,DELTA);
energyFunction.cc:1066:    dot = numForce->dotProduct(analyticalForce);
energyFunction.cc:1067:    numericalMag = numForce->magnitude();
energyFunction.cc:1068:    analyticalMag = analyticalForce->magnitude();
energyFunction.cc:1069:    tempForce = NVector_O::create(pos->size(),_lisp);
energyFunction.cc:1071:    this->evaluateEnergyForce(pos,true,tempForce);
energyFunction.cc:1076:	report->_Message = result.str();
energyFunction.cc:1082:	report->_Message = result.str();
energyFunction.cc:1088:	report->_Message = result.str();
energyFunction.cc:1092:	report->_Message = "average of Analytical & Numerical Forces is VERY small";
energyFunction.cc:1099:    report->_AnalyticalForce = analyticalForce;
energyFunction.cc:1100:    report->_NumericalForce = numForce;
energyFunction.cc:1101:    if ( fabs(analyticalMag-numericalMag)/avg >0.1 ) {
energyFunction.cc:1106:	report->_Message = result.str();
energyFunction.cc:1107:	this->writeCoordinatesAndForceToAtoms(pos,analyticalForce);
energyFunction.cc:1115:	report->_Message = result.str();
energyFunction.cc:1116:	this->writeCoordinatesAndForceToAtoms(pos,analyticalForce);
energyFunction.cc:1119:    report->_Message = "Analytical and Numerical forces are virtually identical";
energyFunction.cc:1132:    this->_AtomTable->dumpTerms();
energyFunction.cc:1133:    this->_Stretch->dumpTerms();
energyFunction.cc:1135:    this->_Angle->dumpTerms();
energyFunction.cc:1136:    this->_Dihedral->dumpTerms();
energyFunction.cc:1137:    this->_Nonbond->dumpTerms();
energyFunction.cc:1138:    this->_ImproperRestraint->dumpTerms();
energyFunction.cc:1139:    this->_ChiralRestraint->dumpTerms();
energyFunction.cc:1140:    this->_AnchorRestraint->dumpTerms();
energyFunction.cc:1141:    this->_FixedNonbondRestraint->dumpTerms();
energyFunction.cc:1151:    restraintIterator->first();
energyFunction.cc:1152:    while ( restraintIterator->notDone() )
energyFunction.cc:1154:	Restraint_sp restraint = restraintIterator->current<Restraint_O>();
energyFunction.cc:1155:	if ( restraint->isOfClass<RestraintDihedral_O>() )
energyFunction.cc:1159:	    energyTerm._Atom1 = dih->getAtomA();
energyFunction.cc:1160:	    energyTerm._Atom2 = dih->getAtomB();
energyFunction.cc:1161:	    energyTerm._Atom3 = dih->getAtomC();
energyFunction.cc:1162:	    energyTerm._Atom4 = dih->getAtomD();
energyFunction.cc:1163:	    EnergyAtom* ea1 = this->getEnergyAtomPointer(dih->getAtomA());
energyFunction.cc:1164:	    EnergyAtom* ea2 = this->getEnergyAtomPointer(dih->getAtomB());
energyFunction.cc:1165:	    EnergyAtom* ea3 = this->getEnergyAtomPointer(dih->getAtomC());
energyFunction.cc:1166:	    EnergyAtom* ea4 = this->getEnergyAtomPointer(dih->getAtomD());
energyFunction.cc:1167:	    energyTerm.term.I1 = ea1->coordinateIndexTimes3();
energyFunction.cc:1168:	    energyTerm.term.I2 = ea2->coordinateIndexTimes3();
energyFunction.cc:1169:	    energyTerm.term.I3 = ea3->coordinateIndexTimes3();
energyFunction.cc:1170:	    energyTerm.term.I4 = ea4->coordinateIndexTimes3();
energyFunction.cc:1171:	    energyTerm.term.U = dih->getMaxDegrees()*0.0174533;
energyFunction.cc:1172:	    energyTerm.term.L = dih->getMinDegrees()*0.0174533;
energyFunction.cc:1173:	    energyTerm.term.K = dih->getWeight();
energyFunction.cc:1174:	    this->_ImproperRestraint->addTerm(energyTerm);
energyFunction.cc:1175:	} else if ( restraint->isOfClass<RestraintAnchor_O>() )
energyFunction.cc:1180:	    Atom_sp a1 = anchor->getAtom();
energyFunction.cc:1181:	    EnergyAtom* ea1 = this->getEnergyAtomPointer(a1);
energyFunction.cc:1182:	    LOG(BF("Create an anchor restraint for %s") % a1->description()  );
energyFunction.cc:1183:	    anchorPos = anchor->getAnchorPos();
energyFunction.cc:1187:	    iterm.term.ka = this->_AnchorRestraintWeight;
energyFunction.cc:1188:	    iterm.term.I1 = ea1->coordinateIndexTimes3();
energyFunction.cc:1189:	    this->_AnchorRestraint->addTerm(iterm);
energyFunction.cc:1190:	} else if ( restraint->isOfClass<RestraintFixedNonbond_O>() )
energyFunction.cc:1192:	    this->_FixedNonbondRestraint->setupForEvaluation(this->_AtomTable,this->_NonbondCrossTermTable);
energyFunction.cc:1193:	    RestraintFixedNonbond_sp fixedNonbond = restraint->as<RestraintFixedNonbond_O>();
energyFunction.cc:1194:	    Matter_sp matter = fixedNonbond->getMatter();
energyFunction.cc:1195:	    FFNonbondDb_sp nonbondDb = forceField->getNonbondDb();
energyFunction.cc:1203:		    if ( a1->isAssignableTo<VirtualAtom_O>() ) continue; // skip virtuals
energyFunction.cc:1204:		    this->_FixedNonbondRestraint->addFixedAtom(nonbondDb,a1);
energyFunction.cc:1211:	restraintIterator->next();
energyFunction.cc:1224:    EnergyAtom* ea1 = this->getEnergyAtomPointer(energyTerm._Atom1);
energyFunction.cc:1225:    EnergyAtom* ea2 = this->getEnergyAtomPointer(energyTerm._Atom2);
energyFunction.cc:1226:    EnergyAtom* ea3 = this->getEnergyAtomPointer(energyTerm._Atom3);
energyFunction.cc:1227:    EnergyAtom* ea4 = this->getEnergyAtomPointer(energyTerm._Atom4);
energyFunction.cc:1228:    energyTerm.term.I1 = ea1->coordinateIndexTimes3();
energyFunction.cc:1229:    energyTerm.term.I2 = ea2->coordinateIndexTimes3();
energyFunction.cc:1230:    energyTerm.term.I3 = ea3->coordinateIndexTimes3();
energyFunction.cc:1231:    energyTerm.term.I4 = ea4->coordinateIndexTimes3();
energyFunction.cc:1235:    this->_ImproperRestraint->addTerm(energyTerm);
energyFunction.cc:1242:    double transMin = -160.0;
energyFunction.cc:1245:    double cisMax = -20.0;
energyFunction.cc:1249:	if ( secondaryAmide->matches(*ni) )
energyFunction.cc:1251:	    ChemInfoMatch_sp match = secondaryAmide->getMatch();
energyFunction.cc:1252:	    Atom_sp ax = match->tag("1");
energyFunction.cc:1253:	    Atom_sp ax1 = match->tag("2");
energyFunction.cc:1254:	    Atom_sp ax2 = match->tag("3");
energyFunction.cc:1255:	    Atom_sp ay = match->tag("4");	// Carbonyl carbon
energyFunction.cc:1256:	    Atom_sp ay1 = match->tag("5");
energyFunction.cc:1257:	    Atom_sp ay2 = match->tag("6");
energyFunction.cc:1266:	    if ( ay->getRingMembershipCount() > 0 )
energyFunction.cc:1272:	    LOG(BF("Applying a secondary amide restraint between %s and %s") % ax->description() % ay->description()  );
energyFunction.cc:1275:	    this->_applyDihedralRestraint(ax1,ax,ay,ay1,cisMin,cisMax,weight);
energyFunction.cc:1276:	    LOG(BF("Restrain cis %s - %s - %s -%s") % ax1->description() % ax->description() % ay->description() % ay1->description()  );
energyFunction.cc:1277:	    this->_applyDihedralRestraint(ax1,ax,ay,ay2,transMin,transMax,weight);
energyFunction.cc:1278:	    LOG(BF("Restrain trans %s - %s - %s -%s") % ax1->description() % ax->description() % ay->description() % ay2->description()  );
energyFunction.cc:1279:	    this->_applyDihedralRestraint(ax2,ax,ay,ay1,transMin,transMax,weight);
energyFunction.cc:1280:	    LOG(BF("Restrain trans %s - %s - %s -%s") % ax2->description() % ax->description() % ay->description() % ay1->description()  );
energyFunction.cc:1281:	    this->_applyDihedralRestraint(ax2,ax,ay,ay2,cisMin,cisMax,weight);
energyFunction.cc:1282:	    LOG(BF("Restrain cis %s - %s - %s -%s") % ax2->description() % ax->description() % ay->description() % ay2->description()  );
energyFunction.cc:1313:	// Assign relative Cahn-Ingold-Preylog priorities
energyFunction.cc:1323:    forceField->assignTypes(matter);
energyFunction.cc:1324://    printf( "%s:%d dumping xml after assignTypes \n%s\n", __FILE__, __LINE__,matter->asXmlString() );
energyFunction.cc:1330:    if ( !(matter->isOfClass<Aggregate_O>() || matter->isOfClass<Molecule_O>() ) )
energyFunction.cc:1338:    this->_NonbondCrossTermTable = temp;
energyFunction.cc:1339:    this->_NonbondCrossTermTable->fillUsingFFNonbondDb(forceField->getNonbondDb());
energyFunction.cc:1345:    this->_Matter= matter;
energyFunction.cc:1346:    this->_DielectricConstant = 80.0;
energyFunction.cc:1347:    this->_eraseMissingParameters();
energyFunction.cc:1351:    this->_AtomTable->constructFromMatter(matter,forceField);
energyFunction.cc:1358:	    if ( a1->isAssignableTo<VirtualAtom_O>() ) continue; // skip virtuals
energyFunction.cc:1359:	    LOG(BF( "Atom = %s")% a1->description() );
energyFunction.cc:1360:	    a1->setAtomTableIndex(this->_AtomTable->getNumberOfAtoms());
energyFunction.cc:1362:	    this->_AtomTable->add(energyAtom);
energyFunction.cc:1368:    lisp->print(BF("%s:%d There were %d atoms") % __FILE__ % __LINE__ % this->_AtomTable.size() );
energyFunction.cc:1371:	ASSERTNOTNULL(forceField->_Stretches);
energyFunction.cc:1376:	    t1 = a1->getTypeString();
energyFunction.cc:1377:	    t2 = a2->getTypeString();
energyFunction.cc:1378:	    ea1 = this->getEnergyAtomPointer(a1);
energyFunction.cc:1379:	    ea2 = this->getEnergyAtomPointer(a2);
energyFunction.cc:1380:	    FFStretch_sp ffStretch = forceField->_Stretches->findTerm(a1,a2);
energyFunction.cc:1382:	    if ( ffStretch->level() != parameterized ) {
energyFunction.cc:1383:		this->_addMissingParameter(ffStretch->levelDescription());
energyFunction.cc:1385:	    energyStretch.defineFrom(ffStretch,ea1,ea2,this->_Stretch->getScale());
energyFunction.cc:1386:	    this->_Stretch->addTerm(energyStretch);
energyFunction.cc:1391:    lisp->print(BF("%s:%d There were %d stretch terms") % __FILE__ % __LINE__ % this->_Stretch.size() );
energyFunction.cc:1401:	    ea1 = this->getEnergyAtomPointer(a1);
energyFunction.cc:1402:	    ea2 = this->getEnergyAtomPointer(a2);
energyFunction.cc:1403:	    ea3 = this->getEnergyAtomPointer(a3);
energyFunction.cc:1404:	    ffAngle = forceField->_Angles->findTerm(a1,a2,a3);
energyFunction.cc:1405:	    if ( ffAngle->level() != parameterized ) {
energyFunction.cc:1406:		LOG(BF("Missing angle parameter between types: %s-%s-%s") % a1->getTypeString()% a2->getTypeString()% a3->getTypeString() );
energyFunction.cc:1407:		this->_addMissingParameter(ffAngle->levelDescription());
energyFunction.cc:1411:	    energyAngle.defineFrom(ffAngle,ea1,ea2,ea3,this->_Angle->getScale());
energyFunction.cc:1412:	    this->_Angle->addTerm(energyAngle);
energyFunction.cc:1424:	    t1 = a1->getTypeString();
energyFunction.cc:1425:	    t2 = a2->getTypeString();
energyFunction.cc:1426:	    t3 = a3->getTypeString();
energyFunction.cc:1427:	    t4 = a4->getTypeString();
energyFunction.cc:1428:	    ea1 = this->getEnergyAtomPointer(a1);
energyFunction.cc:1429:	    ea2 = this->getEnergyAtomPointer(a2);
energyFunction.cc:1430:	    ea3 = this->getEnergyAtomPointer(a3);
energyFunction.cc:1431:	    ea4 = this->getEnergyAtomPointer(a4);
energyFunction.cc:1432:	    if ( !forceField->_Ptors->hasBestTerm(t1,t2,t3,t4) ) 
energyFunction.cc:1436:		ss << t1 << "-";
energyFunction.cc:1437:		ss << t2 << "-";
energyFunction.cc:1438:		ss << t3 << "-";
energyFunction.cc:1441:		ss << a1->getName() << "-";
energyFunction.cc:1442:		ss << a2->getName() << "-";
energyFunction.cc:1443:		ss << a3->getName() << "-";
energyFunction.cc:1444:		ss << a4->getName() << ")";
energyFunction.cc:1445:		_lisp->print(BF("%s") % ss.str() );
energyFunction.cc:1448://		forceField->_Ptors->cantFind(t1,t2,t3,t4);
energyFunction.cc:1450://		this->_MissingDihedralTerms.push_back(energyDihedral);
energyFunction.cc:1454:		ffPtor = forceField->_Ptors->findBestTerm(t1,t2,t3,t4);
energyFunction.cc:1457:		    if ( ffPtor->hasPeriodicity(n) )
energyFunction.cc:1459:			LOG(BF( "Adding proper term for atoms %s-%s-%s-%s types: %s-%s-%s-%s")%
energyFunction.cc:1460:				    ea1->getResidueAndName()
energyFunction.cc:1461:				    % ea2->getResidueAndName()
energyFunction.cc:1462:				    % ea3->getResidueAndName()
energyFunction.cc:1463:				    % ea4->getResidueAndName()
energyFunction.cc:1467:			energyDihedral.defineFrom(n,ffPtor,ea1,ea2,ea3,ea4,this->_Dihedral->getScale());
energyFunction.cc:1468:			this->_Dihedral->addTerm(energyDihedral);
energyFunction.cc:1471:		if (ea1->inBondOrAngle(ea4->atom()) )
energyFunction.cc:1481:		    LOG(BF("Defining 1-4 interaction %-9s- %-9s   ") % t1 % t4 );
energyFunction.cc:1484:		    if ( energyNonbond.defineFrom(forceField, true, ea1, ea4, this->_Nonbond ) ) 
energyFunction.cc:1486:		        this->_Nonbond->addTerm(energyNonbond);
energyFunction.cc:1498:		    LOG(BF("Ignoring 1-4 interaction %-9s- %-9s    ") % t1 % t4 );
energyFunction.cc:1501://		ea1->_CloserThan15.insert(ea4->_Atom);
energyFunction.cc:1502://		ea4->_CloserThan15.insert(ea1->_Atom);
energyFunction.cc:1516:	    t1 = a1->getTypeString();
energyFunction.cc:1517:	    t2 = a2->getTypeString();
energyFunction.cc:1518:	    t3 = a3->getTypeString();
energyFunction.cc:1519:	    t4 = a4->getTypeString();
energyFunction.cc:1520:	    ea1 = this->getEnergyAtomPointer(a1);
energyFunction.cc:1521:	    ea2 = this->getEnergyAtomPointer(a2);
energyFunction.cc:1522:	    ea3 = this->getEnergyAtomPointer(a3);
energyFunction.cc:1523:	    ea4 = this->getEnergyAtomPointer(a4);
energyFunction.cc:1524:	    if ( forceField->_Itors->hasBestTerm(t1,t2,t3,t4) ) 
energyFunction.cc:1531:		    ffItor = forceField->_Itors->findBestTerm(t1,t2,t3,t4);
energyFunction.cc:1533:			if ( ffItor->hasPeriodicity(n) )
energyFunction.cc:1535:			    energyDihedral.defineFrom(n,ffItor,ea1,ea2,ea3,ea4,this->_Dihedral->getScale());
energyFunction.cc:1536:			    this->_Dihedral->addTerm(energyDihedral);
energyFunction.cc:1548:    this->_Nonbond->constructFromAtomTable(this->_AtomTable, forceField);
energyFunction.cc:1551:	if ( this->_AtomTable->getNumberOfAtoms() > 2 )
energyFunction.cc:1556:	    for ( iea1 = this->_AtomTable->begin();
energyFunction.cc:1557:		  iea1 != this->_AtomTable->end()-1; iea1++ ) { //Was iea1 != this->_AtomTable->end()-1
energyFunction.cc:1558:		for ( iea2 = iea1+1; iea2 != this->_AtomTable->end(); iea2++ ) { // Was iea2 != this->_AtomTable->end()
energyFunction.cc:1559:		    if (!iea1->inBondOrAngle(iea2->_Atom)) 
energyFunction.cc:1561:			bool in14 = iea1->relatedBy14(iea2->_Atom);
energyFunction.cc:1564:						      &(*iea1),&(*iea2),this->_Nonbond) )  {
energyFunction.cc:1565:			    this->_Nonbond->addTerm(energyNonbond);
energyFunction.cc:1572:	    LOG(BF("There are no non-bonds"));
energyFunction.cc:1589:	    if ( a1->getStereochemistryType() != undefinedCenter ) 
energyFunction.cc:1591:		LOG(BF("Create a chiral restraint for %s") % a1->description()  );
energyFunction.cc:1595:			// Otherwise if its pro-chiral center then set it to "R"
energyFunction.cc:1599:			// "R" -> side = 1.0
energyFunction.cc:1600:			// "S" -> side = -1.0
energyFunction.cc:1604:			// default R-stereochemistry (1-center)x(2-center).(3-center) is POSITIVE
energyFunction.cc:1606:		if ( a1->getConfiguration() != undefinedConfiguration )
energyFunction.cc:1608:		    if ( a1->getConfiguration() == R_Configuration )
energyFunction.cc:1613:			side = -1.0;
energyFunction.cc:1617:		    if ( a1->getStereochemistryType() == prochiralCenter )
energyFunction.cc:1623:							       % a1->description()
energyFunction.cc:1624:							       % a1->getConfigurationAsString() );
energyFunction.cc:1627:		core::Cons_sp priority = a1->getNeighborsByRelativePriority();
energyFunction.cc:1628:		ASSERTP(priority->length() == 4, "There must be 4 neighbors to assign stereochemistry");
energyFunction.cc:1630:		n1 = cur->car<Atom_O>();
energyFunction.cc:1631:		cur = cur->cdr();
energyFunction.cc:1632:		n2 = cur->car<Atom_O>();
energyFunction.cc:1633:		cur = cur->cdr();
energyFunction.cc:1634:		n3 = cur->car<Atom_O>();
energyFunction.cc:1635:		cur = cur->cdr();
energyFunction.cc:1636:		n4 = cur->car<Atom_O>();
energyFunction.cc:1638:		s1 = a1->getConfigurationPriorityHighest();
energyFunction.cc:1639:		s2 = a1->getConfigurationPriorityHigh();
energyFunction.cc:1640:		s3 = a1->getConfigurationPriorityLow();
energyFunction.cc:1641:		s4 = a1->getConfigurationPriorityLowest();
energyFunction.cc:1642:		n1 = a1->bondedNeighborWithName(s1);
energyFunction.cc:1643:		n2 = a1->bondedNeighborWithName(s2);
energyFunction.cc:1644:		n3 = a1->bondedNeighborWithName(s3);
energyFunction.cc:1645:		n4 = a1->bondedNeighborWithName(s4);
energyFunction.cc:1646:		ASSERTNOTNULLP(n1, "Atom("+a1->getName()+") does not have neighbor1("+s1+")");
energyFunction.cc:1647:		ASSERTNOTNULLP(n2, "Atom("+a2->getName()+") does not have neighbor2("+s2+")");
energyFunction.cc:1648:		ASSERTNOTNULLP(n3, "Atom("+a3->getName()+") does not have neighbor3("+s3+")");
energyFunction.cc:1649:		ASSERTNOTNULLP(n4, "Atom("+a4->getName()+") does not have neighbor4("+s4+")");
energyFunction.cc:1651:		eaCenter = this->getEnergyAtomPointer(a1);
energyFunction.cc:1652:		ea1 = this->getEnergyAtomPointer(n1);
energyFunction.cc:1653:		ea2 = this->getEnergyAtomPointer(n2);
energyFunction.cc:1654:		ea3 = this->getEnergyAtomPointer(n3);
energyFunction.cc:1655:		ea4 = this->getEnergyAtomPointer(n4);
energyFunction.cc:1658:			// Setup chiral restraints for 1->2->center->3
energyFunction.cc:1659:			//			and 1->2->center->4
energyFunction.cc:1661:		ichiral._Atom1 = ea1->atom();
energyFunction.cc:1662:		ichiral._Atom2 = ea2->atom();
energyFunction.cc:1663:		ichiral._Atom3 = eaCenter->atom();
energyFunction.cc:1664:		ichiral._Atom4 = ea3->atom();
energyFunction.cc:1665:		ichiral.term.I1 = ea1->coordinateIndexTimes3();
energyFunction.cc:1666:		ichiral.term.I2 = ea2->coordinateIndexTimes3();
energyFunction.cc:1667:		ichiral.term.I3 = eaCenter->coordinateIndexTimes3();
energyFunction.cc:1668:		ichiral.term.I4 = ea3->coordinateIndexTimes3();
energyFunction.cc:1669:		ichiral.term.K = this->_ChiralRestraintWeight * side;
energyFunction.cc:1670:		ichiral.term.CO = this->_ChiralRestraintOffset;
energyFunction.cc:1671:		this->_ChiralRestraint->addTerm(ichiral);
energyFunction.cc:1675:		ichiral._Atom4 = ea4->atom();
energyFunction.cc:1676:		ichiral.term.I4 = ea4->coordinateIndexTimes3();
energyFunction.cc:1678:		ichiral.term.K = this->_ChiralRestraintWeight * side * -1.0;
energyFunction.cc:1679:		ichiral.term.CO = this->_ChiralRestraintOffset;
energyFunction.cc:1680:		this->_ChiralRestraint->addTerm(ichiral);
energyFunction.cc:1686:			// Setup chiral restraints for 2->4->center->3
energyFunction.cc:1687:			//			and 2->4->center->1
energyFunction.cc:1689:		ichiral._Atom1 = ea2->atom();
energyFunction.cc:1690:		ichiral._Atom2 = ea4->atom();
energyFunction.cc:1691:		ichiral._Atom3 = eaCenter->atom();
energyFunction.cc:1692:		ichiral._Atom4 = ea3->atom();
energyFunction.cc:1693:		ichiral.term.I1 = ea2->coordinateIndexTimes3();
energyFunction.cc:1694:		ichiral.term.I2 = ea4->coordinateIndexTimes3();
energyFunction.cc:1695:		ichiral.term.I3 = eaCenter->coordinateIndexTimes3();
energyFunction.cc:1696:		ichiral.term.I4 = ea3->coordinateIndexTimes3();
energyFunction.cc:1697:		ichiral.term.K = this->_ChiralRestraintWeight * side;
energyFunction.cc:1698:		ichiral.term.CO = this->_ChiralRestraintOffset;
energyFunction.cc:1699:		this->_ChiralRestraint->addTerm(ichiral);
energyFunction.cc:1703:		ichiral._Atom4 = ea1->atom();
energyFunction.cc:1704:		ichiral.term.I4 = ea1->coordinateIndexTimes3();
energyFunction.cc:1706:		ichiral.term.K = this->_ChiralRestraintWeight * side * -1.0;
energyFunction.cc:1707:		ichiral.term.CO = this->_ChiralRestraintOffset;
energyFunction.cc:1708:		this->_ChiralRestraint->addTerm(ichiral);
energyFunction.cc:1711:		LOG(BF("There is no chiral restraint for: %s") % a1->description()  );
energyFunction.cc:1721:	if ( this->_AtomTable->getNumberOfAtoms() > 0 )
energyFunction.cc:1728:	    for ( iea1 = this->_AtomTable->begin();
energyFunction.cc:1729:		  iea1 != this->_AtomTable->end()-1; iea1++ )
energyFunction.cc:1731:		a1 = iea1->atom();
energyFunction.cc:1732:		if ( a1->isAnchorRestraintOn() )
energyFunction.cc:1734:		    LOG(BF("Create an anchor restraint for %s") % a1->description()  );
energyFunction.cc:1735:		    anchorPos = a1->getAnchorPos();
energyFunction.cc:1739:		    iterm.term.ka = this->_AnchorRestraintWeight;
energyFunction.cc:1740:		    iterm.term.I1 = iea1->coordinateIndexTimes3();
energyFunction.cc:1741:		    this->_AnchorRestraint->addTerm(iterm);
energyFunction.cc:1753:    if ( this->_RestrainSecondaryAmides )
energyFunction.cc:1756:	for ( AtomTable_O::iterator it=this->_AtomTable->begin(); it!=this->_AtomTable->end(); it++ )
energyFunction.cc:1758:	    Atom_sp a = it->atom();
energyFunction.cc:1759:	    if ( a->getElement() == element_N )
energyFunction.cc:1764:        this->__createSecondaryAmideRestraints(nitrogens);
energyFunction.cc:1767:	LOG(BF("Skipping Secondary amide restraints because _RestrainSecondaryAmides = %d") % this->_RestrainSecondaryAmides );
energyFunction.cc:1773:	// Set up force-field restraints
energyFunction.cc:1775:    {_BLOCK_TRACE("Defining force-field restraints");
energyFunction.cc:1777:	this->_applyRestraints(forceField,restraintIt);
energyFunction.cc:1788:    this->_applyRestraints(forceField,iterate);
energyFunction.cc:1795:    if ( pos->size() != this->getNVectorSize()) {
energyFunction.cc:1798:    for ( ai=this->_AtomTable->begin(); ai!=this->_AtomTable->end(); ai++ ) {
energyFunction.cc:1799:        ci = ai->coordinateIndexTimes3();
energyFunction.cc:1800:        pos->setElement(ci,ai->atom()->getPosition().getX());
energyFunction.cc:1801:        pos->setElement(ci+1, ai->atom()->getPosition().getY());
energyFunction.cc:1802:        pos->setElement(ci+2, ai->atom()->getPosition().getZ());
energyFunction.cc:1814:    for ( ai=this->_AtomTable->begin(); ai!=this->_AtomTable->end(); ai++ ) {
energyFunction.cc:1815:        ci = ai->coordinateIndexTimes3();
energyFunction.cc:1816:        x = pos->getElement(ci+0);
energyFunction.cc:1817:        y = pos->getElement(ci+1);
energyFunction.cc:1818:        z = pos->getElement(ci+2);
energyFunction.cc:1821:        ai->atom()->setPosition(v);
energyFunction.cc:1831:    for ( ai=this->_AtomTable->begin(); ai!=this->_AtomTable->end(); ai++ ) {
energyFunction.cc:1832:        ci = ai->coordinateIndexTimes3();
energyFunction.cc:1833:        x = force->getElement(ci+0);
energyFunction.cc:1834:        y = force->getElement(ci+1);
energyFunction.cc:1835:        z = force->getElement(ci+2);
energyFunction.cc:1837:        ai->atom()->setForce(v);
energyFunction.cc:1844:    this->writeCoordinatesToAtoms(pos);
energyFunction.cc:1845:    this->writeForceToAtoms(force);
energyFunction.cc:1851:    return this->_AtomTable->getEnergyAtomPointer(a);
energyFunction.cc:1859:    pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:1860:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:1861:    return this->evaluateEnergy(pos);
energyFunction.cc:1870:    pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:1871:    force = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:1872:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:1873:    energy = this->evaluateEnergyForce(pos,true,force);
energyFunction.cc:1874:    	// To calculate the force magnitude use force->magnitude();
energyFunction.cc:1875:    	// To calculate the force rmsMagnitude use force->rmsMagnitude();
energyFunction.cc:1876:    this->writeForceToAtoms(force);
energyFunction.cc:1890:	    problem._Atom1->bumpPosition(0.1);
energyFunction.cc:1891:	    problem._Atom2->bumpPosition(0.1);
energyFunction.cc:1892:	    problem._Atom3->bumpPosition(0.1);
energyFunction.cc:1893:	    problem._Atom4->bumpPosition(0.1);
energyFunction.cc:1896:	    problem._Atom1->bumpPosition(0.1);
energyFunction.cc:1897:	    problem._Atom2->bumpPosition(0.1);
energyFunction.cc:1898:	    problem._Atom3->bumpPosition(0.1);
energyFunction.cc:1899:	    problem._Atom4->bumpPosition(0.1);
energyFunction.cc:1902:	    problem._Atom1->bumpPosition(0.1);
energyFunction.cc:1903:	    problem._Atom2->bumpPosition(0.1);
energyFunction.cc:1904:	    problem._Atom3->bumpPosition(0.1);
energyFunction.cc:1918:    ss << this->_Stretch->beyondThresholdInteractionsAsString();
energyFunction.cc:1920:    ss << this->_Angle->beyondThresholdInteractionsAsString();
energyFunction.cc:1921:    ss << this->_Dihedral->beyondThresholdInteractionsAsString();
energyFunction.cc:1922:    ss << this->_Nonbond->beyondThresholdInteractionsAsString();
energyFunction.cc:1923:    ss << this->_ImproperRestraint->beyondThresholdInteractionsAsString();
energyFunction.cc:1924:    ss << this->_ChiralRestraint->beyondThresholdInteractionsAsString();
energyFunction.cc:1925:    ss << this->_AnchorRestraint->beyondThresholdInteractionsAsString();
energyFunction.cc:1926:    ss << this->_FixedNonbondRestraint->beyondThresholdInteractionsAsString();
energyFunction.cc:1936:    ss << this->_Stretch->summarizeEnergyAsString();
energyFunction.cc:1938:    ss << this->_Angle->summarizeEnergyAsString();
energyFunction.cc:1939:    ss << this->_Dihedral->summarizeEnergyAsString();
energyFunction.cc:1940:    ss << this->_Nonbond->summarizeEnergyAsString();
energyFunction.cc:1941:    ss << this->_ImproperRestraint->summarizeEnergyAsString();
energyFunction.cc:1942:    ss << this->_ChiralRestraint->summarizeEnergyAsString();
energyFunction.cc:1943:    ss << this->_AnchorRestraint->summarizeEnergyAsString();
energyFunction.cc:1944:    ss << this->_FixedNonbondRestraint->summarizeEnergyAsString();
energyFunction.cc:1946:    ss<< "             Total energy: " << this->_TotalEnergy << endl;
energyFunction.cc:1954:    if ( this->_MissingParameters.size() > 0 ) {
energyFunction.cc:1965:    for ( si=this->_MissingParameters.begin();
energyFunction.cc:1966:		si!=this->_MissingParameters.end(); si++ ) {
energyFunction.cc:1976:    ss << this->_Stretch->debugLogAsString() << endl;
energyFunction.cc:1978:    ss << this->_Angle->debugLogAsString() << endl;
energyFunction.cc:1979:    ss << this->_Dihedral->debugLogAsString() << endl;
energyFunction.cc:1980:    ss << this->_Nonbond->debugLogAsString() << endl;
energyFunction.cc:1981:    ss << this->_ImproperRestraint->debugLogAsString() << endl;
energyFunction.cc:1982:    ss << this->_ChiralRestraint->debugLogAsString() << endl;
energyFunction.cc:1983:    ss << this->_AnchorRestraint->debugLogAsString() << endl;
energyFunction.cc:1984:    ss << this->_FixedNonbondRestraint->debugLogAsString() << endl;
energyFunction.cc:2007:    pos = NVector_O::create(this->getNVectorSize(),_lisp);
energyFunction.cc:2008:    this->extractCoordinatesFromAtoms(pos);
energyFunction.cc:2009:    nbComponent = this->getNonbondComponent();
energyFunction.cc:2010:    i = nbComponent->countBadVdwOverlaps(scaleSumOfVdwRadii,pos,displayIn,displayIn->lisp());
energyImproperRestraint.cc:28:    this->_Atom1.reset();
energyImproperRestraint.cc:29:    this->_Atom2.reset();
energyImproperRestraint.cc:30:    this->_Atom3.reset();
energyImproperRestraint.cc:31:    this->_Atom4.reset();
energyImproperRestraint.cc:42:    node->attribute("_AboveThreshold",this->_AboveThreshold);
energyImproperRestraint.cc:43:    node->attribute("_AboveThreshold_Phi",this->_AboveThreshold_Phi);
energyImproperRestraint.cc:44:    node->attribute("U",this->term.U);
energyImproperRestraint.cc:45:    node->attribute("L",this->term.L);
energyImproperRestraint.cc:46:    node->attribute("K",this->term.K);
energyImproperRestraint.cc:47:    node->attribute("I1",this->term.I1);
energyImproperRestraint.cc:48:    node->attribute("I2",this->term.I2);
energyImproperRestraint.cc:49:    node->attribute("I3",this->term.I3);
energyImproperRestraint.cc:50:    node->attribute("I4",this->term.I4);
energyImproperRestraint.cc:51:    node->archiveObject("a1",this->_Atom1);
energyImproperRestraint.cc:52:    node->archiveObject("a2",this->_Atom2);
energyImproperRestraint.cc:53:    node->archiveObject("a3",this->_Atom3);
energyImproperRestraint.cc:54:    node->archiveObject("a4",this->_Atom4);
energyImproperRestraint.cc:56:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyImproperRestraint.cc:57:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyImproperRestraint.cc:58:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyImproperRestraint.cc:67:    pos1 = this->_Atom1->getPosition();
energyImproperRestraint.cc:68:    pos2 = this->_Atom2->getPosition();
energyImproperRestraint.cc:69:    pos3 = this->_Atom3->getPosition();
energyImproperRestraint.cc:70:    pos4 = this->_Atom4->getPosition();
energyImproperRestraint.cc:82:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyImproperRestraint.cc:83:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyImproperRestraint.cc:84:    node->addAttributeString("atom3Name",this->_Atom3->getName());
energyImproperRestraint.cc:85:    node->addAttributeString("atom4Name",this->_Atom4->getName());
energyImproperRestraint.cc:86:    node->addAttributeInt("I1",this->term.I1);
energyImproperRestraint.cc:87:    node->addAttributeInt("I2",this->term.I2);
energyImproperRestraint.cc:88:    node->addAttributeInt("I3",this->term.I3);
energyImproperRestraint.cc:89:    node->addAttributeInt("I4",this->term.I4);
energyImproperRestraint.cc:90:    node->addAttributeDouble("UDeg",this->term.U/0.0174533,6,2);
energyImproperRestraint.cc:91:    node->addAttributeDouble("LDeg",this->term.L/0.0174533,6,2);
energyImproperRestraint.cc:92:    node->addAttributeDoubleScientific("U",this->term.U);
energyImproperRestraint.cc:93:    node->addAttributeDoubleScientific("L",this->term.L);
energyImproperRestraint.cc:94:    node->addAttributeDoubleScientific("K",this->term.K);
energyImproperRestraint.cc:95:    if ( this->_AboveThreshold ) {
energyImproperRestraint.cc:97:	child->addAttributeDoubleScientific("Phi",this->_AboveThreshold_Phi );
energyImproperRestraint.cc:98:	child->addAttributeDouble("PhiDeg",this->_AboveThreshold_Phi/0.0174533,6,2 );
energyImproperRestraint.cc:100:	ss << endl << "This improper has the value("<<this->_AboveThreshold_Phi/0.0174533<<")"
energyImproperRestraint.cc:101:	    << " outside of bounds ["<<this->term.U/0.0174533<<","
energyImproperRestraint.cc:102:	    <<this->term.L/0.0174533<<"]" << endl;
energyImproperRestraint.cc:103:	child->setCharacters(ss.str());
energyImproperRestraint.cc:104:	node->addChild(child);
energyImproperRestraint.cc:108:    xml->addAttributeBool("calcForce",this->_calcForce );
energyImproperRestraint.cc:109:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyImproperRestraint.cc:110:    xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyImproperRestraint.cc:112:    node->addChild(xml);
energyImproperRestraint.cc:120:    this->term.U = xml->getAttributeDouble("U");
energyImproperRestraint.cc:121:    this->term.L = xml->getAttributeDouble("L");
energyImproperRestraint.cc:122:    this->term.K = xml->getAttributeDouble("K");
energyImproperRestraint.cc:123:    this->term.I1 = xml->getAttributeInt("I1");
energyImproperRestraint.cc:124:    this->term.I2 = xml->getAttributeInt("I2");
energyImproperRestraint.cc:125:    this->term.I3 = xml->getAttributeInt("I3");
energyImproperRestraint.cc:126:    this->term.I4 = xml->getAttributeInt("I4");
energyImproperRestraint.cc:127:    this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->term.I1)->atom();
energyImproperRestraint.cc:128:    this->_Atom2 = at->findEnergyAtomWithCoordinateIndex(this->term.I2)->atom();
energyImproperRestraint.cc:129:    this->_Atom3 = at->findEnergyAtomWithCoordinateIndex(this->term.I3)->atom();
energyImproperRestraint.cc:130:    this->_Atom4 = at->findEnergyAtomWithCoordinateIndex(this->term.I4)->atom();
energyImproperRestraint.cc:169:#pragma GCC diagnostic ignored "-Wunused-variable"
energyImproperRestraint.cc:180:    this->_Terms.push_back(e);
energyImproperRestraint.cc:209:// -----------------------
energyImproperRestraint.cc:212:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x=iri->term.x;}
energyImproperRestraint.cc:214:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x=nvPosition->element(ii+of);}
energyImproperRestraint.cc:223:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyImproperRestraint.cc:227:	  m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyImproperRestraint.cc:233:    if ( this->isEnabled() ) {
energyImproperRestraint.cc:235:#pragma GCC diagnostic ignored "-Wunused-variable"
energyImproperRestraint.cc:243:	for ( vector<EnergyImproperRestraint>::iterator iri=this->_Terms.begin();
energyImproperRestraint.cc:244:		    iri!=this->_Terms.end(); iri++ ) {
energyImproperRestraint.cc:263:    if ( this->_DebugEnergy ) 
energyImproperRestraint.cc:266:	LOG_ENERGY(BF("%s {")% this->className());
energyImproperRestraint.cc:276:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyImproperRestraint.cc:282:// -----------------------
energyImproperRestraint.cc:287:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri->term.x;}
energyImproperRestraint.cc:289:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of)	{x = pos->element(ii+of);}
energyImproperRestraint.cc:293:#define	IMPROPER_RESTRAINT_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyImproperRestraint.cc:301:    if ( this->isEnabled() ) {
energyImproperRestraint.cc:303:#pragma GCC diagnostic ignored "-Wunused-variable"
energyImproperRestraint.cc:312:	for ( i=0,iri =this->_Terms.begin();
energyImproperRestraint.cc:313:		    iri!=this->_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:315:		if ( this->_Debug_NumberOfImproperRestraintTermsToCalculate > 0 ) {
energyImproperRestraint.cc:316:		    if ( i>= this->_Debug_NumberOfImproperRestraintTermsToCalculate ) {
energyImproperRestraint.cc:324:	       problem._Atom1 = iri->_Atom1;
energyImproperRestraint.cc:325:	       problem._Atom2 = iri->_Atom2;
energyImproperRestraint.cc:326:	       problem._Atom3 = iri->_Atom3;
energyImproperRestraint.cc:327:	       problem._Atom4 = iri->_Atom4;
energyImproperRestraint.cc:334:		iri->_calcForce = calcForce;
energyImproperRestraint.cc:335:		iri->_calcDiagonalHessian = calcDiagonalHessian;
energyImproperRestraint.cc:336:		iri->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyImproperRestraint.cc:338:		#define EVAL_SET(var,val)	{ iri->eval.var=val;};
energyImproperRestraint.cc:342:	    if ( this->_DebugEnergy ) 
energyImproperRestraint.cc:391:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyImproperRestraint.cc:392:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyImproperRestraint.cc:393:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyImproperRestraint.cc:394:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyImproperRestraint.cc:395:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyImproperRestraint.cc:396:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyImproperRestraint.cc:397:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx3>10000.0);
energyImproperRestraint.cc:398:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy3>10000.0);
energyImproperRestraint.cc:399:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz3>10000.0);
energyImproperRestraint.cc:400:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx4>10000.0);
energyImproperRestraint.cc:401:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy4>10000.0);
energyImproperRestraint.cc:402:		_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz4>10000.0);
energyImproperRestraint.cc:406:    LOG_ENERGY(BF( "ImproperRestraint energy = %lf\n")% (double)(this->_TotalEnergy) );
energyImproperRestraint.cc:407:    if ( this->_DebugEnergy ) 
energyImproperRestraint.cc:409:	LOG_ENERGY(BF("%s }\n")% this->className());
energyImproperRestraint.cc:431://------------------
energyImproperRestraint.cc:436:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri->term.x;}
energyImproperRestraint.cc:438:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x = pos->element(ii+of);}
energyImproperRestraint.cc:451:	if ( this->isEnabled() ) {
energyImproperRestraint.cc:454:#pragma GCC diagnostic ignored "-Wunused-variable"
energyImproperRestraint.cc:463:	    for ( i=0,iri =this->_Terms.begin();
energyImproperRestraint.cc:464:			iri!=this->_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:484:    this->_BeyondThresholdTerms.clear();
energyImproperRestraint.cc:489://------------------
energyImproperRestraint.cc:494:#define	IMPROPER_RESTRAINT_SET_PARAMETER(x)	{x = iri->term.x;}
energyImproperRestraint.cc:496:#define	IMPROPER_RESTRAINT_SET_POSITION(x,ii,of) {x = pos->element(ii+of);}
energyImproperRestraint.cc:509:	if ( this->isEnabled() ) {
energyImproperRestraint.cc:512:#pragma GCC diagnostic ignored "-Wunused-variable"
energyImproperRestraint.cc:521:	    for ( i=0,iri =this->_Terms.begin();
energyImproperRestraint.cc:522:			iri!=this->_Terms.end(); iri++,i++ ) {
energyImproperRestraint.cc:534:		    info << a1->description() << " ";
energyImproperRestraint.cc:535:		    info << a2->description() << " ";
energyImproperRestraint.cc:536:		    info << a3->description() << " ";
energyImproperRestraint.cc:537:		    info << a4->description() << " ";
energyImproperRestraint.cc:539:		    this->_BeyondThresholdTerms.push_back(*iri);
energyImproperRestraint.cc:572:    this->Base::initialize();
energyImproperRestraint.cc:573:    this->setErrorThreshold(0.001);
energyImproperRestraint.cc:579:    this->Base::archiveBase(node);
energyNonbond.cc:36:	node->attribute("_Is14",this->_Is14);
energyNonbond.cc:37:	node->attribute("_A",this->_A);
energyNonbond.cc:38:	node->attribute("_C",this->_C);
energyNonbond.cc:39:	node->attribute("_Charge1",this->_Charge1);
energyNonbond.cc:40:	node->attribute("_Charge2",this->_Charge2);
energyNonbond.cc:41:	node->attribute("_RStar",this->_RStar);
energyNonbond.cc:42:	node->attribute("dQ1Q2",this->term.dQ1Q2);
energyNonbond.cc:43:	node->attribute("dA",this->term.dA);
energyNonbond.cc:44:	node->attribute("dC",this->term.dC);
energyNonbond.cc:45:	node->attribute("I1",this->term.I1);
energyNonbond.cc:46:	node->attribute("I2",this->term.I2);
energyNonbond.cc:47:	node->archiveObject("a1",this->_Atom1);
energyNonbond.cc:48:	node->archiveObject("a2",this->_Atom2);
energyNonbond.cc:50:	node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyNonbond.cc:51:	node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyNonbond.cc:52:	node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyNonbond.cc:75:	this->_Is14 = is14;
energyNonbond.cc:76:	this->_Atom1 = iea1->atom();
energyNonbond.cc:77:	this->_Atom2 = iea2->atom();
energyNonbond.cc:78:	ffNonbond1 = forceField->_Nonbonds->findType(iea1->atom()->getTypeString());
energyNonbond.cc:79:	ffNonbond2 = forceField->_Nonbonds->findType(iea2->atom()->getTypeString());
energyNonbond.cc:81:	if ( ffNonbond1->isNil() )
energyNonbond.cc:83://     	SIMPLE_ERROR(BF("Unknown force field type(",iea1->_Atom->getTypeString().c_str(),") for non-bonded interaction"));
energyNonbond.cc:87:	if ( ffNonbond2->isNil() )
energyNonbond.cc:89://     	SIMPLE_ERROR(BF("Unknown force field type(",iea2->_Atom->getTypeString().c_str(),") for non-bonded interaction"));
energyNonbond.cc:93:	    vdwScale = 1.0/2.0*nb->getVdwScale();
energyNonbond.cc:94:	    electrostaticScale = nb->getElectrostaticScale()*1.0/1.2;
energyNonbond.cc:97:	    vdwScale = nb->getVdwScale();
energyNonbond.cc:98:	    electrostaticScale = nb->getElectrostaticScale();
energyNonbond.cc:104:	    this->_RStar = ffNonbond1->getRadius_Angstroms()+ffNonbond2->getRadius_Angstroms();
energyNonbond.cc:105:	    epsilonij = sqrt(ffNonbond1->getEpsilon_kCal()*ffNonbond2->getEpsilon_kCal());
energyNonbond.cc:106:	    this->_A = epsilonij*pow(this->_RStar,12.0);
energyNonbond.cc:107:	    this->_C = 2.0*epsilonij*pow(this->_RStar,6.0);
energyNonbond.cc:108:	    this->term.dA = this->_A*vdwScale;
energyNonbond.cc:109:	    this->term.dC = this->_C*vdwScale;
energyNonbond.cc:113:	    this->_Charge1 = iea1->atom()->getCharge();
energyNonbond.cc:114:	    this->_Charge2 = iea2->atom()->getCharge();
energyNonbond.cc:115:	    this->term.dQ1Q2 = electrostaticScale*(this->_Charge1*this->_Charge2)/nb->getDielectricConstant();
energyNonbond.cc:117:	    LOG(BF( "Calc dQ1Q2 Dielectric constant = %lf")% (double)(nb->getDielectricConstant()));
energyNonbond.cc:118:	    LOG(BF( "Calc dQ1Q2 Charge1 = %lf")% (double)(this->_Charge1));
energyNonbond.cc:119:	    LOG(BF( "Calc dQ1Q2 Charge2 = %lf")% (double)(this->_Charge2));
energyNonbond.cc:120:	    LOG(BF( "dQ1Q2 = %lf")% (double)(this->term.dQ1Q2));
energyNonbond.cc:122:	this->term.I1 = iea1->coordinateIndexTimes3();
energyNonbond.cc:123:	this->term.I2 = iea2->coordinateIndexTimes3();
energyNonbond.cc:130:	pos1 = this->_Atom1->getPosition();
energyNonbond.cc:131:	pos2 = this->_Atom2->getPosition();
energyNonbond.cc:142:	node->addAttributeString("atom1Name",this->_Atom1->getName());
energyNonbond.cc:143:	node->addAttributeString("atom2Name",this->_Atom2->getName());
energyNonbond.cc:144:	node->addAttributeInt("I1",this->term.I1);
energyNonbond.cc:145:	node->addAttributeInt("I2",this->term.I2);
energyNonbond.cc:146:	node->addAttributeBool("is14",this->_Is14);
energyNonbond.cc:147:	node->addAttributeString("atom1Type",this->_Atom1->getTypeString());
energyNonbond.cc:148:	node->addAttributeString("atom2Type",this->_Atom2->getTypeString());
energyNonbond.cc:149:	node->addAttributeDoubleScientific("RStar",this->_RStar);
energyNonbond.cc:150:	node->addAttributeDoubleScientific("A",this->_A);
energyNonbond.cc:151:	node->addAttributeDoubleScientific("C",this->_C);
energyNonbond.cc:152:	node->addAttributeDoubleScientific("Charge1",this->_Charge1);
energyNonbond.cc:153:	node->addAttributeDoubleScientific("Charge2",this->_Charge2);
energyNonbond.cc:154://    vdiff = this->_Atom1->_Atom->getPosition() - this->_Atom2->_Atom->getPosition();
energyNonbond.cc:156://    node->addAttributeDouble("_r",diff,5,2);
energyNonbond.cc:159:	xml->addAttributeBool("calcForce",this->_calcForce );
energyNonbond.cc:160:	xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyNonbond.cc:161:	xml->addAttributeBool("calcOffDiagonalHessian",this->_calcOffDiagonalHessian );
energyNonbond.cc:163:	node->addChild(xml);
energyNonbond.cc:165:	node->addAttributeDoubleScientific("dA",this->term.dA);
energyNonbond.cc:166:	node->addAttributeDoubleScientific("dC",this->term.dC);
energyNonbond.cc:167:	node->addAttributeDoubleScientific("dQ1Q2",this->term.dQ1Q2);
energyNonbond.cc:177:	this->term.dA = xml->getAttributeDouble("dA");
energyNonbond.cc:178:	this->term.dC = xml->getAttributeDouble("dC");
energyNonbond.cc:179:	this->term.dQ1Q2 = xml->getAttributeDouble("dQ1Q2");
energyNonbond.cc:180:	this->_RStar = xml->getAttributeDouble("RStar");
energyNonbond.cc:181:	this->_A = xml->getAttributeDouble("A");
energyNonbond.cc:182:	this->_C = xml->getAttributeDouble("C");
energyNonbond.cc:183:	this->_Charge1 = xml->getAttributeDouble("Charge1");
energyNonbond.cc:184:	this->_Charge2 = xml->getAttributeDouble("Charge2");
energyNonbond.cc:185:	this->term.I1 = xml->getAttributeInt("I1");
energyNonbond.cc:186:	this->term.I2 = xml->getAttributeInt("I2");
energyNonbond.cc:187:	this->_Is14 = xml->getAttributeBool("is14");
energyNonbond.cc:188:	this->_Atom1 = at->findEnergyAtomWithCoordinateIndex(this->term.I1)->atom();
energyNonbond.cc:189:	this->_Atom2 = at->findEnergyAtomWithCoordinateIndex(this->term.I2)->atom();
energyNonbond.cc:223:#pragma GCC diagnostic ignored "-Wunused-variable"
energyNonbond.cc:234:	this->Base::zeroEnergy();
energyNonbond.cc:235:	this->_EnergyElectrostatic = 0.0;
energyNonbond.cc:236:	this->_EnergyVdw = 0.0;
energyNonbond.cc:242:	e = this->getVdwEnergy();
energyNonbond.cc:243:	e += this->getElectrostaticEnergy();
energyNonbond.cc:253:	for ( eni=this->_Terms.begin(); eni!=this->_Terms.end(); eni++ )
energyNonbond.cc:255:	    as1 = atomLabel(eni->_Atom1);
energyNonbond.cc:256:	    as2 = atomLabel(eni->_Atom2);
energyNonbond.cc:265:	    if ( eni->_Is14 ) {
energyNonbond.cc:266:		_lisp->print(BF("TERM 4CALC14 %-9s - %-9s") %	str1 % str2 );
energyNonbond.cc:268:		_lisp->print(BF("TERM 5NONBOND %-9s - %-9s") %	str1 % str2 );
energyNonbond.cc:296:	    displayIn->clear();
energyNonbond.cc:297:	    color = addon::Color_O::systemColor(_lisp->symbol(addon::_kw_yellow));
energyNonbond.cc:299:	for ( eni=this->_Terms.begin();
energyNonbond.cc:300:	      eni!=this->_Terms.end(); eni++ )
energyNonbond.cc:302:	    ia1 = eni->term.I1;
energyNonbond.cc:303:	    ia2 = eni->term.I2;
energyNonbond.cc:304:	    x1 = pos->element(ia1+0);
energyNonbond.cc:305:	    y1 = pos->element(ia1+1);
energyNonbond.cc:306:	    z1 = pos->element(ia1+2);
energyNonbond.cc:307:	    x2 = pos->element(ia2+0);
energyNonbond.cc:308:	    y2 = pos->element(ia2+1);
energyNonbond.cc:309:	    z2 = pos->element(ia2+2);
energyNonbond.cc:310:	    cutoff = eni->_RStar*scaleSumOfVdwRadii;
energyNonbond.cc:312:	    dx = x1-x2;
energyNonbond.cc:313:	    dy = y1-y2;
energyNonbond.cc:314:	    dz = z1-z2;
energyNonbond.cc:319:		LOG(BF("Atom1 = %s") % eni->_Atom1->description()  );
energyNonbond.cc:320:		LOG(BF("Atom2 = %s") % eni->_Atom2->description()  );
energyNonbond.cc:325:		    lines->appendLineWithVertices(v1,color,v2,color);
energyNonbond.cc:330:	displayIn->append(lines);
energyNonbond.cc:348:// -----------------------
energyNonbond.cc:369:	if ( this->_DebugEnergy ) 
energyNonbond.cc:372:	    LOG_ENERGY(BF("%s {\n")% this->className());
energyNonbond.cc:382:	bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyNonbond.cc:388:// -----------------------
energyNonbond.cc:394:#define	NONBOND_SET_PARAMETER(x)	{x=nbi->term.x;}
energyNonbond.cc:396:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyNonbond.cc:398:#define	NONBOND_EEEL_ENERGY_ACCUMULATE(e) {this->_EnergyElectrostatic +=(e);}
energyNonbond.cc:400:#define	NONBOND_EVDW_ENERGY_ACCUMULATE(e) {this->_EnergyVdw+=(e);}
energyNonbond.cc:412:	if ( this->isEnabled() ) 
energyNonbond.cc:414:	    vector<EnergyNonbond>::iterator firstElement = this->_Terms.begin();
energyNonbond.cc:415:	    int nonBondTerms = this->_Terms.size();
energyNonbond.cc:421:#pragma GCC diagnostic ignored "-Wunused-variable"
energyNonbond.cc:431:		    if ( this->_Debug_NumberOfNonbondTermsToCalculate > 0 ) {
energyNonbond.cc:432:			if ( i>= this->_Debug_NumberOfNonbondTermsToCalculate ) {
energyNonbond.cc:439:		    nbi->_calcForce = calcForce;
energyNonbond.cc:440:		    nbi->_calcDiagonalHessian = calcDiagonalHessian;
energyNonbond.cc:441:		    nbi->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyNonbond.cc:443:#define	EVAL_SET(var,val)	{ nbi->eval.var=val;};
energyNonbond.cc:448:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyNonbond.cc:449:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyNonbond.cc:450:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyNonbond.cc:451:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyNonbond.cc:452:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyNonbond.cc:453:			_lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyNonbond.cc:455:		    if ( this->_DebugEnergy ) {
energyNonbond.cc:457:			LOG_ENERGY(BF( "MEISTER nonbond %d dA %5.3lf\n")% (i+1) % (nbi->term.dA) );
energyNonbond.cc:458:			LOG_ENERGY(BF( "MEISTER nonbond %d dC %5.3lf\n")% (i+1) % (nbi->term.dC) );
energyNonbond.cc:459:			LOG_ENERGY(BF( "MEISTER nonbond %d dQ1Q2 %5.3lf\n")% (i+1) % (nbi->term.dQ1Q2) );
energyNonbond.cc:485:	LOG_ENERGY(BF( "Nonbond energy vdw(%lf) electrostatic(%lf)\n")% (double)this->_EnergyVdw % this->_EnergyElectrostatic );
energyNonbond.cc:507://------------------
energyNonbond.cc:514:#define	NONBOND_SET_PARAMETER(x)	{x=nbi->term.x;}
energyNonbond.cc:516:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyNonbond.cc:530:	if ( this->isEnabled() ) {
energyNonbond.cc:533:#pragma GCC diagnostic ignored "-Wunused-variable"
energyNonbond.cc:539:	    for ( i=0,nbi=this->_Terms.begin();
energyNonbond.cc:540:		  nbi!=this->_Terms.end(); nbi++,i++ ) {
energyNonbond.cc:559:	this->_BeyondThresholdTerms.clear();
energyNonbond.cc:564://------------------
energyNonbond.cc:569:#define	NONBOND_SET_PARAMETER(x)	{x=nbi->term.x;}
energyNonbond.cc:571:#define	NONBOND_SET_POSITION(x,ii,of)	{x=pos->element(ii+of);}
energyNonbond.cc:585:	if ( this->isEnabled() )
energyNonbond.cc:589:#pragma GCC diagnostic ignored "-Wunused-variable"
energyNonbond.cc:595:	    for ( i=0,nbi=this->_Terms.begin();
energyNonbond.cc:596:		  nbi!=this->_Terms.end(); nbi++,i++ ) 
energyNonbond.cc:599:		if ( NonbondDistance < this->_ErrorThreshold ) {
energyNonbond.cc:604://		info<< a1->getAbsoluteIdPath() << " ";
energyNonbond.cc:605://		info<< a2->getAbsoluteIdPath() << " ";
energyNonbond.cc:607:		    info<<"threshold " << this->_ErrorThreshold;
energyNonbond.cc:608:		    info << a1->getName() << " ";
energyNonbond.cc:609:		    info << a2->getName() << " ";
energyNonbond.cc:611:		    this->_BeyondThresholdTerms.push_back(*nbi);
energyNonbond.cc:643:	this->Base::initialize();
energyNonbond.cc:644:	this->setErrorThreshold(1.0);
energyNonbond.cc:645:	this->setDielectricConstant(80.0);
energyNonbond.cc:646:	this->setVdwScale(1.0);
energyNonbond.cc:647:	this->setElectrostaticScale(1.0);
energyNonbond.cc:654:	this->_Terms.push_back(term);
energyNonbond.cc:661:	this->Base::archiveBase(node);
energyNonbond.cc:675:	    if ( atomTable->getNumberOfAtoms() > 2 )
energyNonbond.cc:680:		for ( iea1 = atomTable->begin();
energyNonbond.cc:681:		      iea1 != atomTable->end()-1; iea1++ ) { //Was iea1 != atomTable->end()-1
energyNonbond.cc:682:		    for ( iea2 = iea1+1; iea2 != atomTable->end(); iea2++ ) { // Was iea2 != atomTable->end()
energyNonbond.cc:683:			if (!iea1->inBondOrAngle(iea2->atom())) 
energyNonbond.cc:685:			    bool in14 = iea1->relatedBy14(iea2->atom());
energyNonbond.cc:686:			    LOG(BF("Nonbonded interaction between %s - %s in14[%d]") % iea1->atom()->__repr__() % iea2->atom()->__repr__() % in14 );
energyNonbond.cc:689:							  &(*iea1),&(*iea2),this->sharedThis<EnergyNonbond_O>()) )  {
energyNonbond.cc:690:				this->addTerm(energyNonbond);
energyNonbond.cc:697:		LOG(BF("There are no non-bonds"));
energyStretch.cc:27:    this->_Atom1.reset();
energyStretch.cc:28:    this->_Atom2.reset();
energyStretch.cc:40:    node->attribute("kb",this->term.kb);
energyStretch.cc:41:    node->attribute("r0",this->term.r0);
energyStretch.cc:42:    node->attribute("I1",this->term.I1);
energyStretch.cc:43:    node->attribute("I2",this->term.I2);
energyStretch.cc:44:    node->archiveObject("a1",this->_Atom1);
energyStretch.cc:45:    node->archiveObject("a2",this->_Atom2);
energyStretch.cc:47:    node->attributeIfDefined("calcForce",this->_calcForce,this->_calcForce);
energyStretch.cc:48:    node->attributeIfDefined("calcDiagonalHessian",this->_calcDiagonalHessian,this->_calcDiagonalHessian);
energyStretch.cc:49:    node->attributeIfDefined("calcOffDiagonalHessian",this->_calcOffDiagonalHessian,this->_calcOffDiagonalHessian);
energyStretch.cc:57:	% this->term.kb
energyStretch.cc:58:	% this->term.r0  );
energyStretch.cc:59://    this->_K3 = stretch->_K3;
energyStretch.cc:60://    this->_K4 = stretch->_K4;
energyStretch.cc:61://    this->_Bci = stretch->_Bci;
energyStretch.cc:62:    this->_Atom1 = ea1->atom();
energyStretch.cc:63:    this->_Atom2 = ea2->atom();
energyStretch.cc:64:    LOG(BF(" Adding stretch between %s - %s")
energyStretch.cc:65:	% this->_Atom1->description() % this->_Atom2->description() );
energyStretch.cc:66:    this->term.I1 = ea1->coordinateIndexTimes3();
energyStretch.cc:67:    this->term.I2 = ea2->coordinateIndexTimes3();
energyStretch.cc:68:    this->term.kb = stretch->getKb_kCalPerAngstromSquared();
energyStretch.cc:69:    this->term.r0 = stretch->getR0_Angstrom();
energyStretch.cc:79:    node->addAttributeHex("address",(unsigned long)(this));
energyStretch.cc:80:    node->addAttributeString("atom1Name",this->_Atom1->getName());
energyStretch.cc:81:    node->addAttributeString("atom2Name",this->_Atom2->getName());
energyStretch.cc:82://    node->addAttributeInt("idx1",this->_Atom1->_CoordinateIndex);
energyStretch.cc:83://    node->addAttributeInt("idx2",this->_Atom2->_CoordinateIndex);
energyStretch.cc:84:    node->addAttributeInt("I1",this->term.I1);
energyStretch.cc:85:    node->addAttributeInt("I2",this->term.I2);
energyStretch.cc:86:    node->addAttributeDoubleScientific("r0",this->term.r0);
energyStretch.cc:87:    node->addAttributeDoubleScientific("kb",this->term.kb);
energyStretch.cc:90:    xml->addAttributeBool("calcForce",this->_calcForce );
energyStretch.cc:91:    xml->addAttributeBool("calcDiagonalHessian",this->_calcDiagonalHessian );
energyStretch.cc:92:    xml->addAttributeBool("calcOffDiagonalHessian",
energyStretch.cc:93:				this->_calcOffDiagonalHessian );
energyStretch.cc:99:    node->addChild(xml);
energyStretch.cc:108:    i1 = xml->getAttributeInt("idx1");
energyStretch.cc:109:    i2 = xml->getAttributeInt("idx2");
energyStretch.cc:111:    this->_Atom1 = atomTable->findEnergyAtomWithCoordinateIndex(i1)->atom();
energyStretch.cc:112:    this->_Atom2 = atomTable->findEnergyAtomWithCoordinateIndex(i2)->atom();
energyStretch.cc:114:    this->term.r0 = xml->getAttributeDouble("r0");
energyStretch.cc:115:    this->term.kb = xml->getAttributeDouble("kb");
energyStretch.cc:116:    this->term.I1 = xml->getAttributeInt("I1");
energyStretch.cc:117:    this->term.I2 = xml->getAttributeInt("I2");
energyStretch.cc:125:    pos1 = this->getAtom1()->getPosition();
energyStretch.cc:126:    pos2 = this->getAtom2()->getPosition();
energyStretch.cc:160:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:162:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:191:#define	STRETCH_SET_PARAMETER(x)	{x = si->term.x;}
energyStretch.cc:193:#define	STRETCH_SET_POSITION(x,ii,of)	{x = nvPosition->getElement(ii+of);}
energyStretch.cc:200:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyStretch.cc:204:	m->addToElement((i1)+(o1),(i2)+(o2),v);\
energyStretch.cc:210:    if ( this->isEnabled() ) {
energyStretch.cc:212:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:225://	stretchScale = this->getScale();
energyStretch.cc:226:	for ( vector<EnergyStretch>::iterator si=this->_Terms.begin();
energyStretch.cc:227:		    si!=this->_Terms.end(); si++ ) {
energyStretch.cc:246:    if ( this->_DebugEnergy ) 
energyStretch.cc:249:	LOG_ENERGY(BF("%s {\n")% this->className());
energyStretch.cc:258:bool	hasHdAndD = (hdvec.notnilp())&&(dvec->notNil());
energyStretch.cc:264:#define	STRETCH_SET_PARAMETER(x)	{x = si->term.x;}
energyStretch.cc:266:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos->getElement(ii+of);}
energyStretch.cc:268:#define	STRETCH_ENERGY_ACCUMULATE(e) this->_TotalEnergy += (e);
energyStretch.cc:276:    if ( this->isEnabled() ) 
energyStretch.cc:279:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:287:	for ( i=0,si=this->_Terms.begin();
energyStretch.cc:288:		    si!=this->_Terms.end(); si++,i++ ) {
energyStretch.cc:290:		if ( this->_Debug_NumberOfTermsToCalculate > 0 ) {
energyStretch.cc:291:		    if ( i>= this->_Debug_NumberOfTermsToCalculate ) {
energyStretch.cc:301:		si->_calcForce = calcForce;
energyStretch.cc:302:		si->_calcDiagonalHessian = calcDiagonalHessian;
energyStretch.cc:303:		si->_calcOffDiagonalHessian = calcOffDiagonalHessian;
energyStretch.cc:305:		#define EVAL_SET(var,val) {si->eval.var=val;}
energyStretch.cc:308:	    if ( this->_DebugEnergy ) {
energyStretch.cc:333:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx1>10000.0);
energyStretch.cc:334:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy1>10000.0);
energyStretch.cc:335:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz1>10000.0);
energyStretch.cc:336:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fx2>10000.0);
energyStretch.cc:337:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fy2>10000.0);
energyStretch.cc:338:	    _lisp->profiler().eventCounter(core::forcesGreaterThan10000).recordCallAndProblem(fz2>10000.0);
energyStretch.cc:341:    if ( this->_DebugEnergy ) 
energyStretch.cc:343:	LOG_ENERGY(BF("%s }")% this->className());
energyStretch.cc:365:#define	STRETCH_SET_PARAMETER(x)	{x = si->term.x;}
energyStretch.cc:367:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos->getElement(ii+of);}
energyStretch.cc:377:	if ( this->isEnabled() ) {
energyStretch.cc:380:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:387://	    stretchScale = this->getScale();
energyStretch.cc:389:	    for ( i=0,si=this->_Terms.begin();
energyStretch.cc:390:			si!=this->_Terms.end(); si++,i++ ) {
energyStretch.cc:418:    this->_BeyondThresholdTerms.clear();
energyStretch.cc:424:#define	STRETCH_SET_PARAMETER(x)	{x = si->term.x;}
energyStretch.cc:426:#define	STRETCH_SET_POSITION(x,ii,of)	{x = pos->getElement(ii+of);}
energyStretch.cc:436:	if ( this->isEnabled() ) {
energyStretch.cc:439:#pragma GCC diagnostic ignored "-Wunused-variable"
energyStretch.cc:446://	    stretchScale = this->getScale();
energyStretch.cc:448:	    for ( i=0,si=this->_Terms.begin();
energyStretch.cc:449:			si!=this->_Terms.end(); si++,i++ ) {
energyStretch.cc:454:		if ( fabs(StretchDeviation)/r0 > this->_ErrorThreshold ) {
energyStretch.cc:460:		    info<<"threshold " << this->_ErrorThreshold << " Atoms(";
energyStretch.cc:461:		    info << a1->getName() << " ";
energyStretch.cc:462:		    info << a2->getName() << ")";
energyStretch.cc:464:		    this->_BeyondThresholdTerms.push_back(*si);
energyStretch.cc:482:    for ( idx = 0, esi=this->_Terms.begin(); esi!=this->_Terms.end(); esi++, idx++ )
energyStretch.cc:484:	as1 = atomLabel(esi->_Atom1);
energyStretch.cc:485:	as2 = atomLabel(esi->_Atom2);
energyStretch.cc:493:	_lisp->print(BF("TERM 1BND %-9s - %-9s %8.2lf %8.2lf") 
energyStretch.cc:496:			    % esi->term.kb
energyStretch.cc:497:			    % esi->term.r0 );
energyStretch.cc:498:	LOG(BF("TERM[#%d] 1BND %-9s - %-9s %8.2lf %8.2lf ; I1=%d I2=%d")
energyStretch.cc:502:	    % esi->term.kb
energyStretch.cc:503:	    % esi->term.r0
energyStretch.cc:504:	    % esi->term.I1
energyStretch.cc:505:	    % esi->term.I2 );
energyStretch.cc:531:    this->Base::initialize();
energyStretch.cc:532:    this->setErrorThreshold(0.05);
energyStretch.cc:538:    this->Base::archiveBase(node);
energyStretch.cc:546:    this->_Terms.push_back(term);
entity.cc:23:    this->Base::initialize();
entity.cc:41:    this->Base::archiveBase(node);
entity.cc:56:	if (this->isNil()) ss << "[" << this->className()<<"-nil-]";
entity.cc:57:	else ss << "[" << this->className() << "/name=" << this->getName()->__repr__() << "]";
entity.cc:65:	SHOUT(BF("Generating minimalRepresentativeList of: %s") % this->__repr__() );
entity.cc:66:	RepresentativeList_sp expandedList = this->expandedRepresentativeList();
entity.cc:67:	SHOUT(BF("   after expandedRepresentativeList: %s") % expandedList->__repr__() );
entity.cc:68:	core::Binder_sp binder = _lisp->create<core::Binder_O>();
entity.cc:69:	for ( RepresentativeList_O::iterator it = expandedList->begin(); it != expandedList->end(); it++ )
entity.cc:71:	    RepresentedEntityNameSet_sp curNameSet = (*it)->as<RepresentedEntityNameSet_O>();
entity.cc:72:	    core::Symbol_sp representor = curNameSet->getRepresentative();
entity.cc:74:	    core::Binder_O::iterator bi = binder->find(representor);
entity.cc:75:	    if ( bi != binder->end() )
entity.cc:77:		minimalRepresentedEntityNameSet = binder->indexed_value(bi->second)->as<RepresentedEntityNameSet_O>();
entity.cc:78:		minimalRepresentedEntityNameSet->mergeEntityNames(curNameSet);
entity.cc:82:		minimalRepresentedEntityNameSet->expandToTerminalEntityNames();
entity.cc:83:		binder->extend(representor,minimalRepresentedEntityNameSet);
entity.cc:86:	RepresentativeList_sp minimalList = _lisp->create<RepresentativeList_O>();
entity.cc:87:	for ( core::Binder_O::const_iterator ei = binder->begin(); ei!=binder->end(); ei++ )
entity.cc:89:	    minimalList->append(binder->indexed_value(ei->second));
entity.cc:91:	SHOUT(BF("    resulting minimalRepresentativeList of: %s") % minimalList->__repr__() );
entityNameSet.cc:26:#define	IN_CHAR		"-"
entityNameSet.cc:42:	rec->setMonomerNameOrPdb(nm);
entityNameSet.cc:52:	this->Base::initialize();
entityNameSet.cc:53:	this->_EntityNames = core::SymbolSet_O::create();
entityNameSet.cc:54:	this->_Optional = false;
entityNameSet.cc:59:	return this->_EntityNames;
entityNameSet.cc:72:	core::SymbolSet_sp entityNames = _lisp->create<core::SymbolSet_O>();
entityNameSet.cc:73:	entityNames->insertConsSymbols(entityNamesCons);
entityNameSet.cc:74:	me->_EntityNames = entityNames;
entityNameSet.cc:83:	core::Cons_sp entityNamesCons = translate::from_object<core::Cons_O>::convert(environ->lookup(Pkg(),"entityNames"));
entityNameSet.cc:86:	    core::SymbolSet_sp entityNames = _lisp->create<core::SymbolSet_O>();
entityNameSet.cc:87:	    entityNames->insertConsSymbols(entityNamesCons);
entityNameSet.cc:88:	    this->_EntityNames = entityNames;
entityNameSet.cc:100:	ss << " contains:(" << this->_EntityNames->asString() << ")";
entityNameSet.cc:106:	this->_Optional = emr._Optional;
entityNameSet.cc:107:	this->_EntityNames = RP_Copy<core::SymbolSet_O>(emr._EntityNames);
entityNameSet.cc:122:	SIMPLE_ERROR(BF("Subclass must implement for alias: "+alias->__repr__()));
entityNameSet.cc:128:	this->CandoDatabase_ODependent::setCandoDatabase(bdb);
entityNameSet.cc:145:	for ( ni=this->_EntityNames->begin(); ni!=this->_EntityNames->end(); ni++ )
entityNameSet.cc:147:	    Entity_sp entity = bdb->getEntity(*ni);
entityNameSet.cc:148:	    names = entity->expandedNameSet();
entityNameSet.cc:149:	    allNames->insertSymbolSet(names);
entityNameSet.cc:158:	core::SymbolSet_sp expandedEntityNames = this->expandedNameSet();
entityNameSet.cc:159:	this->_EntityNames = expandedEntityNames;
entityNameSet.cc:165:	core::SymbolSet_sp myExpanded = this->expandedNameSet();
entityNameSet.cc:167:	for ( core::SymbolSet_O::iterator it=entityNames->begin();
entityNameSet.cc:168:	      it!=entityNames->end(); it++ )
entityNameSet.cc:171:	    EntityNameSetBase_sp other = cdb->getEntity(otherName)->as<EntityNameSetBase_O>();
entityNameSet.cc:172:	    core::SymbolSet_sp otherExpanded = other->expandedNameSet();
entityNameSet.cc:173:	    if ( myExpanded->containsSubset(otherExpanded) )
entityNameSet.cc:175:		myExpanded = myExpanded->relativeComplement(otherExpanded);
entityNameSet.cc:176:		myExpanded->insert(otherName);
entityNameSet.cc:179:	this->_EntityNames = myExpanded;
entityNameSet.cc:185:	core::SymbolSet_sp os = other->expandedNameSet();
entityNameSet.cc:186:	this->_EntityNames->insertSymbolSet(os);
entityNameSet.cc:197:	allRepresentatives = _lisp->create<RepresentativeList_O>();
entityNameSet.cc:199:	for ( ni=this->_EntityNames->begin(); ni!=this->_EntityNames->end(); ni++ )
entityNameSet.cc:201:	    ASSERT(bdb->recognizesEntityName(*ni));
entityNameSet.cc:202:	    Entity_sp entity = bdb->getEntity(*ni);
entityNameSet.cc:203:	    RepresentativeList_sp objs = entity->expandedRepresentativeList();
entityNameSet.cc:204:	    LOG(BF("Expanded representative list for entity[%s] is: %s") % entity->__repr__()
entityNameSet.cc:205:		% objs->__repr__() );
entityNameSet.cc:206:	    allRepresentatives->extend(objs);
entityNameSet.cc:220:	ASSERTNOTNULL(this->_EntityNames);
entityNameSet.cc:222:	for ( si=ss->begin(); si!=ss->end(); si++ )
entityNameSet.cc:224:	    if ( !bdb->recognizesMonomerName(*si) )
entityNameSet.cc:226:		this->_StatusTracker->addError("Tried to add unknown monomer name: "+*si);
entityNameSet.cc:228:		this->_EntityNames->insert(*si);
entityNameSet.cc:241:	ASSERTNOTNULL(this->_EntityNames);
entityNameSet.cc:242:	if ( this->recognizesMonomerName(nm) ) return;
entityNameSet.cc:244:	if ( !bdb->recognizesEntityName(nm) )
entityNameSet.cc:246:	    SIMPLE_ERROR(BF("Unknown monomer name: "+nm->__repr__()));
entityNameSet.cc:248:	this->_EntityNames->insert(nm);
entityNameSet.cc:254:	this->_EntityNames = s;
entityNameSet.cc:260:	ASSERTNOTNULL(this->_EntityNames);
entityNameSet.cc:261:	this->_EntityNames->insert(nm);
entityNameSet.cc:266:	this->_EntityNames->clear();
entityNameSet.cc:272:	ASSERTNOTNULL(this->_EntityNames);
entityNameSet.cc:273:	if ( !this->recognizesMonomerName(nm) ) return;
entityNameSet.cc:274:	this->_EntityNames->remove(nm);
entityNameSet.cc:282:	s1 = this->getMonomerNames();
entityNameSet.cc:283:	s2 = e->getMonomerNames();
entityNameSet.cc:285:	s3 = s1->cartesianProductInsert(ins,s2);
entityNameSet.cc:301:	expanded = this->expandedNameSet();
entityNameSet.cc:302:	ASSERTF(expanded->size()>0,
entityNameSet.cc:304:		   " %s but it is completely empty")% this->description() );
entityNameSet.cc:305:	for ( si=expanded->begin(); si!=expanded->end();si++ ) {
entityNameSet.cc:306:	    keys.insert((*si)->identifierName());
entityNameSet.cc:328:	names = this->expandedNameSet();
entityNameSet.cc:335:	names = this->expandedNameSet();
entityNameSet.cc:336:	return names->asString();
entityNameSet.cc:337:// OLD   return this->_MonomerNames->asString();
entityNameSet.cc:343:	names = this->expandedNameSet();
entityNameSet.cc:344:	if ( names->size() != 1 ) {
entityNameSet.cc:347:	return names->first();
entityNameSet.cc:357://    this->setName(mn);
entityNameSet.cc:359:	if ( getCandoDatabase(_lisp)->recognizesNameOrPdb(mn) ) {
entityNameSet.cc:362:	    core::Symbol_sp full = db->getMonomerNameForNameOrPdb(mn);
entityNameSet.cc:363:	    this->_EntityNames->clear();
entityNameSet.cc:364:	    this->_EntityNames->insert(full);
entityNameSet.cc:365:	    LOG(BF("Added monomer name(%s) to EntityNameSetBase") % mn->__repr__()  );
entityNameSet.cc:370:		 << mn->__repr__();
entityNameSet.cc:384:	names = this->expandedNameSet();
entityNameSet.cc:385:	return names->contains(nm);
entityNameSet.cc:398:	ASSERT(bdb->recognizesNameOrPdb(nm));
entityNameSet.cc:399:	core::Symbol_sp name = bdb->getMonomerNameForNameOrPdb(nm);
entityNameSet.cc:400:	core::SymbolSet_sp names = this->expandedNameSet();
entityNameSet.cc:401:	return names->contains(name);
entityNameSet.cc:409:	this->Base::archiveBase(node);
entityNameSet.cc:410:	node->archiveObjectIfDefined("names",this->_EntityNames);
entityNameSet.cc:411:	node->attributeIfNotDefault("optional",this->_Optional,false);
entityNameSet.cc:424:	allNames = bdb->allMonomerNamesOrdered();
entityNameSet.cc:426:	for(sli=allNames->begin();sli!=allNames->end();sli++ )
entityNameSet.cc:428:	    if ( !this->_MonomerNames->contains(*sli) )
entityNameSet.cc:430:		res->append(*sli);
entityNameSet.cc:452:	allNames = bdb->allMonomerNamesOrdered();
entityNameSet.cc:454:	for(sli=allNames->begin();sli!=allNames->end();sli++ )
entityNameSet.cc:456:	    if ( this->_MonomerNames->contains(*sli) )
entityNameSet.cc:458:		res->append(*sli);
entityNameSet.cc:472:	rec->setMonomerNameOrPdb(nm);
entityNameSet.cc:482:	this->Base::initialize();
entityNameSet.cc:483:	this->_Name = _lisp->intern("undefinedEntityNameSetName");
entityNameSet.cc:494:    me->_Name = name;
entityNameSet.cc:502:	this->Base::__init__(exec,args,env,lisp);
entityNameSet.cc:503:	this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"name"));
entityNameSet.cc:511:	this->_Name = emr._Name;
entityNameSet.cc:519:	ss << "EntityNameSet("<<this->_Name<<")@" << std::hex << this;
entityNameSet.cc:520:	ss << " contains:(" << this->_EntityNames->asString() << ")";
entityNameSet.cc:528:	this->Base::archiveBase(node);
entityNameSet.cc:529:	node->attributeSymbolIfNotNil("name",this->_Name);
entityNameSet.cc:547:	this->Base::initialize();
entityNameSet.cc:559:	this->Base::archiveBase(node);
entityNameSet.cc:567:	ss << this->className() << "[" << this->getName()->__repr__() << "]";
entityNameSet.cc:575:	this->addMonomerName(nm);
externalInterface.cc:34:	this->Base::initialize();
externalInterface.cc:35:	this->_Data = _lisp->create<addon::ObjectDictionary_O>();
externalInterface.cc:36:	this->_AtomNames = core::StringList_O::create();
externalInterface.cc:37:	this->_WeakConformationExplorer = ConformationExplorer_O::_nil;
externalInterface.cc:52:    me->_WeakConformationExplorer = conformationExplorer;
externalInterface.cc:53:    me->_StageName = stageName;
externalInterface.cc:61:	this->_WeakConformationExplorer = translate::from_object<ConformationExplorer_O>::convert(env->lookup(Pkg(),"conformationExplorer"));
externalInterface.cc:62:	this->_StageName = translate::from_object<core::Str_O>::convert(env->lookup(Pkg(),"stageName"))->get();
externalInterface.cc:72:	if ( node->saving() )
externalInterface.cc:74:	    ASSERTNOTNULLP(this->_WeakConformationExplorer,"WeakConformationExplorer is NULL");
externalInterface.cc:77:	node->archiveWeakPointer("WeakConformationExplorer",this->_WeakConformationExplorer);
externalInterface.cc:78:	node->attribute("StageName",this->_StageName);
externalInterface.cc:79:	node->archiveString("ExternalScript",this->_ExternalScript);
externalInterface.cc:80:	node->archiveMap("ScriptSubstitutions",this->_ScriptSubstitutions);
externalInterface.cc:81:	node->archiveObject("Data",this->_Data);
externalInterface.cc:82:	node->attribute("Directory",this->_Directory);
externalInterface.cc:83:	node->attribute("FileNamePrefix",this->_FileNamePrefix);
externalInterface.cc:84:	node->archiveObject("AtomNames", this->_AtomNames);
externalInterface.cc:85:	node->archiveMap("AtomNamesToAtoms",this->_AtomNamesToAtoms);
externalInterface.cc:97:	this->_WeakConformationExplorer = explorer->sharedThis<ConformationExplorer_O>();
externalInterface.cc:98:	ASSERTNOTNULL(this->_WeakConformationExplorer);
externalInterface.cc:111:	fnStream << this->_Directory << "/";
externalInterface.cc:112:	fnStream << this->_FileNamePrefix
externalInterface.cc:113:		 << "_" << this->externalInterfaceName() << "_"
externalInterface.cc:132:	fnStream << this->_Directory << "/";
externalInterface.cc:133:	fnStream << this->_FileNamePrefix
externalInterface.cc:134:		 << "_" << this->externalInterfaceName() << "_"
externalInterface.cc:149:	entry = stage->getConformationExplorerEntry();
externalInterface.cc:150:	explorer = stage->getConformationExplorer();
externalInterface.cc:151:	index = explorer->getEntryIndex(entry);
externalInterface.cc:152:	stageName = stage->getStageName();
externalInterface.cc:154:	return this->_assembleFileName(index,stageName,ext);
externalInterface.cc:163:	entry = stage->getConformationExplorerEntry();
externalInterface.cc:164:	explorer = stage->getConformationExplorer();
externalInterface.cc:165:	index = explorer->getEntryIndex(entry);
externalInterface.cc:166:	stageName = stage->getStageName();
externalInterface.cc:168:	return this->_assembleFilePath(index,stageName,ext);
externalInterface.cc:182:	fileName = this->assembleFileName(entryStage,this->summaryFileExtension());
externalInterface.cc:184:	explorer = entryStage->getConformationExplorer();
externalInterface.cc:206:		if ( this->_AtomNamesToAtoms.contains(atomName) )
externalInterface.cc:208:		    atom = this->_AtomNamesToAtoms.get(atomName);
externalInterface.cc:209:		    entryStage->setCoordinateForAtom(atom,pos);
externalInterface.cc:219:		entryStage->setEnergyKCal(hartrees*627.5095);
externalInterface.cc:222:	if ( numCoordsRead != explorer->numberOfAllAtoms() )
ffAngleDb.cc:36:    node->attribute("type1",this->_Type1);
ffAngleDb.cc:37:    node->attribute("type2",this->_Type2);
ffAngleDb.cc:38:    node->attribute("type3",this->_Type3);
ffAngleDb.cc:39:    node->attribute("angRad", this->_AngRad);
ffAngleDb.cc:40:    node->attribute("k2",this->_K2__kJPerRadianSquared);
ffAngleDb.cc:48:    this->FFBaseDb_O::archive(node);
ffAngleDb.cc:49:    node->attribute("angleFunction",this->_AngleFunction);
ffAngleDb.cc:50:    node->archiveObjectVector("angles","Angles",this->_Terms );
ffAngleDb.cc:51:    node->archiveMap<FFAngle_O>("map",this->_Lookup );
ffAngleDb.cc:52:    node->archiveMap("zConstants",this->_ZConstants);
ffAngleDb.cc:53:    node->archiveMap("cConstants",this->_CConstants);
ffAngleDb.cc:63:    node->addAttributeString("Type1",this->_Type1 );
ffAngleDb.cc:64:    node->addAttributeString("Type2",this->_Type2 );
ffAngleDb.cc:65:    node->addAttributeString("Type3",this->_Type3 );
ffAngleDb.cc:66:    node->addAttributeDoubleScientific("AngRad",this->_AngRad);
ffAngleDb.cc:67:    node->addAttributeDoubleScientific("K2",this->_K2);
ffAngleDb.cc:73:    this->_Type1 = node->getAttributeString("Type1");
ffAngleDb.cc:74:    this->_Type2 = node->getAttributeString("Type2");
ffAngleDb.cc:75:    this->_Type3 = node->getAttributeString("Type3");
ffAngleDb.cc:76:    this->_AngRad = node->getAttributeDouble("AngRad");
ffAngleDb.cc:77:    this->_K2 = node->getAttributeDouble("K2");
ffAngleDb.cc:86:    this->Base::initialize();
ffAngleDb.cc:87:    this->_Terms.clear();
ffAngleDb.cc:88:    this->_Lookup.clear();
ffAngleDb.cc:89:    this->_ZConstants.clear();
ffAngleDb.cc:90:    this->_CConstants.clear();
ffAngleDb.cc:98:    this->_K2__kJPerRadianSquared = kCalPerRadianSquared_to_kJPerRadianSquared(val);
ffAngleDb.cc:104:    this->_K2__kJPerRadianSquared = val;
ffAngleDb.cc:110:    return kJPerRadianSquared_to_kCalPerRadianSquared(this->_K2__kJPerRadianSquared);
ffAngleDb.cc:116:    return this->_K2__kJPerRadianSquared;
ffAngleDb.cc:127:#define angleKey(t1,t2,t3) t1+"-"+t2+"-"+t3
ffAngleDb.cc:132:    this->_Terms.push_back(ang);
ffAngleDb.cc:133:    key = angleKey(ang->_Type1,ang->_Type2,ang->_Type3);
ffAngleDb.cc:134:    this->_Lookup.set(key,ang);
ffAngleDb.cc:135:    key = angleKey(ang->_Type3,ang->_Type2,ang->_Type1);
ffAngleDb.cc:136:    this->_Lookup.set(key,ang);
ffAngleDb.cc:145:    t1 = a1->getTypeString();
ffAngleDb.cc:146:    t2 = a2->getTypeString();
ffAngleDb.cc:147:    t3 = a3->getTypeString();
ffAngleDb.cc:149:    if ( this->_Lookup.count(key) != 0 ) {
ffAngleDb.cc:150:        return this->_Lookup.get(key);
ffAngleDb.cc:153:    if ( this->_Lookup.count(key) != 0 ) {
ffAngleDb.cc:154:        return this->_Lookup.get(key);
ffAngleDb.cc:161:    match = this->estimateTerm(a1,a2,a3);
ffAngleDb.cc:172:    if ( this->_Lookup.count(key) != 0 ) {
ffAngleDb.cc:176:    if ( this->_Lookup.count(key) != 0 ) {
ffAngleDb.cc:186:    ss << "PARAMETER_PROBLEM Can't find angle term for ("<<t1<<")-("<<t2<<")-("<<t3<<")";
ffAngleDb.cc:187:    ss << " atoms("<<a1->description()<<") - (" << a2->description()<<")";
ffAngleDb.cc:197:    this->Base::initialize();
ffAngleDb.cc:198:    this->_Type1 = "";
ffAngleDb.cc:199:    this->_Type2 = "";
ffAngleDb.cc:200:    this->_Type3 = "";
ffAngleDb.cc:201:    this->_AngRad = 0.0;
ffAngleDb.cc:202:    this->_K2__kJPerRadianSquared = 0.0;
ffAngleDb.cc:203://    this->_K3 = 0.0;
ffAngleDb.cc:204://    this->_K4 = 0.0;
ffAngleDb.cc:205://    this->_Ub_k = 0.0;
ffAngleDb.cc:206://    this->_Ub_len = 0.0;
ffAngleDb.cc:211:/*! Estimate the angle term according to Wang et al. J. Comput. Chem 25, 1157-1174 (2004) */
ffAngleDb.cc:222:    ASSERTNOTNULL(this->_ForceField);
ffAngleDb.cc:223:    ff = this->_ForceField.lock();
ffAngleDb.cc:225:    t1 = a1->getTypeString();
ffAngleDb.cc:226:    t2 = a2->getTypeString();
ffAngleDb.cc:227:    t3 = a3->getTypeString();
ffAngleDb.cc:234:    ff_121 = ff->_Angles->findTerm(a1,a2,a1);
ffAngleDb.cc:235:    ff_323 = ff->_Angles->findTerm(a3,a2,a3);
ffAngleDb.cc:237:    if ( ff_121->isNil() ) goto GUESS;
ffAngleDb.cc:239:    if ( ff_323->isNil() ) goto GUESS;
ffAngleDb.cc:241:    angRad = (ff_121->_AngRad + ff_323->_AngRad)/2.0;
ffAngleDb.cc:242:    element1 = a1->getElement();
ffAngleDb.cc:243:    element2 = a2->getElement();
ffAngleDb.cc:244:    element3 = a3->getElement();
ffAngleDb.cc:246:    if ( ff->_Angles->_ZConstants.count(element1) == 0 ) goto GUESS;
ffAngleDb.cc:248:    if ( ff->_Angles->_CConstants.count(element2) == 0 ) goto GUESS;
ffAngleDb.cc:250:    if ( ff->_Angles->_ZConstants.count(element3) == 0 ) goto GUESS;
ffAngleDb.cc:252:    z1 = ff->_Angles->_ZConstants.get(element1)->get();
ffAngleDb.cc:253:    c2 = ff->_Angles->_CConstants.get(element2)->get();
ffAngleDb.cc:254:    z3 = ff->_Angles->_ZConstants.get(element3)->get();
ffAngleDb.cc:255:    r12 = ff->_Stretches->findTerm(a1,a2);
ffAngleDb.cc:256:    r32 = ff->_Stretches->findTerm(a3,a2);
ffAngleDb.cc:258:    if ( r12->isNil() ) goto GUESS;
ffAngleDb.cc:260:    if ( r32->isNil() ) goto GUESS;
ffAngleDb.cc:262:    d = (r12->getR0_Angstrom()-r32->getR0_Angstrom())/(r12->getR0_Angstrom()+r32->getR0_Angstrom());
ffAngleDb.cc:264:    k = 143.9*z1*c2*z3*(1.0/((r12->getR0_Angstrom()+r32->getR0_Angstrom())*(angRad*angRad)))*exp(-2.0*d);
ffAngleDb.cc:265:    angle = _lisp->create<FFAngle_O>();
ffAngleDb.cc:266:    angle->_Level = estimated;
ffAngleDb.cc:267:    angle->_Type1 = t1;
ffAngleDb.cc:268:    angle->_Type2 = t2;
ffAngleDb.cc:269:    angle->_Type3 = t3;
ffAngleDb.cc:270:    angle->_AngRad = angRad;
ffAngleDb.cc:271:    angle->setK2_kCalPerRadianSquared(k);
ffAngleDb.cc:274:    angle = _lisp->create<FFAngle_O>();
ffAngleDb.cc:275:    angle->_Level = rough;
ffAngleDb.cc:276:    angle->_Type1 = t1;
ffAngleDb.cc:277:    angle->_Type2 = t2;
ffAngleDb.cc:278:    angle->_Type3 = t3;
ffAngleDb.cc:279:    if ( a2->getHybridization() == hybridization_sp3 ) {
ffAngleDb.cc:280:	angle->_AngRad = 109.5*0.0174533;
ffAngleDb.cc:281:    } else if ( a2->getHybridization() == hybridization_sp2 ) {
ffAngleDb.cc:282:	angle->_AngRad = 120.0*0.0174533;
ffAngleDb.cc:283:    } else if ( a2->getHybridization() == hybridization_sp ) {
ffAngleDb.cc:284:	angle->_AngRad = 180.0*0.0174533;
ffAngleDb.cc:286:	LOG(BF("Unknown hybridization(%s) for: %s") % a2->getHybridization().c_str() % a2->description().c_str() );
ffAngleDb.cc:287:	angle->_AngRad = 109.5*0.0174533;
ffAngleDb.cc:290:    if ( a1->getElement() == element_H && a3->getElement() == element_H ) {
ffAngleDb.cc:291:	angle->_K2__kJPerRadianSquared = kCalPerRadianSquared_to_kJPerRadianSquared(32.5);
ffAngleDb.cc:292:    } else if ( a1->getElement() == element_H || a3->getElement() == element_H ) {
ffAngleDb.cc:293:	angle->_K2__kJPerRadianSquared = kCalPerRadianSquared_to_kJPerRadianSquared(50.0);
ffAngleDb.cc:295:	angle->_K2__kJPerRadianSquared = kCalPerRadianSquared_to_kJPerRadianSquared(70.0);
ffAngleDb.cc:304:    desc << this->FFParameter_O::levelDescription();
ffAngleDb.cc:305:    desc << " angle between types "<<this->_Type1<< " "
ffAngleDb.cc:306:		<< this->_Type2 << " "
ffAngleDb.cc:307:		<< this->_Type3;
ffBaseDb.cc:28:    switch ( this->_Level ) {
ffBaseDb.cc:44:	{ "", -1 }
ffBaseDb.cc:50:    node->attributeEnum( "level", this->_Level, paramLevelEnum );
ffBaseDb.cc:58:    node->archiveWeakPointer( "forceField", this->_ForceField );
ffBaseDb.cc:66:    this->_ForceField = ff;
ffItorDb.cc:31:    this->Base::initialize();
ffItorDb.cc:33:    this->_T1 = "";
ffItorDb.cc:34:    this->_T2 = "";
ffItorDb.cc:35:    this->_T3 = "";
ffItorDb.cc:36:    this->_T4 = "";
ffItorDb.cc:39:	this->_hasPeriodicity[i] = false;
ffItorDb.cc:40:	this->_Vs_kJ[i] = 0.0;
ffItorDb.cc:41:	this->_PhaseRads[i] = 0.0;
ffItorDb.cc:48:    node->attribute( "type1", this->_T1 );
ffItorDb.cc:49:    node->attribute( "type2", this->_T2 );
ffItorDb.cc:50:    node->attribute( "type3", this->_T3 );
ffItorDb.cc:51:    node->attribute( "type4", this->_T4 );
ffItorDb.cc:54:	node->attributeIfDefined ( (BF("v%d")%i).str(), this->_Vs_kJ[i], this->_hasPeriodicity[i]);
ffItorDb.cc:55:	node->attributeIfDefined ( (BF("ph%d")%i).str(), this->_PhaseRads[i], this->_hasPeriodicity[i]);
ffItorDb.cc:64:    this->FFBaseDb_O::archiveBase(node);
ffItorDb.cc:65:    node->archiveObjectVector<FFItor_O>("ptors","Itors",this->_Terms );
ffItorDb.cc:66:    node->archiveMap<FFItor_O>("map",this->_Lookup );
ffItorDb.cc:76:    this->_T1 = t1;
ffItorDb.cc:77:    this->_T2 = t2;
ffItorDb.cc:78:    this->_T3 = t3;
ffItorDb.cc:79:    this->_T4 = t4;
ffItorDb.cc:88:    return this->_Vs_kJ[period-1];
ffItorDb.cc:96:    this->_Vs_kJ[period-1] = val;
ffItorDb.cc:97:    this->_hasPeriodicity[period-1] = true;
ffItorDb.cc:105:    return this->_hasPeriodicity[period-1];
ffItorDb.cc:111:    return kJ_to_kCal(this->getV_kJ(period));
ffItorDb.cc:116:    this->setV_kJ(period,kCal_to_kJ(val));
ffItorDb.cc:125:    return this->_PhaseRads[period-1];
ffItorDb.cc:133:    this->_PhaseRads[period-1] = val;
ffItorDb.cc:134:    this->_hasPeriodicity[period-1] = true;
ffItorDb.cc:142:        if ( itor->hasPeriodicity(i))
ffItorDb.cc:144:	    this->_hasPeriodicity[i-1] = itor->_hasPeriodicity[i-1];
ffItorDb.cc:145:            this->_Vs_kJ[i-1] = itor->_Vs_kJ[i-1];
ffItorDb.cc:146:            this->_PhaseRads[i-1] = itor->_PhaseRads[i-1];
ffItorDb.cc:151:#define keyString(t1,t2,t3,t4) (t1+"-"+t2+"-"+t3+"-"+t4)
ffItorDb.cc:165:    if (this->hasExactTerm(itor->_T1,itor->_T2,itor->_T3,itor->_T4) ){
ffItorDb.cc:166:        itorOld = this->findExactTerm(itor->_T1,itor->_T2,itor->_T3,itor->_T4);
ffItorDb.cc:167:        itorOld->mergeWith(itor);
ffItorDb.cc:169:        this->_Terms.push_back(itor);
ffItorDb.cc:170:        key = keyString(itor->_T1,itor->_T2,itor->_T3,itor->_T4);
ffItorDb.cc:172:	if ( itor->_T3=="c" && itor->_T4=="o" ) {
ffItorDb.cc:176:        this->_Lookup.set(key,itor);
ffItorDb.cc:185:    if ( this->_Lookup.count(key)!=0 ) return true;
ffItorDb.cc:194:    if ( this->_Lookup.count(key)!=0 ) {
ffItorDb.cc:195:        return this->_Lookup.get(key);
ffItorDb.cc:206:    if ( this->_Lookup.count(key4)!=0 ) {
ffItorDb.cc:207:        itor = this->_Lookup.get(key4);
ffItorDb.cc:213:    if ( this->_Lookup.count(key3)!=0 ) {
ffItorDb.cc:214:        itor = this->_Lookup.get(key3);
ffItorDb.cc:219:    if ( this->_Lookup.count(key2)!=0 ) {
ffItorDb.cc:220:        itor = this->_Lookup.get(key2);
ffItorDb.cc:225:    if ( this->_Lookup.count(key1)!=0 ) {
ffItorDb.cc:226:        itor = this->_Lookup.get(key1);
ffItorDb.cc:234:	LOG(BF("FFITorDb::findBestTerm for types %s-%s-%s-%s") % t1.c_str() % t2.c_str() % t3.c_str() % t4.c_str()  );
ffItorDb.cc:244:	        for ( map<string,FFItor_sp>::iterator ii=this->_Lookup.begin();
ffItorDb.cc:245:				ii!=this->_Lookup.end();ii++ ) {
ffItorDb.cc:246:		    LOG(BF("Entry key=%s") % ii->first.c_str()  );
ffItorDb.cc:260:    itor = this->findBestTerm(t1,t2,t3,t4);
ffItorDb.cc:268:    ss << "Can't find itor term for ("<<t1<<")-("<<t2<<")-("<<t3<<")-("<<t4<<")";
ffItorDb.cc:277:    desc << this->FFParameter_O::levelDescription();
ffItorDb.cc:278:    desc << " itor between types "<<this->_T1<< " "
ffItorDb.cc:279:		<< this->_T2 << " "
ffItorDb.cc:280:		<< this->_T3 << " "
ffItorDb.cc:281:		<< this->_T4;
ffNonbondDb.cc:45:    uint numberOfTypes = db->numberOfTypes();
ffNonbondDb.cc:46:    this->_NumberOfTypes = numberOfTypes;
ffNonbondDb.cc:54:	    FFNonbond_sp ffNonbond1 = db->getFFNonbondUsingTypeIndex(it1);
ffNonbondDb.cc:55:	    FFNonbond_sp ffNonbond2 = db->getFFNonbondUsingTypeIndex(it2);
ffNonbondDb.cc:56:	    term._RStar = ffNonbond1->getRadius_Angstroms() + ffNonbond2->getRadius_Angstroms();
ffNonbondDb.cc:57:	    double epsilonij = sqrt(ffNonbond1->getEpsilon_kCal()*ffNonbond2->getEpsilon_kCal());
ffNonbondDb.cc:60:	    this->_CrossTerms.push_back(term);
ffNonbondDb.cc:67:    ASSERT_lt(typeIndex,this->_NumberOfTypes);
ffNonbondDb.cc:68:    return typeIndex*this->_NumberOfTypes;
ffNonbondDb.cc:73:    ASSERT_lt(type1,this->_NumberOfTypes);
ffNonbondDb.cc:74:    ASSERT_lt(type2,this->_NumberOfTypes);
ffNonbondDb.cc:75:    uint idx = type1*this->_NumberOfTypes + type2;
ffNonbondDb.cc:76:    ASSERT_lt(idx,this->_CrossTerms.size());
ffNonbondDb.cc:77:    return this->_CrossTerms[idx];
ffNonbondDb.cc:82:    ASSERT_lt(idx,this->_CrossTerms.size());
ffNonbondDb.cc:83:    return this->_CrossTerms[idx];
ffNonbondDb.cc:88:    ASSERT_lt(type1,this->_NumberOfTypes);
ffNonbondDb.cc:89:    ASSERT_lt(type2,this->_NumberOfTypes);
ffNonbondDb.cc:90:    uint idx = type1*this->_NumberOfTypes + type2;
ffNonbondDb.cc:144:    this->Base::initialize();
ffNonbondDb.cc:145:    this->_Terms.clear();
ffNonbondDb.cc:146:    this->_Lookup.clear();
ffNonbondDb.cc:147:    this->_EleDielectricValue = 0.0;
ffNonbondDb.cc:148:    this->_EleBuffer = 0.0;
ffNonbondDb.cc:149:    this->_EleScale14 = 0.0;
ffNonbondDb.cc:150:    this->_EleChargeFcn = "";
ffNonbondDb.cc:151:    this->_VdwScale14 = 0.0;
ffNonbondDb.cc:152:    this->_VdwScaleBufferA = 0.0;
ffNonbondDb.cc:153:    this->_VdwScaleBufferB = 0.0;
ffNonbondDb.cc:154:    this->_EleDielectricCode = edConstant;
ffNonbondDb.cc:155:    this->_VdwMixRadius = vmrAverage;
ffNonbondDb.cc:156:    this->_VdwMixWell = vmwAverage;
ffNonbondDb.cc:163:	{ "", -1 }
ffNonbondDb.cc:169:    node->attribute("type",this->_Type );
ffNonbondDb.cc:170:    node->attribute("radius",this->_Radius_Nanometers);
ffNonbondDb.cc:171:    node->attribute("well",this->_Epsilon_kJ);
ffNonbondDb.cc:172:    node->attributeIfNotDefault("apol",this->_Apol,0.0);
ffNonbondDb.cc:173:    node->attributeIfNotDefault("neff",this->_Neff,0.0);
ffNonbondDb.cc:174:    node->attribute("mass",this->_Mass);
ffNonbondDb.cc:175:    node->attributeIfNotDefault("pol",this->_Polarizability,0.0);
ffNonbondDb.cc:176:    node->attributeIfNotDefault("initCharge",this->_InitialCharge,0.0);
ffNonbondDb.cc:177:    node->attributeIfNotDefault("fcadj",this->_Fcadj,0.0);
ffNonbondDb.cc:178:    node->attributeIfNotDefault("pbci",this->_Pbci,0.0);
ffNonbondDb.cc:179:    node->attributeEnum("da",this->_DonorAcceptor,daEnum );
ffNonbondDb.cc:186: { "", -1 }
ffNonbondDb.cc:193: { "", -1 }
ffNonbondDb.cc:199: { "", -1 }
ffNonbondDb.cc:205:    this->FFBaseDb_O::archive(node);
ffNonbondDb.cc:206:    node->attributeIfNotDefault("eleDielectricValue", this->_EleDielectricValue, 0.0);
ffNonbondDb.cc:207:    node->attributeIfNotDefault("eleBuffer", this->_EleBuffer, 0.0);
ffNonbondDb.cc:208:    node->attributeIfNotDefault("eleScale14", this->_EleScale14, 0.0);
ffNonbondDb.cc:209:    node->attributeIfNotDefault<string>("eleChargeFcn", this->_EleChargeFcn, "");
ffNonbondDb.cc:210:    node->attributeIfNotDefault("vdwScale14", this->_VdwScale14, 0.0);
ffNonbondDb.cc:211:    node->attributeIfNotDefault("vdwScaleBufferA", this->_VdwScaleBufferA, 0.0);
ffNonbondDb.cc:212:    node->attributeIfNotDefault("vdwScaleBufferB", this->_VdwScaleBufferB, 0.0);
ffNonbondDb.cc:213:    node->archiveObjectVector("nonbonds","Nonbonds",this->_Terms );
ffNonbondDb.cc:214:    node->archiveMapKeyStringValuePOD("map",this->_Lookup );
ffNonbondDb.cc:215:    node->attributeEnum( "eleDielectricCode", this->_EleDielectricCode, dielectricEnum );
ffNonbondDb.cc:216:    node->attributeEnum( "vdwMixRadius", this->_VdwMixRadius, vmrEnum );
ffNonbondDb.cc:217:    node->attributeEnum( "vdwMixWell", this->_VdwMixWell, vmwEnum );
ffNonbondDb.cc:225:    if ( this->_Lookup.count(nb->getType())!= 0 ) {
ffNonbondDb.cc:226:        SIMPLE_ERROR(boost::format("Adding nonbonded( %s ) to database but it's already there") % nb->getType() );
ffNonbondDb.cc:228:    uint index = this->_Terms.size();
ffNonbondDb.cc:229:    this->_Terms.push_back(nb);
ffNonbondDb.cc:230:    this->_Lookup[nb->getType()] = index;
ffNonbondDb.cc:235:    if ( this->_Lookup.count(type) != 0 ) return true;
ffNonbondDb.cc:241:    if ( this->_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:243:	uint index = this->_Lookup[type];
ffNonbondDb.cc:244:        return this->_Terms[index];
ffNonbondDb.cc:251:    if ( this->_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:253:	uint index = this->_Lookup[type];
ffNonbondDb.cc:261:    uint ti = this->findTypeIndex(type);
ffNonbondDb.cc:270:    if ( this->_Lookup.count(type) != 0 ) 
ffNonbondDb.cc:272:	uint index = this->_Lookup[type]*this->_Terms.size();
ffNonbondDb.cc:280:    ASSERT_lt(typeIdx,this->_Terms.size());
ffNonbondDb.cc:281:    return this->_Terms[typeIdx];
ffNonbondDb.cc:288:    return this->_Terms.size();
ffNonbondDb.cc:296:    this->Base::initialize();
ffNonbondDb.cc:297:    this->_Type = "";
ffNonbondDb.cc:298:    this->_Radius_Nanometers = 0.0;
ffNonbondDb.cc:299:    this->_Epsilon_kJ = 0.0; // Depth of the VDW well
ffNonbondDb.cc:300:    this->_Apol = 0.0;
ffNonbondDb.cc:301:    this->_Neff = 0.0;
ffNonbondDb.cc:302:    this->_Mass = 0.0;
ffNonbondDb.cc:303:    this->_Polarizability = 0.0;
ffNonbondDb.cc:304:    this->_DonorAcceptor = daNeither;
ffNonbondDb.cc:305:    this->_InitialCharge = 0.0;
ffNonbondDb.cc:306:    this->_Fcadj = 0.0;
ffNonbondDb.cc:307:    this->_Pbci = 0.0;
ffNonbondDb.cc:313:	this->_Radius_Nanometers = n;
ffNonbondDb.cc:318:	this->_Radius_Nanometers = n/10.0;
ffNonbondDb.cc:323:	return this->_Radius_Nanometers;
ffNonbondDb.cc:328:	return this->_Radius_Nanometers*10.0;
ffNonbondDb.cc:335:	this->_Epsilon_kJ = kj;
ffNonbondDb.cc:340:	this->_Epsilon_kJ = kCal_to_kJ(kcal);
ffNonbondDb.cc:346:	return kJ_to_kCal(this->_Epsilon_kJ);
ffNonbondDb.cc:351:	return this->_Epsilon_kJ;
ffNonbondDb.cc:360:    node->addAttributeString("type",this->_Type);
ffNonbondDb.cc:361:    node->addAttributeDoubleScientific("Radius",this->_Radius);
ffNonbondDb.cc:362:    node->addAttributeDoubleScientific("Well",this->_Well);
ffNonbondDb.cc:368:    this->_Type = node->getAttributeString("type");
ffNonbondDb.cc:369:    this->_Radius = node->getAttributeDouble("Radius");
ffNonbondDb.cc:370:    this->_Well = node->getAttributeDouble("Well");
ffNonbondDb.cc:378:    desc << this->FFParameter_O::levelDescription();
ffNonbondDb.cc:379:    desc << " nonbond type "<<this->_Type;
ffPtorDb.cc:30:    node->attribute( "type1", this->_T1 );
ffPtorDb.cc:31:    node->attribute( "type2", this->_T2 );
ffPtorDb.cc:32:    node->attribute( "type3", this->_T3 );
ffPtorDb.cc:33:    node->attribute( "type4", this->_T4 );
ffPtorDb.cc:36:	node->attributeIfDefined ( (BF("v%d")%i).str(), this->_Vs_kJ[i], this->_hasPeriodicity[i]);
ffPtorDb.cc:37:	node->attributeIfDefined ( (BF("ph%d")%i).str(), this->_PhaseRads[i], this->_hasPeriodicity[i]);
ffPtorDb.cc:46:    this->FFBaseDb_O::archiveBase(node);
ffPtorDb.cc:47:    node->archiveObjectVector<FFPtor_O>("ptors","Ptors",this->_Terms );
ffPtorDb.cc:48:    node->archiveMap<FFPtor_O>("map",this->_Lookup );
ffPtorDb.cc:57:    this->Base::initialize();
ffPtorDb.cc:58:    this->_Lookup.clear();
ffPtorDb.cc:59:    this->_Terms.clear();
ffPtorDb.cc:70:    ss << "Can't find ptor term for ("<<t1<<")-("<<t2<<")-("<<t3<<")-("<<t4<<")";
ffPtorDb.cc:77:    this->Base::initialize();
ffPtorDb.cc:79:    this->_T1 = "";
ffPtorDb.cc:80:    this->_T2 = "";
ffPtorDb.cc:81:    this->_T3 = "";
ffPtorDb.cc:82:    this->_T4 = "";
ffPtorDb.cc:85:	this->_hasPeriodicity[i] = false;
ffPtorDb.cc:86:	this->_Vs_kJ[i] = 0.0;
ffPtorDb.cc:87:	this->_PhaseRads[i] = 0.0;
ffPtorDb.cc:95:    this->_T1 = t1;
ffPtorDb.cc:96:    this->_T2 = t2;
ffPtorDb.cc:97:    this->_T3 = t3;
ffPtorDb.cc:98:    this->_T4 = t4;
ffPtorDb.cc:106:    return this->_hasPeriodicity[idx-1];
ffPtorDb.cc:117:    return this->_Vs_kJ[idx-1];
ffPtorDb.cc:125:    this->_hasPeriodicity[idx-1] = true;
ffPtorDb.cc:126:    this->_Vs_kJ[idx-1] = val;
ffPtorDb.cc:131:    return kJ_to_kCal(this->getV_kJ(idx));
ffPtorDb.cc:136:    this->setV_kJ(idx,kCal_to_kJ(val));
ffPtorDb.cc:143:        SIMPLE_ERROR(BF("Illegal periodicity[%d] for getPhaseRad - must be in [1,%d]") % idx % MaxPeriodicity );
ffPtorDb.cc:145:    return this->_PhaseRads[idx-1];
ffPtorDb.cc:153:    this->_PhaseRads[idx-1] = val;
ffPtorDb.cc:161:	if ( ptor->_hasPeriodicity[i] ) {
ffPtorDb.cc:162:            this->_hasPeriodicity[i] = ptor->_hasPeriodicity[i];
ffPtorDb.cc:163:            this->_Vs_kJ[i] = ptor->_Vs_kJ[i];
ffPtorDb.cc:164:            this->_PhaseRads[i] = ptor->_PhaseRads[i];
ffPtorDb.cc:169:#define keyString(t1,t2,t3,t4) (t1+"-"+t2+"-"+t3+"-"+t4)
ffPtorDb.cc:175:    if (this->hasExactTerm(ptor->_T1,ptor->_T2,ptor->_T3,ptor->_T4) ){
ffPtorDb.cc:176:        ptorOld = this->findExactTerm(ptor->_T1,ptor->_T2,ptor->_T3,ptor->_T4);
ffPtorDb.cc:177:        ptorOld->mergeWith(ptor);
ffPtorDb.cc:179:        this->_Terms.push_back(ptor);
ffPtorDb.cc:180:        key = keyString(ptor->_T1,ptor->_T2,ptor->_T3,ptor->_T4);
ffPtorDb.cc:181:        this->_Lookup.set(key,ptor);
ffPtorDb.cc:182:        key = keyString(ptor->_T4,ptor->_T3,ptor->_T2,ptor->_T1);
ffPtorDb.cc:183:        this->_Lookup.set(key,ptor);
ffPtorDb.cc:192:    if ( this->_Lookup.count(key)!=0 ) return true;
ffPtorDb.cc:194:    if ( this->_Lookup.count(key)!=0 ) return true;
ffPtorDb.cc:203:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:204:        return this->_Lookup.get(key);
ffPtorDb.cc:207:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:208:        return this->_Lookup.get(key);
ffPtorDb.cc:219:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:220:        return this->_Lookup.get(key);
ffPtorDb.cc:223:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:224:        return this->_Lookup.get(key);
ffPtorDb.cc:228:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:229:        return this->_Lookup.get(key);
ffPtorDb.cc:232:    if ( this->_Lookup.count(key)!=0 ) {
ffPtorDb.cc:233:        return this->_Lookup.get(key);
ffPtorDb.cc:244:    ptor = this->findBestTerm(t1,t2,t3,t4);
ffPtorDb.cc:253:    desc << this->FFParameter_O::levelDescription();
ffPtorDb.cc:254:    desc << " ptor between types "<<this->_T1<< " "
ffPtorDb.cc:255:		<< this->_T2 << " "
ffPtorDb.cc:256:		<< this->_T3 << " "
ffPtorDb.cc:257:		<< this->_T4;
ffStretchDb.cc:37:    node->addAttributeString("ti",this->_ti);
ffStretchDb.cc:38:    node->addAttributeString("tj",this->_tj);
ffStretchDb.cc:39:    node->addAttributeDoubleScientific("rij",this->_rij);
ffStretchDb.cc:40:    node->addAttributeDoubleScientific("lnKij",this->_lnKij);
ffStretchDb.cc:47:    this->_ti = node->getAttributeString("ti");
ffStretchDb.cc:48:    this->_tj = node->getAttributeString("tj");
ffStretchDb.cc:49:    this->_rij = node->getAttributeDouble("rij");
ffStretchDb.cc:50:    this->_lnKij = node->getAttributeDouble("lnKij");
ffStretchDb.cc:75:    this->Base::initialize();
ffStretchDb.cc:76:    this->clearEstimateStretch();
ffStretchDb.cc:77:    this->_Lookup.clear();
ffStretchDb.cc:78:    this->_Terms.clear();
ffStretchDb.cc:85:#define stretchKey(t1,t2) t1+"-"+t2
ffStretchDb.cc:90:    this->_Terms.push_back(term);
ffStretchDb.cc:91:    key = stretchKey(term->_Type1,term->_Type2);        // forwards
ffStretchDb.cc:92:    this->_Lookup.set(key,term);
ffStretchDb.cc:93:    key = stretchKey(term->_Type2,term->_Type1);        // backwards
ffStretchDb.cc:94:    this->_Lookup.set(key,term);
ffStretchDb.cc:104:    t1 = a1->getTypeString();
ffStretchDb.cc:105:    t2 = a2->getTypeString();
ffStretchDb.cc:106:    LOG(BF("Looking for stretch between types (%s)-(%s)") % t1.c_str() % t2.c_str() );
ffStretchDb.cc:108:    if ( this->_Lookup.count(key) != 0 ) {
ffStretchDb.cc:109:        return this->_Lookup.get(key);
ffStretchDb.cc:112:    if ( this->_Lookup.count(key) != 0 ) {
ffStretchDb.cc:113:        return this->_Lookup.get(key);
ffStretchDb.cc:117:    ss << "PARAMETER_PROBLEM Can't find stretch term for types(" << t1 << ")-("<<t2<<")";
ffStretchDb.cc:118:    ss << " atoms("<<a1->description()<<") - (" << a2->description()<<")";
ffStretchDb.cc:132:    if ( this->_Lookup.count(key) != 0 ) {
ffStretchDb.cc:136:    if ( this->_Lookup.count(key) != 0 ) {
ffStretchDb.cc:146:    ss << "Can't find stretch term for types(" << t1 << ")-("<<t2<<")";
ffStretchDb.cc:155:    this->_EstimateStretch.clear();
ffStretchDb.cc:168:    tt = es._ti+"-"+es._tj;
ffStretchDb.cc:169:    this->_EstimateStretch[tt] = es;
ffStretchDb.cc:182:    tt = ti+"-"+tj;
ffStretchDb.cc:183:    this->_addEstimateStretch(es);
ffStretchDb.cc:191:    node->attribute( "type1", this->_Type1 );
ffStretchDb.cc:192:    node->attribute( "type2", this->_Type2 );
ffStretchDb.cc:193:    node->attribute( "r0", this->_R0_Nanometer );
ffStretchDb.cc:194:    node->attribute( "kb", this->_Kb_kJPerNanometerSquared );
ffStretchDb.cc:202:    this->FFBaseDb_O::archiveBase(node);
ffStretchDb.cc:203:    node->archiveObjectVector<FFStretch_O>("stretches","Stretches",this->_Terms );
ffStretchDb.cc:204:    node->archiveMap<FFStretch_O>("map",this->_Lookup );
ffStretchDb.cc:238:    this->Base::initialize();
ffStretchDb.cc:239:    this->_Type1 = "";
ffStretchDb.cc:240:    this->_Type2 = "";
ffStretchDb.cc:241:    this->_R0_Nanometer = 0.0;
ffStretchDb.cc:242:    this->_Kb_kJPerNanometerSquared = 0.0;
ffStretchDb.cc:243://    this->_K3 = 0.0;
ffStretchDb.cc:244://    this->_K4 = 0.0;
ffStretchDb.cc:245://    this->_Bci = 0.0;
ffStretchDb.cc:252:    return this->_R0_Nanometer;
ffStretchDb.cc:257:    return this->_R0_Nanometer*10.0;
ffStretchDb.cc:262:    return this->_Kb_kJPerNanometerSquared;
ffStretchDb.cc:268:    this->_Kb_kJPerNanometerSquared = val;
ffStretchDb.cc:274:    this->_R0_Nanometer = val;
ffStretchDb.cc:280:    return kJPerNanometerSquared_to_kCalPerAngstromSquared(this->_Kb_kJPerNanometerSquared);
ffStretchDb.cc:290:    desc << this->FFParameter_O::levelDescription();
ffStretchDb.cc:291:    desc << " stretch between types "<<this->_Type1<< " "
ffStretchDb.cc:292:		<< this->_Type2;
ffTypesDb.cc:29:    this->Base::initialize();
ffTypesDb.cc:30:    this->_TypeAssignmentRules.clear();
ffTypesDb.cc:57:        LOG(BF("atom name: %s") % atom->getName().c_str() );
ffTypesDb.cc:58:        LOG(BF("Assigning type for atom: %s") % atom->description().c_str()  );
ffTypesDb.cc:60:	    for ( it=this->_TypeAssignmentRules.begin();
ffTypesDb.cc:61:		    it!=this->_TypeAssignmentRules.end(); it++ ) 
ffTypesDb.cc:62:	    {_BLOCK_TRACEF(BF("Testing rule code(%s)") % (*it)->getCode().c_str() );
ffTypesDb.cc:63:		LOG(BF("as xml: %s") % ((*it)->asXmlString().c_str() ) );
ffTypesDb.cc:64:		if ( (*it)->matches(atom) ) 
ffTypesDb.cc:80:    this->FFBaseDb_O::archive(node);
ffTypesDb.cc:81:    node->archiveObjectVector<chem::ChemInfo_O>("typeRules","List", this->_TypeAssignmentRules);
ffTypesDb.cc:88:    ASSERT_lessThan(index,this->_TypeAssignmentRules.size());
ffTypesDb.cc:89:    return this->_TypeAssignmentRules[index];
ffVdwDb.cc:19:    node->attribute("type1",this->_T1);
ffVdwDb.cc:20:    node->attribute("type2",this->_T2);
ffVdwDb.cc:21:    node->attribute("R",this->_R);
ffVdwDb.cc:22:    node->attribute("Eps",this->_Eps);
ffVdwDb.cc:23:    node->attribute("M",this->_M);
ffVdwDb.cc:24:    node->attribute("N",this->_N);
ffVdwDb.cc:25:    node->attribute("Edep",this->_Edep);
ffVdwDb.cc:33:    this->FFBaseDb_O::archive(node);
ffVdwDb.cc:34:    node->archiveObjectVector("Vdw","Vdw",this->_Terms);
forceField.cc:36:    node->archiveMapIfDefined("k",this->db);
forceField.cc:43:	if ( this->db.count(key)==0 ) {
forceField.cc:44:	    this->db.set(key,core::Str_O::create(data,_lisp));
forceField.cc:46:	    this->db.set(key,core::Str_O::create(this->db.get(key)->get()+"\n"+data,_lisp));
forceField.cc:55:    this->Base::initialize();
forceField.cc:57:    this->_Info = InfoDb_O::create();
forceField.cc:59:    this->_Types = FFTypesDb_O::create();
forceField.cc:61:    this->_Stretches = FFStretchDb_O::create();
forceField.cc:63:    this->_Angles = FFAngleDb_O::create();
forceField.cc:65:    this->_Itors = FFItorDb_O::create();
forceField.cc:67:    this->_Ptors = FFPtorDb_O::create();
forceField.cc:69:    this->_Nonbonds = FFNonbondDb_O::create();
forceField.cc:71:    this->_Vdws = FFVdwDb_O::create();
forceField.cc:78:    node->attribute("title",this->_Title);
forceField.cc:79:    node->attribute("ref",this->_Ref);
forceField.cc:80:    node->archiveVectorStrings( "bondDistinctions", this->_SingleBondMultiBondDistinctions );
forceField.cc:81:    node->archiveObject( "_Info", this->_Info );
forceField.cc:82:    node->archiveObject( "_Types", this->_Types );
forceField.cc:83:    node->archiveObject( "_Stretches", this->_Stretches );
forceField.cc:84:    node->archiveObject( "_Angles", this->_Angles );
forceField.cc:85:    node->archiveObject( "_Itors", this->_Itors );
forceField.cc:86:    node->archiveObject( "_Ptors", this->_Ptors );
forceField.cc:87:    node->archiveObject( "_Nonbonds", this->_Nonbonds );
forceField.cc:88:    node->archiveObject( "_Vdws", this->_Vdws );
forceField.cc:97:    xml = _lisp->create<core::XmlSaveArchive_O>();
forceField.cc:98:    xml->put("forceField",this->sharedThis<ForceField_O>());
forceField.cc:99:    xml->saveAs(fileName);
forceField.cc:106:    types = this->getTypes();
forceField.cc:107:    types->assignTypes(matter);
forceField.cc:114:    this->_Title = title;
forceField.cc:119:    this->_Info = Info;
forceField.cc:124:    this->_Types = Types;
forceField.cc:125:    this->_Types->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:131:    this->_Stretches = Stretches;
forceField.cc:132:    this->_Stretches->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:136:    this->_Angles = Angles;
forceField.cc:137:    this->_Angles->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:141:    this->_Itors = Itors;
forceField.cc:142:    this->_Itors->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:146:    this->_Ptors = Ptors;
forceField.cc:147:    this->_Ptors->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:151:    this->_Nonbonds = Nonbonds;
forceField.cc:152:    this->_Nonbonds->setForceField(this->sharedThis<ForceField_O>());
forceField.cc:156:    this->_Vdws = Vdws;
forceField.cc:157:    this->_Vdws->setForceField(this->sharedThis<ForceField_O>());
frameRecognizer.cc:14:    this->_Name = _Nil<core::Symbol_O>();
frameRecognizer.cc:15:    this->_GroupName = _Nil<core::Symbol_O>();
frameRecognizer.cc:20:    this->_Smarts = osm;
frameRecognizer.cc:21:    this->_ChemInfo = chem::ChemInfo_O::create();
frameRecognizer.cc:22:    this->_ChemInfo ->compileSmarts(this->_Smarts);
frameRecognizer.cc:23:    if ( !this->_ChemInfo->compileSucceeded() )
frameRecognizer.cc:25:	SIMPLE_ERROR(BF("Error compiling ChemInfo: %s") % this->_ChemInfo);
frameRecognizer.cc:28:    LOG(BF("ChemInfo code = %s") % this->_ChemInfo->asXmlString());
frameRecognizer.cc:36:    node->attribute("name",this->_Name);
frameRecognizer.cc:38:    if ( node->loading() )
frameRecognizer.cc:40:	if ( node->hasAttribute("name") )
frameRecognizer.cc:42:	    node->attribute("name",this->_Name);
frameRecognizer.cc:45:	    node->attribute("_key",this->_Name);
frameRecognizer.cc:49:	node->attribute("name",this->_Name);
frameRecognizer.cc:52:    node->attribute("smarts",this->_Smarts);
frameRecognizer.cc:53:    node->attributeSymbolIfNotNil("groupName",this->_GroupName);
frameRecognizer.cc:55:    if ( node->loading() )
frameRecognizer.cc:59:            this->compileSmarts(this->_Smarts);
frameRecognizer.cc:62:	    SIMPLE_ERROR(BF("Could not parse Smarts code for %s %s")% this->_Smarts % err.message() );
frameRecognizer.cc:72:    ASSERTNOTNULL(this->_ChemInfo);
frameRecognizer.cc:73:    ASSERT(this->_ChemInfo->compileSucceeded());
frameRecognizer.cc:74:    return this->_ChemInfo->matches(o);
frameRecognizer.cc:80:    return this->_ChemInfo->getMatch();
frameRecognizer.cc:87:    this->_Name = fn;
frameRecognizer.cc:92:    ASSERTNOTNULL(this->_ChemInfo);
frameRecognizer.cc:93:    return this->_ChemInfo->depth();
frameRecognizer.cc:99:    return this->_Name;
frameRecognizer.cc:104:    this->_GroupName = fn;
frameRecognizer.cc:109:    if ( this->_GroupName->isNil() )
frameRecognizer.cc:110:	return this->_Name;
frameRecognizer.cc:111:    return this->_GroupName;
frameRecognizer.cc:119:    ss << "( " << this->className() << " ";
frameRecognizer.cc:120:    if ( this->_Name.use_count() != 0 )
frameRecognizer.cc:122:	ss << " :name " << this->_Name->__repr__();
frameRecognizer.cc:125:	ss << " :name -UNDEFINED-";
frameRecognizer.cc:127:    ss << " :groupName \"" << this->_GroupName->__repr__() << "\"";
frameRecognizer.cc:128:    ss << " :smarts " << "\"" << this->_Smarts << "\" )";
frameRecognizer.cc:141:    me->_Name = name;
frameRecognizer.cc:142:    me->_Smarts = smarts;
frameRecognizer.cc:143:    me->_GroupName = groupName;
frameRecognizer.cc:144:    me->_ChemInfo = ChemInfo_O::create();
frameRecognizer.cc:145:    me->_ChemInfo->compileSmarts(me->_Smarts);
frameRecognizer.cc:146:    if ( !me->_ChemInfo->compileSucceeded() )
frameRecognizer.cc:148:	SIMPLE_ERROR(BF("%s") % me->_ChemInfo->compilerMessage());
frameRecognizer.cc:157:    this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"name"));
frameRecognizer.cc:158:    this->_Smarts = translate::from_object<core::Str_O>::convert(env->lookup(Pkg(),"smarts"))->get();
frameRecognizer.cc:159:    this->_GroupName = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"groupName"));
frameRecognizer.cc:160:    this->_ChemInfo = ChemInfo_O::create();
frameRecognizer.cc:161:    this->_ChemInfo->compileSmarts(this->_Smarts);
frameRecognizer.cc:162:    if ( !this->_ChemInfo->compileSucceeded() )
frameRecognizer.cc:164:	SIMPLE_ERROR(this->_ChemInfo->compilerMessage());
grPickableMatter.cc:51:    this->_Atom = atom;
grPickableMatter.cc:52:    this->_Style = atom->getPropertyOrDefault(addon::_kw_renderStyle,addon::_kw_ballAndStick)->as<core::Symbol_O>();
grPickableMatter.cc:53:    this->_ShowLabel = atom->getPropertyOrDefault(addon::_kw_showLabel,_lisp->_false())->isTrue();
grPickableMatter.cc:54:    core::Str_sp label = atom->getPropertyOrDefault(addon::_kw_label,core::Str_O::_nil)->as<core::Str_O>();
grPickableMatter.cc:57:        this->_Label = label->get();
grPickableMatter.cc:60:        this->_Label = atom->getName();
grPickableMatter.cc:62:    this->_NumberOfBonds = atom->numberOfBonds();
grPickableMatter.cc:63:    bool colorByElement = atom->getPropertyOrDefault(addon::_kw_colorByElement,_lisp->_true())->isTrue();
grPickableMatter.cc:66:	this->_Color = (GrPickableMatter_O::elementToColor(atom->getElement(),_lisp));
grPickableMatter.cc:69:	addon::Color_sp color = atom->getPropertyOrDefault(addon::_kw_color,addon::Color_O::_nil)->as<addon::Color_O>();
grPickableMatter.cc:70:	if ( color->isNil() )
grPickableMatter.cc:72:	    this->_Color = addon::Color_O::systemColor(addon::_kw_magenta);
grPickableMatter.cc:75:	    this->_Color = color;
grPickableMatter.cc:84:    this->Base::archiveBase(node);
grPickableMatter.cc:85:    node->attribute("style",this->_Style);
grPickableMatter.cc:86:    node->attribute("sl",this->_ShowLabel);
grPickableMatter.cc:87:    node->attribute("lbl",this->_Label);
grPickableMatter.cc:88:    node->attribute("numBonds",this->_NumberOfBonds);
grPickableMatter.cc:89:    node->archiveObject("color",this->_Color);
grPickableMatter.cc:90:    node->archiveObject("atom",this->_Atom);
grPickableMatter.cc:96:    /*! Find the distance from this atom to the line defined from p1->p2
grPickableMatter.cc:97:      Also return the alpha that gives the closest point on the line by (p1+alpha(p2-p1))
grPickableMatter.cc:102:	Vector3& p3 = this->_Atom->getPositionRef();
grPickableMatter.cc:104:	Vector3 d13 = p1 - p3;
grPickableMatter.cc:105:	Vector3	d21 = p2 - p1;
grPickableMatter.cc:111:	Vector3 delta = p3 - p0;
grPickableMatter.cc:137:    this->_Atom1 = idx1;
grPickableMatter.cc:138:    this->_Atom2 = idx2;
grPickableMatter.cc:139:    this->_Bond = a1->getBondTo(a2);
grPickableMatter.cc:140:    Vector3 v1 = a1->getPosition();
grPickableMatter.cc:141:    Vector3 v2 = a2->getPosition();
grPickableMatter.cc:143:    this->_Center = center;
grPickableMatter.cc:150:    this->Base::archiveBase(node);
grPickableMatter.cc:151:    node->attribute("i1",this->_Atom1);
grPickableMatter.cc:152:    node->attribute("i2",this->_Atom2);
grPickableMatter.cc:153:    node->archivePlainObject<Vector3>("ctr","V3",this->_Center);
grPickableMatter.cc:154:    node->archiveObject("bond",this->_Bond);
grPickableMatter.cc:194:    core::IntegerKeyObjectDictionary_sp elementColorMap = sym->symbolValue()->as<core::IntegerKeyObjectDictionary_O>();
grPickableMatter.cc:195:    if ( elementColorMap->contains(element) )
grPickableMatter.cc:197:	return elementColorMap->get(element)->as<addon::Color_O>();
grPickableMatter.cc:199:    return elementColorMap->get(element_Undefined)->as<addon::Color_O>();
grPickableMatter.cc:223:    this->Base::initialize();
grPickableMatter.cc:224:    this->setName(_lisp->internKeyword("matter"));
grPickableMatter.cc:231:    this->Base::archiveBase(node);
grPickableMatter.cc:232:    node->archiveObject("matter",this->_Matter);
grPickableMatter.cc:233:    node->archiveVector0("atoms",this->_Atoms);
grPickableMatter.cc:234:    node->archiveVector0("bonds",this->_Bonds);
grPickableMatter.cc:235:    node->needsFinalization();
grPickableMatter.cc:246:    this->Base::loadFinalize(node);
grPickableMatter.cc:247:    this->generateRenderObjects();
grPickableMatter.cc:264:    for ( it=this->_PartsDisplayList.begin(); it!=this->_PartsDisplayList.end(); it++ )
grPickableMatter.cc:266:	if ( (*it)->isAssignableTo<addon::Render_O>() )
grPickableMatter.cc:268:	    LOG(BF( "Child: %s")% (*it)->description().c_str() );
grPickableMatter.cc:269:	    LOG(BF( " (*it)->_InitializationOwner.use_count() == %d")% 
grPickableMatter.cc:270:		(*it)->_InitializationOwner.use_count() );
grPickableMatter.cc:271:	    if ( (*it)->_InitializationOwner.use_count() != 0 )
grPickableMatter.cc:273:		LOG(BF( "   (*it)->_InitializationOwner.lock().get() = %p")%
grPickableMatter.cc:274:		    (*it)->_InitializationOwner.lock().get() );
grPickableMatter.cc:276:	    addon::Render_sp render = (*it)->as<addon::Render_O>();
grPickableMatter.cc:277:	    LOG(BF( "    (*it)->getParent().get() = %p")% (*it)->as<addon::Render_O>()->getParent().get() );
grPickableMatter.cc:278:	    if ( render->getParent().get() != this )
grPickableMatter.cc:280:		SIMPLE_ERROR(BF("A child of %s name(%s) specifically(%s) does not have it as a parent") % this->description() % this->getName() % (*it)->description() );
grPickableMatter.cc:282:	    (*it)->as<addon::Render_O>()->check();
grPickableMatter.cc:292:    if ( !this->isOn(controller) ) return _Nil<addon::Render_O>();
grPickableMatter.cc:293:    if ( this->_Name->isNil() )
grPickableMatter.cc:299:    if ( symbolPath->cdr()->isNil() )
grPickableMatter.cc:301:	if ( symbolPath->car<core::Symbol_O>() == this->_Name ) return this->sharedThis<addon::Render_O>();
grPickableMatter.cc:317:    if ( this->getName().notnilp() )
grPickableMatter.cc:319:	core::SymbolVector_sp fullPath = this->getFullName();
grPickableMatter.cc:320:	controller->createSwitch(fullPath);
grPickableMatter.cc:327:    core::SymbolVector_sp fullName = this->getFullSwitchName();
grPickableMatter.cc:328:    if ( controller->isSwitchOn(fullName) )
grPickableMatter.cc:330:	return this->_PartsDisplayList.begin();
grPickableMatter.cc:332:    return this->_PartsDisplayList.end();
grPickableMatter.cc:337:    return this->_PartsDisplayList.end();
grPickableMatter.cc:348:    LOG(BF( "Rendering %d atoms")% this->_Atoms.size() );
grPickableMatter.cc:349:    for ( ai=this->_Atoms.begin(); ai!=this->_Atoms.end(); ai++ )
grPickableMatter.cc:351:	Atom_sp atom = (*ai)->getAtom();
grPickableMatter.cc:352:	sum = sum + atom->getPosition();
grPickableMatter.cc:363:    this->_AtomPoints = _lisp->create<addon::GrPickablePoints_O>();
grPickableMatter.cc:365:    for ( ai=this->_Atoms.begin(); ai!=this->_Atoms.end(); ai++ )
grPickableMatter.cc:367:        LOG(BF( "Atom %s _NumberOfBonds = %d")% (*ai)->_Label % (*ai)->_NumberOfBonds );
grPickableMatter.cc:368:	Vector3 pos = (*ai)->getAtom()->getPosition();
grPickableMatter.cc:369:	addon::Color_sp color = (*ai)->getColor();
grPickableMatter.cc:370:	this->_AtomPoints->appendPickablePoint(pos,color,*ai);
grPickableMatter.cc:371:	(*ai)->setBondLineVertexIndex(UndefinedUnsignedInt);
grPickableMatter.cc:374:    this->_BondLines = _lisp->create<addon::GrPickableLines_O>();
grPickableMatter.cc:375:    for ( bi=this->_Bonds.begin(); bi!=this->_Bonds.end(); bi++ )
grPickableMatter.cc:377:	uint ai1 = (*bi)->getAtom1Index();
grPickableMatter.cc:378:	uint ai2 = (*bi)->getAtom2Index();
grPickableMatter.cc:379:	RenderMatterAtom_sp ra1 = this->_Atoms[ai1];
grPickableMatter.cc:380:	RenderMatterAtom_sp ra2 = this->_Atoms[ai2];
grPickableMatter.cc:381:	Vector3 p1 = ra1->getAtom()->getPosition();
grPickableMatter.cc:382:	Vector3 p2 = ra2->getAtom()->getPosition();
grPickableMatter.cc:383:	addon::Color_sp c1 = ra1->getColor();
grPickableMatter.cc:384:	addon::Color_sp c2 = ra2->getColor();
grPickableMatter.cc:385:	Vector3& center = (*bi)->getCenter();
grPickableMatter.cc:386:	uint bondLineVertexIndex1 = ra1->getBondLineVertexIndex();
grPickableMatter.cc:389:	    bondLineVertexIndex1 = this->_BondLines->appendVertex(ra1->getAtom()->getPosition(),c1);
grPickableMatter.cc:390:	    ra1->setBondLineVertexIndex(bondLineVertexIndex1);
grPickableMatter.cc:392:	uint bondLineVertexIndex2 = ra2->getBondLineVertexIndex();
grPickableMatter.cc:395:	    bondLineVertexIndex2 = this->_BondLines->appendVertex(ra2->getAtom()->getPosition(),c2);
grPickableMatter.cc:396:	    ra2->setBondLineVertexIndex(bondLineVertexIndex2);
grPickableMatter.cc:400:	    this->_BondLines->appendPickableLine(bondLineVertexIndex1,bondLineVertexIndex2,*bi);
grPickableMatter.cc:403:	    uint centerIndex1 = this->_BondLines->appendVertex(center,c1);
grPickableMatter.cc:404:	    uint centerIndex2 = this->_BondLines->appendVertex(center,c2);
grPickableMatter.cc:405:	    this->_BondLines->appendPickableLine(bondLineVertexIndex1,centerIndex1,*bi);
grPickableMatter.cc:406:	    this->_BondLines->appendPickableLine(bondLineVertexIndex2,centerIndex2,*bi);
grPickableMatter.cc:410:	this->_Labels = addon::GrLabels_O::create();
grPickableMatter.cc:411:	for ( ai=this->_Atoms.begin(); ai!=this->_Atoms.end(); ai++ )
grPickableMatter.cc:413:	    if ( (*ai)->getShowLabel() )
grPickableMatter.cc:415:		Vector3& pos = (*ai)->getAtom()->getPositionRef();
grPickableMatter.cc:416:		string& label = (*ai)->getLabel();
grPickableMatter.cc:417:		addon::Color_sp color = (*ai)->getColor();
grPickableMatter.cc:418:		this->_Labels->appendLabel(pos,label,color);
grPickableMatter.cc:434:    this->_Matter = matter;
grPickableMatter.cc:436:	this->_Atoms.clear();
grPickableMatter.cc:440:	    grMatterAtom = _lisp->create<RenderMatterAtom_O>();
grPickableMatter.cc:442:	    grMatterAtom->defineForAtom(atom,this->sharedThis<GrPickableMatter_O>());
grPickableMatter.cc:443:	    atomIndices[atom] = this->_Atoms.size();
grPickableMatter.cc:444:	    this->_Atoms.push_back(grMatterAtom);
grPickableMatter.cc:450:	grMatterBond = _lisp->create<RenderMatterBond_O>();
grPickableMatter.cc:457:	    grMatterBond->setup(ai1,ai2,a1,a2);
grPickableMatter.cc:458:	    this->_Bonds.push_back(grMatterBond);
grPickableMatter.cc:464:    this->generateRenderObjects();
grPickableMatter.cc:469:    if ( !this->isOn(rc) ) return;
grPickableMatter.cc:470:    this->_AtomPoints->accumulateCenterOfGeometry(cogType,rc,sumPos,sumPoints);
grPickableMatter.cc:471:    this->_BondLines->accumulateCenterOfGeometry(cogType,rc,sumPos,sumPoints);
grPickableMatter.cc:477:    if ( !this->isOn(rc) ) return;
grPickableMatter.cc:478:    this->_AtomPoints->accumulateBoundingBox(transform,cogType,rc,bbox);
improperTorsion.cc:11:// ----------------------------------------------------------------------
improperTorsion.cc:38:	obj->setup(a1,a2,a3central,a4);
improperTorsion.cc:48:	this->_a1 = a1;
improperTorsion.cc:49:	this->_a2 = a2;
improperTorsion.cc:50:	this->_a3central = a3central;
improperTorsion.cc:51:	this->_a4 = a4;
improperTorsion.cc:64:        this->Base::archiveBase(node);
improperTorsion.cc:72:        this->Base::initialize();
improperTorsion.cc:78:	ss << this->className()
improperTorsion.cc:80:	   <<this->_a1->getName()
improperTorsion.cc:81:	   <<"-"<<this->_a2->getName()
improperTorsion.cc:82:	   <<"-center["
improperTorsion.cc:83:	   <<this->_a3central->getName()
improperTorsion.cc:84:	   <<"]-"
improperTorsion.cc:85:	   <<this->_a4->getName()
indirectAtomCoordinateReference.cc:18:	node->archiveObject("atom",this->_SharedAtom);
indirectAtomCoordinateReference.cc:19:	node->attribute("idx3",this->_IndexTimes3);
iterateMatter.cc:51://	this->Base::oldLispInitialize(kargs,env);
iterateMatter.cc:58:	m->_Top = top;
iterateMatter.cc:59:	m->_Goal = goal;
iterateMatter.cc:67:	this->Base::initialize();
iterateMatter.cc:82:	this->_Top = top;
iterateMatter.cc:87:	this->_Goal = goal;
iterateMatter.cc:93:	this->_IsDone = false;
iterateMatter.cc:94:	this->_Loop.loopTopGoal(this->_Top,this->_Goal);
iterateMatter.cc:95:	this->next();
iterateMatter.cc:100:	this->advance();
iterateMatter.cc:105:	if ( !this->_IsDone )
iterateMatter.cc:107:	    bool d = this->_Loop.advance();
iterateMatter.cc:111:		this->_IsDone = true;
iterateMatter.cc:114:	return this->_IsDone;
iterateMatter.cc:119:	if ( this->_IsDone ) return Matter_O::_nil;
iterateMatter.cc:120:	Matter_sp res = this->_Loop.getMatter();
iterateMatter.cc:127:	return this->_IsDone;
iterateMatter.cc:140:	ia->initTopAndGoal(top,ATOMS);
iterateMatter.cc:154:	ia->initTopAndGoal(matter,ATOMS);
iterateMatter.cc:166:    me->initTopAndGoal(matter,ATOMS);
iterateMatter.cc:174:	this->Base::__init__(exec,args,env,lisp);
iterateMatter.cc:175:	Matter_sp matter = env->lookup(lisp->internWithPackageName(ChemPkg,"matter"))->as<Matter_O>();
iterateMatter.cc:176:	this->initTopAndGoal(matter,ATOMS);
iterateMatter.cc:184:	if ( this->isDone() ) return core::T_O::_nil;
iterateMatter.cc:185:	return this->_Loop.getAtom();
iterateMatter.cc:195:	ia->initTopAndGoal(top,RESIDUES);
iterateMatter.cc:214:	if ( this->isDone() ) return core::T_O::_nil;
iterateMatter.cc:215:	return this->_Loop.getResidue();
iterateMatter.cc:224:	ia->initTopAndGoal(top,BONDS);
iterateMatter.cc:245:	return this->sharedThis<IterateBonds_O>();
iterateMatter.cc:251:	return this->_Loop.getAtom1();
iterateMatter.cc:256:	return this->_Loop.getAtom2();
iterateMatter.cc:261:	return this->_Loop.getBondOrder();
iterateRestraints.cc:16:    m->initTop(matter);
iterateRestraints.cc:23:    this->Base::initialize();
iterateRestraints.cc:29:    RestraintList_sp mine = m->allRestraints();
iterateRestraints.cc:31:    for ( it=mine->begin(); it!=mine->end(); it++ )
iterateRestraints.cc:33:	core::Cons_sp one = core::Cons_O::create((*it),this->_Restraints,_lisp);
iterateRestraints.cc:34:	this->_Restraints = one;
iterateRestraints.cc:45:    this->_Restraints = core::Cons_O::_nil;
iterateRestraints.cc:46:    this->_accumulateRestraints(m);
iterateRestraints.cc:51:    this->_CurRestraint = this->_Restraints;
iterateRestraints.cc:56:    if ( this->_CurRestraint.notnilp() )
iterateRestraints.cc:58:        this->_CurRestraint = this->_CurRestraint->cdr();
iterateRestraints.cc:65:    if ( this->_CurRestraint->isNil() ) return core::T_O::_nil;
iterateRestraints.cc:66:    return core::oCar(this->_CurRestraint);
iterateRestraints.cc:71:    ASSERTNOTNULL(this->_CurRestraint);
iterateRestraints.cc:72:    return this->_CurRestraint->isNil();
jobHistory.cc:14:    this->Base::initialize();
jobHistory.cc:15:    this->_Command = "";
jobHistory.cc:16:    this->_Outcome = "";
jobHistory.cc:17:    this->_Comment = "";
jobHistory.cc:18:    this->_StartSeconds = 0;
jobHistory.cc:19:    this->_StopSeconds = 0;
jobHistory.cc:27:    node->attribute("Command",this->_Command);
jobHistory.cc:28:    node->attribute("StartSeconds",this->_StartSeconds);
jobHistory.cc:29:    node->attribute("StopSeconds",this->_StopSeconds);
jobHistory.cc:30:    node->attribute("Outcome",this->_Outcome);
jobHistory.cc:31:    if ( node->loading() )
jobHistory.cc:33:        this->_Comment = node->characters();
jobHistory.cc:36:        node->setCharacters(this->_Comment);
jobHistory.cc:47:    this->setStartSeconds(seconds);
jobHistory.cc:48:    this->setCommand(command);
jobHistory.cc:57:    this->setStopSeconds(seconds);
jobHistory.cc:58:    this->setState(newStateName);
jobHistory.cc:65:    node->archiveVector0<TrainerHistoryEntry_O>("entries",this->_Entries);
largeSquareMatrix.cc:35:    this->_Triangle = type;
largeSquareMatrix.cc:36:    this->_Columns = dim;
largeSquareMatrix.cc:37:    this->_Rows = dim;
largeSquareMatrix.cc:42:    this->_Triangle = orig._Triangle;
largeSquareMatrix.cc:43:    this->_Columns = orig._Columns;
largeSquareMatrix.cc:44:    this->_Rows = orig._Rows;
largeSquareMatrix.cc:51:    ii = this->indexBegin();
largeSquareMatrix.cc:52:    iEnd = this->indexEnd();
largeSquareMatrix.cc:54:	this->setAtIndex(ii,d);
largeSquareMatrix.cc:55:	ii = this->indexAdvance(ii);
largeSquareMatrix.cc:65:    ii = this->indexBegin();
largeSquareMatrix.cc:66:    iEnd = this->indexEnd();
largeSquareMatrix.cc:68:	dMaxAbs = MAX(dMaxAbs,fabs(this->getAtIndex(ii)));
largeSquareMatrix.cc:69:	ii = this->indexAdvance(ii);
largeSquareMatrix.cc:77:    uint idx = this->indexFromCoordinatesOrUndefinedUnsignedInt(x,y);
largeSquareMatrix.cc:80:	SIMPLE_ERROR(BF("Illegal coordinates for %s[%u,%u]") % this->className() % x % y );
largeSquareMatrix.cc:97:    for ( y = 0; y<this->dimension(); y++ ) {
largeSquareMatrix.cc:102:	for ( x = 0; x<this->dimension(); x++ ) {
largeSquareMatrix.cc:106:	    fout << this->element(x,y);
largeSquareMatrix.cc:123:    for ( y = 0; y<this->dimension(); y++ ) {
largeSquareMatrix.cc:128:	for ( x = 0; x<this->dimension(); x++ ) {
largeSquareMatrix.cc:132:	    if ( this->hasElement(x,y) ) {
largeSquareMatrix.cc:144://! Dump the matrix from 0,0-upto,upto
largeSquareMatrix.cc:148:    for ( y = 0; y<this->dimension(); y++ ) {
largeSquareMatrix.cc:149:	for ( x = 0; x<this->dimension(); x++ ) {
largeSquareMatrix.cc:151:		_lisp->print(BF(" "));
largeSquareMatrix.cc:153:	    _lisp->print(BF("%12.7lf") % this->element(x,y));
largeSquareMatrix.cc:155:	_lisp->print(BF(""));
largeSquareMatrix.cc:165:    if ( result->size() != this->_Rows ) {
largeSquareMatrix.cc:168:    if ( d->size() != this->_Rows ) {
largeSquareMatrix.cc:172:    for ( y=0; y<this->_Rows; y++ ) {
largeSquareMatrix.cc:174:	for ( x=0; x<this->_Rows; x++ ) {
largeSquareMatrix.cc:175:	    sum += this->element(x,y)*d->element(x);
largeSquareMatrix.cc:177:	result->setElement(y,sum);
largeSquareMatrix.cc:194:    res->setup(dim,type);
largeSquareMatrix.cc:202:    this->AbstractLargeSquareMatrix_O::setup(dim,type);
largeSquareMatrix.cc:204:	this->_ActiveElements = dim*dim;
largeSquareMatrix.cc:206:	this->_ActiveElements = ((dim+1)*dim)/2;
largeSquareMatrix.cc:208:	this->_ActiveElements = ((dim+1)*dim)/2;
largeSquareMatrix.cc:210:    this->_Values.resize(this->_ActiveElements,0);
largeSquareMatrix.cc:218:    this->_ActiveElements = orig._ActiveElements;
largeSquareMatrix.cc:219:    this->_Values.assign(orig._Values.begin(),orig._Values.end());
largeSquareMatrix.cc:228:    if ( x >= this->_Columns || y >= this->_Rows ) {
largeSquareMatrix.cc:231:    if ( this->_Triangle == UpperDiagonalLower ) {
largeSquareMatrix.cc:232:	i = y*this->_Columns+x;
largeSquareMatrix.cc:233:	if ( i >= this->_ActiveElements ) {
largeSquareMatrix.cc:237:    } else if ( this->_Triangle == SymmetricDiagonalLower ) {
largeSquareMatrix.cc:248:	if ( i>=this->_ActiveElements ) {
largeSquareMatrix.cc:252:    } else if ( this->_Triangle == SymmetricUpperDiagonal ) {
largeSquareMatrix.cc:259:	i = i0 + (x-y);
largeSquareMatrix.cc:260:	if ( i>=this->_ActiveElements ) {
largeSquareMatrix.cc:284:    if ( ii < this->indexBegin() || ii >= this->indexEnd() ) {
largeSquareMatrix.cc:287:    if ( this->_Triangle == UpperDiagonalLower ) {
largeSquareMatrix.cc:288:	y = ii/this->_Columns;
largeSquareMatrix.cc:289:	x = ii%this->_Columns;
largeSquareMatrix.cc:290:    } else if ( this->_Triangle == SymmetricDiagonalLower ) {
largeSquareMatrix.cc:292:	for (i=0; i<=this->_Rows; i++ ) {
largeSquareMatrix.cc:295:	y = i-1;
largeSquareMatrix.cc:296:	x = ii-((y+1)*y)/2;
largeSquareMatrix.cc:297:    } else if ( this->_Triangle == SymmetricUpperDiagonal ) {
largeSquareMatrix.cc:299:	for (i=0; i<=this->_Rows; i++ ) {
largeSquareMatrix.cc:302:	y = i-1;
largeSquareMatrix.cc:303:	x = ii-((y+1)*y)/2+y;
largeSquareMatrix.cc:330:    res->setup(dim,type);
largeSquareMatrix.cc:341:    this->releaseStorage();
largeSquareMatrix.cc:347:    this->AbstractLargeSquareMatrix_O::setup(dim,type);
largeSquareMatrix.cc:348:    this->_InsertionIsComplete = false;
largeSquareMatrix.cc:349:    this->initializeStorage();
largeSquareMatrix.cc:362:    this->_InsertionIsComplete = orig._InsertionIsComplete;
largeSquareMatrix.cc:363:    this->_RowStartEntries = orig._RowStartEntries;
largeSquareMatrix.cc:364:    this->_RowStarts.assign(orig._RowStarts.begin(),orig._RowStarts.end());
largeSquareMatrix.cc:365:    this->_ActiveElements = orig._ActiveElements;
largeSquareMatrix.cc:366:    this->_ReservedElements = orig._ReservedElements;
largeSquareMatrix.cc:367:    this->_ColumnForValue.assign(orig._ColumnForValue.begin(),orig._ColumnForValue.end());
largeSquareMatrix.cc:368:    this->_Values.assign(orig._Values.begin(),orig._Values.end());
largeSquareMatrix.cc:374:uint	rows = this->_Rows;
largeSquareMatrix.cc:375:    this->_InsertionIsComplete = false;
largeSquareMatrix.cc:376:    this->_RowStartEntries = rows+1;
largeSquareMatrix.cc:377:    this->_RowStarts.assign((rows+1),0);
largeSquareMatrix.cc:378:    this->_ActiveElements = 0;
largeSquareMatrix.cc:379:    this->_ReservedElements = 100;
largeSquareMatrix.cc:380:    this->_ColumnForValue.reserve(this->_ReservedElements);
largeSquareMatrix.cc:381:    this->_Values.reserve(this->_ReservedElements);
largeSquareMatrix.cc:388:    this->_RowStarts.clear();
largeSquareMatrix.cc:389:    this->_ColumnForValue.clear();
largeSquareMatrix.cc:390:    this->_Values.clear();
largeSquareMatrix.cc:391:    this->_RowStartEntries = 0;
largeSquareMatrix.cc:392:    this->_ReservedElements = 0;
largeSquareMatrix.cc:393:    this->_ActiveElements = 0;
largeSquareMatrix.cc:399:    this->_ReservedElements *= 2;
largeSquareMatrix.cc:400:    this->_ColumnForValue.reserve(this->_ReservedElements);
largeSquareMatrix.cc:401:    this->_Values.reserve(this->_ReservedElements);
largeSquareMatrix.cc:407:    this->releaseStorage();
largeSquareMatrix.cc:408:    this->initializeStorage();
largeSquareMatrix.cc:418:    if ( this->_InsertionIsComplete ) {
largeSquareMatrix.cc:421:    if ( y>=this->_Rows || x>=this->_Columns ) {
largeSquareMatrix.cc:424:    if ( this->_Triangle == SymmetricDiagonalLower && x>y ) {
largeSquareMatrix.cc:429:    } else if ( this->_Triangle == SymmetricUpperDiagonal && x<y ) {
largeSquareMatrix.cc:435:    ib = this->_RowStarts[y];
largeSquareMatrix.cc:436:    ie = this->_RowStarts[y+1];
largeSquareMatrix.cc:438:	if ( this->_ColumnForValue[i] == x ) {
largeSquareMatrix.cc:445:	if ( this->_ColumnForValue[i] > x ) {
largeSquareMatrix.cc:452:    if ( this->_ActiveElements>=this->_ReservedElements ) {
largeSquareMatrix.cc:453:	this->expandStorage();
largeSquareMatrix.cc:458:    printf("Sliding from %d to %d num=%d\n", i, i+1, (this->_ActiveElements-i) );
largeSquareMatrix.cc:459:    printf("Befor slide value@%d = %d\n", i, this->_ColumnForValue[i]);
largeSquareMatrix.cc:461:    this->_ColumnForValue.insert(this->_ColumnForValue.begin()+i,x);
largeSquareMatrix.cc:462:    this->_Values.insert(this->_Values.begin()+i,0.0);
largeSquareMatrix.cc:464:    printf("After slide value@%d = %d\n", i+1, this->_ColumnForValue[i+1]);
largeSquareMatrix.cc:466:    this->_ActiveElements++;
largeSquareMatrix.cc:470:    for ( uint rr = y+1; rr<this->_RowStartEntries;rr++ ) {
largeSquareMatrix.cc:471:	this->_RowStarts[rr]++;
largeSquareMatrix.cc:482:    if ( x >= this->_Columns || y >= this->_Rows ) {
largeSquareMatrix.cc:485:    if ( this->_Triangle == SymmetricDiagonalLower && x>y ) {
largeSquareMatrix.cc:488:    } else if ( this->_Triangle == SymmetricUpperDiagonal && x<y ) {
largeSquareMatrix.cc:493:    uint ib = this->_RowStarts[y];
largeSquareMatrix.cc:494:    uint ie = this->_RowStarts[y+1]-1;
largeSquareMatrix.cc:495:    LOG(BF("This row has columns in the list between indices: %d-%d") % ib % ie );
largeSquareMatrix.cc:497:    if ( ib >= this->_ColumnForValue.size() ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:498:    if ( x < this->_ColumnForValue[ib] ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:499:    if ( ie >= this->_ColumnForValue.size() ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:500:    if ( x > this->_ColumnForValue[ie] ) return UndefinedUnsignedInt;
largeSquareMatrix.cc:501:    if ( x == this->_ColumnForValue[ib] )
largeSquareMatrix.cc:506:    if ( x == this->_ColumnForValue[ie] )
largeSquareMatrix.cc:511:    while ( ib<ie-1 ) {
largeSquareMatrix.cc:513:	if ( this->_ColumnForValue[im] == x ) 
largeSquareMatrix.cc:518:	if ( this->_ColumnForValue[im] < x ) {
largeSquareMatrix.cc:527:    if ( ret >= this->_Values.size() )
largeSquareMatrix.cc:529:        _lisp->print(BF("Out of bounds at: %s line: %d") % __FILE__% __LINE__ );
largeSquareMatrix.cc:530:	_lisp->print(BF("Looking for point: %u, %u") % x% y );
largeSquareMatrix.cc:531:	_lisp->print(BF("Calculated: %u") % ret );
largeSquareMatrix.cc:532:	_lisp->print(BF("this->_Values.size() = %u") % this->_Values.size() );
largeSquareMatrix.cc:533:	this->debug();
largeSquareMatrix.cc:544:    dest = RP_Copy<SparseLargeSquareMatrix_O>(this->sharedThis<SparseLargeSquareMatrix_O>());
largeSquareMatrix.cc:552:    for ( r=0; r<this->_Rows; r++ ) {
largeSquareMatrix.cc:553:	if ( this->_RowStarts[r] > is ) break;
largeSquareMatrix.cc:555:    if ( this->_RowStarts[r]<=is ) {
largeSquareMatrix.cc:559:    y = r-1;
largeSquareMatrix.cc:560:    x = this->_ColumnForValue[is];
largeSquareMatrix.cc:567:    _lisp->print(BF("this->_Rows = %d") % this->_Rows );
largeSquareMatrix.cc:568:    _lisp->print(BF("this->_Columns = %d") % this->_Columns );
largeSquareMatrix.cc:569:    for ( uint r=0; r<this->_Rows; r++ ) {
largeSquareMatrix.cc:570:	ib = this->_RowStarts[r];
largeSquareMatrix.cc:571:	ie = this->_RowStarts[r+1];
largeSquareMatrix.cc:572:	_lisp->print(BF("Row%3d [%3d-%3d]: ") % r % ib % ie );
largeSquareMatrix.cc:575:	    _lisp->print(BF(" x%d@%-3d") % this->_ColumnForValue[i] % i );
largeSquareMatrix.cc:577:	_lisp->print(BF( "" ));
largeSquareMatrix.cc:579:    _lisp->print(BF("Columns: "));
largeSquareMatrix.cc:580:    for ( uint i=0; i<this->_ActiveElements; i++ ) {
largeSquareMatrix.cc:581:	_lisp->prin1(BF("x%d@%d ") % this->_ColumnForValue[i] % i);
largeSquareMatrix.cc:583:    _lisp->print(BF("Number of values: %u") % this->_Values.size() );
largeSquareMatrix.cc:590:	uint ii= this->indexFromCoordinatesOrUndefinedUnsignedInt(x,y);
largeSquareMatrix.cc:592:	return this->_Values[ii];
largeSquareMatrix.cc:598:	dp = this->indexFromCoordinatesOrUndefinedUnsignedInt(x,y);
largeSquareMatrix.cc:601:	    if ( this->_InsertionIsComplete ) {
largeSquareMatrix.cc:603:		ss << "Trying to write to non-existent element (x,y)=("<< x << "," << y <<") in sparse matrix";
largeSquareMatrix.cc:606:		this->insertElement(x,y);
largeSquareMatrix.cc:607:		dp = this->indexFromCoordinates(x,y);
largeSquareMatrix.cc:612:	this->_Values[dp] = d;
largeSquareMatrix.cc:619:	dp = this->indexFromCoordinatesOrUndefinedUnsignedInt(x,y);
largeSquareMatrix.cc:622:	    if ( this->_InsertionIsComplete ) {
largeSquareMatrix.cc:624:		ss << "Trying to write to non-existent element (x,y)=("<< x << "," << y <<") in sparse matrix";
largeSquareMatrix.cc:628:		this->insertElement(x,y);
largeSquareMatrix.cc:629:		dp = this->indexFromCoordinates(x,y);
largeSquareMatrix.cc:632:	if ( this->_Values.size() == 0 )
largeSquareMatrix.cc:635:	    _lisp->print(BF("Failing in %s line: %d") % __FILE__% __LINE__ );
largeSquareMatrix.cc:636:	    _lisp->print(BF("Trying to add to element at: %u, %u") % x% y );
largeSquareMatrix.cc:637:	    _lisp->print(BF( "inserted dp = %u") % dp );
largeSquareMatrix.cc:638:	    _lisp->print(BF( "initial dp = %u") % idp );
largeSquareMatrix.cc:639:	    _lisp->print(BF( "inserted = %d") % inserted );
largeSquareMatrix.cc:640:	    _lisp->print(BF( "this->_Values.size() = %u") % this->_Values.size() );
largeSquareMatrix.cc:641:	    _lisp->print(BF( "this->_InsertionIsComplete = %d") % this->_InsertionIsComplete );
largeSquareMatrix.cc:644:	ASSERT_lessThan(dp,this->_Values.size());
largeSquareMatrix.cc:645:	this->_Values[dp] += d;
largeSquareMatrix.cc:651:	ASSERT_lessThan(y,this->_Rows);
largeSquareMatrix.cc:652:	return this->_RowStarts[y+1]-1;
largeSquareMatrix.cc:660:	ASSERT_lessThan(x,this->_Columns);
largeSquareMatrix.cc:661:	ASSERT_lessThan(y,this->_Rows);
largeSquareMatrix.cc:662:	ASSERT(this->_Triangle == SymmetricUpperDiagonal);
largeSquareMatrix.cc:664:	uint ib = this->_RowStarts[y];
largeSquareMatrix.cc:665:	uint ie = this->_RowStarts[y+1]-1;
largeSquareMatrix.cc:666:	LOG(BF("This row has columns in the list between indices: %d-%d") % ib % ie );
largeSquareMatrix.cc:668:	if ( x < this->_ColumnForValue[ib] ) return ib;
largeSquareMatrix.cc:669:	if ( x > this->_ColumnForValue[ie] ) return this->_RowStarts[y+1];
largeSquareMatrix.cc:670:	if ( x == this->_ColumnForValue[ib] ) return ib;
largeSquareMatrix.cc:671:	if ( x == this->_ColumnForValue[ie] ) return ie;
largeSquareMatrix.cc:672:	while ( ib<ie-1 ) {
largeSquareMatrix.cc:674:	    if ( this->_ColumnForValue[im] == x ) return im;
largeSquareMatrix.cc:675:	    if ( this->_ColumnForValue[im] < x ) {
linearAlgebra.cc:19:    dim = m->dimension();
linearAlgebra.cc:24:	ldlt->insertElement(j,j);	// Diagonal element is always there
linearAlgebra.cc:25:	for ( int i=j+1; i<dim; i++ ) {	// i is X-coordinate
linearAlgebra.cc:26:	    if ( m->hasElement(i,j) ) {
linearAlgebra.cc:27:		ldlt->insertElement(i,j);
linearAlgebra.cc:29:	    if ( j>0 && ldlt->hasElement(i,j-1) ) {
linearAlgebra.cc:30:		ldlt->insertElement(i,j);
linearAlgebra.cc:34:    ldlt->insertionIsComplete();
linearAlgebra.cc:54:_lisp->profiler().timer(core::timerPreconditioner).start();
linearAlgebra.cc:55:_lisp->profiler().timer(core::timerPreconditionerSolver).start();
linearAlgebra.cc:56:_lisp->profiler().timer(core::timerPreconditionerSolverFactor).start();
linearAlgebra.cc:57:    dim = m->dimension();
linearAlgebra.cc:62:    epsilon = m->maxAbsValue();
linearAlgebra.cc:64:    betaSquared = epsilon/(sqrt(ddim*(ddim-1.0)));
linearAlgebra.cc:65:    delta = 1e-9;
linearAlgebra.cc:70:	    cjkIndex = ldlt->indexFromCoordinatesOrUndefinedUnsignedInt(j,k);
linearAlgebra.cc:72:	    cjk = ldlt->getAtIndex(cjkIndex);
linearAlgebra.cc:73:	    dk = ldlt->element(k,k);
linearAlgebra.cc:77:	    ldlt->setElement(j,k,ljk);
linearAlgebra.cc:81:	djbar = m->element(j,j)-ksum;
linearAlgebra.cc:89:        _lisp->profiler().timer(core::timerPreconditionerSolverFactorFocus).start();
linearAlgebra.cc:92:	nvKSum->zero();	// initialize ksum vector to zero
linearAlgebra.cc:96:	    rowFirstIndex = ldlt->indexOfFirstElementAtOrAfterX(j,k);
linearAlgebra.cc:101:	    if ( ldlt->columnForIndex(rowFirstIndex) > j ) continue;
linearAlgebra.cc:103:	    rowLastIndex = ldlt->indexOfLastElementOnRow(k);
linearAlgebra.cc:105:	    ldltJk = ldlt->getAtIndex(rowFirstIndex);
linearAlgebra.cc:109:		cik = ldlt->getAtIndex(ii);
linearAlgebra.cc:110:		xII = ldlt->columnForIndex(ii);
linearAlgebra.cc:111:		nvKSum->addToElement(xII,cik*ldltJk);
linearAlgebra.cc:116:	    LOG(BF("Setting up to calculate cij j+1(%d) columns(%d)") % j+1 % ldlt->columns() );
linearAlgebra.cc:117:	    rowFirstIndex = ldlt->indexOfFirstElementAtOrAfterX(j+1,j);
linearAlgebra.cc:118:	    rowLastIndex = ldlt->indexOfLastElementOnRow(j);
linearAlgebra.cc:119:			    // ii indexes along X-coordinate
linearAlgebra.cc:123:		xII = ldlt->columnForIndex(ii);
linearAlgebra.cc:125:		cij = m->element(xII,j)-nvKSum->element(xII);
linearAlgebra.cc:127:		ldlt->setElement(xII,j,cij);
linearAlgebra.cc:134:	{	// i is X-coordinate
linearAlgebra.cc:138:		cik = ldlt->element(i,k); // Temporarily store cik in l
linearAlgebra.cc:140:		ksum += ldlt->element(j,k)*cik;
linearAlgebra.cc:142:	    cij = m->element(i,j)-ksum;
linearAlgebra.cc:143:	    hasij = ldlt->hasElement(i,j);
linearAlgebra.cc:151:	    ldlt->setElement(i,j,cij);
linearAlgebra.cc:155:        _lisp->profiler().timer(core::timerPreconditionerSolverFactorFocus).stop();
linearAlgebra.cc:169:	} else if ( djtilde < -delta ) {
linearAlgebra.cc:173:	        dj = MAX(djtilde,-thetaSquared/betaSquared);
linearAlgebra.cc:179:	ldlt->setElement(j,j,dj);
linearAlgebra.cc:181:    _lisp->profiler().timer(core::timerPreconditionerSolverFactor).stop();
linearAlgebra.cc:182:    _lisp->profiler().timer(core::timerPreconditionerSolver).stop();
linearAlgebra.cc:183:    _lisp->profiler().timer(core::timerPreconditioner).stop();
linearAlgebra.cc:193:    _lisp->profiler().timer(core::timerPreconditioner).start();
linearAlgebra.cc:194:    _lisp->profiler().timer(core::timerPreconditionerSolver).start();
linearAlgebra.cc:195:    _lisp->profiler().timer(core::timerPreconditionerSolverBackSubstitute).start();
linearAlgebra.cc:196:    tx = NVector_O::create(b->size(),ldlt->lisp());
linearAlgebra.cc:198:    for ( y=0; y<b->size(); y++ ) {
linearAlgebra.cc:201:	    sum += ldlt->element(x,y)*s->element(x);
linearAlgebra.cc:203:	s->setElement(y,b->element(y)-sum);
linearAlgebra.cc:207:    for ( x=0; x<s->size(); x++ ) {
linearAlgebra.cc:208:	dd = ldlt->element(x,x);
linearAlgebra.cc:210:	tx->setElement(x,s->element(x)/dd);
linearAlgebra.cc:214:    for ( y=b->size()-1; y < b->size(); y-- ) {
linearAlgebra.cc:216:	for ( x=y+1; x<b->size(); x++ ) {
linearAlgebra.cc:217:	    sum += ldlt->element(x,y)*s->element(x);
linearAlgebra.cc:219:	s->setElement(y,tx->element(y)-sum);
linearAlgebra.cc:221:    _lisp->profiler().timer(core::timerPreconditionerSolverBackSubstitute).stop();
linearAlgebra.cc:222:    _lisp->profiler().timer(core::timerPreconditionerSolver).stop();
linearAlgebra.cc:223:    _lisp->profiler().timer(core::timerPreconditioner).stop();
loop.cc:36:    LOG(BF("pushSubLoop: Starting a subloop over: %s") % c->description().c_str()  );
loop.cc:37:    this->curSubLoop++;
loop.cc:38:    this->subLoopTop[this->curSubLoop] = c;
loop.cc:39:    this->subLoopIteratorCur[this->curSubLoop] = c->_contents.begin();
loop.cc:40:    this->subLoopIteratorEnd[this->curSubLoop] = c->_contents.end();
loop.cc:41:    LOG(BF("pushSubLoop:  number of children count = %d") % c->_contents.size()  );
loop.cc:47:    if ( !this->done) {
loop.cc:49:        this->advanceLoop();
loop.cc:50:	if ( this->done )
loop.cc:80:    fFlags = aAtom->getFlags();
loop.cc:81:    if ( (fFlags&this->fVisibleFlagsOn)!=this->fVisibleFlagsOn )
loop.cc:84:    if ( (fFlags|(~(this->fVisibleFlagsOff)))!=(~(this->fVisibleFlagsOff)) )
loop.cc:91:    if ( this->fVisibilityFlags & TEMPINTUSED ) {
loop.cc:92:	if ( this->fVisibilityFlags & TEMPINTINVISIBLE ) {
loop.cc:93:	    if ( aAtom->getTempInt() == this->iTempInt ) {
loop.cc:97:	    if ( aAtom->getTempInt() != this->iTempInt ) {
loop.cc:107:    if ( this->aInvisibleAtom == aAtom ) return(false);
loop.cc:129:    if ( aAtom->getSeenId() == this->iSeenId ) {
loop.cc:137:    if ( this->iMaxDistanceFromRoot >= 0 ) {
loop.cc:138:	if ( this->iMaxDistanceFromRoot <
loop.cc:139:		this->aCurSpan->getBackCount()+1 ) {
loop.cc:143:    return(this->bLoopAtomVisible( aAtom ));
loop.cc:160:    this->loopTopGoal(cont,over);
loop.cc:166:    this->iIndex0 = 0;
loop.cc:167:    this->iIndex1 = 0;
loop.cc:168:    this->iIndex2 = 0;
loop.cc:169:    this->iIndex3 = 0;
loop.cc:170:    this->_Impropers.clear();
loop.cc:171:    this->_ImproperIndex = -1;
loop.cc:180:    this->_Impropers.clear();
loop.cc:181:    blrest0 = a->getBondList();
loop.cc:182:    LOG(BF("Attempting to build a list of impropers centered on %s") % a->description() );
loop.cc:183:    LOG(BF("It has the bonds: %s") % blrest0->description() );
loop.cc:184:    if ( blrest0->size() >= 3 )
loop.cc:187:	for ( bl1=blrest0->begin(); bl1!=blrest0->end(); bl1++ )
loop.cc:191:	    accumulate1->append(*bl1);
loop.cc:193:	    LOG(BF("Copy blrest1 = %s") % blrest1->description() );
loop.cc:194:	    ASSERTF(blrest1->size() == blrest0->size(),
loop.cc:196:	    blrest1->removeBond(*bl1);
loop.cc:197:	    for ( bl2 = blrest1->begin(); bl2!=blrest1->end(); bl2++ )
loop.cc:201:		accumulate2->append(*bl2);
loop.cc:203:		blrest2->removeBond(*bl2);
loop.cc:204:		for ( bl3=blrest2->begin(); bl3!=blrest2->end(); bl3++ ) {
loop.cc:207:		    accumulate3->append(*bl3);
loop.cc:208:		    this->_Impropers.push_back(accumulate3);
loop.cc:213:    LOG(BF("Number of impropers = %d") % this->_Impropers.size() );
loop.cc:220:    if ( c->isNil() ) {
loop.cc:224:    this->goal = 	goal;
loop.cc:225:    this->top = 	c;
loop.cc:226:    this->initialized = false;
loop.cc:227:    this->done	= 	false;
loop.cc:232:    this->iTempInt = 0;
loop.cc:233:    this->curSubLoop = -1;
loop.cc:234:    this->clearAtomIndices();
loop.cc:235:    this->fVisibilityFlags = 0;
loop.cc:240:        LOG(BF("Loop::loopTopGoal pushing subloop object=%s") % c->description().c_str()  );
loop.cc:241:	this->pushSubLoop( c );
loop.cc:248: * and put it in the atom array this->atoms[] and return true
loop.cc:261:    top = downcast<Atom_O>(this->getCurSubLoopTop());
loop.cc:262:    allowDuplicates = ( (this->goal&ALLOWDUPLICATES) != 0 );
loop.cc:263:    LOG(BF("Loop::nextObjectInAtom atom name: %s  address=0x%08x") % top->getName().c_str() % top.get() );
loop.cc:264:    switch ( this->goal&GOALONLY )
loop.cc:278:	while ( this->iIndex0 < top->coordination() )
loop.cc:282:	    ASSERT(this->iIndex0<top->numberOfBonds());
loop.cc:283:	    Atom_sp bondedTo = top->bondedNeighbor(this->iIndex0);
loop.cc:286:		this->atoms[0] = top;
loop.cc:287:		this->atoms[1] = top->bondedNeighbor(this->iIndex0);
loop.cc:288:		this->bondOrder = top->bondedOrder(this->iIndex0);
loop.cc:289:		this->_Bond = top->getBonds()[this->iIndex0];
loop.cc:290:		this->iIndex0++;
loop.cc:293:	    this->iIndex0++;
loop.cc:312:	    if ( this->iIndex0>=top->coordination() ) goto ANONE;
loop.cc:313:	    aAtom1 = top->bondedNeighbor( this->iIndex0 );
loop.cc:314:	    if ( this->iIndex1>=aAtom1->coordination() ) goto AINC1;
loop.cc:315:	    aAtom2 = aAtom1->bondedNeighbor( this->iIndex1 );
loop.cc:321:	    if ( !top->atLowerAddressThan(aAtom2) && !allowDuplicates )
loop.cc:333:	    this->iIndex1++;
loop.cc:334:	    if ( this->iIndex1 >= aAtom1->coordination() ) {
loop.cc:336:		this->iIndex0++;
loop.cc:337:		this->iIndex1 = 0;
loop.cc:341:	this->atoms[0] = top;
loop.cc:342:	this->atoms[1] = aAtom1;
loop.cc:343:	this->atoms[2] = aAtom2;
loop.cc:371:	    if ( this->iIndex0>=top->coordination() ) goto TNONE;
loop.cc:372:	    aAtom1 = top->bondedNeighbor(this->iIndex0);
loop.cc:373:	    if ( this->iIndex1>=aAtom1->coordination() ) goto TINC1;
loop.cc:374:	    aAtom2 = aAtom1->bondedNeighbor( this->iIndex1 );
loop.cc:375:	    if ( this->iIndex2>=aAtom2->coordination() ) goto TINC2;
loop.cc:376:	    aAtom3 = aAtom2->bondedNeighbor( this->iIndex2 );
loop.cc:378:	    if ( !top->atLowerAddressThan(aAtom3) && !allowDuplicates )  goto TINC2;
loop.cc:388:	    this->iIndex2++;
loop.cc:389:	    if ( this->iIndex2 >= aAtom2->coordination() ) {
loop.cc:391:		this->iIndex1++;
loop.cc:392:		this->iIndex2 = 0;
loop.cc:393:		if ( this->iIndex1 >= aAtom1->coordination() ) {
loop.cc:395:		    this->iIndex0++;
loop.cc:396:		    this->iIndex1 = 0;
loop.cc:401:	this->atoms[0] = top;
loop.cc:402:	this->atoms[1] = aAtom1;
loop.cc:403:	this->atoms[2] = aAtom2;
loop.cc:404:	this->atoms[3] = aAtom3;
loop.cc:428:	    if ( this->_Impropers.size() == 0 )
loop.cc:430:		this->buildListOfImpropersCenteredOn(top);
loop.cc:431:		if ( this->_Impropers.size() == 0 ) goto FAIL;
loop.cc:432:		this->_ImproperIndex = 0;
loop.cc:434:	    if ( this->_ImproperIndex < this->_Impropers.size() )
loop.cc:437:		this->atoms[2] = top;
loop.cc:438:		bl = this->_Impropers[this->_ImproperIndex];
loop.cc:439:		this->atoms[3] = bl->atIndex(0)->getOtherAtom(top);
loop.cc:440:		this->atoms[0] = bl->atIndex(1)->getOtherAtom(top);
loop.cc:441:		this->atoms[1] = bl->atIndex(2)->getOtherAtom(top);
loop.cc:442:		LOG(BF("Pulled an improper off of the list: %s-%s-%s-%s")
loop.cc:443:		    % this->atoms[0]
loop.cc:444:		    % this->atoms[1]
loop.cc:445:		    % this->atoms[2]
loop.cc:446:		    % this->atoms[3] );
loop.cc:447:		this->_ImproperIndex++;
loop.cc:453:	    if ( this->iIndex1 <= this->iIndex0 )
loop.cc:454:		this->iIndex1 = this->iIndex0+1;
loop.cc:455:	    if ( this->iIndex2 <= this->iIndex1 )
loop.cc:456:		this->iIndex2 = this->iIndex1+1;
loop.cc:457:	    else this->iIndex2++;
loop.cc:458:	    if ( this->iIndex2 >= top->coordination() ) {
loop.cc:459:		this->iIndex1++;
loop.cc:460:		this->iIndex2 = this->iIndex1 + 1;
loop.cc:461:		if ( this->iIndex2 >= top->coordination()) {
loop.cc:462:		    this->iIndex0++;
loop.cc:463:		    this->iIndex1 = this->iIndex0 + 1;
loop.cc:464:		    this->iIndex2 = this->iIndex1 + 1;
loop.cc:467:	    if ( this->iIndex2 < (top->coordination()) ) {
loop.cc:468:		this->atoms[2] = top;
loop.cc:469:		this->atoms[0] = top->bondedNeighbor(this->iIndex0);
loop.cc:470:		this->atoms[1] = top->bondedNeighbor(this->iIndex1);
loop.cc:471:		this->atoms[3] = top->bondedNeighbor(this->iIndex2);
loop.cc:480:    this->clearAtomIndices();
loop.cc:498:    goalOnly = this->goal & GOALONLY;
loop.cc:509:	ANN(this->getCurSubLoopTop());
loop.cc:510:	if ( (this->getCurSubLoopTop()->getMatterType()==ATOM_CLASS) &&
loop.cc:511:		    (this->goal&NONCONTAINERLOOP)!=0 ){
loop.cc:513:	    if ( this->nextObjectInAtom() ) {
loop.cc:515:		retVal = this->getCurSubLoopTop();
loop.cc:522:	    LOG(BF("this->curSubLoop=%d") % this->curSubLoop  );
loop.cc:526:	    hitEnd = this->curSubLoopIteratorDone();
loop.cc:530:	        retVal = this->getCurSubLoopIteratorCur();
loop.cc:531:		LOG(BF("getCurSubLoopIteratorCur = %s") % retVal->description().c_str()  );
loop.cc:532:		this->curSubLoopAdvanceIteratorCur();
loop.cc:543:	    this->popSubLoop();
loop.cc:545:	    if ( this->noSubLoops() ) {
loop.cc:548:		this->done = true;
loop.cc:559:	LOG(BF("retVal->getMatterType() = %d") % retVal->getMatterType()  );
loop.cc:560:	if ( goalOnly == retVal->getMatterType() ) {
loop.cc:561:    	    LOG(BF("goalOnly == retVal->getMatterType() ") );
loop.cc:565:		if ( retVal->getMatterType()!=ATOM_CLASS ) 
loop.cc:567:    		    LOG(BF("retVal->getMatterType() !=ATOM_CLASS") );
loop.cc:568:		    this->pushSubLoop(retVal);
loop.cc:572:	    if ( retVal->getMatterType() == ATOM_CLASS ) {
loop.cc:583:	this->pushSubLoop(retVal);
loop.cc:594:// At the end of this function either this->currentObject is the next object
loop.cc:595:// or this->done == true, in which case this->currentObject is invalid.
loop.cc:603:    if ( this->done ) {
loop.cc:609:    goalOnly = this->goal & GOALONLY;
loop.cc:612:    retVal = this->nextHierarchyMatter();
loop.cc:614:    this->currentObject = retVal;
loop.cc:619:        LOG(BF("Loop::next returning with object: %s") % retVal->description().c_str()  );
macroModel.cc:85:    this->file = fopen(fn.c_str(),"r");
macroModel.cc:86:    fgets( caLine, sizeof(caLine), this->file );
macroModel.cc:88:    this->lines = iAtoms;
macroModel.cc:101:    this->file = fopen(fn.c_str(),"w");
macroModel.cc:112:    if ( this->file ) {
macroModel.cc:113:        return feof(this->file);
macroModel.cc:125:    fclose(this->file);
macroModel.cc:126:    this->file = NULL;
macroModel.cc:208://    I5 NIATMS (INTEGER*4) - The number of atoms in the entry
macroModel.cc:209://    A70 (CHARACTER*70) - The text name of the entry (optional)
macroModel.cc:225://    F11.6 (REAL*4) - X-coordinate in Angstroms.
macroModel.cc:226://    F11.6 (REAL*4) - Y-coordinate in Angstroms.
macroModel.cc:227://    F11.6 (REAL*4) - Z-coordinate in Angstroms.
macroModel.cc:228://    I5 (INTEGER*4) - Optional residue number (used only with biopolymers).
macroModel.cc:229://    A1 (CHARACTER*1) - Optional single-character MacroModel residue
macroModel.cc:231://    A1 (CHARACTER*1) - Optional single-character residue chain name.
macroModel.cc:232://    I4 (INTEGER*4) - Optional atom color (see below). If no color
macroModel.cc:234://		atom type-based color.
macroModel.cc:235://    2F9.5 (REAL*4) - Optional atomic charge in electron units (BatchMin
macroModel.cc:240://    A4 (CHARACTER*4) - Optional ascii residue name (e.g. PDB residue name)
macroModel.cc:241://    A4 (CHARACTER*4) - Optional ascii atom name (e.g. PDB atom name)
macroModel.cc:244:    iAtoms = this->lines;
macroModel.cc:246:	fgets( caLine, sizeof(caLine), this->file );
macroModel.cc:375:    mol = _lisp->create<Molecule_O>();
macroModel.cc:382:	    res = _lisp->create<Residue_O>();
macroModel.cc:384:	    res->setName(sTemp);
macroModel.cc:386:	    mol->addMatter(res);
macroModel.cc:398:	aPAtom = _lisp->create<Atom_O>();
macroModel.cc:406:	res->addAtom(aPAtom);
macroModel.cc:411:	aPAtom->setName(sTemp);
macroModel.cc:412:	aPAtom->setTypeString(mmodToAmberTypes[atoms[i].iType]);
macroModel.cc:413:	aPAtom->setElementFromString(mmodToAmberElement[atoms[i].iType]);
macroModel.cc:415:	aPAtom->setPosition(vPos);
macroModel.cc:416:        aPAtom->setCharge(atoms[i].dCharge );
macroModel.cc:428:		    aPTo = atoms[iTo-1].atom;
macroModel.cc:429:		    if ( aPAtom->atLowerAddressThan(aPTo) )
macroModel.cc:431:			aPAtom->bondTo(aPTo,iOrder);
macroModel.cc:441:    fgets( caLine, sizeof(caLine), this->file );
macroModel.cc:443:    this->lines = iAtoms;
matter.cc:51:	this->Base::initialize();
matter.cc:52:	this->_Id = 1; // UNDEFINED_ID;
matter.cc:53:	this->_NextContentId = 1;
matter.cc:54:	this->setContainedByNothing();
matter.cc:55:	this->_Restraints = _Nil<RestraintList_O>();
matter.cc:66:    me->name = name;
matter.cc:74:	this->name = translate::from_object<string>::convert(env->lookup(Matter_O::Package(),"name"));
matter.cc:83:	ss << this->className();
matter.cc:94:	this->_NextContentId = c._NextContentId;
matter.cc:95:	this->_Id = c._Id;
matter.cc:96:	this->name = c.name;
matter.cc:97:	this->containerContainedBy = c.containerContainedBy;
matter.cc:98:	this->_Properties = c._Properties;
matter.cc:99:	this->_Restraints = _Nil<RestraintList_O>();
matter.cc:111:	this->_contents.erase( this->_contents.begin(), this->_contents.end() );
matter.cc:122:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:123:	    LOG(BF("Looking at(%s) for(%s)") % (*aCur)->getName().c_str() % sName.c_str()  );
matter.cc:124:	    if ( (*aCur)->getName() == sName ) {
matter.cc:134:	allRestraints->merge(this->_Restraints);
matter.cc:135:	for ( const_contentIterator ci=this->begin_contents(); ci!=this->end_contents(); ci++ )
matter.cc:137:	    (*ci)->accumulateRestraints(allRestraints);
matter.cc:145:	this->accumulateRestraints(allRestraints);
matter.cc:153:	if ( this->_Restraints->isNil() )
matter.cc:155:	    this->_Restraints = _lisp->create<RestraintList_O>();
matter.cc:157:	this->_Restraints->addRestraint(restraint);
matter.cc:165:	this->_contents.resize(sz,_Nil<Matter_O>());
matter.cc:171:	ASSERTF(idx>=0 && idx<(int)this->_contents.size(),BF("Illegal putMatter index[%d] must be less than %d") % idx % this->_contents.size());
matter.cc:172:	this->_contents[idx] = matter;
matter.cc:173:	matter->setContainedBy(this->sharedThis<Matter_O>());
matter.cc:174:	matter->setId(idx);
matter.cc:180:	ss << "Properties for matter[" << this->__repr__() << "]"<<endl;
matter.cc:181:	for (core::SymbolMap<core::T_O>::const_iterator it=this->_Properties.begin();
matter.cc:182:	     it!=this->_Properties.end(); it++ )
matter.cc:184:	    ss << it->first->__repr__() << "-->" << it->second->__repr__() << endl;
matter.cc:193:	this->_Properties.erase(prop);
matter.cc:198:	this->_Properties.set(prop,val);
matter.cc:203:	this->_Properties.set(prop,_lisp->_boolean(true));
matter.cc:208:	if ( this->_Properties.count(prop) == 0 )
matter.cc:211:	    props << core::StringSet_O::create_fromKeysOfSymbolMap(this->_Properties,_lisp)->asString();
matter.cc:212:	    SIMPLE_ERROR(BF("You asked for an unknown property[%s] for matter[%s@%p] - the available properties are[%s]") % prop->__repr__() % this->__repr__() % this % props.str()  );
matter.cc:214:	return this->_Properties.get(prop,_lisp);
matter.cc:219:	if ( this->_Properties.count(prop) == 0 )
matter.cc:223:	return this->_Properties.get(prop,_lisp);
matter.cc:228:	return ( this->_Properties.count(prop) != 0 );
matter.cc:236:	l.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:240:	    if ( a->getName() == name )
matter.cc:245:	THROW(_lisp->create<core::ContentException_O>("Could not find atom with name: "+name));
matter.cc:252:	l.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:256:	    if ( a->isOfClass<VirtualAtom_O>() )
matter.cc:258:		VirtualAtom_sp va = a->as<VirtualAtom_O>();
matter.cc:259:		va->calculatePosition();
matter.cc:269:	la.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:275:	for ( ai=atoms.begin(); ai<atoms.end()-1; ai++ )
matter.cc:277:	    Vector3 aipos = (*ai)->getPosition();
matter.cc:280:		Vector3 ajpos = (*aj)->getPosition();
matter.cc:281:		if ( fabs(ajpos.getX()-aipos.getX()) > 2.0 ) continue;
matter.cc:282:		if ( fabs(ajpos.getY()-aipos.getY()) > 2.0 ) continue;
matter.cc:283:		if ( fabs(ajpos.getZ()-aipos.getZ()) > 2.0 ) continue;
matter.cc:284:		if ( (*ai)->isBondedTo(*aj) ) continue;
matter.cc:287:		(*ai)->bondToSingle(*aj);
matter.cc:306:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:307:	    LOG(BF("Looking at(%s) for(%s)") % (*aCur)->getName().c_str() % sName.c_str()  );
matter.cc:308:	    if ( (*aCur)->getName() == sName ) {
matter.cc:312:	LOG(BF("Matter(%s) with %d contents does not contain content with name(%s)") % this->name.c_str() % this->_contents.size() % sName.c_str()  );
matter.cc:314:	ss << this->className() << " (" << this->name << ") does not contain name(" << sName << ")";
matter.cc:315:	THROW(_lisp->create<core::ContentException_O>(ss.str()));
matter.cc:326:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:327:	    LOG(BF("Looking at(%s) for(%s)") % (*aCur)->getName().c_str() % sName.c_str()  );
matter.cc:328:	    if ( (*aCur)->getName() == sName ) {
matter.cc:340:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
matter.cc:342:	    (*aCur)->makeAllAtomNamesInEachResidueUnique();
matter.cc:349:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
matter.cc:351:	    (*aCur)->fillInImplicitHydrogensOnCarbon();
matter.cc:358:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
matter.cc:360:	    (*aCur)->randomizeAtomPositions();
matter.cc:368:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
matter.cc:370:	    (*aCur)->perturbAtomPositions(dist);
matter.cc:386:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++, i++ ) {
matter.cc:387:	    if ( (*aCur)->getName() == sName ) {
matter.cc:392:	ss << this->description() <<") does not contain name("<<sName<<")";
matter.cc:405:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:407:	    LOG(BF("Looking at content with id(%d)") % c->getId() );
matter.cc:408:	    if ( c->getId() == lid ) {
matter.cc:414:	ss << this->description() << ") does not contain id("<<lid<<")";
matter.cc:425:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:427:	    LOG(BF("Looking at content with id(%d)") % c->getId() );
matter.cc:428:	    if ( c->getId() == lid ) {
matter.cc:447:	LOG(BF("Looking in container(%s) type(%c) for content with storageId(%d)") % this->name.c_str() % this->containerType % lid );
matter.cc:448:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:450:	    LOG(BF("Looking at content with id(%d)") % c->getId() );
matter.cc:451:	    if ( c->getStorageId() == lid ) {
matter.cc:458:	ss << "Matter("<<this->name<<") type("<<this->containerType<<") does not contain id("<<lid<<")";
matter.cc:469:	LOG(BF("Looking in container(%s) type(%c) for content with storageId(%d)") % this->name.c_str() % this->containerType % lid );
matter.cc:470:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) {
matter.cc:472:	    LOG(BF("Looking at content with id(%d)") % c->getId() );
matter.cc:473:	    if ( c->getStorageId() == lid ) {
matter.cc:493:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++, i++ ) {
matter.cc:495:	    if ( c->getId() == lid ) {
matter.cc:499:	strncpy( str1, &(this->name[0]), this->name.length() );
matter.cc:500:	str1[this->name.length()] = '\0';
matter.cc:518:	for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++, i++ ) {
matter.cc:523:	strncpy( str1, &(this->name[0]), this->name.length() );
matter.cc:524:	str1[this->name.length()] = '\0';
matter.cc:525:	strncpy( str2, &(cc->getName()[0]), (cc->getName()).length() );
matter.cc:526:	str2[(cc->getName()).length()] = '\0';
matter.cc:538:	LOG(BF("Adding: %s of type: %c") % cp->getName().c_str() % cp->getMatterType()  );
matter.cc:539:	ctemp = this->sharedThis<Matter_O>();
matter.cc:540:	cp->setContainedBy(ctemp);
matter.cc:541:	LOG(BF("Adding %c:0x%08x to parent %c:0x%08x") % (cp->getMatterType()) % (cp.get()) % (this->getMatterType()) % (this ) );
matter.cc:545:	this->_contents.push_back(cp);
matter.cc:546:	if ( this->_Id == UNDEFINED_ID )
matter.cc:548:	    this->_Id = this->_NextContentId;
matter.cc:549:	    this->_NextContentId++;
matter.cc:564:	    % this->description()
matter.cc:565:	    % cp->description() );
matter.cc:566:	ctemp = this->sharedThis<Matter_O>();
matter.cc:567:	cp->setContainedBy(ctemp);
matter.cc:568:	LOG(BF("Adding %c:0x%08x to parent %c:0x%08x") % (cp->getMatterType()) % (cp.get()) % (this->getMatterType()) % (this ) );
matter.cc:572:	this->_contents.push_back(cp);
matter.cc:573:	if (this->_NextContentId <= cp->_Id ) 
matter.cc:575:	    this->_NextContentId = cp->_Id+1;
matter.cc:588:	if ( this->_NextContentId < i ) {
matter.cc:589:	    this->_NextContentId = i+1;
matter.cc:591:	this->_Id = i;
matter.cc:604:	for ( a=this->_contents.begin(); a!=this->_contents.end(); a++ ) {
matter.cc:605:	    (*a)->applyTransformToAtoms(m);
matter.cc:616:	for ( a=this->_contents.begin(); a!=this->_contents.end(); a++ )
matter.cc:618:	    (*a)->invertStructureAndRestraints();
matter.cc:620:	this->invertStereochemistryOfRestraints();
matter.cc:627:	if ( this->_Restraints.notnilp() )
matter.cc:630:	    for ( it=this->_Restraints->begin(); it!=this->_Restraints->end(); it++ )
matter.cc:632:		(*it)->invertStereochemistryOfRestraint();
matter.cc:642:	this->applyTransformToAtoms(transform);
matter.cc:648:	Matter_sp outer = this->sharedThis<Matter_O>();
matter.cc:652:	    if ( !outer->containedByValid() ) return false;
matter.cc:653:	    outer = outer->containedByLock();
matter.cc:662:	if ( this->containedByValid() ) {
matter.cc:663:	    if ( (parentShouldBe != Matter_sp(this->containedBy())) ) {
matter.cc:665:		LOG(BF("  My name/type = %s/%c") % this->getName().c_str() % this->getMatterType()  );
matter.cc:666://	    LOG(BF("  My parent address = %x  was supposed to be: %x") % &(Matter_sp(this->containedBy))() % &parentShouldBe  );
matter.cc:672:	c = this->sharedThis<Matter_O>();
matter.cc:673:	for ( a=this->_contents.begin(); a!=this->_contents.end(); a++ ) {
matter.cc:675:	    if ( !(c->testConsistancy(this->sharedThis<Matter_O>())) ) {
matter.cc:690://    oldParent = this->containedBy();
matter.cc:691:	this->setContainedBy(newParent);
matter.cc:692:	newParent->addMatter(this->sharedThis<Matter_O>());
matter.cc:699:	l.loopTopGoal(this->sharedThis<Matter_O>(),RESIDUES);
matter.cc:705:	    netCharge += r->getNetCharge();
matter.cc:715:	l.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:720:	    a->setMask(m);
matter.cc:742:	if ( this->isOfClass<Atom_O>() )
matter.cc:746:	LOG(BF("setAtomAliasesForResiduesNamed with parts(%s) atomAliases(%s)") % parts->__repr__().c_str() % atomAliases->__repr__().c_str()  );
matter.cc:748:	for ( core::Cons_sp cur = parts; cur.notnilp(); cur=cur->cdr() )
matter.cc:750:	    core::Cons_sp oneExtend = cur->car<core::Cons_O>();
matter.cc:751:	    if ( oneExtend->length() != 2 )
matter.cc:753:		SIMPLE_ERROR(BF("Each entry must have two elements: "+oneExtend->__repr__() ));
matter.cc:755:	    core::Str_sp residueName = oneExtend->car<core::Str_O>();
matter.cc:756:	    core::Cons_sp aliasAtoms = oneExtend->ocadr()->as<core::Cons_O>();
matter.cc:757:	    LOG(BF("residueName(%s) aliasAtoms(%s)") % residueName->get().c_str() % aliasAtoms->__repr__().c_str() );
matter.cc:758:	    residueNamesToAliasAtoms[residueName->get()] = aliasAtoms;
matter.cc:764:	lResidues.loopTopGoal(this->sharedThis<Matter_O>(),RESIDUES);
matter.cc:768:	    if ( residueNamesToAliasAtoms.count(res->getName())>0 )
matter.cc:770:		LOG(BF("%s:%d Setting aliases for residue(%s)") % (__FILE__) % (__LINE__) % (res->getName().c_str()) );
matter.cc:771:		core::Cons_sp aliasAtoms = residueNamesToAliasAtoms[res->getName()];
matter.cc:772:		LOG(BF("setting aliases for residueName(%s) aliasAtoms(%s) atomAliases(%s)") % res->getName().c_str() % aliasAtoms->__repr__().c_str() % atomAliases->__repr__().c_str() );
matter.cc:773:		res->setAliasesForAtoms(aliasAtoms,atomAliases);
matter.cc:776:		LOG(BF("%s:%d Not setting aliases for residue(%s)") % (__FILE__) % (__LINE__) % (res->getName().c_str()) );
matter.cc:792:	c = this->sharedThis<Matter_O>();
matter.cc:798:	    sum = sum + a->getPosition();
matter.cc:818:	c = this->sharedThis<Matter_O>();
matter.cc:825:	    bbox->expandToEncompassPoint(a->getPosition());
matter.cc:828:	bbox->pad(pad);
matter.cc:837:	for ( it=this->_contents.end()-1; it>=this->_contents.begin(); it-- )
matter.cc:850:	atoms = _lisp->create<addon::ObjectList_O>();
matter.cc:851:	la.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:854:	    atoms->append(la.getAtom());
matter.cc:865:	atoms = _lisp->create<addon::ObjectList_O>();
matter.cc:866:	la.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:870:	    if ( a->getElement() == element )
matter.cc:872:		atoms->append(a);
matter.cc:882:	lRes.loopTopGoal(this->sharedThis<Matter_O>(),RESIDUES);
matter.cc:885:	    if ( lRes.getResidue()->recognizesMonomerAlias(alias->getMonomerAlias()) )
matter.cc:895:	Residue_sp a = this->aliasResidueOrNil(alias);
matter.cc:902:	Residue_sp res = this->aliasResidueOrNil(alias);
matter.cc:903:	if ( res->isNil() ) return Atom_O::_nil;
matter.cc:904:	return res->atomWithAliasOrNil(alias->getAtomAlias());
matter.cc:909:	Atom_sp a = this->aliasAtomOrNil(alias);
matter.cc:924:	la.loopTopGoal(this->sharedThis<Matter_O>(),ATOMS);
matter.cc:928:	    if ( a->getElement() == element )
matter.cc:940:	node->attribute<string>("name",this->name);
matter.cc:941:	LOG(BF("Got name(%s)") % this->name.c_str()  );
matter.cc:942:	node->attribute<int>("id",this->_Id);
matter.cc:943:	node->archiveObjectIfDefined("restraints",this->_Restraints);
matter.cc:944:	node->archiveSymbolMapIfDefined("properties",this->_Properties);
matter.cc:945://    this->containerContainedBy = node->archiveWeakPointer("parent",
matter.cc:946://    		this->containerContainedBy);
matter.cc:949:	if ( node->saving() ) {
matter.cc:950:	    LOG(BF("About to archive the contents of a Matter_O %d objects") % this->_contents.size()  );
matter.cc:953:	node->archiveObjectVector<Matter_O>("c",this->subMatter()+"s",this->_contents);
matter.cc:955:	if ( node->loading() ) {
matter.cc:956:	    _BLOCK_TRACEF(BF("serializing container contents - there are %d objects")% this->_contents.size() );
matter.cc:958:	    Matter_sp c = this->sharedThis<Matter_O>();
matter.cc:960:	    for ( ai=this->_contents.begin(); ai!=this->_contents.end(); ai++ ) {
matter.cc:961:		(*ai)->setContainedBy(c);
matter.cc:974:	node->attribute<string>("name",this->name);
matter.cc:975:	node->attribute<int>("id",this->_Id);
matter.cc:976:	node->archiveObjectIfDefined("restraints",this->_Restraints);
matter.cc:977:	node->archiveSymbolMapIfDefined("properties",this->_Properties);
matter.cc:979:	if ( node->saving() )
matter.cc:981:	    LOG(BF("About to archive the contents of a Matter_O %d objects") % this->_contents.size()  );
matter.cc:984:	node->archiveObjectVectorIfNotEmpty<Matter_O>("c",this->subMatter()+"s",this->_contents);
matter.cc:986:	if ( node->loading() )
matter.cc:988:	    _BLOCK_TRACEF(BF("serializing container contents - there are %d objects")% this->_contents.size() );
matter.cc:990:	    Matter_sp c = this->sharedThis<Matter_O>();
matter.cc:992:	    for ( ai=this->_contents.begin(); ai!=this->_contents.end(); ai++ ) {
matter.cc:993:		(*ai)->setContainedBy(c);
matter.cc:1015:	Matter_sp matter = args->listref<Matter_O>(0);
matter.cc:1016:	core::Str_sp name = args->listref<core::Str_O>(1);
matter.cc:1017:	return matter->contentWithName(name->get());
matter.cc:1032:	Loop l(this->const_sharedThis<Matter_O>(),ATOMS);
matter.cc:1036:	    if ( !allowVirtualAtoms && a1->isVirtual() ) continue;
matter.cc:1047:	Loop l(this->const_sharedThis<Matter_O>(),BONDS);
matter.cc:1051:	    LOG(BF("Adding %s") % bond->description() );
matter.cc:1052:	    Atom_sp a1 = bond->getAtom1();
matter.cc:1053:	    Atom_sp a2 = bond->getAtom2();
matter.cc:1054:	    if ( !allowVirtualAtoms && ( a1->isVirtual() || a2->isVirtual() ) ) continue;
matter.cc:1065:	Loop l(this->const_sharedThis<Matter_O>(),ANGLES);
matter.cc:1071:	    if ( !allowVirtualAtoms && ( a1->isVirtual()
matter.cc:1072:					 || a2->isVirtual()
matter.cc:1073:					 || a3->isVirtual()
matter.cc:1085:	Loop l(this->const_sharedThis<Matter_O>(),IMPROPERS);
matter.cc:1095:		if ( !allowVirtualAtoms && ( a1->isVirtual()
matter.cc:1096:					     || a2->isVirtual()
matter.cc:1097:					     || a3->isVirtual()
matter.cc:1098:					     || a4->isVirtual() ) ) continue;
matter.cc:1113:	Loop l(this->const_sharedThis<Matter_O>(),PROPERS);
matter.cc:1120:	    if ( !allowVirtualAtoms && ( a1->isVirtual()
matter.cc:1121:					 || a2->isVirtual()
matter.cc:1122:					 || a3->isVirtual()
matter.cc:1123:					 || a4->isVirtual() ) ) continue;
matter.cc:1146:	if ( orig->_Restraints->isNil() )
matter.cc:1148:	    this->_Restraints = RestraintList_O::_nil;
matter.cc:1151:	    this->_Restraints = orig->_Restraints->copyDontRedirectAtoms();
matter.cc:1158:	if ( this->_Restraints.notnilp() )
matter.cc:1160:	    this->_Restraints->redirectAtoms();
mbbCoreTools.cc:48:	sum = sum + a->getPosition();
mbbCoreTools.cc:104:	    x = (*ai)->getPosition().getX() - a->getPosition().getX();
mbbCoreTools.cc:106:	    y = (*ai)->getPosition().getY() - a->getPosition().getY();
mbbCoreTools.cc:108:	    z = (*ai)->getPosition().getZ() - a->getPosition().getZ();
mbbCoreTools.cc:144:    for ( rmain = residues.size()-1; rmain>= 0; rmain-- ) {
mbbCoreTools.cc:146:	    for ( rtemp = rmain-2; rtemp >= 0; rtemp-- ) {
mbbCoreTools.cc:154:	if ( rmain<((int)residues.size()-2) ) {
mbbCoreTools.cc:172:	for ( vector<Atom_sp>::iterator i1 = atoms.begin(); i1!=atoms.end()-1; i1++ )
mbbCoreTools.cc:174:	    Vector3 v1 = (*i1)->getPosition();
mbbCoreTools.cc:175://	    double rad1 = vdwRadiusForElement((*i1)->getElement());
mbbCoreTools.cc:178:		Vector3 v2 = (*i2)->getPosition();
mbbCoreTools.cc:179://		double rad2 = vdwRadiusForElement((*i2)->getElement());
mbbCoreTools.cc:182:		double maxLen = maximumBondLengthBetweenElements((*i1)->getElement(),(*i2)->getElement());
mbbCoreTools.cc:185:		    if (!(*i1)->isBondedTo(*i2))
mbbCoreTools.cc:187:			LOG(BF("Forming bond between atom(%s) and atom(%s) - they were %lf angstroms apart < max(%lf)") % (*i1)->description() % (*i2)->description() % len % maxLen );
mbbCoreTools.cc:188:			(*i1)->bondToSingle(*i2);
mbbCoreTools.cc:212://	lisp->print(BF("Number of unconnected atoms(%d)") % atoms.size() );
mbbCoreTools.cc:213://	lisp->print(BF("Number of atoms connected by vdw overlap(%d)") % numVdwConnected);
mbbCoreTools.cc:229:	    Vector3 pos = a->getPosition();
mbbCoreTools.cc:235:		result->insert(a);
mbbCoreTools.cc:253:	    result->insert(a);
minimizer.cc:5:   I have to fix this - for now, disable USE_POSIX_TIME */
minimizer.cc:92:    e->setMessage(msg);
minimizer.cc:116:    e->setMessage(msg);
minimizer.cc:140:    e->setMessage(msg);
minimizer.cc:147:#define	EPS	1.0e-10
minimizer.cc:148:#define	TOL	2.0e-4
minimizer.cc:150:#define ZEPS 1.0e-10
minimizer.cc:155:#define	SIGN(a,b)	((b)>0.0?fabs(a):-fabs(a))
minimizer.cc:157:#define	TINY	1.0e-20
minimizer.cc:168:#define NOTFOUND                        -1
minimizer.cc:189:	    return "-unknown preconditioner-";
minimizer.cc:191:	return "-unknown preconditioner-";
minimizer.cc:220:    options->setBoolValueIfAvailable(this->_ShowElapsedTime,":showElapsedTime");
minimizer.cc:305:	switch (this->_Status) {
minimizer.cc:325:	status = status + "-" + stringForPreconditionerType(this->_CurrentPreconditioner);
minimizer.cc:338:    if ( givenEnergyFunction->isNil() )
minimizer.cc:340:	if ( matter.notnilp() && forceField->notNil() )
minimizer.cc:344:	    ef->defineForMatter(matter,forceField);
minimizer.cc:345:	    me->setEnergyFunction(ef);
minimizer.cc:349:	if ( matter->isNil() && forceField->isNil() )
minimizer.cc:352:	    me->setEnergyFunction(givenEnergyFunction);
minimizer.cc:366:	this->Base::__init__(exec,args,env,lisp);
minimizer.cc:368:	Matter_sp matter = env->lookup(lisp->internWithPackageName(ChemPkg,"matter"))->as<Matter_O>();
minimizer.cc:369:	ForceField_sp forceField = env->lookup(lisp->internWithPackageName(ChemPkg,"forceField"))->as<ForceField_O>();
minimizer.cc:370:	EnergyFunction_sp givenEnergyFunction = env->lookup(lisp->internWithPackageName(ChemPkg,"energyFunction"))->as<EnergyFunction_O>();
minimizer.cc:371:	if ( givenEnergyFunction->isNil() )
minimizer.cc:373:	    if ( matter.notnilp() && forceField->notNil() )
minimizer.cc:377:		ef->defineForMatter(matter,forceField);
minimizer.cc:378:		this->setEnergyFunction(ef);
minimizer.cc:382:	    if ( matter->isNil() && forceField->isNil() )
minimizer.cc:385:		this->setEnergyFunction(givenEnergyFunction);
minimizer.cc:400:	node->attribute("_InitialLineSearchStep",this->_InitialLineSearchStep);
minimizer.cc:401:	node->attribute("_ShowElapsedTime",this->_ShowElapsedTime);
minimizer.cc:402:	node->attribute("_SteepestDescentTolerance",this->_SteepestDescentTolerance);
minimizer.cc:403:	node->attribute("_NumberOfSteepestDescentSteps",this->_NumberOfSteepestDescentSteps);
minimizer.cc:404:	node->attribute("_NumberOfConjugateGradientSteps",this->_NumberOfConjugateGradientSteps);
minimizer.cc:405:	node->attribute("_ConjugateGradientTolerance",this->_ConjugateGradientTolerance);
minimizer.cc:406:	node->attribute("_NumberOfTruncatedNewtonSteps",this->_NumberOfTruncatedNewtonSteps);
minimizer.cc:407:	node->attribute("_TruncatedNewtonTolerance",this->_TruncatedNewtonTolerance);
minimizer.cc:408:	node->archiveObject("energyFunction",this->_EnergyFunction );
minimizer.cc:410://    node->attribute("_ZZ",this->_ZZ);
minimizer.cc:417:	switch (this->_Status) {
minimizer.cc:436:	status = status + shortStringForPreconditionerType(this->_CurrentPreconditioner);
minimizer.cc:445:    this->_StepCallback = cb;
minimizer.cc:450:    this->_DebugOn = true;
minimizer.cc:452:    this->_Log = MinimizerLog_O::create();
minimizer.cc:454:    this->_Log->_Minimizer = this->sharedThis<Minimizer_O>();
minimizer.cc:462:    if ( !this->_DebugOn ) return;
minimizer.cc:463:    ASSERTNOTNULL(this->_Log);
minimizer.cc:468:    arc->put("minimizerLog",this->_Log);
minimizer.cc:470:    arc->saveAs(fileName);
minimizer.cc:486:	nvResult->XPlusYTimesScalar(nvOrigin,nvDirection,x);
minimizer.cc:502:	dEnergy = this->_EnergyFunction->evaluateEnergy( nvPos );
minimizer.cc:519:	return this->_EnergyFunction->evaluateEnergyForce(nvPos,true,nvForce);
minimizer.cc:531://    this->nvP1DSearchOrigin->debugDump("origin");
minimizer.cc:533://    this->nvP1DSearchDirection->debugDump("direction");
minimizer.cc:535:	this->getPosition(this->nvP1DSearchTemp1, this->nvP1DSearchOrigin, this->nvP1DSearchDirection,x);
minimizer.cc:536:	return this->_EnergyFunction->evaluateEnergy(this->nvP1DSearchTemp1);
minimizer.cc:548://    this->nvP1DSearchOrigin->debugDump("origin");
minimizer.cc:550://    this->nvP1DSearchDirection->debugDump("direction");
minimizer.cc:552:	this->getPosition(this->nvP1DSearchTemp1,
minimizer.cc:553:			  this->nvP1DSearchOrigin,
minimizer.cc:554:			  this->nvP1DSearchDirection, x );
minimizer.cc:555:	*fx = this->_EnergyFunction->evaluateEnergyForce( this->nvP1DSearchTemp1,
minimizer.cc:556:							  true, this->nvP1DSearchTemp2 );
minimizer.cc:557:	*dfx = -(this->nvP1DSearchTemp2)->dotProduct(this->nvP1DSearchDirection);
minimizer.cc:587:    this->_MinBracketSteps = 0;
minimizer.cc:590:    fa = this->d1DTotalEnergy(xa);
minimizer.cc:591:    fb = this->d1DTotalEnergy(xb);
minimizer.cc:592:    // Make sure that we are going downhill a->b
minimizer.cc:597:    xc = xb+GOLD*(xb-xa);
minimizer.cc:598:    fc = this->d1DTotalEnergy(xc);
minimizer.cc:601:	this->_MinBracketSteps++;
minimizer.cc:603:	r = (xb-xa)*(fb-fc);
minimizer.cc:604:	q = (xb-xc)*(fb-fa);
minimizer.cc:605:	u = xb-((xb-xc)*q-(xb-xa)*r)/
minimizer.cc:606:	    (2.0*SIGN(MAX(fabs(q-r),TINY),q-r));
minimizer.cc:607:	ulim = (xb)+GLIMIT*(xc-xb);
minimizer.cc:608:	if (( xb-u)*(u-xc)>0.0) {
minimizer.cc:609:	    fu = this->d1DTotalEnergy(u);
minimizer.cc:621:	    u = xc+GOLD*(xc-xb);
minimizer.cc:622:	    fu = this->d1DTotalEnergy(u);
minimizer.cc:623:	} else if ((xc-u)*(u-ulim) > 0.0) {
minimizer.cc:624:	    fu = this->d1DTotalEnergy(u);
minimizer.cc:626:		LEFT_SHIFT_VALUES( xb, xc, u, xc+GOLD*(xc-xb) );
minimizer.cc:627:		LEFT_SHIFT_VALUES( fb, fc, fu, this->d1DTotalEnergy(u));
minimizer.cc:630:	} else if ((u-ulim)*(ulim-xc)>=0.0 ){
minimizer.cc:632:	    fu = this->d1DTotalEnergy(u);
minimizer.cc:634:	    u = xc+GOLD*(xc-xb);
minimizer.cc:635:	    fu = this->d1DTotalEnergy(u);
minimizer.cc:706:	if (fabs(x-xm) <=(tol2-0.5*(_b-_a))) {	// Stopping criterion
minimizer.cc:709:	    LOG(BF("done due to (fabs(x-xm).LE.(tol2-0.5*(_b-_a)))") );
minimizer.cc:713:	    d1=2.0*(_b-_a);
minimizer.cc:715:	    if (dw != dx ) d1=(w-x)*dx/(dx-dw); // Secant method, first on one, then on
minimizer.cc:716:	    if (dv != dx ) d2=(v-x)*dx/(dx-dv); // the other point
minimizer.cc:722:	    ok1=(_a-u1)*(u1-_b)>0.0 && dx*d1 <= 0.0;
minimizer.cc:723:	    ok2=(_a-u2)*(u2-_b)>0.0 && dx*d2 <= 0.0;
minimizer.cc:736:		    if ( u-_a<tol2 || _b-u < tol2 )
minimizer.cc:737:		        _d = SIGN(tol1,xm-x);
minimizer.cc:739:		    _e=(dx>=0.0?_a-x:_b-x); // Bisect, not golden section
minimizer.cc:745:	        _e=(dx>=0.0?_a-x:_b-x);
minimizer.cc:749:	    _e=(dx>=0.0?_a-x:_b-x);
minimizer.cc:790:    retval = -1.0;
minimizer.cc:805:	lenForce = nvForce->magnitude();
minimizer.cc:806:	lenDir = nvDir->magnitude();
minimizer.cc:810:	    cosAngle = nvDir->dotProduct(nvForce)/(lenForce*lenDir);
minimizer.cc:812:	    if ( cosAngle < -1.0 ) cosAngle = -1.0;
minimizer.cc:815:	report->_AngleBetweenDirectionAndForceDeg = angle/0.0174533;
minimizer.cc:816:	report->_Xa = xa;
minimizer.cc:817:	report->_Xb = xb;
minimizer.cc:818:	report->_Xc = xc;
minimizer.cc:819:	report->_Fa = fa;
minimizer.cc:820:	report->_Fb = fb;
minimizer.cc:821:	report->_Fc = fc;
minimizer.cc:822:	report->_MinBracketSteps = this->_MinBracketSteps;
minimizer.cc:823:	report->_EnergyTermsEnabled = this->_EnergyFunction->energyTermsEnabled();
minimizer.cc:824:	report->_TotalEnergy = this->d1DTotalEnergy(0.0);
minimizer.cc:825:	report->_DirectionMagnitude = nvDir->magnitude();
minimizer.cc:826:	report->_ForceMagnitude = nvForce->magnitude();
minimizer.cc:827:	report->_MinimizerStatus = this->statusAsString();
minimizer.cc:832:	    report->_Direction = "searchForward";
minimizer.cc:836:	    report->_Direction = "searchBackward";
minimizer.cc:840:	double xinc = (dxc-dxa)/100.0;
minimizer.cc:841:	report->_LineSearchPosition = nvPos->deepCopy()->as<NVector_O>();
minimizer.cc:842:	report->_LineSearchDirection = nvDir->deepCopy()->as<NVector_O>();
minimizer.cc:843:	report->_TotalEnergyFn = NumericalFunction_O::create("Alpha","Total",xmin,xinc,_lisp);
minimizer.cc:844:	report->_StretchEnergyFn = NumericalFunction_O::create("Alpha","Stretch",xmin,xinc,_lisp);
minimizer.cc:845:	report->_AngleEnergyFn = NumericalFunction_O::create("Alpha","Angle",xmin,xinc,_lisp);
minimizer.cc:846:	report->_DihedralEnergyFn = NumericalFunction_O::create("Alpha","Dihedral",xmin,xinc,_lisp);
minimizer.cc:847:	report->_NonbondEnergyFn = NumericalFunction_O::create("Alpha","Nonbond",xmin,xinc,_lisp);
minimizer.cc:848:	report->_ImproperEnergyFn = NumericalFunction_O::create("Alpha","Improper",xmin,xinc,_lisp);
minimizer.cc:849:	report->_ChiralRestraintEnergyFn = NumericalFunction_O::create("Alpha","ChiralRestraint",xmin,xinc,_lisp);
minimizer.cc:850:	report->_AnchorRestraintEnergyFn = NumericalFunction_O::create("Alpha","AnchorRestraint",xmin,xinc,_lisp);
minimizer.cc:851:	report->_FixedNonbondRestraintEnergyFn = NumericalFunction_O::create("Alpha","FixedNonbondRestraint",xmin,xinc,_lisp);
minimizer.cc:853:	for ( zx=dxa;zx<=dxc;zx+=(dxc-dxa)/100.0 ) {
minimizer.cc:854:	    zy = this->d1DTotalEnergy(zx);
minimizer.cc:855:	    report->_TotalEnergyFn->appendValue(zy);
minimizer.cc:856:	    report->_StretchEnergyFn->appendValue(
minimizer.cc:857:		this->_EnergyFunction->getStretchComponent()->getEnergy());
minimizer.cc:859:	    report->_AngleEnergyFn->appendValue(
minimizer.cc:860:		this->_EnergyFunction->getAngleComponent()->getEnergy());
minimizer.cc:861:	    report->_DihedralEnergyFn->appendValue(
minimizer.cc:862:		this->_EnergyFunction->getDihedralComponent()->getEnergy());
minimizer.cc:863:	    report->_NonbondEnergyFn->appendValue(
minimizer.cc:864:		this->_EnergyFunction->getNonbondComponent()->getEnergy());
minimizer.cc:865:	    report->_ImproperEnergyFn->appendValue(
minimizer.cc:866:		this->_EnergyFunction->getImproperRestraintComponent()->getEnergy());
minimizer.cc:867:	    report->_ChiralRestraintEnergyFn->appendValue(
minimizer.cc:868:		this->_EnergyFunction->getChiralRestraintComponent()->getEnergy());
minimizer.cc:869:	    report->_AnchorRestraintEnergyFn->appendValue(
minimizer.cc:870:		this->_EnergyFunction->getAnchorRestraintComponent()->getEnergy());
minimizer.cc:871:	    report->_FixedNonbondRestraintEnergyFn->appendValue(
minimizer.cc:872:		this->_EnergyFunction->getFixedNonbondRestraintComponent()->getEnergy());
minimizer.cc:880:    THROW(_lisp->create<MinimizerExceededMaxSteps_O>("test throw of MinimizerExceededMaxSteps"));
minimizer.cc:885:    THROW(_lisp->create<MinimizerStuck_O>("test throw of MinimizerStuck"));
minimizer.cc:891:    THROW(_lisp->create<MinimizerError_O>("test throw of MinimizerError"));
minimizer.cc:899:    ASSERT(report->_Iteration == this->_Iteration);
minimizer.cc:900:    report->_DbrentSteps = dbrentSteps;
minimizer.cc:901:    report->_EnergyEvals = energyEvals;
minimizer.cc:902:    report->_ForceEvals = forceEvals;
minimizer.cc:903:    report->_Step = step;
minimizer.cc:904:    report->_FMin = fMin;
minimizer.cc:910:    ASSERT(report->_Iteration == this->_Iteration);
minimizer.cc:911:    report->_ForceMagnitude = force->magnitude();
minimizer.cc:912:    report->_TotalEnergy = energy;
minimizer.cc:913:    report->_IterationMessages = this->_IterationMessages.str();
minimizer.cc:944:    this->define1DSearch(nvOrigin,nvDirection,nvTemp1,nvTemp2);
minimizer.cc:945:    double directionMag = nvDirection->magnitude();
minimizer.cc:947:	xb = this->_InitialLineSearchStep;
minimizer.cc:949:	xb = this->_InitialLineSearchStep/directionMag;
minimizer.cc:957:    this->minBracket( nvOrigin, nvDirection,
minimizer.cc:962:    if ( this->_DebugOn )
minimizer.cc:964:	this->lineSearchInitialReport(report,nvOrigin,nvDirection,nvForce,
minimizer.cc:978:    if ( this->_DebugOn )
minimizer.cc:980:	this->lineSearchFinalReport( report, step, fb, energyEvals,
minimizer.cc:1005:	if ( this->_Iteration%10 == 1 || this->_DebugOn ) 
minimizer.cc:1007:	    sout << "---Stage--";
minimizer.cc:1008:	    if ( this->_ShowElapsedTime )
minimizer.cc:1010:		sout << "Seconds-";
minimizer.cc:1012:	    sout << "Step-----Alpha---Dir-------------Energy-----------RMSforce";
minimizer.cc:1013:	    if ( this->_EnergyFunction->getName() != "" ) 
minimizer.cc:1015:		sout << "-------Name";
minimizer.cc:1019:	sout << BF(" min%4s") % this->statusAsShortString();
minimizer.cc:1020:	if ( this->_ShowElapsedTime )
minimizer.cc:1023:	    core::PosixTimeDuration_sp elapsed = core::PosixTimeDuration_O::createDurationSince(this->_StartTime);
minimizer.cc:1024:	    sout << BF(" %8ld") % elapsed->totalSeconds();
minimizer.cc:1027:	sout << BF(" %5d") % this->_Iteration;
minimizer.cc:1034:	    if ( cosAngle < -1.0 ) cosAngle = -1.0;
minimizer.cc:1045:	if ( this->_EnergyFunction->getName() != "" ) 
minimizer.cc:1047:	    sout << BF(" %s") % this->_EnergyFunction->getName();
minimizer.cc:1049:	_lisp->print(BF("%s") % sout.str() );
minimizer.cc:1050:	if ( this->_DebugOn ) 
minimizer.cc:1052:	    this->_Log->addMessage(buffer);
minimizer.cc:1080:	if ( this->_Status == minimizerError ) return;
minimizer.cc:1081:	this->_Status = steepestDescentRunning;
minimizer.cc:1082:	this->_CurrentPreconditioner = noPreconditioner;
minimizer.cc:1093:	iRestartSteps = x->size();
minimizer.cc:1105:	double fp = this->dTotalEnergyForce( x, force );
minimizer.cc:1107://    r->inPlaceTimesScalar(-1.0);
minimizer.cc:1109:	s->copyIntoMe(force);
minimizer.cc:1113:	// s = M^(-1)force rather than just copying it from force
minimizer.cc:1117:	    s->copy(force);
minimizer.cc:1121:	    m->fill(1.0);
minimizer.cc:1122:	    this->_EnergyFunction->backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1126:	    this->_EnergyFunction->setupDiagonalPreconditioner(x,m);
minimizer.cc:1127:	    LOG(BF("Preconditioner max value: %lf") % m->maxValue() );
minimizer.cc:1128:	    LOG(BF("Preconditioner min value: %lf") % m->minValue() );
minimizer.cc:1129:	    minVal = m->minValue();
minimizer.cc:1131:		m->addScalar(m,fabs(minVal)+1.0);
minimizer.cc:1133:	    this->_EnergyFunction->backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1139:	dir->copyIntoMe(s);
minimizer.cc:1140:	deltaNew = force->dotProduct(dir);
minimizer.cc:1147:	if ( this->_PrintIntermediateResults ) {
minimizer.cc:1148:	    _lisp->print(BF( "======= Starting Steepest Descent Minimizer" ));
minimizer.cc:1158:		forceMag = force->magnitude();
minimizer.cc:1159:		forceRmsMag = force->rmsMagnitude();
minimizer.cc:1160:		this->_RMSForce = forceRmsMag;
minimizer.cc:1162:		    if ( this->_PrintIntermediateResults ) {
minimizer.cc:1163:			_lisp->print(BF("DONE absolute force test:\nforceRmsMag(%lf).LT.forceTolerance(%lf)") % forceRmsMag % forceTolerance );
minimizer.cc:1168:		this->_IterationMessages.str("");
minimizer.cc:1182:// 1. F(x(k-1)) - F(xk) < T (1 + |F(xk)|)
minimizer.cc:1183:// 2. |x(k-1) - xk| < Sqrt(T)(1+|xk|)
minimizer.cc:1202:		    if ( this->_DebugOn )
minimizer.cc:1205:			stepReport->_Iteration = this->_Iteration;
minimizer.cc:1214:		    dirMag = dir->magnitude();
minimizer.cc:1218:			cosAngle = force->dotProduct(dir)/(forceMag*dirMag);
minimizer.cc:1221:			dir->copyIntoMe(force);
minimizer.cc:1229:		    if ( this->_PrintIntermediateResults ) {
minimizer.cc:1230:			this->_displayIntermediateMessage(step,fnew,forceMag,forceRmsMag,cosAngle,steepestDescent);
minimizer.cc:1233:		    this->lineSearch( &step, &fnew, x, dir, force, tv1, tv2, localSteps, stepReport );
minimizer.cc:1241:		    x->inPlaceAddTimesScalar( dir, step );
minimizer.cc:1243:		    // r = -f'(x)   r == force!!!!
minimizer.cc:1247:		    if ( this->_EnergyFunction->getMessages() != "" )
minimizer.cc:1249:			_lisp->print(BF("Minimizer_O::steepestDescentWithPreconditioner>> energy function messages: %s")%
minimizer.cc:1250:					    this->_EnergyFunction->getMessages());
minimizer.cc:1251:			this->_IterationMessages << this->_EnergyFunction->getMessages();
minimizer.cc:1255:		    if ( this->_DebugOn ) {
minimizer.cc:1256:			this->stepReport(stepReport,fp,force);
minimizer.cc:1261:		    this->validateForce(x,force);
minimizer.cc:1266:		    s->copyIntoMe(force);
minimizer.cc:1271:			s->copy(force);
minimizer.cc:1274:			m->fill(1.0);
minimizer.cc:1275:			this->_EnergyFunction->backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1279:			this->_EnergyFunction->setupDiagonalPreconditioner(x,m);
minimizer.cc:1280:			LOG(BF("Preconditioner max value: %lf") % m->maxValue()  );
minimizer.cc:1281:			LOG(BF("Preconditioner min value: %lf") % m->minValue()  );
minimizer.cc:1282:			minVal = m->minValue();
minimizer.cc:1284:			    m->addScalar(m,fabs(minVal)+1.0);
minimizer.cc:1286:			this->_EnergyFunction->backSubstituteDiagonalPreconditioner(m,s,force);
minimizer.cc:1287:			//		    if ( s->dotProduct(force) < 0 ) {
minimizer.cc:1288:			//			s->copy(force);
minimizer.cc:1296:		    dir->copyIntoMe(s);
minimizer.cc:1297:		    if ( this->_DebugOn )
minimizer.cc:1299:			ASSERTNOTNULL(this->_Log);
minimizer.cc:1300:			this->_Log->addReport(stepReport);
minimizer.cc:1304:		    this->_Iteration++;
minimizer.cc:1307:		if ( this->_StepCallback.notnilp() )
minimizer.cc:1309:		    this->_StepCallback->invoke(this->sharedThis<Minimizer_O>());
minimizer.cc:1314:	    if ( this->_DebugOn )
minimizer.cc:1319:		    stepReport->prematureTermination("ExceededNumSteps");
minimizer.cc:1320:		    this->_Log->addReport(stepReport);
minimizer.cc:1330:	    this->_EnergyFunction->writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1331:	    THROW(_lisp->create<MinimizerExceededMaxSteps_O>(fail.message()));
minimizer.cc:1334:	this->_EnergyFunction->writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1336:	if ( this->_DebugOn )
minimizer.cc:1343:		stepReport->prematureTermination("Stuck");
minimizer.cc:1344:		ASSERTNOTNULL(this->_Log);
minimizer.cc:1346:		this->_Log->addReport(stepReport);
minimizer.cc:1378:    if ( this->_Status == minimizerError ) return;
minimizer.cc:1379:    this->_Status = conjugateGradientRunning;
minimizer.cc:1380:    this->_CurrentPreconditioner = noPreconditioner;
minimizer.cc:1388:    iRestartSteps = x->size();
minimizer.cc:1398://    r->inPlaceTimesScalar(-1.0);
minimizer.cc:1400:    // s = M^(-1)r rather than just copying it from r
minimizer.cc:1401:    s->copyIntoMe(force);
minimizer.cc:1405:	s->copy(force);
minimizer.cc:1409:	this->_EnergyFunction->setupDiagonalPreconditioner(x,diag);
minimizer.cc:1410:	LOG(BF("Preconditioner max value: %lf") % diag->maxValue() );
minimizer.cc:1411:	LOG(BF("Preconditioner min value: %lf") % diag->minValue() );
minimizer.cc:1412:	this->_EnergyFunction->backSubstituteDiagonalPreconditioner(diag,s,force);
minimizer.cc:1417:	m->fill(0.0);
minimizer.cc:1418:	ldlt->fill(0.0);
minimizer.cc:1419:	this->_EnergyFunction->setupHessianPreconditioner(x,m);
minimizer.cc:1420:	this->_EnergyFunction->unconventionalModifiedCholeskyFactorization(m,ldlt);
minimizer.cc:1421:	this->_EnergyFunction->backSubstituteLDLt(ldlt,s,force);
minimizer.cc:1427:    d->copyIntoMe(s);
minimizer.cc:1428:    deltaNew = force->dotProduct(d);
minimizer.cc:1436:    if ( this->_PrintIntermediateResults ) {
minimizer.cc:1437:	_lisp->print(BF( "======= Starting Conjugate Gradient Minimizer" ));
minimizer.cc:1446:	    forceMag = force->magnitude();
minimizer.cc:1447:	    forceRmsMag = force->rmsMagnitude();
minimizer.cc:1448:	    this->_RMSForce = forceRmsMag;
minimizer.cc:1450:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:1451:		    _lisp->print(BF("DONE absolute force test:\nforceRmsMag(%lf).LT.forceTolerance(%lf)")% forceRmsMag % forceTolerance );
minimizer.cc:1456:	    this->_IterationMessages.str("");
minimizer.cc:1460:		    if ( this->_PrintIntermediateResults )
minimizer.cc:1462:			_lisp->print(BF( "Exceeded max number of steps(%d)") % numSteps );
minimizer.cc:1471:		    MinimizerError_Stuck fail("CG-Two successive steps went nowhere!!!!");
minimizer.cc:1481:// 1. F(x(k-1)) - F(xk) < T (1 + |F(xk)|)
minimizer.cc:1482:// 2. |x(k-1) - xk| < Sqrt(T)(1+|xk|)
minimizer.cc:1500:		if ( this->_DebugOn )
minimizer.cc:1503:		    stepReport->_Iteration = this->_Iteration;
minimizer.cc:1508:		//	deltaD = d->squared();	// Used for secant method
minimizer.cc:1516:		dirMag = d->magnitude();
minimizer.cc:1523:		    cosAngle = force->dotProduct(d)/(forceMag*dirMag);
minimizer.cc:1526:		    d->copyIntoMe(force);
minimizer.cc:1531:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:1532:		    this->_displayIntermediateMessage(prevStep,fnew,forceMag,forceRmsMag,cosAngle,steepestDescent);
minimizer.cc:1535:		this->lineSearch( &step, &fnew, x, d, force,
minimizer.cc:1541:		// r = -f'(x)   r == force!!!!
minimizer.cc:1542:		x->inPlaceAddTimesScalar( d, step );
minimizer.cc:1546:		if ( this->_DebugOn )
minimizer.cc:1548:		    this->stepReport(stepReport,fp,force);
minimizer.cc:1553:		this->validateForce(x,force);
minimizer.cc:1556:		deltaMid = force->dotProduct(s);
minimizer.cc:1559:		s->copyIntoMe(force);
minimizer.cc:1563:		// s = M^(-1)r
minimizer.cc:1566:		    s->copy(force);
minimizer.cc:1569:		    this->_EnergyFunction->setupDiagonalPreconditioner(x,diag);
minimizer.cc:1570:		    LOG(BF("Preconditioner max value: %lf") % diag->maxValue() );
minimizer.cc:1571:		    LOG(BF("Preconditioner min value: %lf") % diag->minValue() );
minimizer.cc:1572:		    this->_EnergyFunction->backSubstituteDiagonalPreconditioner(diag,s,force);
minimizer.cc:1577:		    this->_EnergyFunction->setupHessianPreconditioner(x,m);
minimizer.cc:1578:		    this->_EnergyFunction->unconventionalModifiedCholeskyFactorization(m,ldlt);
minimizer.cc:1581:		    this->_EnergyFunction->backSubstituteLDLt(ldlt,s,force);
minimizer.cc:1587:		deltaNew = force->dotProduct(s);		// deltaNew = r.r
minimizer.cc:1588:		beta = (deltaNew-deltaMid)/deltaOld;
minimizer.cc:1591:		    d->copyIntoMe(s);
minimizer.cc:1595:		    d->XPlusYTimesScalar(s,d,beta);
minimizer.cc:1597:		if ( this->_DebugOn )
minimizer.cc:1599:		    ASSERTNOTNULL(this->_Log);
minimizer.cc:1600:		    this->_Log->addReport(stepReport);
minimizer.cc:1604:		this->_Iteration++;
minimizer.cc:1607:	    if ( this->_StepCallback.notnilp() )
minimizer.cc:1608:		this->_StepCallback->invoke(this->sharedThis<Minimizer_O>());
minimizer.cc:1612:	if ( this->_DebugOn )
minimizer.cc:1616:		stepReport->prematureTermination("ExceededNumSteps");
minimizer.cc:1617:		this->_Log->addReport(stepReport);
minimizer.cc:1626:	this->_EnergyFunction->writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1627:	THROW(_lisp->create<MinimizerExceededMaxSteps_O>(fail.message()));
minimizer.cc:1629:	if ( this->_DebugOn )
minimizer.cc:1633:		stepReport->prematureTermination("Stuck");
minimizer.cc:1634:		this->_Log->addReport(stepReport);
minimizer.cc:1643:	this->_EnergyFunction->writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1644:	THROW(_lisp->create<MinimizerStuck_O>(fail.message()));
minimizer.cc:1647:    this->_EnergyFunction->writeCoordinatesAndForceToAtoms(x,force);
minimizer.cc:1648:    if ( this->_DebugOn )
minimizer.cc:1652:	    stepReport->prematureTermination("Stuck");
minimizer.cc:1653:	    this->_Log->addReport(stepReport);
minimizer.cc:1685:    ASSERTNOTNULL(this->_EnergyFunction);
minimizer.cc:1690:    if ( this->_DebugOn )
minimizer.cc:1692:	this->_Log->addMessage("_truncatedNewtonInnerLoop>>Starting\n");
minimizer.cc:1696:    pj->zero();	// NVector
minimizer.cc:1698:    delta = 10.0e-10;
minimizer.cc:1701:    rj->copyIntoMe(force);
minimizer.cc:1715:    LOG(BF("this->_EnergyFunction.use_count() = %d") % this->_EnergyFunction.use_count()  );
minimizer.cc:1718://    this->_EnergyFunction->unconventionalModifiedCholeskyFactorization(mprecon,ldlt);
minimizer.cc:1722:    // systems: (L)(x)=(rj) and (L^T)(zj)=(D^-1)(x)
minimizer.cc:1730:    dj->copyIntoMe(zj);
minimizer.cc:1732:    rjDotzj = rj->dotProduct(zj);
minimizer.cc:1736:    // Compute the matrix-vector product qj=(H)(dj)
minimizer.cc:1738:    // or |((dj)^T).(qj)|<=delta (e.g., delta=10^-10)
minimizer.cc:1742:    this->_EnergyFunction->evaluateAll( xk, true, nvDummy,
minimizer.cc:1747:    // rjDotzj = rj->dotProduct(zj);
minimizer.cc:1748:    djDotqj = dj->dotProduct(qj);
minimizer.cc:1751:	    pj->copyIntoMe(force);
minimizer.cc:1753:	if ( this->_DebugOn ) {
minimizer.cc:1756:	    this->_Log->addMessage(ss.str().c_str());
minimizer.cc:1757:	    this->_Log->addMessage("_truncatedNewtonInnerLoop>>Singularity test was true\n" );
minimizer.cc:1768:    //	{pj+1}->pj + alphaj*dj
minimizer.cc:1776:    pjNext->XPlusYTimesScalar(pj,dj,alphaj);
minimizer.cc:1777:    LOG(BF("pjNext angle with force=%lf(deg)") % pjNext->angleWithVector(force)/0.0174533 );
minimizer.cc:1778:    forceDotpjNext = force->dotProduct(pjNext);
minimizer.cc:1781:	    pj->copyIntoMe(force);
minimizer.cc:1783:	    // pk->copy(pj);  pk is pj
minimizer.cc:1785:	if ( this->_DebugOn ) {
minimizer.cc:1786:	    this->_Log->addMessage("_truncatedNewtonInnerLoop>>Descent direction test was true\n" );
minimizer.cc:1793:    // Compute rjNext = rj - (alphaj)(qj)
minimizer.cc:1799:    rj->inPlaceAddTimesScalar(qj,-alphaj);
minimizer.cc:1800:    rmsRjMag = rj->rmsMagnitude();
minimizer.cc:1803:	pj->copyIntoMe(pjNext);
minimizer.cc:1804:	if ( this->_DebugOn ) {
minimizer.cc:1805:	    this->_Log->addMessage("_truncatedNewtonInnerLoop>>Truncation test was true\n" );
minimizer.cc:1812:	pj->copyIntoMe(pjNext);
minimizer.cc:1813:	if ( this->_DebugOn ) {
minimizer.cc:1814:	    this->_Log->addMessage("_truncatedNewtonInnerLoop>>Step limit test was true\n" );
minimizer.cc:1828:    rjDotzjNext = rj->dotProduct(zj);
minimizer.cc:1831:    dj->XPlusYTimesScalar(zj,dj,betaj);
minimizer.cc:1833:    pj->copyIntoMe(pjNext);
minimizer.cc:1842:#define	EPSILONF	1.0e-10
minimizer.cc:1843:#define	EPSILONG	1.0e-8
minimizer.cc:1844:#define	SQRT_EPSILONF	1.0e-5
minimizer.cc:1845:#define	CUBERT_EPSILONF	4.6416e-4
minimizer.cc:1863:#define	TENEMINUS8	10.0e-8
minimizer.cc:1867:    if ( this->_Status == minimizerError ) return;
minimizer.cc:1868:    this->_Status = truncatedNewtonRunning;
minimizer.cc:1869:    this->_CurrentPreconditioner = this->_TruncatedNewtonPreconditioner;
minimizer.cc:1873:    iDimensions = xK->size();
minimizer.cc:1880:    pK->zero();
minimizer.cc:1891:    mprecon->fill(0.0);
minimizer.cc:1892:    ldlt->fill(0.0);
minimizer.cc:1898:    rmsForceMag = forceK->rmsMagnitude();
minimizer.cc:1904:    this->_EnergyFunction->setupHessianPreconditioner(xK,mprecon);
minimizer.cc:1908:    if ( this->_PrintIntermediateResults ) {
minimizer.cc:1909://	_lisp->print(BF("======= Starting Steepest Descent Minimizer\nn" );
minimizer.cc:1910://	_lisp->print(BF( "======= Starting Conjugate Gradient Minimizer" ));
minimizer.cc:1911:	_lisp->print(BF( "======= Starting Truncated Newton Minimizer" ));
minimizer.cc:1919:	    if ( this->_DebugOn )
minimizer.cc:1922:		stepReport->_Iteration = this->_Iteration;
minimizer.cc:1938:	    if ( this->_PrintIntermediateResults ) {
minimizer.cc:1939:		dirMag = pK->magnitude();
minimizer.cc:1940:		forceMag = forceK->magnitude();
minimizer.cc:1945:		    cosAngle = forceK->dotProduct(pK)/(forceMag*dirMag);
minimizer.cc:1949:		if ( this->_PrintIntermediateResults )
minimizer.cc:1951:		    this->_displayIntermediateMessage(prevAlphaK,energyXkNext,forceMag,rmsForceMag,cosAngle,false);
minimizer.cc:1956:	    this->lineSearch( &alphaK, &energyXkNext, xK, pK, forceK,
minimizer.cc:1958:	    xKNext->XPlusYTimesScalar(xK,pK,alphaK);
minimizer.cc:1963:	    if ( this->_DebugOn )
minimizer.cc:1965:		this->stepReport(stepReport,fp,forceK);
minimizer.cc:1972:	    b1aTest=fabs(energyXkNext-energyXk)<EPSILONF*(1.0+fabs(energyXk));
minimizer.cc:1976:	    LOG(BF("fabs[energyXkNext-energyXk]=%le") % fabs(energyXkNext-energyXk) );
minimizer.cc:1979:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:1980:		    _lisp->print(BF( "search complete according to b1aTest" ));
minimizer.cc:1984:	    delta = xKNext->rmsDistanceFrom(xK);
minimizer.cc:1985:	    rmsMagXKNext = xKNext->rmsMagnitude();
minimizer.cc:1988:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:1989:		    _lisp->print(BF( "search complete according to b1bTest" ));
minimizer.cc:1994:	    rmsForceMag = forceK->rmsMagnitude();
minimizer.cc:1996:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:1997:		    _lisp->print(BF( "search complete according to absolute force test" ));
minimizer.cc:2007:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:2008:		    _lisp->print(BF( "search complete according to b1cTest" ));
minimizer.cc:2014:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:2015:		    _lisp->print(BF( "search complete according to b1dTest" ));
minimizer.cc:2026:	    this->_EnergyFunction->setupHessianPreconditioner(xK,mprecon);
minimizer.cc:2028:	    xK->copyIntoMe(xKNext);
minimizer.cc:2030:	    this->_Iteration++;
minimizer.cc:2031:	    if ( this->_DebugOn )
minimizer.cc:2033:		ASSERTNOTNULL(this->_Log);
minimizer.cc:2034:		this->_Log->addReport(stepReport);
minimizer.cc:2044:	    if ( this->_StepCallback.notnilp() )
minimizer.cc:2045:		this->_StepCallback->invoke(this->sharedThis<Minimizer_O>());
minimizer.cc:2049:	if ( this->_DebugOn )
minimizer.cc:2053:		stepReport->prematureTermination("ExceededNumSteps");
minimizer.cc:2054:		this->_Log->addReport(stepReport);
minimizer.cc:2063:	this->_EnergyFunction->writeCoordinatesAndForceToAtoms(xK,forceK);
minimizer.cc:2064:	THROW(_lisp->create<MinimizerExceededMaxSteps_O>(fail.message()));
minimizer.cc:2067:    xK->copyIntoMe(xKNext);
minimizer.cc:2069:    this->_EnergyFunction->writeCoordinatesAndForceToAtoms(xK,forceK);
minimizer.cc:2070:    if ( this->_DebugOn )
minimizer.cc:2074:	    stepReport->prematureTermination("Stuck");
minimizer.cc:2075:	    this->_Log->addReport(stepReport);
minimizer.cc:2096:  ---------------------------------------------------------------------------
minimizer.cc:2097:  ---------------------------------------------------------------------------
minimizer.cc:2098:  ---------------------------------------------------------------------------
minimizer.cc:2115:    iSize = nvPos->size();
minimizer.cc:2123:    this->_Iteration = 1;
minimizer.cc:2125:        dEnergy = this->dTotalEnergyForce( nvPos, nvNewForce);
minimizer.cc:2127:	    _lisp->print(BF("Evaluating energy step#%d") % iCount );
minimizer.cc:2140:	if ( this->_DebugOn ) {
minimizer.cc:2141:	    report = this->_EnergyFunction->checkIfAnalyticalForceMatchesNumericalForce(pos,force);
minimizer.cc:2142:	    this->_Log->addReport(report);
minimizer.cc:2169:	this->Base::initialize();
minimizer.cc:2171:	this->bFCallback   = NULL;
minimizer.cc:2173:	this->_DebugOn = false;
minimizer.cc:2174:	this->useDefaultSettings();
minimizer.cc:2175:	this->restart();
minimizer.cc:2176://	this->_StepCallback = core::LispCallback_O::_nil;
minimizer.cc:2183:	this->_InitialLineSearchStep = 0.01;
minimizer.cc:2184:	this->_NumberOfSteepestDescentSteps = MAXSTEEPESTDESCENTSTEPS;
minimizer.cc:2185:	this->_SteepestDescentTolerance = 2000.0;
minimizer.cc:2186:	this->_NumberOfConjugateGradientSteps = MAXCONJUGATEGRADIENTSTEPS;
minimizer.cc:2187:	this->_ConjugateGradientTolerance = 10.0;		//	Use this for now, later add TN minimizer and switch to that when this is <10.0
minimizer.cc:2188:	this->_NumberOfTruncatedNewtonSteps = MAXTRUNCATEDNEWTONSTEPS;
minimizer.cc:2189:	this->_TruncatedNewtonTolerance = 0.00000001;
minimizer.cc:2190:	this->_TruncatedNewtonPreconditioner = hessianPreconditioner;
minimizer.cc:2191:	this->_PrintIntermediateResults = false;
minimizer.cc:2192:	LOG(BF("_PrintIntermediateResults = %d") % this->_PrintIntermediateResults  );
minimizer.cc:2193:	this->_ReportEverySteps = -1;
minimizer.cc:2194:	this->_Status = minimizerIdle;
minimizer.cc:2195:	this->_ShowElapsedTime = true;
minimizer.cc:2198:	this->iPythonCallbackEverySteps = 1;
minimizer.cc:2199:	this->POPythonCallback = NULL;
minimizer.cc:2202:	this->_MinGradientMean = MIN_GRADIENT_MEAN;
minimizer.cc:2211:    this->_PrintIntermediateResults = true;
minimizer.cc:2219:    this->_PrintIntermediateResults = false;
minimizer.cc:2227:	this->_EnergyFunction = f;
minimizer.cc:2228:	this->_Iteration = 1;
minimizer.cc:2234:    if ( this->_EnergyFunction->isNil() )
minimizer.cc:2238:    this->_Iteration = 1;
minimizer.cc:2239:    pos = NVector_O::create(this->_EnergyFunction->getNVectorSize(),_lisp);
minimizer.cc:2240:    this->_EnergyFunction->extractCoordinatesFromAtoms(pos);
minimizer.cc:2241:    this->_evaluateEnergyAndForceManyTimes(numSteps,pos);
minimizer.cc:2252:    this->_StartTime = core::PosixTime_O::createNow(_lisp);
minimizer.cc:2254:    if ( this->_EnergyFunction->isNil() )
minimizer.cc:2258:    pos = NVector_O::create(this->_EnergyFunction->getNVectorSize(),_lisp);
minimizer.cc:2264:		this->_EnergyFunction->extractCoordinatesFromAtoms(pos);
minimizer.cc:2265:		this->_steepestDescent(this->_NumberOfSteepestDescentSteps,pos,
minimizer.cc:2266:				       this->_SteepestDescentTolerance );
minimizer.cc:2268:		this->_EnergyFunction->dealWithProblem(ld);
minimizer.cc:2269:		retries--;
minimizer.cc:2271:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:2272:		    _lisp->print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2277:	this->_Message.str("");
minimizer.cc:2278:	this->_Message<<"Steepest descent minimizer exceeded max("
minimizer.cc:2280:	this->_Status = minimizerError;
minimizer.cc:2281:	THROW(_lisp->create<MinimizerExceededMaxSteps_O>(this->_Message.str()));
minimizer.cc:2284:	this->_Status = minimizerError;
minimizer.cc:2285:	this->_Message << "There was a persistant interaction problem";
minimizer.cc:2286:	THROW(_lisp->create<MinimizerError_O>(this->_Message.str()));
minimizer.cc:2298:    this->_StartTime = core::PosixTime_O::createNow(_lisp);
minimizer.cc:2300:    if ( this->_EnergyFunction->isNil() )
minimizer.cc:2304:    pos = NVector_O::create(this->_EnergyFunction->getNVectorSize(),_lisp);
minimizer.cc:2310:		this->_EnergyFunction->extractCoordinatesFromAtoms(pos);
minimizer.cc:2311:		this->_conjugateGradient(this->_NumberOfConjugateGradientSteps,pos,
minimizer.cc:2312:					 this->_ConjugateGradientTolerance );
minimizer.cc:2314:		this->_EnergyFunction->dealWithProblem(ld);
minimizer.cc:2315:		retries--;
minimizer.cc:2317:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:2318:		    _lisp->print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2323:	this->_Message.str("");
minimizer.cc:2324:	this->_Message<<"Conjugate gradient minimizer exceeded max("
minimizer.cc:2326:	this->_Status = minimizerError;
minimizer.cc:2327:	THROW(_lisp->create<MinimizerExceededMaxSteps_O>(this->_Message.str()));
minimizer.cc:2329:	this->_Message.str("");
minimizer.cc:2330:	this->_Message<< fail.message() ;
minimizer.cc:2331:	this->_Status = minimizerError;
minimizer.cc:2332:	THROW(_lisp->create<MinimizerStuck_O>(this->_Message.str()));
minimizer.cc:2335:	this->_Status = minimizerError;
minimizer.cc:2336:	this->_Message << "There was a persistant interaction problem";
minimizer.cc:2337:	THROW(_lisp->create<MinimizerError_O>(this->_Message.str()));
minimizer.cc:2344:    this->_Status = minimizerIdle;
minimizer.cc:2345:    this->minimize();
minimizer.cc:2355:    this->_StartTime = core::PosixTime_O::createNow(_lisp);
minimizer.cc:2357:    if ( this->_EnergyFunction->isNil() )
minimizer.cc:2361:    pos = NVector_O::create(this->_EnergyFunction->getNVectorSize(),_lisp);
minimizer.cc:2367:		this->_EnergyFunction->extractCoordinatesFromAtoms(pos);
minimizer.cc:2368:		if ( this->_NumberOfSteepestDescentSteps > 0 ) {
minimizer.cc:2369:		    this->_steepestDescent( this->_NumberOfSteepestDescentSteps,
minimizer.cc:2370:					    pos, this->_SteepestDescentTolerance );
minimizer.cc:2372:		if ( this->_NumberOfConjugateGradientSteps > 0 ) {
minimizer.cc:2373:		    this->_conjugateGradient( this->_NumberOfConjugateGradientSteps,
minimizer.cc:2374:					      pos, this->_ConjugateGradientTolerance );
minimizer.cc:2376:		if ( this->_NumberOfTruncatedNewtonSteps > 0 ) {
minimizer.cc:2377:		    this->_truncatedNewton( this->_NumberOfTruncatedNewtonSteps,
minimizer.cc:2378:					    pos, this->_TruncatedNewtonTolerance );
minimizer.cc:2381:		this->_EnergyFunction->dealWithProblem(ld);
minimizer.cc:2382:		retries--;
minimizer.cc:2384:		if ( this->_PrintIntermediateResults ) {
minimizer.cc:2385:		    _lisp->print(BF("Dealt with problem(%s)") % ld._Message.c_str());
minimizer.cc:2390:	this->_Message.str("");
minimizer.cc:2391:	this->_Message<<"Minimizer exceeded max("
minimizer.cc:2393:	this->_Status = minimizerError;
minimizer.cc:2394:	THROW(_lisp->create<MinimizerExceededMaxSteps_O>(this->_Message.str()));
minimizer.cc:2396:	this->_Message.str("");
minimizer.cc:2397:	this->_Message<< fail.message();
minimizer.cc:2398:	this->_Status = minimizerError;
minimizer.cc:2399:	THROW(_lisp->create<MinimizerStuck_O>(this->_Message.str()));
minimizer.cc:2402:	this->_Status = minimizerError;
minimizer.cc:2403:	this->_Message << "There was a persistant interaction problem";
minimizer.cc:2404:	THROW(_lisp->create<MinimizerError_O>(this->_Message.str()));
minimizer.cc:2413:	xml->addAttributeDoubleScientific("InitialLineSearchStep",this->_InitialLineSearchStep);
minimizer.cc:2414:	xml->addAttributeInt("MaximumNumberOfSteepestDescentSteps",this->_NumberOfSteepestDescentSteps);
minimizer.cc:2415:	xml->addAttributeInt("MaximumNumberOfConjugateGradientSteps",this->_NumberOfConjugateGradientSteps);
minimizer.cc:2416:	xml->addAttributeInt("MaximumNumberOfTruncatedNewtonSteps",this->_NumberOfTruncatedNewtonSteps);
minimizer.cc:2417:	xml->addAttributeDoubleScientific("SteepestDescentTolerance",this->_SteepestDescentTolerance);
minimizer.cc:2418:	xml->addAttributeDoubleScientific("ConjugateGradientTolerance",this->_ConjugateGradientTolerance);
minimizer.cc:2419:	xml->addAttributeDoubleScientific("TruncatedNewtonTolerance",this->_TruncatedNewtonTolerance);
minimizer.cc:2420:	xml->addAttributeString("TruncatedNewtonPreconditioner",stringForPreconditionerType(this->_TruncatedNewtonPreconditioner));
minimizer.cc:2430:	ss << "InitialLineSearchStep:                 " <<this->_InitialLineSearchStep << endl;
minimizer.cc:2431:	ss << "MaximumNumberOfSteepestDescentSteps:   "<<this->_NumberOfSteepestDescentSteps << endl;
minimizer.cc:2432:	ss << "SteepestDescentTolerance:              "<<this->_SteepestDescentTolerance << endl;
minimizer.cc:2433:	ss << "MaximumNumberOfConjugateGradientSteps: "<<this->_NumberOfConjugateGradientSteps << endl;
minimizer.cc:2434:	ss << "ConjugateGradientTolerance:            "<<this->_ConjugateGradientTolerance << endl;
minimizer.cc:2435:	ss << "MaximumNumberOfTruncatedNewtonSteps: "<<this->_NumberOfTruncatedNewtonSteps << endl;
minimizer.cc:2436:	ss << "TruncatedNewtonTolerance:            "<<this->_TruncatedNewtonTolerance << endl;
minimizer.cc:2437:	ss << "TruncatedNewtonPreconditioner:       "<<stringForPreconditionerType(this->_TruncatedNewtonPreconditioner)<<endl;
minimizer.cc:2443:	this->_Status = minimizerIdle;
minimizer.cc:2444:	this->_Message.str("");
minimizer.cc:2445:	this->_Iteration = 1;
minimizerLog.cc:22:	this->Base::initialize();
minimizerLog.cc:23:	this->_Time = (unsigned long)std::time(0);
minimizerLog.cc:29:    node->attribute("time",this->_Time);
minimizerLog.cc:36:    this->archiveBase(node);
minimizerLog.cc:37:    node->archiveString("message",this->_Message);
minimizerLog.cc:44:    this->archiveBase(node);
minimizerLog.cc:45:    node->archiveString("message",this->_Message);
minimizerLog.cc:46:    node->archiveObject("analyticalForce",this->_AnalyticalForce);
minimizerLog.cc:47:    node->archiveObject("numericalForce",this->_NumericalForce);
minimizerLog.cc:54:    this->Base::initialize();
minimizerLog.cc:55:    this->_PrematureTermination = false;
minimizerLog.cc:56:    this->_LineSearchPosition = NVector_O::_nil;
minimizerLog.cc:57:    this->_LineSearchDirection = NVector_O::_nil;
minimizerLog.cc:58:    this->_LineSearchForce = NVector_O::_nil;
minimizerLog.cc:59:    this->_TotalEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:60:    this->_StretchEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:61:    this->_AngleEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:62:    this->_DihedralEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:63:    this->_NonbondEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:64:    this->_ImproperEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:65:    this->_ChiralRestraintEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:66:    this->_AnchorRestraintEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:67:    this->_ImproperRestraintEnergyFn = NumericalFunction_O::_nil;
minimizerLog.cc:74:    this->archiveBase(node);
minimizerLog.cc:75:    node->attribute("_Iteration",this->_Iteration);
minimizerLog.cc:77:    node->attribute("_Iteration", this->_Iteration);
minimizerLog.cc:79:    node->attribute("_Xa", this->_Xa);
minimizerLog.cc:80:    node->attribute("_Xb", this->_Xb);
minimizerLog.cc:81:    node->attribute("_Xc", this->_Xc);
minimizerLog.cc:82:    node->attribute("_Fa", this->_Fa);
minimizerLog.cc:83:    node->attribute("_Fb", this->_Fb);
minimizerLog.cc:84:    node->attribute("_Fc", this->_Fc);
minimizerLog.cc:85:    node->attribute("_MinBracketSteps", this->_MinBracketSteps);
minimizerLog.cc:86:    node->attribute("_EnergyTermsEnabled", this->_EnergyTermsEnabled);
minimizerLog.cc:87:    node->attribute("_TotalEnergy", this->_TotalEnergy);
minimizerLog.cc:88:    node->attribute("_DirectionMagnitude", this->_DirectionMagnitude);
minimizerLog.cc:89:    node->attribute("_ForceMagnitude", this->_ForceMagnitude);
minimizerLog.cc:91:    node->attribute("_MinimizerStatus", this->_MinimizerStatus);
minimizerLog.cc:93:    node->attribute("_Direction", this->_Direction);
minimizerLog.cc:96:    node->archiveObjectIfDefined("_LineSearchPosition", this->_LineSearchPosition );
minimizerLog.cc:98:    LOG(BF("this->_LineSearchPosition use_count=%d") % this->_LineSearchPosition.use_count()  );
minimizerLog.cc:99:    ANN(this->_LineSearchPosition);
minimizerLog.cc:100:    if ( this->_LineSearchPosition.notnilp() )
minimizerLog.cc:102:	LOG(BF("this->_LineSearchPosition size=%d") % this->_LineSearchPosition->size()  );
minimizerLog.cc:106:    node->archiveObjectIfDefined("_LineSearchDirection", this->_LineSearchDirection);
minimizerLog.cc:108:    ASSERTNOTNULL(this->_LineSearchForce);
minimizerLog.cc:109:    node->archiveObjectIfDefined("_LineSearchForce", this->_LineSearchForce);
minimizerLog.cc:112:    ASSERTNOTNULL(this->_TotalEnergyFn);
minimizerLog.cc:113:    node->archiveObjectIfDefined("_TotalEnergyFn",  this->_TotalEnergyFn);
minimizerLog.cc:115:    ASSERTNOTNULL(this->_StretchEnergyFn);
minimizerLog.cc:116:    node->archiveObjectIfDefined("_StretchEnergyFn",  this->_StretchEnergyFn);
minimizerLog.cc:118:    ASSERTNOTNULL(this->_AngleEnergyFn);
minimizerLog.cc:119:    node->archiveObjectIfDefined("_AngleEnergyFn",  this->_AngleEnergyFn);
minimizerLog.cc:121:    ASSERTNOTNULL(this->_DihedralEnergyFn);
minimizerLog.cc:122:    node->archiveObjectIfDefined("_DihedralEnergyFn",  this->_DihedralEnergyFn);
minimizerLog.cc:124:    ASSERTNOTNULL(this->_NonbondEnergyFn);
minimizerLog.cc:125:    node->archiveObjectIfDefined("_NonbondEnergyFn",  this->_NonbondEnergyFn);
minimizerLog.cc:127:    ASSERTNOTNULL(this->_ImproperEnergyFn);
minimizerLog.cc:128:    node->archiveObjectIfDefined("_ImproperEnergyFn",  this->_ImproperEnergyFn);
minimizerLog.cc:130:    ASSERTNOTNULL(this->_ChiralRestraintEnergyFn);
minimizerLog.cc:131:    node->archiveObjectIfDefined("_ChiralRestraintEnergyFn",  this->_ChiralRestraintEnergyFn);
minimizerLog.cc:133:    ASSERTNOTNULL(this->_AnchorRestraintEnergyFn);
minimizerLog.cc:134:    node->archiveObjectIfDefined("_AnchorRestraintEnergyFn",  this->_AnchorRestraintEnergyFn);
minimizerLog.cc:135:    ASSERTNOTNULL(this->_ImproperRestraintEnergyFn);
minimizerLog.cc:136:    node->archiveObjectIfDefined("_ImproperRestraintEnergyFn",  this->_ImproperRestraintEnergyFn);
minimizerLog.cc:138:    node->attribute("_DbrentSteps", this->_DbrentSteps);
minimizerLog.cc:140:    node->attribute("_EnergyEvals", this->_EnergyEvals);
minimizerLog.cc:142:    node->attribute("_ForceEvals", this->_ForceEvals);
minimizerLog.cc:143:    node->attribute("_Step", this->_Step);
minimizerLog.cc:144:    node->attribute("_FMin", this->_FMin);
minimizerLog.cc:145:    node->attribute("_ForceMag", this->_ForceMag);
minimizerLog.cc:146:    node->attribute("_StepEnergy", this->_StepEnergy);
minimizerLog.cc:147:    node->attribute("_IterationMessages", this->_IterationMessages);
minimizerLog.cc:148:    node->attribute("_AngleBetweenDirectionAndForceDeg", this->_AngleBetweenDirectionAndForceDeg);
minimizerLog.cc:149:    node->attribute("_PrematureTermination", this->_PrematureTermination);
minimizerLog.cc:150:    node->attribute("_PrematureTerminationMessage", this->_PrematureTerminationMessage);
minimizerLog.cc:161:    node->archiveObject( "_Minimizer",this->_Minimizer );
minimizerLog.cc:162:    node->archiveVector0( "_Reports",this->_Reports );
moe.cc:62:		ParaValue(TYPE a) {this->val=a;};
moe.cc:63:	void	setValue(TYPE v) {this->val = v;};
moe.cc:64:	TYPE&	getValue()	{return this->val;};
moe.cc:75:	    this->erase();
moe.cc:76://	    for (i=this->vals.begin();i!=this->vals.end();i++) {
moe.cc:80:	void	push_back(ParaPrimValue* p) {this->vals.push_back(p);};
moe.cc:81:	ParaPrimValue*	operator[](int i)	{return this->vals[i];};
moe.cc:82:	int	size()	{return this->vals.size();};
moe.cc:83:	void	erase()	{this->vals.erase(this->vals.begin(),this->vals.end());};
moe.cc:89:	void	push_back(TYPE p) {this->vals.push_back(p);};
moe.cc:90:	TYPE	operator[](int i)	{return this->vals[i];};
moe.cc:91:	int	size()	{return this->vals.size();};
moe.cc:92:	void	erase()	{this->vals.erase(this->vals.begin(),
moe.cc:93:						this->vals.end());};
moe.cc:115:	void	addFieldVector(string f,ParaVector& v) { this->fieldIndices[f]=this->vectors.size(); this->vectors.push_back(v); };
moe.cc:117:	ParaVector&	getVector(int f) {return this->vectors[f];};
moe.cc:119:	ParaVector&	getFieldVector(string f) {return this->vectors[this->fieldIndices[f]];};
moe.cc:120:	int	getFieldIndex(string f) {return this->fieldIndices[f];};
moe.cc:125:	void	erase()	{ this->vectors.erase(this->vectors.begin(),
moe.cc:126:					this->vectors.end());
moe.cc:127:			  this->fieldIndices.erase(this->fieldIndices.begin(),
moe.cc:128:						this->fieldIndices.end() );};
moe.cc:161:    core::Lisp_sp lisp() { return this->_Lisp;};
moe.cc:165:	bool		nextParaTableExists() {return !this->done;};
moe.cc:166:	string		nextParaTableName() {return this->paraName;};
moe.cc:167:	int		nextParaTableRows() {return this->paraRows;};
moe.cc:168:	int		nextParaTableFieldCount() {return this->paraFieldNames.size();};
moe.cc:169:	string		nextParaTableFieldName(int i) {return this->paraFieldNames[i];};
moe.cc:170:	string		nextParaTableFieldType(int i) {return this->paraFieldTypes[i];};
moe.cc:196:    if ( rest->isOfClass<RestraintDistance_O>() )
moe.cc:200:		<< distRest->getAtomA()->getTempFileId() << " "
moe.cc:201:		<< distRest->getAtomB()->getTempFileId() << " "
moe.cc:203:		<< distRest->getMin() << " "
moe.cc:204:		<< distRest->getMax() << " "
moe.cc:205:		<< distRest->getWeight() << endl;
moe.cc:208:    if ( rest->isOfClass<RestraintAngle_O>() )
moe.cc:212:		<< distAngle->getAtomA()->getTempFileId() << " "
moe.cc:213:		<< distAngle->getAtomB()->getTempFileId() << " "
moe.cc:214:		<< distAngle->getAtomC()->getTempFileId() << " "
moe.cc:216:		<< distAngle->getMin() << " "
moe.cc:217:		<< distAngle->getMax() << " "
moe.cc:218:		<< distAngle->getWeight() << endl;
moe.cc:223:	    << distDih->getAtomA()->getTempFileId() << " "
moe.cc:224:	    << distDih->getAtomB()->getTempFileId() << " "
moe.cc:225:	    << distDih->getAtomC()->getTempFileId() << " "
moe.cc:226:	    << distDih->getAtomD()->getTempFileId() << " "
moe.cc:228:	    << distDih->getMinDegrees() << " "
moe.cc:229:	    << distDih->getMaxDegrees() << " "
moe.cc:230:	    << distDih->getWeight() << endl;
moe.cc:277:    if ( c == '-' ) return true;
moe.cc:322:    this->_Lisp = lisp;
moe.cc:328:    if ( this->mustDestroy_fMoe) {
moe.cc:329:	delete this->fMoe;
moe.cc:365:		    *copy = ((prefix - 1)<<6) | ((encode-1)&0x3F);
moe.cc:413:    strcpy( line, this->nextLine );
moe.cc:419:    this->splitLine( words, line );
moe.cc:420:    this->paraName = words.front();
moe.cc:421:    this->paraRows = 0;
moe.cc:423:    if ( this->paraName == "moe" ) {
moe.cc:424:	this->moeFileVersion = words.front();
moe.cc:434:	this->paraRows = atoi(buf);
moe.cc:437:    this->paraFieldNames.erase(this->paraFieldNames.begin(),
moe.cc:438:				this->paraFieldNames.end() );
moe.cc:439:    this->paraFieldTypes.erase(this->paraFieldTypes.begin(),
moe.cc:440:				this->paraFieldTypes.end() );
moe.cc:442:	this->paraFieldNames.push_back( words.front() );
moe.cc:444:	this->paraFieldTypes.push_back( words.front() );
moe.cc:463:    if ( this->fMoe->eof() ) {
moe.cc:464:	this->done = true;
moe.cc:467:    cPPut = this->nextLine;
moe.cc:468:    iSize = sizeof(this->nextLine)-1;
moe.cc:469:    while ( !this->fMoe->eof() && (c=this->fMoe->get()) && iSize>0 ) 
moe.cc:474:	    iSize--;
moe.cc:479:    if ( this->fMoe->eof() ) {
moe.cc:480:	this->done = true;
moe.cc:499:	if ( stat(sFileName,&buf)==-1 ) {
moe.cc:506:	fIn->open(sFileName);
moe.cc:508:	this->fileName = sFileName;
moe.cc:509:	this->fMoe = fIn;
moe.cc:510:	this->mustDestroy_fMoe = true;
moe.cc:511:	this->done = false;
moe.cc:512:	this->readNextLine();
moe.cc:513:	this->parseHeader();
moe.cc:523:	this->fileName = "";
moe.cc:524:	this->fMoe = fIn;
moe.cc:525:	this->mustDestroy_fMoe= false;
moe.cc:526:	this->done = false;
moe.cc:527:	this->readNextLine();
moe.cc:528:	this->parseHeader();
moe.cc:561:	    LOG(BF("readParaTable-- reading next line") );
moe.cc:562:	    this->readNextLine();
moe.cc:563:	    LOG(BF("Read line: %s") % this->nextLine  );
moe.cc:564:	    if ( !this->done && this->nextLine[0] != '#' ) {
moe.cc:566:		this->splitLine( words, this->nextLine );
moe.cc:569:	} while ( !this->done && this->nextLine[0] != '#' );
moe.cc:573:	table->erase();
moe.cc:574:	for ( field=0; field<this->nextParaTableFieldCount(); field++ ) {
moe.cc:575:	    LOG(BF("Adding  fieldVector name: %s") % this->nextParaTableFieldName(field).c_str()  );
moe.cc:576:	    table->addFieldVector( this->nextParaTableFieldName(field), col );
moe.cc:581:	for ( row=0; row<this->nextParaTableRows(); row++ ) {
moe.cc:583:	    for ( field = 0; field < this->nextParaTableFieldCount(); field++ ) {
moe.cc:585:		type = this->nextParaTableFieldType(field);
moe.cc:593:		    table->getVector(field).push_back(paraInt);
moe.cc:598:		    num = type.substr(2,type.length()-2);
moe.cc:603:		    table->getVector(field).push_back(paraInt);
moe.cc:608:		    num = type.substr(2,type.length()-2);
moe.cc:613:		    table->getVector(field).push_back(paraReal);
moe.cc:630:			paraArrayInt->push_back(ddd);
moe.cc:632:		    table->getVector(field).push_back(paraArrayInt);
moe.cc:649:			paraArrayDbl->push_back(ddd);
moe.cc:651:		    table->getVector(field).push_back(paraArrayDbl);
moe.cc:661:		    table->getVector(field).push_back(paraHex);
moe.cc:671:		    table->getVector(field).push_back(paraReal);
moe.cc:679:		    table->getVector(field).push_back(paraChar);
moe.cc:687:		    table->getVector(field).push_back(paraToken);
moe.cc:695:		    table->getVector(field).push_back(paraString);
moe.cc:705:	if ( !this->done && this->nextLine[0] == '#' ) {
moe.cc:707:	    this->parseHeader();
moe.cc:722:	    this->readNextLine();
moe.cc:723:	} while ( !this->done && this->nextLine[0] != '#' );
moe.cc:724:	if ( !this->done && this->nextLine[0] == '#' ) {
moe.cc:725:	    this->parseHeader();
moe.cc:880:		if ( f.nextParaTableFieldType(1)=="i=-1" ) {
moe.cc:881:		    LOG(BF("Reading aForceRS i=-1 ParaTable") );
moe.cc:890:		    cerr << "should be... aForceRS [i=-1/i=1]" << endl;
moe.cc:931:	    agg->addMolecule(mol);
moe.cc:933:	    numResidues = dynamic_cast<ParaInteger*>(ptMolecules.getVector(index_cResidueCount)[im])->getValue();
moe.cc:938:		res->setTempFileId(ir+1);
moe.cc:939:		mol->addMatter(res);
moe.cc:941:		numAtoms = dynamic_cast<ParaInteger*>(ptResidues.getVector(index_rAtomCount)[tir])->getValue();
moe.cc:943:		str = dynamic_cast<ParaToken*>(ptResidues.getVector(index_rName)[tir])->getValue();
moe.cc:944:		res->setName( str );
moe.cc:950:		    a->setMoeIndex( dynamic_cast<ParaInteger*>(ptAtoms.getVector(index_ID)[ia])->getValue() );
moe.cc:951:		    a->setName( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:952:							 .getVector(index_aName)[ia])->getValue() );
moe.cc:953:		    a->setElementFromString( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:954:								      .getVector(index_aElement)[ia])->getValue() );
moe.cc:955:		    a->setHybridizationFromString( dynamic_cast<ParaToken*>(ptAtoms
moe.cc:956:									    .getVector(index_aGeometry)[ia])->getValue() );
moe.cc:958:						.getVector(index_aPosX)[ia])->getValue();
moe.cc:960:						.getVector(index_aPosY)[ia])->getValue();
moe.cc:962:						.getVector(index_aPosZ)[ia])->getValue();
moe.cc:964:		    a->setPosition(pos);
moe.cc:965:		    a->resetFlags();
moe.cc:967:		    LOG(BF("Created atom: %s") % a->getName().c_str()  );
moe.cc:968:		    res->addAtom(a);
moe.cc:989:		aid = dynamic_cast<ParaInteger*>(ptFixed.getVector(i_id)[i])->getValue()-1;
moe.cc:991:		fixed = dynamic_cast<ParaInteger*>(ptFixed.getVector(i_fixed)[i])->getValue();
moe.cc:995:		    atoms[aid]->modifyFlags(ATOMFLAG_ON,ATOM_FIXED);
moe.cc:997:		    atoms[aid]->modifyFlags(ATOMFLAG_OFF,ATOM_FIXED);
moe.cc:1018:		aid = dynamic_cast<ParaInteger*>(ptCharges.getVector(i_id)[i])->getValue()-1;
moe.cc:1020:		charge = dynamic_cast<ParaReal*>(ptCharges.getVector(i_charge)[i])->getValue();
moe.cc:1023:		atoms[aid]->setCharge(charge);
moe.cc:1042:		aid = dynamic_cast<ParaInteger*>(ptMMTypes.getVector(index_mmTypeId)[i])->getValue()-1;
moe.cc:1044:		type = dynamic_cast<ParaToken*>(ptMMTypes.getVector(index_mmTypes)[i])->getValue();
moe.cc:1047:		atoms[aid]->setMoeType(type);
moe.cc:1059:		    from = dynamic_cast<ParaInteger*>(ptBonds.getVector(index_a)[i])->getValue()-1;
moe.cc:1060:		    to = dynamic_cast<ParaInteger*>(ptBonds.getVector(index_b)[i])->getValue()-1;
moe.cc:1061:		    LOG(BF("Read bond between atom indices %d-%d") % from+1 % to+1  );
moe.cc:1062:		    if ( atoms[from]->getHybridization()==hybridization_sp2 &&
moe.cc:1063:			 atoms[to]->getHybridization()==hybridization_sp2 ) 
moe.cc:1066:			atoms[from]->bondTo( atoms[to], bo );
moe.cc:1067:			DEBUG_ASSERTP(!atoms[from]->invalid(),
moe.cc:1068:				      "Bond I just formed is invalid atom:"+atoms[from]->getName());
moe.cc:1069:			DEBUG_ASSERTP(!atoms[to]->invalid(),
moe.cc:1070:				      "Bond I just formed is invalid atom:"+atoms[to]->getName());
moe.cc:1073:			atoms[from]->bondTo( atoms[to], bo );
moe.cc:1074:			DEBUG_ASSERTP(!atoms[from]->invalid(),
moe.cc:1075:				      "Bond I just formed is invalid atom:"+atoms[from]->getName());
moe.cc:1076:			DEBUG_ASSERTP(!atoms[to]->invalid(),
moe.cc:1077:				      "Bond I just formed is invalid atom:"+atoms[to]->getName());
moe.cc:1079:		    LOG(BF("Installed bond between atoms: %s - %s") % atoms[from]->description().c_str() % atoms[to]->description().c_str()  );
moe.cc:1087:		    from = dynamic_cast<ParaInteger*>(ptBondsO1.getVector(index_a)[i])->getValue()-1;
moe.cc:1088:		    to = dynamic_cast<ParaInteger*>(ptBondsO1.getVector(index_b)[i])->getValue()-1;
moe.cc:1089:		    LOG(BF("Read bond between atom indices %d-%d") % from+1 % to+1  );
moe.cc:1091:		    atoms[from]->bondTo( atoms[to], bo );
moe.cc:1092:		    DEBUG_ASSERTP(!atoms[from]->invalid(),
moe.cc:1093:				  "Bond I just formed is invalid atom:"+atoms[from]->getName());
moe.cc:1094:		    DEBUG_ASSERTP(!atoms[to]->invalid(),
moe.cc:1095:				  "Bond I just formed is invalid atom:"+atoms[to]->getName());
moe.cc:1096:		    LOG(BF("Installed bond between atoms: %s - %s") % atoms[from]->description().c_str() % atoms[to]->description().c_str()  );
moe.cc:1104:		    from = dynamic_cast<ParaInteger*>(ptBondsO2.getVector(index_a)[i])->getValue()-1;
moe.cc:1105:		    to = dynamic_cast<ParaInteger*>(ptBondsO2.getVector(index_b)[i])->getValue()-1;
moe.cc:1106:		    LOG(BF("Read bond between atom indices %d-%d") % from+1 % to+1  );
moe.cc:1108:		    atoms[from]->bondTo( atoms[to], bo );
moe.cc:1109:		    DEBUG_ASSERTP(!atoms[from]->invalid(),
moe.cc:1110:				  "Bond I just formed is invalid atom:"+atoms[from]->getName());
moe.cc:1111:		    DEBUG_ASSERTP(!atoms[to]->invalid(),
moe.cc:1112:				  "Bond I just formed is invalid atom:"+atoms[to]->getName());
moe.cc:1113:		    LOG(BF("Installed bond between atoms: %s - %s") % atoms[from]->description().c_str() % atoms[to]->description().c_str()  );
moe.cc:1121:		    from = dynamic_cast<ParaInteger*>(ptBondsO3.getVector(index_a)[i])->getValue()-1;
moe.cc:1122:		    to = dynamic_cast<ParaInteger*>(ptBondsO3.getVector(index_b)[i])->getValue()-1;
moe.cc:1123:		    LOG(BF("Read bond between atom indices %d-%d") % from+1 % to+1  );
moe.cc:1125:		    atoms[from]->bondTo( atoms[to], bo );
moe.cc:1126:		    DEBUG_ASSERTP(!atoms[from]->invalid(),
moe.cc:1127:				  "Bond I just formed is invalid atom:"+atoms[from]->getName());
moe.cc:1128:		    DEBUG_ASSERTP(!atoms[to]->invalid(),
moe.cc:1129:				  "Bond I just formed is invalid atom:"+atoms[to]->getName());
moe.cc:1130:		    LOG(BF("Installed bond between atoms: %s - %s") % atoms[from]->description().c_str() % atoms[to]->description().c_str()  );
moe.cc:1139:	    aggRestraints = agg->allRestraints();
moe.cc:1143:		aid = ( dynamic_cast<ParaInteger*>(ptForceRSm1.getVector(index_ID)[i])->getValue()-1 );
moe.cc:1148:			cerr << "Atom RS-1: " << rsAtom << "  moe ID: " << rsAtom->getMoeIndex()<< endl;
moe.cc:1150:		    restrainChiral->setAtomA(rsAtom);
moe.cc:1151:		restrainChiral->setChirality(-1);
moe.cc:1152:		aggRestraints->addRestraint(restrainChiral);
moe.cc:1157:	    aggRestraints = agg->allRestraints();
moe.cc:1161:		aid = ( dynamic_cast<ParaInteger*>(ptForceRSp1.getVector(index_ID)[i])->getValue()-1 );
moe.cc:1166:			cerr << "Atom RS+1: " << rsAtom << "moe ID: " << rsAtom->getMoeIndex()<< endl;
moe.cc:1168:		    restrainChiral->setAtomA(rsAtom);
moe.cc:1169:		restrainChiral->setChirality(1);
moe.cc:1170:		aggRestraints->addRestraint(restrainChiral);
moe.cc:1178:		aid = (dynamic_cast<ParaInteger*>(ptHintLP.getVector(index_ID)[i])->getValue()-1 );
moe.cc:1180:		LOG(BF("Setting HintLP=True for atom(%s)") % lpAtom->getName().c_str() );
moe.cc:1181:		lpAtom->setHintLP(true);
moe.cc:1188:	    aggRestraints = agg->allRestraints();
moe.cc:1196:		    (ptRestraints.getVector(index_type)[i])->getValue();
moe.cc:1202:		    (ptRestraints.getVector(index_weight)[i])->getValue();
moe.cc:1216:				 << atoms[(*resAtoms)[0]-1]->getMoeIndex() << " "
moe.cc:1217:				 << atoms[(*resAtoms)[1]-1]->getMoeIndex() << " "
moe.cc:1218:				 << atoms[(*resAtoms)[2]-1]->getMoeIndex() << " "
moe.cc:1219:				 << atoms[(*resAtoms)[3]-1]->getMoeIndex() << " " << endl;
moe.cc:1221:			restraint->setAtomA(atoms[(*resAtoms)[0]-1]);
moe.cc:1222:		    restraint->setAtomB(atoms[(*resAtoms)[1]-1]);
moe.cc:1223:		    restraint->setAtomC(atoms[(*resAtoms)[2]-1]);
moe.cc:1224:		    restraint->setAtomD(atoms[(*resAtoms)[3]-1]);
moe.cc:1225:		    restraint->setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1226:		    aggRestraints->addRestraint(restraint);
moe.cc:1230:		    restraint->setAtomA(atoms[(*resAtoms)[0]-1]);
moe.cc:1231:		    restraint->setAtomB(atoms[(*resAtoms)[1]-1]);
moe.cc:1232:		    restraint->setAtomC(atoms[(*resAtoms)[2]-1]);
moe.cc:1233:		    restraint->setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1234:		    aggRestraints->addRestraint(restraint);
moe.cc:1238:		    restraint->setAtomA(atoms[(*resAtoms)[0]-1]);
moe.cc:1239:		    restraint->setAtomB(atoms[(*resAtoms)[1]-1]);
moe.cc:1240:		    restraint->setParameters( (*target)[0], (*target)[1], weight );
moe.cc:1241:		    aggRestraints->addRestraint(restraint);
moe.cc:1281:		if ( a->getMoeType() != "" ) {
moe.cc:1282:		    a->setTypeString(a->getMoeType() );
moe.cc:1283://		setType( ps, a, a->getMoeType() );
moe.cc:1287:	    SIMPLE_ERROR(BF("moeReadAggregateWithAtomTypesFromFileName-- there were no types in the file" ));
moe.cc:1384:		    a->setTempFileId(count);
moe.cc:1389:		residueNames.push_back(r->getPdbName());  // PDBNAME
moe.cc:1390:		r->setTempFileId(resId);
moe.cc:1407:	fout << "ViewOrientationY r* 3 -0.6040875 0.7739065 0.1901233 ViewOrientationZ r*" << endl;
moe.cc:1408:	fout << "3 0.7362871 0.4507356 0.5046968 ViewLookAt r* 3 -0.4651223 0.3664901" << endl;
moe.cc:1409:	fout << "-0.2553613 ViewScale r 21.1468887" << endl;
moe.cc:1417:	    fout << a->getTempFileId() << " " << b->getTempFileId() << endl;
moe.cc:1425:	    fout << a->getTempFileId() << " ";
moe.cc:1426:	    fout << a->getName() << " ";
moe.cc:1427:	    fout << a->getElement() << " ";
moe.cc:1430:	    if ( a->getHybridization() != hybridization_undefined)
moe.cc:1432:		fout << a->getHybridizationAsString() << " ";
moe.cc:1437:	    fout << a->getPosition().getX() << " ";
moe.cc:1438:	    fout << a->getPosition().getY() << " ";
moe.cc:1439:	    fout << a->getPosition().getZ() << endl;
moe.cc:1440:	    if ( a->getFlags()&ATOM_FIXED ) fixedCount++;
moe.cc:1441:	    if ( a->getHintLP() ) hintLPCount++;
moe.cc:1449:		if ( a->getFlags()&ATOM_FIXED ) {
moe.cc:1450:		    fout << a->getTempFileId();
moe.cc:1451:		    if ((ai-atoms.begin())%16!=15 ) fout << " ";
moe.cc:1463:		if ( a->getHintLP() ) {
moe.cc:1464:		    fout << a->getTempFileId();
moe.cc:1465:		    if ((ai-atoms.begin())%16!=15 ) fout << " ";
moe.cc:1478:	    fout << resOffset+i-1 << " " << (*vii) << " " ;
moe.cc:1479:	    if ( residueNames[i-1] == "" ) {
moe.cc:1482:		fout << residueNames[i-1];
moe.cc:1502:	restTotal = agg->getRestraints()->size();
moe.cc:1508:		restraint = agg->getRestraints()->getRestraintIndex(i);
moe.cc:1509:		if ( restraint->getType()==RESTRAINT_CHIRALITY ) 
moe.cc:1511:		    if ( restraint->getChirality() > 0 ) rsp1Count++;
moe.cc:1512:		    if ( restraint->getChirality() < 0 ) rsm1Count++;
moe.cc:1520:		restraint = agg->getRestraints()->getRestraintIndex(i);
moe.cc:1521:		if ( restraint->getType() == RESTRAINT_CHIRALITY ) {
moe.cc:1522:		    if ( restraint->getChirality() > 0 ) {
moe.cc:1523:			fout << restraint->getAtomA()->getTempFileId() << endl;
moe.cc:1528:	// Handle ForceRS-1 restraints
moe.cc:1530:	    fout << "#attr " << rsm1Count << " ID i aForceRS i=-1" << endl;
moe.cc:1532:		restraint = agg->getRestraints()->getRestraintIndex(i);
moe.cc:1533:		if ( restraint->getType() == RESTRAINT_CHIRALITY ) {
moe.cc:1534:		    if ( restraint->getChirality() < 0 ) {
moe.cc:1535:			fout << restraint->getAtomA()->getTempFileId() << endl;
moe.cc:1543:	// Handle non-chiral restraints
moe.cc:1547:		restraint = agg->getRestraints()->getRestraintIndex(i);
moe.cc:1548:		if ( restraint->getType() != RESTRAINT_CHIRALITY ) {
mol2.cc:52:	this->mLine.str("");
mol2.cc:64:		    this->mLine.put(c);
mol2.cc:69:    stringstream&	line() { return this->mLine; };
mol2.cc:72:	core::queueSplitString(this->mLine.str(), qWords, " \t" );
mol2.cc:76:	if ( this->eof() ) return false;
mol2.cc:77:	if ( this->mLine.str().size() == 0 ) return false;
mol2.cc:78:	if ( this->mLine.str()[0] != '@' ) return true;
mol2.cc:83:	this->fIn.open(fileName.c_str(), ios::in);
mol2.cc:84:	if ( this->fIn.fail() ) {
mol2.cc:87:	this->advanceLine();
mol2.cc:89:    core::Lisp_sp lisp() { return this->_Lisp;};
mol2.cc:90:    Mol2File(core::Lisp_sp lisp) {this->_Lisp=lisp;};
mol2.cc:152:        seqNum = -1;
mol2.cc:180:    nm = a->getName();
mol2.cc:212:    neighbors = a->numberOfBonds();
mol2.cc:231:    a->setElement(el);
mol2.cc:232:    a->setHybridization(geom);
mol2.cc:346:	    lastmId = -1;
mol2.cc:406:	    _lisp->print(BF("Ignoring mol2 command: %s") % line.c_str() );
mol2.cc:421:    aggregate->setName(mi->mMoleculeName);
mol2.cc:430:	a->setName(ai->second.atom_name);
mol2.cc:432:	LOG(BF("Creating atom with id: %d name: %s element: %s charge: %8.2f") % ai->second.mIndex % ai->second.atom_name.c_str() % el.c_str() % ai->second.mCharge  );
mol2.cc:433:	pos.set(ai->second.mX,ai->second.mY,ai->second.mZ);
mol2.cc:434:	a->setPosition(pos);
mol2.cc:435:	a->setTypeString(ai->second.mType);
mol2.cc:436:	a->setCharge(ai->second.mCharge);
mol2.cc:437:	LOG(BF(" atom info: %s") % a->description().c_str()  );
mol2.cc:438:	ai->second.mAtom = a;
mol2.cc:443:	if ( residues.count(ai->second.mSubstId)==0 ) {
mol2.cc:450:	    res->setName(ai->second.mSubstName);
mol2.cc:451:	    res->setPdbName(ai->second.mSubstName);
mol2.cc:452:	    LOG(BF("Creating residue with id(%d) and name(%s)") % ai->second.mSubstId % ai->second.mSubstName.c_str()  );
mol2.cc:453:	    residues[ai->second.mSubstId] = res;
mol2.cc:454:	    LOG(BF("New residue %s") % res->description().c_str()  );
mol2.cc:456:	    res = residues[ai->second.mSubstId];
mol2.cc:457:	    LOG(BF("Reusing residue with mSubstId=%d %s") % ai->second.mSubstId % res->description().c_str()  );
mol2.cc:459:	LOG(BF("Adding atom(%s) to residue(%s) SubstId(%d)") % a->getName().c_str() % res->getPdbName().c_str() % ai->second.mSubstId  );
mol2.cc:460:	res->addAtom(a);
mol2.cc:470:	LOG(BF("Creating bond between atom id: %d - %d") % bi->mAtom1Id % bi->mAtom2Id  );
mol2.cc:471:	a1 = atoms[bi->mAtom1Id].mAtom;
mol2.cc:472:	a2 = atoms[bi->mAtom2Id].mAtom;
mol2.cc:473:	LOG(BF("Creating bond between %s - %s") % a1->description().c_str() % a2->description().c_str()  );
mol2.cc:474:	if ( bi->mOrder=="1" ) bo = singleBond;
mol2.cc:475:	else if ( bi->mOrder=="2" ) bo = doubleBond;
mol2.cc:476:	else if ( bi->mOrder=="3" ) bo = tripleBond;
mol2.cc:477:	else if ( bi->mOrder=="ar" ) bo = aromaticBond;
mol2.cc:479:	a1->bondTo(a2,bo);
mol2.cc:490:		if ( chains.count(si->chain) == 0 ) {
mol2.cc:491:		    LOG(BF("Creating molecule: %s") % si->chain.c_str()  );
mol2.cc:494:		    m->setName(si->chain);
mol2.cc:496:		    aggregate->addMolecule(m);
mol2.cc:497:		    LOG(BF("setting chains index=%s") % si->chain.c_str() );
mol2.cc:498:		    chains[si->chain] = m;
mol2.cc:501:		m = chains[si->chain];
mol2.cc:502:		if ( m->isNil() )
mol2.cc:504:		    SIMPLE_ERROR(boost::format("Could not find molecule with chain=%s") % si->chain.c_str());
mol2.cc:506:		LOG(BF("Looking up residue with mId=%d") % si->mId );
mol2.cc:507:		res = residues[si->mId];
mol2.cc:508:		if ( res->isNil() )
mol2.cc:511:		    serr << "Could not find residue with si->mId=";
mol2.cc:512:		    serr << si->mId;
mol2.cc:516:		LOG(BF("Adding residue(use_count=%d) to molecule(use_count=%d)") % residues[si->mId].use_count() % m.use_count() );
mol2.cc:517:		m->addMatter(residues[si->mId]);
mol2.cc:518:		LOG(BF("Setting residue name at index: %d") % si->mId  );
mol2.cc:519:		LOG(BF("Setting residue name to: %s") % si->subst_name.c_str()  );
mol2.cc:520:		residues[si->mId]->setName(si->subst_name);
mol2.cc:521:		LOG(BF("Setting residue PDB name to: %s") % si->sub_type.c_str()  );
mol2.cc:522:		residues[si->mId]->setPdbName(si->sub_type);
mol2.cc:523:		LOG(BF("Setting residue file_sequence_number(%d)") % si->file_sequence_number );
mol2.cc:524:		residues[si->mId]->setFileSequenceNumber(si->file_sequence_number);
mol2.cc:525:		LOG(BF("Adding residue number: %d name(%s) pdbName(%s) to molecule: %s") % si->mId % residues[si->mId]->getName().c_str() % residues[si->mId]->getPdbName().c_str() % si->chain.c_str()  );
mol2.cc:536:	    mol->addMatter(rit->second);
mol2.cc:538:	aggregate->addMolecule(mol);
mol2.cc:545:	_calculateElementAndHybridization(ai->second.mAtom);
mol2.cc:580:    atomCount = agg->numberOfAtoms();
mol2.cc:597:    out << agg->getName() << endl;
mol2.cc:615:	r->setTempFileId(resId);
mol2.cc:623:	    a->setTempFileId(atomId);
mol2.cc:625:	    one._SybylType = sybylRules->calculateType(a);
mol2.cc:641:	m->setName(nameId);
mol2.cc:653:	a = ai->_Atom;
mol2.cc:654:	out << a->getTempFileId() << " ";
mol2.cc:655:	out << a->getName() << " ";
mol2.cc:656:	pos = a->getPosition();
mol2.cc:660:	LOG(BF("Writing mol2 atom(%s) pos(%s)") % a->description() % a->getPosition().asString() );
mol2.cc:661:	out << ai->_SybylType << " ";
mol2.cc:662:	out << a->containedBy().lock()->getTempFileId() << " ";
mol2.cc:663:	out << a->containedBy().lock()->getName() << "_"
mol2.cc:664:		<< a->containedBy().lock()->getTempFileId() << " ";
mol2.cc:668:	out << a->getCharge() << endl;
mol2.cc:689:	out << a1->getTempFileId() << " ";
mol2.cc:690:	out << a2->getTempFileId() << " ";
mol2.cc:703:	r = ri->res;
mol2.cc:705:	out << r->getTempFileId() << " ";
mol2.cc:706:	out << r->getName() << "_" << r->getTempFileId() << " ";
mol2.cc:707:	out << ri->firstAtom << " ";
mol2.cc:709:	out << downcast<Molecule_O>(r->containedBy().lock())->getName() << " ";
mol2.cc:710:	out << r->getName() << " 1";
mol2.cc:722:    mol2WriteAggregateStream( agg, fout,agg->lisp() );
mol2.cc:730:    if ( matter->isOfClass<Aggregate_O>() )
mol2.cc:736:    if ( matter->isOfClass<Molecule_O>() )
mol2.cc:740:	agg->addMolecule(mol);
mol2.cc:744:    THROW(_lisp->create<core::ContentException_O>("You must pass a Molecule or Aggregate"));
mol2.cc:756:    wilds->addWildName("XX");
mol2.cc:757:    wilds->addWildNameMap("XX","C");
mol2.cc:758:    wilds->addWildNameMap("XX","N");
mol2.cc:759:    wilds->addWildNameMap("XX","O");
mol2.cc:760:    wilds->addWildNameMap("XX","S");
mol2.cc:761:    wilds->addWildNameMap("XX","P");
mol2.cc:763:    wilds->addWildName("XA");
mol2.cc:764:    wilds->addWildNameMap("XA","O");
mol2.cc:765:    wilds->addWildNameMap("XA","S");
mol2.cc:767:    wilds->addWildName("XB");
mol2.cc:768:    wilds->addWildNameMap("XB","N");
mol2.cc:769:    wilds->addWildNameMap("XB","P");
mol2.cc:771:    wilds->addWildName("XC");
mol2.cc:772:    wilds->addWildNameMap("XC","F");
mol2.cc:773:    wilds->addWildNameMap("XC","Cl");
mol2.cc:774:    wilds->addWildNameMap("XC","Br");
mol2.cc:775:    wilds->addWildNameMap("XC","I");
mol2.cc:777:    wilds->addWildName("XD");
mol2.cc:778:    wilds->addWildNameMap("XD","S");
mol2.cc:779:    wilds->addWildNameMap("XD","P");
mol2.cc:780:    sybylRules->setWildElementDict(wilds);
mol2.cc:856:	match->compileAntechamber(typeRuleString,wilds);
mol2.cc:857:	rule->setAssignTypeName(match->getAssignType());
mol2.cc:858:	rule->setCode(match);
mol2.cc:859:	sybylRules->appendRule(rule);
molecule.cc:31:	this->Base::initialize();
molecule.cc:40:	return this->Base::__repr__();
molecule.cc:54:	this->Base::serialize(node);
molecule.cc:55:	if ( node->saving() ) {
molecule.cc:57:	    _BLOCK_TRACE("Xmling inter-residue bonds");
molecule.cc:61:		lb.loopTopMoleculeGoal( this->sharedThis<Molecule_O>(), BONDS );
molecule.cc:65:		    // LOG(BF("bond with atom1=%s") % a1->description().c_str()  );
molecule.cc:66:		    // LOG(BF("bond with atom2=%s") % a2->description().c_str()  );
molecule.cc:68:		    bond = _lisp->create<Bond_O>(a1,a2,o);
molecule.cc:69:		    if ( bond->isInterResidueBond() )
molecule.cc:72:			    % a1->description()
molecule.cc:73:			    % a2->description() );
molecule.cc:74:			bondList->addBond(bond);
molecule.cc:78:	    node->archiveObject<BondList_O>("bl",bondList);
molecule.cc:82:	    node->archiveObject<BondList_O>("bl",bondList);
molecule.cc:84:	    bondList->imposeYourself();
molecule.cc:102:	this->Matter_O::archiveBase(node);
molecule.cc:103:	if ( node->saving() ) {
molecule.cc:105:	    _BLOCK_TRACE("Xmling inter-residue bonds");
molecule.cc:109:		lb.loopTopMoleculeGoal( this->sharedThis<Molecule_O>(), BONDS );
molecule.cc:113:		    // LOG(BF("bond with atom1=%s") % a1->description().c_str()  );
molecule.cc:114:		    // LOG(BF("bond with atom2=%s") % a2->description().c_str()  );
molecule.cc:116:		    bond = _lisp->create<Bond_O>(a1,a2,o);
molecule.cc:117:		    if ( bond->isInterResidueBond() )
molecule.cc:120:			    % a1->description()
molecule.cc:121:			    % a2->description() );
molecule.cc:122:			bondList->addBond(bond);
molecule.cc:126:	    node->archiveObject<BondList_O>("bl",bondList);
molecule.cc:130:	    node->archiveObject<BondList_O>("bl",bondList);
molecule.cc:132:	    bondList->imposeYourself();
molecule.cc:168:	this->addMatter( r );
molecule.cc:169:	LOG(BF("Added %s to %s") % r->description().c_str() % this->description().c_str()  );
molecule.cc:179:	LOG(BF("Adding %s to %s") % r->description().c_str() % this->description().c_str()  );
molecule.cc:180:	this->addMatterRetainId( r );
molecule.cc:195:	for ( it=this->getContents().begin(); it!= this->getContents().end(); it++ ) {
molecule.cc:197:		this->eraseContent(it);
molecule.cc:201:	SIMPLE_ERROR(BF("removeResidue: Molecule does not contain residue: %s", a->getName() )));
molecule.cc:207:	if ( this->eq(obj) ) return true;
molecule.cc:208:	if ( !obj->isOfClass<Molecule_O>() ) return false;
molecule.cc:209:	Molecule_sp other = obj->as<Molecule_O>();
molecule.cc:210:	if ( other->getName() != this->getName() ) return false;
molecule.cc:211:	if ( other->_contents.size() != this->_contents.size() ) return false;
molecule.cc:212:	Matter_O::const_contentIterator tit = this->_contents.begin();
molecule.cc:213:	Matter_O::const_contentIterator oit = this->_contents.begin();
molecule.cc:214:	for ( ; tit!=this->_contents.end(); tit++, oit++ )
molecule.cc:216:	    if ( ! (*tit)->equal(*oit) ) return false;
molecule.cc:222:	if ( !obj->isOfClass<Molecule_O>() ) 
molecule.cc:226:	Molecule_sp other = obj->as<Molecule_O>();
molecule.cc:227:	if ( other->_contents.size() != this->_contents.size() )
molecule.cc:232:	for ( tit=this->_contents.begin(), oit=other->_contents.begin();
molecule.cc:233:	      tit!=this->_contents.end(); tit++, oit++ )
molecule.cc:235:	    (*tit)->transferCoordinates(*oit);
molecule.cc:244:	rHead = this->getContents().begin();
molecule.cc:246:	for ( r=rRest;r!=this->getContents().end(); ) {
molecule.cc:247:	    for ( a = (*r)->getContents().begin(); a!= (*r)->getContents().end();) {
molecule.cc:248:		(*a)->reparent(*rHead);
molecule.cc:249:		a = (*r)->eraseContent(a);
molecule.cc:252:	    r = this->eraseContent(r);
molecule.cc:270://    newMol->duplicate(this);	// *newMol = *this;
molecule.cc:272:	for ( const_contentIterator a=this->begin_contents(); a!=this->end_contents(); a++ )
molecule.cc:274:	    res = (*a)->as<Residue_O>();
molecule.cc:275:	    newMol->addMatter(res->copyDontRedirectAtoms());
molecule.cc:278:	newMol->copyRestraintsDontRedirectAtoms(this);
molecule.cc:287:	for ( contentIterator a=this->getContents().begin(); a!=this->getContents().end(); a++ )
molecule.cc:290:	    res->redirectAtoms();
molecule.cc:292:	this->redirectRestraintAtoms();
molecule.cc:301:	newMol = this->copyDontRedirectAtoms()->as<Molecule_O>();
molecule.cc:302:	newMol->redirectAtoms();
molecule.cc:311:	printf( "Molecule: %s at: 0x%lx contains %d residues\n", this->getName().c_str(), this, this->getContents().size() );
molecule.cc:312:	for ( rit=this->getContents().begin();
molecule.cc:313:	      rit!=this->getContents().end(); rit++ ) {
molecule.cc:315:	    res->dump();
molecule.cc:323:	lr.loopTopMoleculeGoal( this->sharedThis<Molecule_O>(), RESIDUES );
molecule.cc:325:	    if ( lr.getResidue()->getName() == name ) {
molecule.cc:337:	residues = this->getResiduesWithName(name);
molecule.cc:344:	residues = this->getResiduesWithName(name);
molecule.cc:356:	rend = _lisp->create<GrPickableMatter_O>();
molecule.cc:357:	rend->setFromMatter(this->sharedThis<Molecule_O>());
molecule.cc:367:	lb.loopTopMoleculeGoal( this->sharedThis<Molecule_O>(), RESIDUES);
molecule.cc:370:	    numberOfAtoms += lb.getResidue()->numberOfAtoms();
molecule.cc:378:	AtomIdToAtomMap_sp atomIdMap = _lisp->create<AtomIdToAtomMap_O>();
molecule.cc:379:	atomIdMap->resize(1);
molecule.cc:381:	int numResidues = this->_contents[mid]->_contents.size();
molecule.cc:382:	atomIdMap->resize(mid,numResidues);
molecule.cc:385:	    int numAtoms = this->_contents[mid]->_contents[rid]->_contents.size();
molecule.cc:386:	    atomIdMap->resize(mid,rid,numAtoms);
molecule.cc:390:		atomIdMap->set(atomId,this->_contents[mid]->_contents[rid]->_contents[aid]->as<Atom_O>());
molecule.cc:398:	int resId = atomId->residueId();
molecule.cc:399:	if ( resId >=0 && resId <=(int)this->_contents.size() )
molecule.cc:401:	    Residue_sp residue = this->_contents[resId]->as<Residue_O>();
molecule.cc:402:	    return residue->atomWithAtomId(atomId);
molecule.cc:404:	SIMPLE_ERROR(BF("Illegal residueId[%d] must be less than %d") % resId % this->_contents.size() );
monomer.cc:47:	this->_SpanningBackToRoot = info->_SpanningBackToRoot;
monomer.cc:48:	this->_SpanningNext = info->_SpanningNext;
monomer.cc:49:	this->_SpanningTouched = info->_SpanningTouched;
monomer.cc:50:	this->_CouplingBackToRoot = info->_CouplingBackToRoot;
monomer.cc:68:	this->Base::archiveBase(node);
monomer.cc:69:	node->archiveWeakPointer("oligomer",this->_WeakOligomer);
monomer.cc:70:	node->archiveWeakPointer("tempResidue",this->_WeakTempResidue);
monomer.cc:71:	node->archiveWeakSymbolMultiMap<Coupling_O>("couplings",this->_WeakCouplings);
monomer.cc:72:	node->attribute("comment", this->_Comment);
monomer.cc:73:	node->attributeSymbolIfNotNil("id", this->_Id);
monomer.cc:74:	node->archiveObjectIfDefined("aliases", this->_Aliases);
monomer.cc:75:	node->attribute("verbose", this->_Verbose);
monomer.cc:76:	node->attributeIfNotDefault("tempInt", this->_TemporaryInt,0);
monomer.cc:77:	node->attribute("sequenceNumber",this->_SequenceNumber);
monomer.cc:78:	node->archiveObjectIfDefined("status",this->_Status);
monomer.cc:79:	node->archivePlainObject<addon::Vector2>( "pos2","Vector2",
monomer.cc:80:						 this->_Position2D );
monomer.cc:81:	node->attribute("selected",this->_Selected );
monomer.cc:82:	if ( node->loading() )
monomer.cc:84:	    if ( this->_Status->isNil() )	
monomer.cc:86:		this->_Status = _lisp->create<StatusTracker_O>();
monomer.cc:105:	if ( !this->isMonomerContextValid() )
monomer.cc:107:	    SIMPLE_ERROR(BF("Monomer context is invalid: %s") % this->sharedThis<Monomer_O>()->description() );
monomer.cc:110:	context = _lisp->create<MonomerContext_O>();
monomer.cc:112:	selfRecognizer->addGroupName(this->getGroupName());
monomer.cc:113:	context->setFocus(selfRecognizer);
monomer.cc:114:	for ( ci=this->begin_WeakCouplings(); ci!=this->end_WeakCouplings(); ci++ )
monomer.cc:116:	    coupling = (ci->second).lock();
monomer.cc:120:	    if ( coupling->isAssignableTo<RingCoupling_O>() ) continue;
monomer.cc:122:	    neighborMonomer = coupling->getOtherSideMonomer(this->sharedThis<Monomer_O>());
monomer.cc:123:	    neighborRecognizer->addGroupName(neighborMonomer->getGroupName());
monomer.cc:124:	    context->addNeighbor(ci->first,neighborRecognizer);
monomer.cc:129:    void	Monomer_O::clearError()	{_OF();ASSERTNOTNULL(this->_Status);this->_Status->reset();};
monomer.cc:130:    bool	Monomer_O::getHasError()	{ return this->_Status->hasError();};
monomer.cc:131:    string	Monomer_O::getStatusMessage() { return this->_Status->getStatus();};
monomer.cc:132:    void	Monomer_O::addErrorMessage(const string& s) { this->_Status->addError(s);};
monomer.cc:133:    void	Monomer_O::addStatusMessage(const string& s) {this->_Status->addMessage(s);};
monomer.cc:134:    StatusTracker_sp	Monomer_O::getStatusTracker() { return this->_Status;};
monomer.cc:141:	for ( ci=this->begin_WeakCouplings(); ci!=this->end_WeakCouplings(); ci++ )
monomer.cc:143:	    Coupling_sp coupling = (ci->second).lock();
monomer.cc:144:	    core::Cons_sp oneOne = core::Cons_O::createList(ci->first,coupling);
monomer.cc:146:	    cur->setCdr(one);
monomer.cc:149:	return first->cdr();
monomer.cc:156:	for ( it=this->_WeakCouplings.begin(); it!=this->_WeakCouplings.end(); it++ )
monomer.cc:158:	    if ( it->second.lock()->isRingClosing() ) return true;
monomer.cc:167:	return core::SymbolSet_O::create_fromKeysOfWeakSymbolMultiMap(this->_WeakCouplings,_lisp);
monomer.cc:173:	this->_Aliases->clear();
monomer.cc:174:	this->_Aliases->insertConsSymbols(aliases);
monomer.cc:180:	ASSERTNOTNULL(this->_WeakTempResidue);
monomer.cc:181:	return this->_WeakTempResidue.lock().notnilp();
monomer.cc:189:	if ( !this->hasInCoupling() )
monomer.cc:193:	DirectionalCoupling_sp coupling = this->getInCoupling();
monomer.cc:194:	OutPlug_sp preceedingPlug = coupling->getPlugForOtherMonomer(this->sharedThis<Monomer_O>())->as<OutPlug_O>();
monomer.cc:195:	Monomer_sp preceedingMonomer = coupling->getOtherSideMonomer(this->sharedThis<Monomer_O>());
monomer.cc:196:	Frame_sp frame = preceedingPlug->getExportFrame();
monomer.cc:197:	if ( frame->isNil() )
monomer.cc:201:	    ss << this->description() << endl;
monomer.cc:202:	    ss << " coupling = " << coupling->description() << endl;
monomer.cc:203:	    ss << " preceeding monomer is = " << preceedingMonomer->description() << endl;
monomer.cc:204:	    ss << " preceeding plug = " << preceedingPlug->description() << endl;
monomer.cc:208:	BoundFrame_sp bound = frame->getBoundFrame(preceedingMonomer);
monomer.cc:209:	if ( !bound->isOfClass<AtomBoundFrame_O>() )
monomer.cc:211:	    SIMPLE_ERROR(BF("The frame must return an AtomBoundFrame but instead it returned a "+bound->description()));
monomer.cc:213:	return bound->as<AtomBoundFrame_O>();
monomer.cc:220:	ASSERTNOTNULL(this->_Aliases);
monomer.cc:221:	this->_Aliases->setFromString(s);
monomer.cc:228:	ASSERTNOTNULL(this->_Aliases);
monomer.cc:229:	return this->_Aliases->asString();
monomer.cc:236:	this->_Aliases->clear();
monomer.cc:237:	this->_Aliases->insertSymbolList(aliases);
monomer.cc:246:	LOG(BF("Check for bad connections %s") % this->description().c_str() );
monomer.cc:247:	for ( it=this->begin_WeakCouplings(); it!=this->end_WeakCouplings(); it++ )
monomer.cc:249:	    if ( it->second.lock()->isNil() )
monomer.cc:251:		this->addErrorMessage("Coupling with plug("+it->first->__repr__()+") is Null");
monomer.cc:255:	    coup = it->second.lock();
monomer.cc:256:	    if ( !coup->containsMonomer(this->sharedThis<Monomer_O>()) )
monomer.cc:258:		this->addErrorMessage("The coupling through plug("+it->first->__repr__()+") doesn't contain me");
monomer.cc:267:	if ( this->checkForBadConnections() )
monomer.cc:269:	    LOG(BF("Found bad connections in %s  error: %s") % this->description().c_str() % this->getStatusMessage().c_str()  );
monomer.cc:270:	    SIMPLE_ERROR(BF("Bad connections for monomer: %s") % this->sharedThis<Monomer_O>()->description());
monomer.cc:282:	this->clearError();
monomer.cc:283:	this->checkForBadConnections();
monomer.cc:296:	if ( !this->isMonomerContextValid() )
monomer.cc:298:	    SIMPLE_ERROR(BF("Monomer context is invalid: %s") %this->sharedThis<Monomer_O>()->description() );
monomer.cc:301:	context = _lisp->create<MonomerContext_O>();
monomer.cc:303:	selfRecognizer->setMonomerNameOrPdb(this->getName());
monomer.cc:304:	context->setFocus(selfRecognizer);
monomer.cc:305:	for ( ci=this->begin_WeakCouplings(); ci!=this->end_WeakCouplings(); ci++ )
monomer.cc:307:	    coupling = (ci->second).lock();
monomer.cc:308:	    if ( coupling->isOfClass<DirectionalCoupling_O>() )
monomer.cc:311:		neighborMonomer = coupling->getOtherSideMonomer(this->sharedThis<Monomer_O>());
monomer.cc:312:		neighborRecognizer->setMonomerNameOrPdb(neighborMonomer->getName());
monomer.cc:313:		context->addNeighbor(ci->first,neighborRecognizer);
monomer.cc:316:		RingCoupling_sp rc = coupling->as<RingCoupling_O>();
monomer.cc:317:		LOG(BF("Ignoring out coupling for RingCoupling: %s") % rc->getName()->__repr__() );
monomer.cc:333:	constitution = bdb->constitutionForNameOrPdb(this->getName());
monomer.cc:334:	return constitution->getMissingRingClosingPlug(this->sharedThis<Monomer_O>(),mate);
monomer.cc:345:	constitution = bdb->constitutionForNameOrPdb(this->getName());
monomer.cc:348:	topology = constitution->getTopologyForMonomerEnvironment(this->sharedThis<Monomer_O>());
monomer.cc:358:	this->_WeakOligomer = o->sharedThis<Oligomer_O>();
monomer.cc:363:	this->Base::initialize();
monomer.cc:364:	this->_WeakOligomer = Oligomer_O::_nil;
monomer.cc:365:	this->_WeakTempResidue = Residue_O::_nil;
monomer.cc:366:	this->setComment("");
monomer.cc:367:	this->_Id = core::Symbol_O::_nil;
monomer.cc:368:	this->_Aliases = core::SymbolSet_O::create();
monomer.cc:369:	this->_Verbose = false;
monomer.cc:370:	this->_TemporaryInt = 0;
monomer.cc:371:	this->_SequenceNumber = 0;
monomer.cc:372:	this->_Status = _lisp->create<StatusTracker_O>();
monomer.cc:373:	this->_Status->reset();
monomer.cc:374:	this->_Selected = false;
monomer.cc:375:	this->setPosition2D_xy(0.0,0.0);
monomer.cc:388:	for ( it=this->begin_WeakCouplings(); it!=this->end_WeakCouplings(); it++ ) {
monomer.cc:389:	    if ( DirectionalCoupling_O::isInPlugName(it->first,_lisp) )
monomer.cc:391:		ASSERTNOTNULL(it->second);
monomer.cc:392:		coup = it->second.lock()->as<DirectionalCoupling_O>();
monomer.cc:406:	for ( it=this->begin_WeakCouplings(); it!=this->end_WeakCouplings(); it++ ) 
monomer.cc:408:	    ASSERTNOTNULL(it->second);
monomer.cc:409:	    Coupling_sp coup = it->second.lock();
monomer.cc:410:	    if ( coup->isOfClass<DirectionalCoupling_O>() )
monomer.cc:412:		DirectionalCoupling_sp dc = coup->as<DirectionalCoupling_O>();
monomer.cc:413:		if ( dc->isInCouplingToMonomer(this->sharedThis<Monomer_O>()) ) return it->first;
monomer.cc:423:	coup = this->getInCoupling();
monomer.cc:431:	coup = this->getInCoupling();
monomer.cc:441:	con = getCandoDatabase(_lisp)->constitutionForNameOrPdb(this->getName());
monomer.cc:443:	if ( !con->hasPlugNamed(pn) )
monomer.cc:446:	    ss << "Constitution(" << con->getName();
monomer.cc:447:	    ss << ") does not have plug named(" << pn->__repr__() << ")";
monomer.cc:448:	    ss << "  available plugs(" << con->getPlugNames()->asString() << ")";
monomer.cc:451:	plug = con->getPlugNamed(pn);
monomer.cc:464:	nm = this->getName();
monomer.cc:466:	LOG(BF("Monomer name (%s)") % nm->__repr__() );
monomer.cc:467:	return db->constitutionForNameOrPdb(nm);
monomer.cc:476:	if ( this->_WeakCouplings.contains(s) ) {
monomer.cc:478:	    coup = this->_WeakCouplings.get(s,_lisp);
monomer.cc:488:	c = this->getCouplingWithPlugName(s);
monomer.cc:500:	LOG(BF("Looking for plug name: %s and coupling: %s") % plugName->__repr__() % coup->description() );
monomer.cc:503:	range = this->_WeakCouplings.equal_range(plugName);
monomer.cc:507:	    ASSERTNOTNULLP(it->second,"Coupling is undefined");
monomer.cc:508:	    myCoup = it->second.lock();
monomer.cc:509:	    LOG(BF("Looking at coupling: %s") % myCoup->description().c_str()  );
monomer.cc:525:	LOG(BF("add coupling to %s") % this->description() );
monomer.cc:526:	LOG(BF("Adding plug(%s) coupling: %s") % plugName->__repr__() % coup->description() );
monomer.cc:527:	this->_WeakCouplings.insert2(plugName, coup->sharedThis<Coupling_O>());
monomer.cc:528:	LOG(BF("After add monomer is %s") % this->description() );
monomer.cc:535:	LOG(BF("resetting in coupling of %s") % this->description() );
monomer.cc:537:	if ( this->hasInCoupling() ) {
monomer.cc:540:	    inCoup = this->getInCoupling();
monomer.cc:541:	    this->removeCoupling(inCoup);
monomer.cc:549:	LOG(BF("setting in coupling of %s") % this->description() );
monomer.cc:551:	this->resetInCoupling();
monomer.cc:552:	LOG(BF("Adding in coupling: %s") % coup->description() );
monomer.cc:553:	inCoupName = DirectionalCoupling_O::inPlugName(coup->getName(),_lisp);
monomer.cc:554:	this->addCoupling( inCoupName, coup );
monomer.cc:562:	LOG(BF("adding out coupling to %s") % this->description()  );
monomer.cc:563:	core::Symbol_sp outPlugName = DirectionalCoupling_O::outPlugName(coup->getName(),_lisp);
monomer.cc:564:	LOG(BF("Adding out coupling: %s") % coup->description() );
monomer.cc:565:	this->addCoupling( outPlugName, coup );
monomer.cc:576:	for ( wci=this->begin_WeakCouplings(); wci!=this->end_WeakCouplings(); wci++ )
monomer.cc:578:	    coup = wci->second.lock();
monomer.cc:579:	    otherMonomer = coup->getOtherSideMonomer(this->sharedThis<Monomer_O>());
monomer.cc:588:	    SIMPLE_ERROR(BF("Could not find coupling to monomer: %s %s") % mon->description() % this->sharedThis<Monomer_O>()->description() );
monomer.cc:590:	LOG(BF("Removing coupling: %s") % coup->description() );
monomer.cc:591:	this->_WeakCouplings.erase(wci);
monomer.cc:605:	for ( wci=this->begin_WeakCouplings(); wci!=this->end_WeakCouplings(); wci++ )
monomer.cc:607:	    myCoup = (wci->second).lock();
monomer.cc:611:		isInPlug = DirectionalCoupling_O::isInPlugName(wci->first,_lisp);
monomer.cc:612:		LOG(BF("Original plug name: %s") % wci->first->__repr__() );
monomer.cc:618:	    THROW(_lisp->create<core::ContentException_O>("Could not find coupling : "+coup->description(), this->sharedThis<Monomer_O>()->description() ));
monomer.cc:620:	LOG(BF("Fixing the PlugName key for coupling: %s") % coup->description().c_str()  );
monomer.cc:621:	this->_WeakCouplings.erase(wci);
monomer.cc:624:	    plugName = DirectionalCoupling_O::inPlugName(coup->getName(),_lisp);
monomer.cc:627:	    plugName = DirectionalCoupling_O::outPlugName(coup->getName(),_lisp);
monomer.cc:629:	LOG(BF("Changing plug name to: %s") % plugName->__repr__() );
monomer.cc:630:	this->addCoupling( plugName, coup );
monomer.cc:649:	for ( wci=this->_WeakCouplings.begin(); wci!=this->_WeakCouplings.end(); wci++ )
monomer.cc:651:	    myCoup = wci->second.lock();
monomer.cc:660:	    THROW(_lisp->create<core::ContentException_O>("Could not find coupling: "+coup->description(), this->sharedThis<Monomer_O>()->description() ));
monomer.cc:662:	LOG(BF("Removing coupling: %s") % myCoup->description().c_str()  );
monomer.cc:663:	this->_WeakCouplings.erase(wci);
monomer.cc:668://---------------------------------------------------------------------
monomer.cc:669://---------------------------------------------------------------------
monomer.cc:670://---------------------------------------------------------------------
monomer.cc:671://---------------------------------------------------------------------
monomer.cc:676:	node->attribute("name",this->_Name);
monomer.cc:680://---------------------------------------------------------------------
monomer.cc:681://---------------------------------------------------------------------
monomer.cc:682://---------------------------------------------------------------------
monomer.cc:683://---------------------------------------------------------------------
monomer.cc:688:	this->Base::initialize();
monomer.cc:689:	this->_Monomers.clear();
monomer.cc:690:	this->_CurrentMonomerIndex = -1;
monomer.cc:702:    if ( name.notnilp() ) me->setGroupName(name);
monomer.cc:703:    if ( comment != "" ) me->setComment(comment);
monomer.cc:712:	core::Symbol_sp name = translate::from_object<core::Symbol_O>::convert(env->lookup(Package(),"name"));
monomer.cc:713:	if ( name.notnilp() ) this->setGroupName(name);
monomer.cc:714:	string comment = translate::from_object<string>::convert(env->lookup(Package(),"comment"));
monomer.cc:715:	if ( comment != "" ) this->setComment(comment);
monomer.cc:723:	this->Monomer_O::archiveBase(node);
monomer.cc:724:	node->attribute("currentMonomerIndex",this->_CurrentMonomerIndex );
monomer.cc:725:	node->attribute("groupName",this->_GroupName);
monomer.cc:726:	node->archiveVector0("monomers",this->_Monomers);
monomer.cc:733:	if ( this->_Monomers.size() == 0 ) return _Nil<core::Symbol_O>();
monomer.cc:734:	return this->getOneMonomer()->getName();
monomer.cc:744:	name = this->_GroupName;
monomer.cc:745:	this->_Monomers.clear();
monomer.cc:747:	this->clearError();
monomer.cc:748:	if ( !bdb->recognizesSetOrConstitutionOrMonomerName(name) )
monomer.cc:750:	    LOG(BF("Illegal group name(%s)") % name->__repr__() );
monomer.cc:751:	    this->addErrorMessage("Illegal group name: "+name->__repr__());
monomer.cc:754:	LOG(BF("Legal group name(%s)") % name->__repr__() );
monomer.cc:755:	monomerNames = bdb->expandEntityNameToTerminals(name);
monomer.cc:756:	LOG(BF("Got %d monomer names") % monomerNames->size() );
monomer.cc:758:	for ( si=monomerNames->begin(); si!=monomerNames->end(); si++ )
monomer.cc:760:	    LOG(BF("Adding monomer named(%s)") % (*si)->__repr__() );
monomer.cc:761:	    this->addMonomerName(*si);
monomer.cc:763:	if ( this->_CurrentMonomerIndex >= this->_Monomers.size() )
monomer.cc:765:	    this->_CurrentMonomerIndex = 0;
monomer.cc:775:	this->_GroupName = name;
monomer.cc:776:	this->_expandGroupName();
monomer.cc:788:	this->addStatusMessage("MultiMonomer_O::checkForErrorsAndUnknownContexts");
monomer.cc:790:	this->Monomer_O::checkForErrorsAndUnknownContexts(cdb);
monomer.cc:791:	if ( this->getHasError() ) return;
monomer.cc:792:	if ( this->numberOfPossibleMonomers() == 0 )
monomer.cc:794:	    this->addErrorMessage("This MultiMonomer is empty");
monomer.cc:797:	if ( !this->isMonomerContextValid() )
monomer.cc:799:	    this->addErrorMessage("The MonomerContext is invalid");
monomer.cc:802:	context = this->getGeneralMonomerContext();
monomer.cc:803:	allSpecificContextKeys = context->getAllSpecificKeys();
monomer.cc:806:	ss << "There are " << allSpecificContextKeys->size() << " specific contexts" << endl;
monomer.cc:807:	this->addStatusMessage(ss.str());
monomer.cc:808:	if ( allSpecificContextKeys->size() == 0 )
monomer.cc:810:	    this->addErrorMessage("There are no legal specific contexts");
monomer.cc:813:	    for ( sit=allSpecificContextKeys->begin(); sit!=allSpecificContextKeys->end(); sit++ )
monomer.cc:815:		if ( !cdb->recognizesMonomerCoordinatesKey(*sit) )
monomer.cc:817:		    this->addErrorMessage("Monomer->Unrecognized context: "+*sit);
monomer.cc:824:		this->addStatusMessage("All contexts are recognized.");
monomer.cc:835:	om->setName(name);
monomer.cc:836:	this->_Monomers.push_back(om);
monomer.cc:844:	ASSERT(this->_Monomers.size()>=1);
monomer.cc:845:	if ( this->_Monomers.size()==1 )
monomer.cc:850:	uint newMonomerIndex = core::randomNumber01()*this->_Monomers.size();
monomer.cc:851:	if ( newMonomerIndex != this->_CurrentMonomerIndex )
monomer.cc:853:	    this->_CurrentMonomerIndex = newMonomerIndex;
monomer.cc:856:	    this->_CurrentMonomerIndex++;
monomer.cc:857:	    if ( this->_CurrentMonomerIndex >= this->_Monomers.size() )
monomer.cc:859:		this->_CurrentMonomerIndex = 0;
monomer.cc:862:	LOG(BF("Randomized monomer(%s) to %d out of %d") % this->getComment().c_str()
monomer.cc:863:	    % this->_CurrentMonomerIndex % this->_Monomers.size()  );
monomer.cc:871:	if ( this->_Monomers.size() < 1 ) {
monomer.cc:872:	    SIMPLE_ERROR(BF("There are no monomers defined for MultiMonomer group("+this->_GroupName->__repr__()+")"));
monomer.cc:874:	LOG(BF("Looking up monomer: %d") % this->_CurrentMonomerIndex  );
monomer.cc:875:	return this->_Monomers[this->_CurrentMonomerIndex];
monomer.cc:884:	monName = this->getName();
monomer.cc:885:	con = getCandoDatabase(_lisp)->constitutionForNameOrPdb(monName);
monomer.cc:886:	Residue_sp res = con->createResidueForStereoisomerName(monName);
monomer.cc:887:	Constitution_sp residueConstitution = res->getConstitution();
monomer.cc:890:	    SIMPLE_ERROR(BF("Residue created with a different constitution(%s) from the one it was created from constitution(%s)") % residueConstitution->__repr__() % con->__repr__() );
monomer.cc:899:	res->setMonomerAliases(this->_Aliases);
monomer.cc:900:	res->setUniqueLabel(this->_Id->identifierName());
monomer.cc:901:	if ( getCandoDatabase(_lisp)->recognizesEntityNameSetName(this->_GroupName) )
monomer.cc:903:	    EntityNameSet_sp monomerPack = getCandoDatabase(_lisp)->getEntity(this->_GroupName)->as<EntityNameSet_O>();
monomer.cc:904:	    if ( monomerPack->supportsInterestingAtomAliases() )
monomer.cc:906:		core::SymbolList_sp atomAliases = monomerPack->getInterestingAtomAliases();
monomer.cc:907:		AtomIndexer_sp aliasAtoms = monomerPack->getAtomIndexerForMonomerName(this->getName());
monomer.cc:908:		ASSERTP(atomAliases->size() == aliasAtoms->numberOfAtomNames(),
monomer.cc:912:		for ( ii = aliasAtoms->begin_AtomNames(), ai=atomAliases->begin();
monomer.cc:913:		      ii != aliasAtoms->end_AtomNames(); ii++, ai++ )
monomer.cc:915:		    Atom_sp atom = res->atomWithName(*ii);
monomer.cc:916:		    atom->setAlias(*ai);
monomer.cc:923:		    ss << "    The _GroupName is ("<<this->_GroupName<<") and the monomer has the aliases("<<this->_Aliases->asString()<< ")"<< endl;
monomer.cc:924:		    ss << "    The monomer name is ("<<this->getName()<<")"<<endl;
monomer.cc:925:		    ss << "    The atoms interesting atom names are ("<<monomerPack->getInterestingAtomNamesForMonomerName(this->getName())<<")"<<endl;
monomer.cc:926:		    ss << "    The atom aliases are ("<<monomerPack->getInterestingAtomAliasesAsString() <<")"<<endl;
monomer.cc:927:		    _lisp->print(BF("%s"), ss.str());
monomer.cc:932:	this->setTempResidue(res);
monomer.cc:944:	ss << "["<<this->getGroupName()<<" id:" << this->_Id->__repr__() << "]=";
monomer.cc:947:	for ( ci=this->begin_WeakCouplings(); ci!=this->end_WeakCouplings(); ci++ )
monomer.cc:949:	    ss << ci->first << ",";
monomer.cc:959:	core::SymbolSet_sp keys = core::SymbolSet_O::create_fromKeysOfWeakSymbolMultiMap(this->_WeakCouplings,_lisp);
monomer.cc:962:	if ( keys->size() < this->_WeakCouplings.size() )
monomer.cc:975:	for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
monomer.cc:977:	    if ( (*mi)->getName() == name ) return *mi;
monomer.cc:990:	if ( bdb->recognizesEntityNameSetName(this->getGroupName()) )
monomer.cc:992:	    entityNameSet = bdb->getEntityNameSet(this->getGroupName());
monomer.cc:993:	    if ( entityNameSet->supportsInterestingAtomAliases() )
monomer.cc:995:		atomIndexer = entityNameSet->getAtomIndexerForMonomerName(this->getName());
monomer.cc:999:	atomIndexer = _lisp->create<AtomIndexer_O>();
monomer.cc:1012:	if ( bdb->recognizesEntityNameSetName(this->getGroupName()) )
monomer.cc:1014:	    LOG(BF("Recognized the EntityNameSetName(%s)")% this->getGroupName() );
monomer.cc:1015:	    entityNameSet = bdb->getEntityNameSet(this->getGroupName());
monomer.cc:1016:	    core::SymbolList_sp aliases = entityNameSet->getInterestingAtomAliases();
monomer.cc:1017:	    LOG(BF("Returning with aliases(%s)")% aliases->asString() );
monomer.cc:1021:	    LOG(BF("Did not recognize the EntityNameSetName(%s)")% this->getGroupName());
monomer.cc:1036:	    this->_Lisp = lisp;
monomer.cc:1040:	    Alias_sp alias = Alias_O::create(this->_Lisp,obj1,obj2);
monomer.cc:1048:	ASSERTNOTNULL(this->_Aliases);
monomer.cc:1049:	if ( this->_Aliases->size() == 0 )
monomer.cc:1051:	    if ( this->allAtomAliases()->size() != 0 )
monomer.cc:1053:		SIMPLE_ERROR(BF("The monomer[%s] doesn't have monomer aliases but it has atom aliases(%s) - this should never happen") % this->getName() % this->allAtomAliases()->asString() );
monomer.cc:1057:	ASSERT_gt(this->_Aliases->size(),0);
monomer.cc:1059:	core::SymbolList_sp atomAliasesList = this->allAtomAliases();
monomer.cc:1060:	atomAliases->insertSymbolList(atomAliasesList);
monomer.cc:1062:	core::ObjectSet_sp allAliases = this->_Aliases->cartesianProductWrapped(atomAliases,wrapper);
monomer.cc:1075:	LOG(BF("Checking if %s recognizes alias(%s)") % this->description().c_str() % alias->__repr__().c_str()  );
monomer.cc:1076:	if ( !this->_Aliases->contains(alias->getMonomerAlias()) )
monomer.cc:1079:	    LOG(BF("The monomer aliases that it recognizes are: %s") % this->_Aliases->asString().c_str()  );
monomer.cc:1082:	LOG(BF("%s does recognize monomer alias(%s)") % this->description().c_str() % alias->__repr__().c_str() );
monomer.cc:1084:	if ( bdb->recognizesEntityNameSetName(this->getGroupName()) )
monomer.cc:1086:	    LOG(BF("Checking if represents a EntityNameSet with interesting atom alias(%s)") % alias->getAtomAlias()->__repr__()  );
monomer.cc:1087:	    entityNameSet = bdb->getEntityNameSet(this->getGroupName());
monomer.cc:1088:	    if ( entityNameSet->hasInterestingAtomAlias( alias ) )
monomer.cc:1090:		LOG(BF("EntityNameSet does have interesting atom with alias(%s)") % alias->getAtomAlias()->__repr__()  );
monomer.cc:1094:		LOG(BF("EntityNameSet does not have interesting atom with alias(%s)") % alias->getAtomAlias()->__repr__()  );
monomer.cc:1107:	this->_CurrentMonomerIndex++;
monomer.cc:1108:	if ( this->_CurrentMonomerIndex == this->_Monomers.size() )
monomer.cc:1110:	    LOG(BF("Increment overflow -- resetting to zero") );
monomer.cc:1111:	    this->_CurrentMonomerIndex = 0;
monomer.cc:1114:	LOG(BF("After increment index(%d)  monomer=%s") % this->_CurrentMonomerIndex % this->description().c_str()  );
monomer.cc:1125:	for ( wci=this->begin_WeakCouplings();
monomer.cc:1126:	      wci!=this->end_WeakCouplings(); wci++ ) {
monomer.cc:1127:	    if ( DirectionalCoupling_O::isOutPlugName(wci->first,_lisp) )
monomer.cc:1129:		ASSERTNOTNULL(wci->second);
monomer.cc:1130:		coup = wci->second.lock();
monomerContext.cc:38:	this->_Self = RP_Copy<EntityNameSetBase_O>(mc._Self);
monomerContext.cc:40:	    rec = RP_Copy<EntityNameSetBase_O>(mi->second);
monomerContext.cc:41:	    this->_Neighbors.set(mi->first,rec);
monomerContext.cc:53:	if ( node->saving() )
monomerContext.cc:56:	    for ( mi=this->_Neighbors.begin(); mi!=this->_Neighbors.end(); mi++ )
monomerContext.cc:58:		ASSERTF(DirectionalCoupling_O::isPlugName(mi->first,_lisp),BF("About to save Bad plug name in MonomerContext Neighbor: %s")% mi->first );
monomerContext.cc:62:	node->archiveObject("self",this->_Self);
monomerContext.cc:63:	node->archiveSymbolMap("neighbors", this->_Neighbors );
monomerContext.cc:65:	if ( node->loading() )
monomerContext.cc:68:	    for ( mi=this->_Neighbors.begin(); mi!=this->_Neighbors.end(); mi++ )
monomerContext.cc:70:		ASSERTF(DirectionalCoupling_O::isPlugName(mi->first,_lisp), BF("Loaded Bad plug name in MonomerContext Neighbor: %s")% mi->first );
monomerContext.cc:81:	desc << this->core::T_O::description();
monomerContext.cc:88:	LOG(BF("Added neighbor with key plug: %s") % cn->__repr__()  );
monomerContext.cc:91:	ASSERTF(this->_Neighbors.count(cn) == 0, BF("MonomerContext already has a key: %s")% cn );
monomerContext.cc:92:	this->_Neighbors.set(cn,r);
monomerContext.cc:105:	if ( mit==this->_Neighbors.end() ) {
monomerContext.cc:106:	    SpecificContext_sp final = name->copy();
monomerContext.cc:107:	    list->add(final);
monomerContext.cc:109:	    if ( mit->second->getOptional() )
monomerContext.cc:114:		this->expandOutsSpecificContexts(mitNext, list, name );
monomerContext.cc:119:	    name->pushNeighbor(mit->first,_Nil<core::Symbol_O>());
monomerContext.cc:120://	name->pushNeighbor(mit->first,"");
monomerContext.cc:122:	    core::SymbolSet_sp ss = mit->second->getMonomerNames();
monomerContext.cc:123:	    LOG(BF("There are %d equivalent names") % ss->size() );
monomerContext.cc:124://	ASSERTP(ss->size()!=0,"Problem, there are no equivalent names");
monomerContext.cc:125:	    if ( ss->size() == 0 )
monomerContext.cc:128:		ss->insert(_lisp->intern("undef"));
monomerContext.cc:130:	    for (core::SymbolSet_O::iterator it=ss->begin(); it!=ss->end(); it++ ) 
monomerContext.cc:132:		name->setLastNeighborName(*it);
monomerContext.cc:133:		LOG(BF("Pushed equivalent name: %s") % (*it)->__repr__() );
monomerContext.cc:136:		this->expandOutsSpecificContexts(mitNext, list, name );
monomerContext.cc:138:	    name->popNeighbor();
monomerContext.cc:155:	if ( mit==this->_Neighbors.end() ) {
monomerContext.cc:157:	    list->insert(name.all());
monomerContext.cc:160:	    name.push(mit->first->identifierName());
monomerContext.cc:163:	    ss = mit->second->getMonomerNames();
monomerContext.cc:164:	    LOG(BF("There are %d equivalent names") % ss->size() );
monomerContext.cc:165://	ASSERTP(ss->size()!=0,"Problem, there are no equivalent names");
monomerContext.cc:166:	    if ( ss->size() == 0 )
monomerContext.cc:169:		ss->insert(_lisp->intern("undef"));
monomerContext.cc:171:	    for ( it=ss->begin(); it!=ss->end(); it++ ) {
monomerContext.cc:173:		name.push((*it)->identifierName());
monomerContext.cc:175:		LOG(BF("Pushed equivalent name: %s") % (*it)->__repr__() );
monomerContext.cc:178:		this->expandOuts(mitNext, list, name );
monomerContext.cc:197:	   << this->_Self->getKey();
monomerContext.cc:198:	for ( ci=this->_Neighbors.begin(); ci!=this->_Neighbors.end(); ci++ )
monomerContext.cc:200:	    ss << ci->first->identifierName() << COUPLING_CHAR << ci->second->getKey();
monomerContext.cc:214:	LOG(BF("Getting context strings for context: %s") % this->asXmlString().c_str()  );
monomerContext.cc:217:	selfNames = this->_Self->getMonomerNames();
monomerContext.cc:218:	LOG(BF("There are %d selfNames") % selfNames->size()  );
monomerContext.cc:219:	for ( si=selfNames->begin(); si!=selfNames->end(); si++ ) 
monomerContext.cc:221:	    LOG(BF("Push self name: %s") % (*si)->__repr__() );
monomerContext.cc:223:	    name.push((*si)->identifierName());
monomerContext.cc:225:	    this->expandOuts(this->_Neighbors.begin(), expandedList, name );
monomerContext.cc:237:	LOG(BF("Getting context strings for context: %s") % this->asXmlString().c_str()  );
monomerContext.cc:240:	one->clear();
monomerContext.cc:241:	selfNames = this->_Self->getMonomerNames();
monomerContext.cc:242:	LOG(BF("There are %d selfNames") % selfNames->size()  );
monomerContext.cc:243:	for ( si=selfNames->begin(); si!=selfNames->end(); si++ ) 
monomerContext.cc:245:	    LOG(BF("Push self name: %s") % (*si)->__repr__() );
monomerContext.cc:246:	    one->setSelfName(*si);
monomerContext.cc:247:	    this->expandOutsSpecificContexts(this->_Neighbors.begin(), expandedList, one );
monomerContext.cc:267:	expandedList = this->getAllSpecificKeys();
monomerContext.cc:268:	res = *(expandedList->begin());
monomerContext.cc:286:	if ( !this->_Self->recognizesNameOrPdb(
monomerContext.cc:287:		 testSub->_Self->getMonomerNames()->first()) ) {
monomerContext.cc:291:	if ( this->_Neighbors.size() != testSub->_Neighbors.size() ) {
monomerContext.cc:295:	for ( ti = this->_Neighbors.begin();
monomerContext.cc:296:	      ti != this->_Neighbors.end(); ti++ ) 
monomerContext.cc:298:	    if ( !testSub->_Neighbors.contains(ti->first) ) {
monomerContext.cc:299:		LOG(BF("testSub doesn't have a neighbor: %s") % ti->first->__repr__()  );
monomerContext.cc:302:	    testSubRecognizer = testSub->_Neighbors.get(ti->first,_lisp);
monomerContext.cc:303:	    core::SymbolSet_sp myNames = ti->second->getMonomerNames();
monomerContext.cc:304:	    core::SymbolSet_sp testSubNames = testSubRecognizer->getMonomerNames();
monomerContext.cc:305:	    if ( !myNames->containsSubset(testSubNames) )
monomerContext.cc:308:		LOG(BF("I recognize (%s)-> names: %s") % ti->first->__repr__() % myNames->asString()  );
monomerContext.cc:309:		LOG(BF("testSub recognizes (%s)-> names: %s") % ti->first->__repr__() % testSubNames->asString() );
monomerContext.cc:323:	if ( !this->_Self->recognizesNameOrPdb(mon->getName() )) {
monomerContext.cc:324:	    LOG(BF("MonomerContext doesn't recognize central monomer: %s") % (mon->getName()->__repr__() ));
monomerContext.cc:328:	if ( this->_Neighbors.size() != mon->numberOfCouplings() ) {
monomerContext.cc:332:	LOG(BF("STATUS monomer = %s") % (mon->getName()->__repr__() ) );
monomerContext.cc:333:	LOG(BF("Monomer has %d couplings") % (mon->numberOfCouplings() ) );
monomerContext.cc:334:	LOG(BF("MonomerContext has %d neighbors") % (this->_Neighbors.size() ) );
monomerContext.cc:337:	for ( oi=mon->begin_WeakCouplings(); oi!=mon->end_WeakCouplings(); oi++ )
monomerContext.cc:339:	    Coupling_sp coup = (oi->second).lock();
monomerContext.cc:340:	    if (coup->isOfClass<DirectionalCoupling_O>() )
monomerContext.cc:342:		DirectionalCoupling_sp dc = coup->as<DirectionalCoupling_O>();
monomerContext.cc:343:		LOG(BF("Looking at dc->getName()= %s") % (dc->getName()->__repr__() ) );
monomerContext.cc:344:		if ( !this->_Neighbors.contains(dc->getName()) )
monomerContext.cc:346:		    LOG(BF("MonomerContext doesn't recognize out.coupling=%s ") % dc->getName()->__repr__() );
monomerContext.cc:351:		RingCoupling_sp rc = coup->as<RingCoupling_O>();
monomerContext.cc:352:		LOG(BF("Ignoring out coupling for RingCoupling: %s") % rc->getName()->__repr__() );
monomerContext.cc:365:	ss->setMonomerNameOrPdb(mon->getName());
monomerContext.cc:367:	this->_Self = ss;
monomerContext.cc:373:	core::SymbolSet_sp names = _lisp->create<core::SymbolSet_O>();
monomerContext.cc:374:	for ( NeighborMap::const_iterator it=this->_Neighbors.begin();
monomerContext.cc:375:	      it!=this->_Neighbors.end(); it++ )
monomerContext.cc:377:	    names->insert(it->first);
monomerContext.cc:385:	if ( this->_Neighbors.count(name) == 0 )
monomerContext.cc:387:	    SIMPLE_ERROR(BF("Unknown MonomerContext-plugName[%s]") % name->__repr__() );
monomerContext.cc:389:	return this->_Neighbors.get(name,_lisp);
monomerCoordinates.cc:32:    this->_TrainerName = "";
monomerCoordinates.cc:39:    node->attribute("comment",this->_Comment);
monomerCoordinates.cc:40:    node->attributeIfNotDefault<string>("trainerName",this->_TrainerName, "" );
monomerCoordinates.cc:41:    node->archiveObject("context",this->_Context);
monomerCoordinates.cc:42:    node->archiveVector0("rotamers",this->_Rotamers);
monomerCoordinates.cc:55:    me->setContext(context);
monomerCoordinates.cc:63:    MonomerContext_sp context = translate::from_object<MonomerContext_O>::convert(env->lookup(Pkg(),"context"));
monomerCoordinates.cc:64:    this->setContext(context);
monomerCoordinates.cc:103:	    extractFragment = topology->getExtractCoreFragment();
monomerCoordinates.cc:104:	    LOG(BF("Got core fragment: %s") % extractFragment->description().c_str() );
monomerCoordinates.cc:105:	    uniqueStructures = extractFragment->isolateUniqueStructures(
monomerCoordinates.cc:108:	    extractScaffold = topology->getExtractScaffold();
monomerCoordinates.cc:109:	    Anchor_sp anchor = extractScaffold->getAnchor();
monomerCoordinates.cc:114:	    if ( anchor->isOfClass<AnchorOrigin_O>() )
monomerCoordinates.cc:119:		agg = uniqueStructures->getMatter()->as<Aggregate_O>();
monomerCoordinates.cc:126:		ASSERT(extractScaffold->numberOfExtractCompleteFrames()>0);
monomerCoordinates.cc:127:		firstExtractFrame = *(extractScaffold->begin_ExtractCompleteFrames());
monomerCoordinates.cc:128:		firstFrame = firstExtractFrame->getFrame();
monomerCoordinates.cc:132:		for ( sli=uniqueStructures->begin_Entries();
monomerCoordinates.cc:133:				sli!=uniqueStructures->end_Entries(); sli++ )
monomerCoordinates.cc:135:		    (*sli)->writeCoordinatesToMatter(agg);
monomerCoordinates.cc:138:		        coordSys = firstFrame->getCoordinateSystem(focusMonomer);
monomerCoordinates.cc:141:			if ( !e.conditionObject()->isAssignableTo<core::MathException_O>() )
monomerCoordinates.cc:151:		    toOriginTransform = coordSys->matrixToCanonical();
monomerCoordinates.cc:152:		    agg->applyTransformToAtoms(toOriginTransform);
monomerCoordinates.cc:153:		    (*sli)->extractCoordinatesFromMatter(agg);
monomerCoordinates.cc:157:	    if ( !extractFragment->sharesAtomsWithExtractScaffold(extractScaffold,
monomerCoordinates.cc:162:		ss << "ExtractFragment constitution["<< topology->getConstitution()->getName() << "] "
monomerCoordinates.cc:163:		   << "topology[" << topology->getName() << "]"
monomerCoordinates.cc:164:		   << " fragmentName:("+extractFragment->getFragment()->getName()+") atoms: ["
monomerCoordinates.cc:165:		   << extractFragment->getFragment()->getAtomNames()->asString() << "]" << endl;
monomerCoordinates.cc:167:		THROW(_lisp->create<core::ContentException_O>(ss.str()));
monomerCoordinates.cc:171:	    coreFragmentCoordinates = _lisp->create<FragmentCoordinates_O>();
monomerCoordinates.cc:172:	    coreFragmentCoordinates->defineFromConformationCollection(extractFragment,
monomerCoordinates.cc:176:	    this->_FragmentCoordinates.clear();
monomerCoordinates.cc:177:	    this->_FragmentCoordinates.push_back(coreFragmentCoordinates);
monomerCoordinates.cc:180:	    scaffoldList = _lisp->create<ScaffoldList_O>();
monomerCoordinates.cc:181:	    scaffoldList->defineFromExtractScaffoldAndConformationCollection( extractScaffold,
monomerCoordinates.cc:187:	    this->_ScaffoldList = scaffoldList;
monomerCoordinates.cc:193:    {_BLOCK_TRACE("Extract the non-core fragments");
monomerCoordinates.cc:195:	for ( fi = topology->begin_ExtractFragments();
monomerCoordinates.cc:196:		    fi!=topology->end_ExtractFragments(); fi++ )
monomerCoordinates.cc:198:	    uniqueStructures = (*fi)->isolateUniqueStructures(conformationExplorer,
monomerCoordinates.cc:200:	    fragmentCoordinates = _lisp->create<FragmentCoordinates_O>();
monomerCoordinates.cc:201:	    fragmentCoordinates->defineFromConformationCollection(*fi,
monomerCoordinates.cc:206:	    this->_FragmentCoordinates.push_back(fragmentCoordinates);
monomerCoordinates.cc:209:    LOG(BF("MonomerCoordinates defined: %s") % this->asXmlString().c_str()  );
monomerCoordinates.cc:220:    this->_defineFromConformationExplorerOrDebug(topology, conformationExplorer, focusMonomer, false,
monomerCoordinates.cc:238:    conformationExplorer->setMatter(aggregate);
monomerCoordinates.cc:239:    conformationExplorer->superposeAllHeavyAtoms();
monomerCoordinates.cc:240:    ConformationExplorerEntry_sp entry = conformationExplorer->createEntry();
monomerCoordinates.cc:241:    ConformationExplorerEntryStage_sp stage = entry->createEntryStage("test");
monomerCoordinates.cc:243:    stage->setExternalInterfaceName("testPackage");
monomerCoordinates.cc:244:    stage->setModel("testModel");
monomerCoordinates.cc:245:    stage->setEnergyKCal(987654321.0);
monomerCoordinates.cc:246:    entry->setSelectedStage(stage);
monomerCoordinates.cc:247:    stage->extractCoordinatesFromMatter(aggregate);
monomerCoordinates.cc:248:    stage->setComplete(true);
monomerCoordinates.cc:249:    conformationExplorer->appendEntry(entry);
monomerCoordinates.cc:251:    IMPLEMENT_MEF(BF("The following code catches an exception - figure out how to do it using Conditions"));
monomerCoordinates.cc:255:        this->_defineFromConformationExplorerOrDebug(topology,conformationExplorer,focusMonomer,true,UndefinedUnsignedInt);
monomerCoordinates.cc:258:	if ( !e.conditionObject()->isAssignableTo<core::MathException_O>() )
monomerCoordinates.cc:261://	    RESIMPLE_ERROR(BF("An error was caught in MonomerCoordinates_O::testExtraction - here it is: %s") % e.message() ));
monomerCoordinates.cc:265:	problems->write(e.message());
monomerCoordinates.cc:267:    core::Cons_sp results = core::Cons_O::createList(_lisp->internKeyword("sawProblems"),
monomerCoordinates.cc:268:					 _lisp->_boolean(sawProblem),
monomerCoordinates.cc:269:					 _lisp->internKeyword("problems"),
monomerPack.cc:60:	if ( bdb->recognizesUserMonomerPack(packName->get()) )
monomerPack.cc:61:	    SIMPLE_ERROR(BF("monomerPack("+packName->get()+") is already defined"));
monomerPack.cc:63:	MonomerPack_sp monomerPack = _lisp->create<MonomerPack_O>();
monomerPack.cc:64:	monomerPack->setName(packName);
monomerPack.cc:65:	monomerPack->defineContentsFromCons(atomAliases, parts);
monomerPack.cc:69:	bdb->addEntity(monomerPack);
monomerPack.cc:107:	if ( !bdb->recognizesMonomerPack(packName) )
monomerPack.cc:108:	    SIMPLE_ERROR(BF("monomerPack("+packName->__repr__()+") has not been defined"));
monomerPack.cc:109:	MonomerPack_sp monomerPack = bdb->getEntity(packName)->as<MonomerPack_O>();
monomerPack.cc:110:	monomerPack->extendAliases(atomAliases, parts);
monomerPack.cc:147:	core::Symbol_sp sym = pack->getName();
monomerPack.cc:148:	sym->defparameter(opack);
monomerPack.cc:167:    this->Base::initialize();
monomerPack.cc:168:    this->_InterestingAtomAliases = core::SymbolList_O::create();
monomerPack.cc:169:    this->_AtomIndexers = _lisp->create<MapOfMonomerNamesToAtomIndexers_O>();
monomerPack.cc:179:    this->EntityNameSet_O::archive(node);
monomerPack.cc:180:    node->archiveObject("interestingAtomAliases",this->_InterestingAtomAliases);
monomerPack.cc:181:    node->archiveObject("atomIndexers",this->_AtomIndexers);
monomerPack.cc:194:    for ( p=atomAliases; p.notnilp(); p=p->cdr() )
monomerPack.cc:196:	name = p->car<core::Symbol_O>();
monomerPack.cc:197:	aliases->append(name);
monomerPack.cc:199:    this->setInterestingAtomAliasesFromSymbolList(aliases);
monomerPack.cc:200:    for ( p=parts; p.notnilp(); p = p->cdr() )
monomerPack.cc:202:	core::Cons_sp entry = p->car<core::Cons_O>();
monomerPack.cc:203:	if ( entry->length() <1 ) SIMPLE_ERROR(BF("monomerPack Entry contains no monomer name"));
monomerPack.cc:204:	core::Symbol_sp monomerName = entry->car<core::Symbol_O>();
monomerPack.cc:205:	this->addMonomerName(monomerName);
monomerPack.cc:206:	if ( aliases->size() > 0 )
monomerPack.cc:208:	    if ( entry->length() < 2 ) SIMPLE_ERROR(BF("You defined atom aliases to each monomer must have interesting atom names"));
monomerPack.cc:209:	    core::Cons_sp interestingAtomNames = entry->listref<core::Cons_O>(1);
monomerPack.cc:210:	    this->setInterestingAtomNamesForMonomerNameFromCons(monomerName,interestingAtomNames);
monomerPack.cc:221:    uint numberOfAtomAliases = atomAliases->length();
monomerPack.cc:222:    this->_InterestingAtomAliases->appendConsOfStrings(atomAliases);
monomerPack.cc:223:    for ( core::Cons_sp cur = parts; cur.notnilp(); cur=cur->cdr() )
monomerPack.cc:225:	core::Cons_sp oneExtend = cur->car<core::Cons_O>();
monomerPack.cc:226:	if ( oneExtend->length() != 2 )
monomerPack.cc:228:	    SIMPLE_ERROR(BF("Each extendAliases entry must have two elements: "+oneExtend->__repr__() ));
monomerPack.cc:230:	core::Symbol_sp monomerName = oneExtend->car<core::Symbol_O>();
monomerPack.cc:231:	core::Cons_sp aliasAtoms = oneExtend->ocadr()->as<core::Cons_O>();
monomerPack.cc:232:	extendMonomers->insert(monomerName);
monomerPack.cc:233:	if ( !this->_AtomIndexers->recognizesMonomerName(monomerName) )
monomerPack.cc:235:	    SIMPLE_ERROR(BF("MonomerPack("+this->getName()->__repr__()+") does not recognize monomer name("+monomerName->__repr__()+")"));
monomerPack.cc:237:	AtomIndexer_sp indexer = this->_AtomIndexers->getAtomIndexerForMonomerName(monomerName);
monomerPack.cc:238:	if ( aliasAtoms->length() != numberOfAtomAliases )
monomerPack.cc:242:	    ss << aliasAtoms->__repr__();
monomerPack.cc:243:	    ss << " for monomer(" << monomerName->__repr__();
monomerPack.cc:245:	    ss << atomAliases->__repr__() ;
monomerPack.cc:248:	indexer->appendConsOfTexts(aliasAtoms);
monomerPack.cc:250:    if ( !extendMonomers->equal(this->_EntityNames) )
monomerPack.cc:253:	ss << "There is a mismatch between the monomers in this extendAliases command in the MonomerPack(" << this->getName() << ")" << endl;
monomerPack.cc:254:	ss << "extendAliases monomer names: " << extendMonomers->__repr__() <<endl;
monomerPack.cc:255:	ss << "MonomerPack names: " << this->_EntityNames->__repr__();
monomerPack.cc:270:    ASSERTNOTNULL(this->_AtomIndexers);
monomerPack.cc:271:    if ( !this->recognizesMonomerName(monomerName) )
monomerPack.cc:273:        THROW(_lisp->create<core::ContentException_O>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this->description() ));
monomerPack.cc:275:    indexer = _lisp->create<AtomIndexer_O>();
monomerPack.cc:276:    indexer->setFromAtomNames(atomIndexerNames);
monomerPack.cc:277:    this->_AtomIndexers->set(monomerName,indexer);
monomerPack.cc:278:    this->_checkAtomIndexers();
monomerPack.cc:290:    ASSERTNOTNULL(this->_AtomIndexers);
monomerPack.cc:291:    if ( !this->recognizesMonomerName(monomerName) )
monomerPack.cc:293:        THROW(_lisp->create<core::ContentException_O>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this->description() ));
monomerPack.cc:295:    indexer = _lisp->create<AtomIndexer_O>();
monomerPack.cc:296:    indexer->setFromStringList(names);
monomerPack.cc:297:    this->_AtomIndexers->set(monomerName,indexer);
monomerPack.cc:298:    this->_checkAtomIndexers();
monomerPack.cc:309:    ASSERTNOTNULL(this->_AtomIndexers);
monomerPack.cc:310:    if ( !this->recognizesMonomerName(monomerName) )
monomerPack.cc:312:        THROW(_lisp->create<core::ContentException_O>(boost::format("Unrecognized monomer name: %s %s") % monomerName % this->sharedThis<MonomerPack_O>()->description() ));
monomerPack.cc:314:    indexer = _lisp->create<AtomIndexer_O>();
monomerPack.cc:315:    for ( core::Cons_sp p=names; p.notnilp(); p=p->cdr() )
monomerPack.cc:317:	core::Str_sp	interest = p->car<core::Str_O>();
monomerPack.cc:318:	indexer->addAtomName(interest->get());
monomerPack.cc:320:    this->_AtomIndexers->set(monomerName,indexer);
monomerPack.cc:321:    this->_checkAtomIndexers();
monomerPack.cc:326:    this->EntityNameSet_O::setMonomerNameOrPdb(nm);
monomerPack.cc:327:    this->setInterestingAtomNamesForMonomerName(nm,"");
monomerPack.cc:333:    this->EntityNameSet_O::addMonomerName(nm);
monomerPack.cc:334:    this->setInterestingAtomNamesForMonomerName(nm,"");
monomerPack.cc:339:    this->_removeMonomerName(nm);
monomerPack.cc:340:    this->_AtomIndexers->eraseEntryForMonomer(nm);
monomerPack.cc:347:    if ( this->_AtomIndexers->recognizesMonomerName(nm) )
monomerPack.cc:349:        s = this->_AtomIndexers->getAtomIndexerForMonomerName(nm)->asString();
monomerPack.cc:359:    this->_InterestingAtomAliases->clear();
monomerPack.cc:360:    this->_InterestingAtomAliases->appendSymbolList(names);
monomerPack.cc:361:    LOG(BF("For MonomerPack(%s) setting aliases(%s)") % this->getName().c_str() % this->_InterestingAtomAliases->asString().c_str()  );
monomerPack.cc:368:    return this->_InterestingAtomAliases->asString();
monomerPack.cc:374:    ASSERT(this->_AtomIndexers->recognizesMonomerName(monomerName));
monomerPack.cc:375:    return this->_AtomIndexers->getAtomIndexerForMonomerName(monomerName);
monomerPack.cc:392:    if ( this->_AtomIndexers->isNil() ) return;
monomerPack.cc:393:    ais = this->_AtomIndexers;
monomerPack.cc:395:    for ( ii = ais->begin(); ii != ais->end(); ii++ )
monomerPack.cc:397:	if ( ii->second->numberOfAtomNames() > mostNumberOfAtoms )
monomerPack.cc:399:	    mostNumberOfAtoms = ii->second->numberOfAtomNames();
monomerPack.cc:405:	this->_AtomIndexers = MapOfMonomerNamesToAtomIndexers_O::_nil;
monomerPack.cc:414:    ASSERTNOTNULL(this->_AtomIndexers);
monomerPack.cc:417:    if ( !this->recognizesMonomerName(nm) )
monomerPack.cc:419:        THROW(_lisp->create<core::ContentException_O>(boost::format("Unrecognized monomer name: %s %s")% nm % this->sharedThis<MonomerPack_O>()->description() ));
monomerPack.cc:421:    if ( this->_AtomIndexers->recognizesMonomerName(nm) )
monomerPack.cc:423:        atomIndexer = this->_AtomIndexers->getAtomIndexerForMonomerName(nm);
monomerPack.cc:424:        ss << " [" << atomIndexer->asString() << "]";
monomerPack.cc:433:    LOG(BF("MonomerPack: %s") % this->getName().c_str() );
monomerPack.cc:434:    LOG(BF("Checking to see if it recognizes atom alias: %s") % alias->getAtomAlias().c_str()  );
monomerPack.cc:435:    LOG(BF("The interesting atom aliases I recognize are(%s)") % this->_InterestingAtomAliases->asString().c_str()  );
monomerPack.cc:436:    return this->_InterestingAtomAliases->contains(alias->getAtomAlias());
monomerPack.cc:443:    return this->_InterestingAtomAliases->indexOf(alias->getAtomAlias());
nVector.cc:30:    nv->setup(sz);
nVector.cc:45:    this->_Size = orig._Size;
nVector.cc:46:    this->_Values.assign(orig._Values.begin(),orig._Values.end());
nVector.cc:54:    this->setup(0);
nVector.cc:59:    this->_Size = iElements;
nVector.cc:60:    this->_Values.resize(iElements,0.0);
nVector.cc:61:    LOG(BF("Created NVector_O@%0X with %d entries") % &(this->_Values) % this->_Size );
nVector.cc:74:    ASSERTP(this->_Size == orig->_Size,"NVector_O::copy>>mismatched size");
nVector.cc:75:    this->_Values.assign(orig->_Values.begin(),orig->_Values.end());
nVector.cc:82:    vv = RP_Copy<NVector_O>(this->const_sharedThis<NVector_O>());
nVector.cc:95:    this->_Values.assign(this->_Size,0.0);
nVector.cc:109:    this->_Values.assign(this->_Size,dValue);
nVector.cc:121:    for ( dp=this->_Values.begin(); dp!=this->_Values.end(); dp++ ) {
nVector.cc:135:    for ( dp=this->_Values.begin(); dp!=this->_Values.end(); dp++ ) {
nVector.cc:150:    maxVal = -9.0e99;
nVector.cc:151:    for ( dp=this->_Values.begin(); dp!=this->_Values.end(); dp++ ) {
nVector.cc:165:    for ( dp=this->_Values.begin(); dp!=this->_Values.end(); dp++ ) {
nVector.cc:182:    cout << "NVector_O length= " << this->_Size << endl;
nVector.cc:183:    for ( i=0; i<this->_Size; i++ )
nVector.cc:184:        cout << "---[" << i << "] = " << this->_Values[i] << endl;
nVector.cc:193:    for (uint i=0; i<this->_Size; i++ ) {
nVector.cc:194:	ss << this->_Values[i] << " ";
nVector.cc:217:    ASSERTP( this->_Values.size() == x->size(),"NVector_O::add>>mismatched size");
nVector.cc:218:    ASSERTP( this->_Values.size() == y->size(),"NVector_O::add>>mismatched size");
nVector.cc:219:    for ( resi = this->_Values.begin(), xi=x->_Values.begin(), yi=y->_Values.begin();
nVector.cc:220:	    resi!=this->_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:232:    LOG(BF("this->_Values.size() = %d") % this->_Values.size() );
nVector.cc:233:    LOG(BF("x->size() = %d") % x->size() );
nVector.cc:234:    LOG(BF("y->size() = %d") % y->size() );
nVector.cc:235:    ASSERTP( this->_Values.size() == x->size(),"NVector_O::addTimesScalar>>mismatched size");
nVector.cc:236:    ASSERT( this->_Values.size() == y->size());
nVector.cc:237:    for ( resi = this->_Values.begin(), xi=x->_Values.begin(), yi=y->_Values.begin();
nVector.cc:238:	    resi!=this->_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:253:    LOG(BF("this->_Values.size() = %d") % this->_Values.size() );
nVector.cc:254:    LOG(BF("x->size() = %d") % x->size() );
nVector.cc:255:    ASSERTP( this->_Values.size() == x->size(),"NVector_O::addTimesScalar>>mismatched size");
nVector.cc:256:    for ( resi = this->_Values.begin(), xi=x->_Values.begin();
nVector.cc:257:	    resi!=this->_Values.end(); resi++, xi++ ) {
nVector.cc:266:    ASSERT( this->_Values.size() == dir->size());
nVector.cc:267:    for ( resi = this->_Values.begin(), diri=dir->_Values.begin();
nVector.cc:268:	    resi!=this->_Values.end(); resi++, diri++ ) {
nVector.cc:285:    ASSERT( this->_Values.size() == x->size());
nVector.cc:286:    ASSERT( this->_Values.size() == y->size());
nVector.cc:287:    for ( resi = this->_Values.begin(), xi=x->_Values.begin(), yi=y->_Values.begin();
nVector.cc:288:	    resi!=this->_Values.end(); resi++, xi++, yi++ ) {
nVector.cc:289:	*resi = *xi-*yi;
nVector.cc:306:    for ( resi=this->_Values.begin(),xi=x->_Values.begin(); resi!=this->_Values.end(); resi++,xi++ ) {
nVector.cc:329:    for ( resi=this->_Values.begin(),xi=x->_Values.begin(); resi!=this->_Values.end(); resi++,xi++ ) {
nVector.cc:342:    for ( resi=this->_Values.begin(); resi!=this->_Values.end(); resi++ ) {
nVector.cc:353:    for ( resi=this->_Values.begin(); resi!=this->_Values.end(); resi++ ) {
nVector.cc:361:    node->archiveVectorDouble( "vec", this->_Values );
nVector.cc:362:    LOG(BF("size of this->_Values=%d") % this->_Values.size()  );
nVector.cc:363:    if ( node->loading() )
nVector.cc:365:       this->_Size = this->_Values.size();
nVector.cc:384:    dDot = this->squared();
nVector.cc:393:    dDot = this->squared();
nVector.cc:394:    dDot /= (double)this->size();
nVector.cc:403: * List the term-by-term differences and return as an XML object
nVector.cc:412:    resi = this->_Values.begin();
nVector.cc:413:    ni = n->_Values.begin();
nVector.cc:414:    for ( i=0; i<this->_Size; i++, resi++, ni++ ) {
nVector.cc:417:	if ( fabs(*resi-*ni)/avg > 0.1 ) {
nVector.cc:419:	    part->addAttributeInt("i",i);
nVector.cc:420:	    part->addAttributeDoubleScientific(thisName,*resi);
nVector.cc:421:	    part->addAttributeDoubleScientific(otherName,*ni);
nVector.cc:422:	    xml->addChild(part);
nVector.cc:438:    for ( y = 0; y<this->_Size; y++ ) {
nVector.cc:442:	fout << this->element(y);
nVector.cc:451:#define	VERY_SMALL 1.0e-6
nVector.cc:453:    lenThis = this->magnitude();
nVector.cc:454:    lenOther = other->magnitude();
nVector.cc:455:    dot = this->dotProduct(other);
nVector.cc:459:	if ( dot < -1.0 ) dot = -1.0;
nVector.cc:470:    ASSERT(v->size() == this->size() );
nVector.cc:472:    for ( i=0; i<this->size(); i++ ) {
nVector.cc:473:	e = this->_Values[i]-v->_Values[i];
nVector.cc:476:    sum /= (float)(this->size());
numericalFunction.cc:16:#define	ROUND(x) ((x)>0.0)?floor((x)+0.5):-floor((-x)+0.5)
numericalFunction.cc:26:    this->Base::initialize();
numericalFunction.cc:27:    this->title = "";
numericalFunction.cc:28:    this->xAxisName = "";
numericalFunction.cc:29:    this->yAxisName = "";
numericalFunction.cc:30:    this->values.clear();
numericalFunction.cc:39:    this->xAxisName = ss.xAxisName;
numericalFunction.cc:40:    this->yAxisName = ss.yAxisName;
numericalFunction.cc:41:    this->xStart = ss.xStart;
numericalFunction.cc:42:    this->xInc = ss.xInc;
numericalFunction.cc:43:    this->values = ss.values;
numericalFunction.cc:55:    node->attribute("title",this->title);
numericalFunction.cc:56:    node->attribute("xAxisName",this->xAxisName);
numericalFunction.cc:57:    node->attribute("yAxisName",this->yAxisName);
numericalFunction.cc:58:    node->attribute("xInc",this->xInc);
numericalFunction.cc:59:    node->archiveVectorDouble("values",this->values);
numericalFunction.cc:68:/*! Return the index of the entry with the largest x-value smaller than or equal to
numericalFunction.cc:75:    if ( this->values.size()== 0 ) {
numericalFunction.cc:78:    if ( this->xInc == 0 ) {
numericalFunction.cc:81:    index = (int)ROUND((double)((x - this->xStart)/this->xInc));
numericalFunction.cc:89:    x = this->xStart+this->xInc*index;
numericalFunction.cc:99:	this->values.insert( this->values.begin(), -i, 0.0 );
numericalFunction.cc:100:	this->xStart = this->xStart + (i*this->xInc);
numericalFunction.cc:101:	this->values[0] = v;
numericalFunction.cc:102:    } else if ( i >= (int)(this->values.size()) ) {
numericalFunction.cc:103:	this->values.insert( this->values.end(), i-this->values.size()+1, 0.0 );
numericalFunction.cc:104:	this->values[this->values.size()-1] = v;
numericalFunction.cc:106:	this->values[i] = v;
numericalFunction.cc:115:    } else if ( i >= (int)(this->values.size()) ) {
numericalFunction.cc:118:    return this->values[i];
numericalFunction.cc:130:    fprintf( fOut, "# %s %s\n", this->xAxisName.c_str(), this->yAxisName.c_str() );
numericalFunction.cc:132:    for (dp=this->values.begin(); dp!=this->values.end(); dp++ ) {
numericalFunction.cc:133:	fprintf( fOut, "%10.9lf %10.9lf\n", this->xValue(dp-this->values.begin()), *dp );
numericalFunction.cc:146:    fprintf( fOut, "# %s %s\n", this->xAxisName.c_str(), this->yAxisName.c_str() );
numericalFunction.cc:148:    for (dp=this->values.begin(); dp!=this->values.end(); dp++ ) {
numericalFunction.cc:149:	fprintf( fOut, "%10.9lf %10.9lf\n", this->xValue(dp-this->values.begin()), *dp );
numericalFunction.cc:165:    return this->xStart;
numericalFunction.cc:171:    return this->xStart+this->xInc*this->values.size();
numericalFunction.cc:179:    for (dp=this->values.begin(); dp!=this->values.end(); dp++ ) {
numericalFunction.cc:189:    highY = -99999999.0;
numericalFunction.cc:190:    for (dp=this->values.begin(); dp!=this->values.end(); dp++ ) {
numericalFunction.cc:212:    this->reset();
numericalFunction.cc:222:	if ( xindex-1 < n ) {
numericalFunction.cc:223:	    x = values[xindex-1];
numericalFunction.cc:227:	if ( yindex-1 < n ) {
numericalFunction.cc:228:	    y = values[yindex-1];
numericalFunction.cc:236:    this->xInc = xv[1]-xv[0];
numericalFunction.cc:237:    this->xStart = ROUND(xv[0]/this->xInc)*this->xInc;
numericalFunction.cc:238:    this->values.clear();
numericalFunction.cc:240:	this->values.push_back(*dp);
numericalFunction.cc:247:    this->values.clear();
numericalFunction.cc:258:    if ( this->xInc != fn->xInc ) {
numericalFunction.cc:260:	ss << "xInc values must be identical this->xInc("
numericalFunction.cc:261:		<< this->xInc << ") != fn->xInc("
numericalFunction.cc:262:		<< fn->xInc << ")";
numericalFunction.cc:265:    if ( this->values.size() == 0 ) {
numericalFunction.cc:266:	xMin = fn->xStart;
numericalFunction.cc:267:	xMax = fn->xStart+fn->xInc*(fn->values.size());
numericalFunction.cc:268:    } else if ( fn->values.size() == 0 ) {
numericalFunction.cc:269:	xMin = this->xStart;
numericalFunction.cc:270:	xMax = this->xStart+fn->xInc*(fn->values.size());
numericalFunction.cc:272:        xMin = min(this->xStart,fn->xStart);
numericalFunction.cc:273:        xMax = max(this->xStart+this->xInc*(this->values.size()),
numericalFunction.cc:274:		fn->xStart+fn->xInc*(fn->values.size()));
numericalFunction.cc:276:    vals = (int)((xMax-xMin)/this->xInc);
numericalFunction.cc:277:    newFunc = _lisp->create<NumericalFunction_O>();
numericalFunction.cc:278:    newFunc->setXStart(xMin);
numericalFunction.cc:279:    newFunc->setXInc(this->xInc);
numericalFunction.cc:280:    newFunc->values.assign(vals,0.0);
numericalFunction.cc:281:    LOG(BF("resulting NumericalFunction has %d vals") % (newFunc->values.size()) );
numericalFunction.cc:282:    for ( dp=newFunc->values.begin(); dp!=newFunc->values.end(); dp++ ) {
numericalFunction.cc:283:	x = newFunc->getXValueAtIndex(dp-newFunc->values.begin());
numericalFunction.cc:285:	thisIndex = this->findIndex(x);
numericalFunction.cc:286:	LOG(BF("   thisIndex = %d value=%lf") % (thisIndex) % (this->getYValueAtIndex(thisIndex) ) );
numericalFunction.cc:287:	fnIndex = fn->findIndex(x);
numericalFunction.cc:288:	LOG(BF("     fnIndex = %d valut=%lf") % (fnIndex) % (fn->getYValueAtIndex(fnIndex) ) );
numericalFunction.cc:289:	*dp = this->getYValueAtIndex(thisIndex) + fn->getYValueAtIndex(fnIndex);
numericalFunction.cc:290:	LOG(BF("  Wrote value(%lf) to index(%d)") % (*dp) % (dp-newFunc->values.begin()) );
numericalFunction.cc:301:    if ( this->xInc != fn->xInc ) {
numericalFunction.cc:303:	ss << "xInc values must be identical this->xInc("
numericalFunction.cc:304:		<< this->xInc << ") != fn->xInc("
numericalFunction.cc:305:		<< fn->xInc << ")";
numericalFunction.cc:308:    if ( this->values.size() == 0 ) {
numericalFunction.cc:309:	xMin = fn->xStart;
numericalFunction.cc:310:	xMax = fn->xStart+fn->xInc*(fn->values.size());
numericalFunction.cc:311:    } else if ( fn->values.size() == 0 ) {
numericalFunction.cc:312:	xMin = this->xStart;
numericalFunction.cc:313:	xMax = this->xStart+fn->xInc*(fn->values.size());
numericalFunction.cc:315:        xMin = min(this->xStart,fn->xStart);
numericalFunction.cc:316:        xMax = max(this->xStart+this->xInc*(this->values.size()),
numericalFunction.cc:317:		fn->xStart+fn->xInc*(fn->values.size()));
numericalFunction.cc:319:    vals = (int)((xMax-xMin)/this->xInc);
numericalFunction.cc:320:    newFunc = _lisp->create<NumericalFunction_O>();
numericalFunction.cc:321:    newFunc->setXStart(xMin);
numericalFunction.cc:322:    newFunc->setXInc(this->xInc);
numericalFunction.cc:323:    newFunc->values.assign(vals,0.0);
numericalFunction.cc:324:    LOG(BF("resulting NumericalFunction has %d vals") % (newFunc->values.size()) );
numericalFunction.cc:325:    for ( dp=newFunc->values.begin(); dp!=newFunc->values.end(); dp++ ) {
numericalFunction.cc:326:	x = newFunc->getXValueAtIndex(dp-newFunc->values.begin());
numericalFunction.cc:328:	thisIndex = this->findIndex(x);
numericalFunction.cc:329:	LOG(BF("   thisIndex = %d value=%lf") % (thisIndex) % (this->getYValueAtIndex(thisIndex) ) );
numericalFunction.cc:330:	fnIndex = fn->findIndex(x);
numericalFunction.cc:331:	LOG(BF("     fnIndex = %d valut=%lf") % (fnIndex) % (fn->getYValueAtIndex(fnIndex) ) );
numericalFunction.cc:332:	*dp = this->getYValueAtIndex(thisIndex) - fn->getYValueAtIndex(fnIndex);
numericalFunction.cc:333:	LOG(BF("  Wrote value(%lf) to index(%d)") % (*dp) % (dp-newFunc->values.begin()) );
numericalFunction.cc:343:    LOG(BF("addValueToHistogram value = %lf    xInc = %lf") % (x) % (this->xInc ) );
numericalFunction.cc:344:    if ( this->values.size() == 0 ) {
numericalFunction.cc:345:	rnd = ROUND(x/this->xInc);
numericalFunction.cc:347:	this->xStart = this->xInc*rnd;
numericalFunction.cc:348:	LOG(BF("addValueToHistogram xStart = %lf") % (this->xStart ) );
numericalFunction.cc:349:	this->values.push_back(1.0);
numericalFunction.cc:352:    index = this->findIndex(x);
numericalFunction.cc:354:    cnt = this->getYValueAtIndex(index) + 1.0;
numericalFunction.cc:355:    this->setYValueAtIndex(index,cnt);
numericalFunction.cc:367:    newFunc = this->sub(fn);
numericalFunction.cc:369:    for ( dp=newFunc->values.begin(); dp!=newFunc->values.end(); dp++ ) {
numericalFunction.cc:372:    rms /= this->values.size();
numericalFunction.cc:378:    this->xStart *= scale;
numericalFunction.cc:379:    this->xInc *= scale;
numericalFunction.cc:387:    for (ip=this->values.begin(); ip!=this->values.end(); ip++ ) {
numericalFunction.cc:396:    for (ip=this->values.begin(); ip!=this->values.end(); ip++ ) {
oligomer.cc:28: * 	-# Define the oligomer
oligomer.cc:29: * 		- Create the _Monomers, add them to the oligomer and couple them together.
oligomer.cc:30: * 	-# Construct the alchemists Oligomer_O::createAlchemists (you may need to dismissAlchemists first)
oligomer.cc:31: * 	-# Either accept the default build plan or construct one
oligomer.cc:32: *	 	-# For each monomer define the domainId using setDomainId
oligomer.cc:33: * 		-# (optional) Fix the coordinates of the fragmentAlchemists that have defined coordinates
oligomer.cc:34: * 			-# Clear all Fixed alchemists using Oligomer_O::clearAllFragmentAlchemistsCoordinatesAreFixed
oligomer.cc:35: * 			-# Use setAllFragemntAlchemistsCoordinatesAreFixed(True)
oligomer.cc:36: * 			-# Define the coordinates for the residue of the monomer using applyCoordinatesFromResidue(res)
oligomer.cc:37: * 			-# Create a BuildPlan Dumb_BuildPlan::Dumb_BuildPlan(_kinemat_)
oligomer.cc:38: * 			-# Define a BuildPlan using Dumb_BuildPlan::recordPlan()
oligomer.cc:39: * 			-# Tell the Conformation that you want to use that plan using Conformation_O::applyBuildPlan
oligomer.cc:40: * 	-# Build the coordinates by calling:
oligomer.cc:41: * 		- Conformation_O::build
oligomer.cc:42: * 		- or Conformation_O::buildCore followed by Conformation_O::buildFinish
oligomer.cc:43: * 		- or Oligomer_O::buildCoordinates()
oligomer.cc:57:    this->Base::initialize();
oligomer.cc:58:    this->empty();
oligomer.cc:59:    this->_Verbose = false;
oligomer.cc:60:    this->_HasError = false;
oligomer.cc:61:    this->_Name = _Nil<NameType>();
oligomer.cc:68:    this->notify(Oligomer_monomerContentsChanged);
oligomer.cc:74://    this->notify(Oligomer_connectivityChanged);
oligomer.cc:82:    this->core::Model_O::catchSignal(signal,source,data);
oligomer.cc:89:	    this->checkForErrors();
oligomer.cc:90:	    this->_WeakLastMultiMonomerChanged = monomer;
oligomer.cc:98:    ASSERTNOTNULL(this->_WeakLastMultiMonomerChanged);
oligomer.cc:99:    return this->_WeakLastMultiMonomerChanged.lock().notnilp();
oligomer.cc:103:    ASSERTNOTNULL(this->_WeakLastMultiMonomerChanged);
oligomer.cc:104:    return this->_WeakLastMultiMonomerChanged.lock();
oligomer.cc:118:    this->_Monomers.clear();
oligomer.cc:119:    this->_Couplings.clear();
oligomer.cc:125:    this->_WeakCandoDatabase = bdb->sharedThis<CandoDatabase_O>();
oligomer.cc:132://    node->archiveWeakPointer("candoDatabase",this->_WeakCandoDatabase);
oligomer.cc:133:    this->Base::archiveBase(node);
oligomer.cc:134:    node->attribute("name",this->_Name);
oligomer.cc:135:    node->archiveVector0("monomers",this->_Monomers);
oligomer.cc:136:    node->archiveVector0("couplings",this->_Couplings);
oligomer.cc:137:    node->attribute("hasError",this->_HasError);
oligomer.cc:138:    node->attribute("verbose",this->_Verbose);
oligomer.cc:139:    node->attribute("errorMessage",this->_ErrorMessage);
oligomer.cc:148:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:166:	LOG(BF("    %s") % (*mi)->description().c_str()  );
oligomer.cc:167:        for ( ci = (*mi)->begin_WeakCouplings();
oligomer.cc:168:		ci != (*mi)->end_WeakCouplings(); ci++ )
oligomer.cc:170:	    ASSERTNOTNULL(ci->second);
oligomer.cc:171:	    coupling = ci->second.lock();
oligomer.cc:172:	    neighbor = coupling->getOtherSideMonomer(*mi);
oligomer.cc:180:	LOG(BF("    %s") % (*si)->description().c_str()  );
oligomer.cc:193:    this->expandMonomerListToNeighbors(expanded);
oligomer.cc:194:    this->checkMonomersAndNotNeighborsForErrors(cdb,expanded);
oligomer.cc:204:        (*it)->checkForErrorsAndUnknownContexts(cdb);
oligomer.cc:206:    this->checkForErrors();
oligomer.cc:218:    monomer = s->sharedThis<Monomer_O>();
oligomer.cc:220:    LOG(BF("Adding monomer@%X with name (%s)") % monomer.get() % s->description().c_str() );
oligomer.cc:221:    idx = this->_Monomers.size();
oligomer.cc:222:    monomer->setSequenceNumber(idx);
oligomer.cc:223:    this->_Monomers.push_back(monomer);
oligomer.cc:224:    if ( monomer->getHasError() )
oligomer.cc:226:        this->_HasError = true;
oligomer.cc:228://    monomer->connectListener(this->sharedThis<Oligomer_O>(),MultiMonomer_contentsChanged);
oligomer.cc:229:    monomer->setOligomer(this->sharedThis<Oligomer_O>());
oligomer.cc:236:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:238:	if ( (*mi)->getId() == id ) return true;
oligomer.cc:247:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:249:	if ( (*mi)->getId() == id ) return *mi;
oligomer.cc:262:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:266://	    (*mi)->disconnectAll(this->sharedThis<Oligomer_O>());
oligomer.cc:267:	    this->_Monomers.erase(mi);
oligomer.cc:279:    for ( mi=this->_Couplings.begin(); mi!=this->_Couplings.end(); mi++ ) {
oligomer.cc:281://	    (*mi)->disconnectAll(this->sharedThis<Oligomer_O>());
oligomer.cc:282:	    this->_Couplings.erase(mi);
oligomer.cc:294:    this->_HasError = false;
oligomer.cc:295:    this->_ErrorMessage.str("");
oligomer.cc:296:    for ( mi=this->_Monomers.begin(); mi != this->_Monomers.end(); mi++ )
oligomer.cc:298:	if ( (*mi)->getHasError() )
oligomer.cc:300:	    this->addErrorMessage("Error in "+(*mi)->description() );
oligomer.cc:303:    for ( ci=this->_Couplings.begin();
oligomer.cc:304:		ci != this->_Couplings.end(); ci++ )
oligomer.cc:306:	if ( (*ci)->getHasError() )
oligomer.cc:308:	    this->_HasError = true;
oligomer.cc:309:	    this->addErrorMessage("Error in "+(*ci)->description() );
oligomer.cc:312:    return this->_HasError;
oligomer.cc:320:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:322:        (*mi)->updateGroupName();
oligomer.cc:338:    coup->setName(couplingName);
oligomer.cc:339:    monTo = _lisp->create<MultiMonomer_O>();
oligomer.cc:340:    monTo->setGroupName(representedEntityNameSetName);
oligomer.cc:341:    monTo->setPosition2D(pos);
oligomer.cc:342:    coup->setOutMonomer(monTo);
oligomer.cc:343:    monTo->setInCoupling(coup);
oligomer.cc:345:    monFrom->addOutCoupling(coup);
oligomer.cc:346:    coup->setInMonomer(monFrom);
oligomer.cc:347:    this->addMonomer(monTo);
oligomer.cc:348:    this->addCoupling(coup);
oligomer.cc:349:    monFrom->throwIfBadConnections();
oligomer.cc:350:    monTo->throwIfBadConnections();
oligomer.cc:351:    coup->throwIfBadConnections();
oligomer.cc:365:    if ( !monomerToRemove->hasInCoupling() )
oligomer.cc:367:        THROW(_lisp->create<core::ContentException_O>(BF("Trying to remove a leaf monomer that has no in coupling!") %monomerToRemove->description()));
oligomer.cc:369:    couplings = monomerToRemove->numberOfCouplings();
oligomer.cc:372:        THROW(_lisp->create<core::ContentException_O>(BF("Trying to remove a leaf monomer but it has out couplings!")%monomerToRemove->description()));
oligomer.cc:374:    couplingToRemove = monomerToRemove->getInCoupling()->as<DirectionalCoupling_O>();
oligomer.cc:375:    monomerToRemain = couplingToRemove->getMonomer1();
oligomer.cc:376:    monomerToRemain->removeCoupling(couplingToRemove);
oligomer.cc:377:    this->removeMonomer(monomerToRemove);
oligomer.cc:378:    this->removeCoupling(couplingToRemove);
oligomer.cc:379:    monomerToRemain->throwIfBadConnections();
oligomer.cc:389:    this->_Couplings.push_back(c);
oligomer.cc:390://    c->connectListener(this->sharedThis<Oligomer_O>(),Coupling_nameChanged);
oligomer.cc:391:    c->setOligomer(this->sharedThis<Oligomer_O>());
oligomer.cc:404:    sub = this->_Monomers[0];
oligomer.cc:406:        LOG(BF("Looking at monomer: %s") % sub->description().c_str()  );
oligomer.cc:407:	if ( sub->hasInCoupling() )
oligomer.cc:409:	    LOG(BF("    It has an in-coupling") );
oligomer.cc:410:	    coupling = sub->getInCoupling();
oligomer.cc:411:	    if ( coupling->isNil() ) 
oligomer.cc:416:	    sub = coupling->getInMonomer();
oligomer.cc:431:    for ( mi=this->_Monomers.begin(); mi != this->_Monomers.end(); mi++ )
oligomer.cc:433:        (*mi)->throwIfBadConnections();
oligomer.cc:435:    for ( ci=this->_Couplings.begin();
oligomer.cc:436:		ci != this->_Couplings.end(); ci++ )
oligomer.cc:438:        (*ci)->throwIfBadConnections();
oligomer.cc:452:    this->_Verbose = v;
oligomer.cc:454:    for ( mi = this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) {
oligomer.cc:457:        LOG(BF("Setting verbosity of monomer: %s") % (*mi)->description().c_str() );
oligomer.cc:458:	(*mi)->setVerbose(v);
oligomer.cc:473:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:489:    if ( outMon->hasCouplingWithPlugName(outMonPlugName) ) {
oligomer.cc:493:    if ( inMon->hasCouplingWithPlugName(inMonPlugName) ) {
oligomer.cc:494:	SIMPLE_ERROR(boost::format("The first monomer[%s] already has an out coupling with the name: %s") % inMon->getName() % name );
oligomer.cc:497:    coupling->setName(name);
oligomer.cc:498:    coupling->setInMonomer(inMon->sharedThis<Monomer_O>());
oligomer.cc:499:    coupling->setOutMonomer(outMon->sharedThis<Monomer_O>());
oligomer.cc:500:    inMon->addCoupling(inMonPlugName,coupling);
oligomer.cc:501:    outMon->addCoupling(outMonPlugName,coupling);
oligomer.cc:502:    this->addCoupling(coupling);
oligomer.cc:503:    LOG(BF("after coupling coupling: %s") % coupling->description().c_str()  );
oligomer.cc:515:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:532:    RingClosingPlug_sp rcPlug1 = mon1->getMissingRingClosingPlug(mon2);
oligomer.cc:533:    if ( rcPlug1->isNil() )
oligomer.cc:536:					 % mon1->description() );
oligomer.cc:538:    RingClosingPlug_sp rcPlug2 = mon2->getMissingRingClosingPlug(mon1);
oligomer.cc:539:    if ( rcPlug2->isNil() )
oligomer.cc:542:					 % mon2->description()
oligomer.cc:545:    core::Symbol_sp mon1PlugName = rcPlug1->getName();
oligomer.cc:546:    core::Symbol_sp mon2PlugName = rcPlug2->getName();
oligomer.cc:548:    coupling->setMonomer1(mon1->sharedThis<Monomer_O>());
oligomer.cc:549:    coupling->setPlug1(mon1PlugName);
oligomer.cc:550:    coupling->setMonomer2(mon2->sharedThis<Monomer_O>());
oligomer.cc:551:    coupling->setPlug2(mon2PlugName);
oligomer.cc:552:    mon1->addCoupling(mon1PlugName,coupling);
oligomer.cc:553:    mon2->addCoupling(mon2PlugName,coupling);
oligomer.cc:554:    this->addCoupling(coupling);
oligomer.cc:565:    if ( this->getHasError() ) {
oligomer.cc:570:    mol = _lisp->create<Molecule_O>();
oligomer.cc:572:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) 
oligomer.cc:575:    	res = (*mi)->createResidue();
oligomer.cc:576:	topology = (*mi)->getTopology();
oligomer.cc:577:	residueNetCharge = topology->getResidueNetCharge();
oligomer.cc:578:	res->setNetCharge(residueNetCharge);
oligomer.cc:579:	(*mi)->setTempResidue(res);
oligomer.cc:580:	mol->addMatter(res);
oligomer.cc:585:    for ( ci=this->_Couplings.begin(); ci!=this->_Couplings.end(); ci++ ) 
oligomer.cc:587:	mon1 = (*ci)->getMonomer1();
oligomer.cc:589:	mon2 = (*ci)->getMonomer2();
oligomer.cc:591:	res1 = mon1->getTemporaryResidue();
oligomer.cc:592:	res2 = mon2->getTemporaryResidue();
oligomer.cc:593:    	(*ci)->doCoupling(res1,res2);
oligomer.cc:605:    msg << this->_ErrorMessage.str();
oligomer.cc:608:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ ) {
oligomer.cc:609:	if ( (*mi)->getHasError() ) {
oligomer.cc:610:	    msg << (*mi)->getStatusMessage() << endl;
oligomer.cc:614:    for ( ci=this->_Couplings.begin(); ci!=this->_Couplings.end(); ci++ ) {
oligomer.cc:615:	if ( (*ci)->getHasError() ) {
oligomer.cc:616:	    msg << (*mi)->getStatusMessage() << endl;
oligomer.cc:628:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:630:	if ( (*mi)->numberOfPossibleMonomers()>1 )
oligomer.cc:651:    this->_gatherMultiMonomers(multiMonomers);
oligomer.cc:665:    multiMonomers[iperturb]->randomizeMonomer();
oligomer.cc:674:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:676:        bases.push_back((*mi)->numberOfPossibleMonomers());
oligomer.cc:679:    for ( mi=this->_Monomers.begin(),di=digits.begin();
oligomer.cc:680:    		mi!=this->_Monomers.end(); mi++,di++ )
oligomer.cc:682:        (*mi)->setMonomerIndex(*di);
oligomer.cc:694:    this->gotoSequence(0);
oligomer.cc:705:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:707:        bases.push_back((*mi)->numberOfPossibleMonomers());
oligomer.cc:708:	digits.push_back((*mi)->getMonomerIndex());
oligomer.cc:717: * Return -1 if there are too many sequences.
oligomer.cc:724:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:726:        bases.push_back((*mi)->numberOfPossibleMonomers());
oligomer.cc:741:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:743:        if ( (*mi)->incrementMonomerIndex() ) return true;
oligomer.cc:744:        numSeq *= (*mi)->numberOfPossibleMonomers();
oligomer.cc:754:    if ( this->_Monomers.size() != 0 ) {
oligomer.cc:755:        return this->_Monomers[0];
oligomer.cc:765:    seq << "monomer '" << mon->getId()->__repr__();
oligomer.cc:766:    if ( mon->getGroupName() == mon->getName() )
oligomer.cc:768:	seq << " '" << mon->getGroupName()->symbolName();
oligomer.cc:770:	seq << " (GroupPart :group '" << mon->getGroupName()->symbolName() <<" :part '" <<mon->getName()->symbolName() << ")";
oligomer.cc:772:    core::SymbolSet_sp aliases = mon->getMonomerAliases();
oligomer.cc:773:    if ( aliases->size() > 0 )
oligomer.cc:775:	seq << " :aliases '(" << aliases->asString() << " ) ";
oligomer.cc:785:    outCouplings = rootMonomer->getOutCouplings();
oligomer.cc:788:        Monomer_sp mon1 = (*oci)->getMonomer1();
oligomer.cc:789:        Monomer_sp mon2 = (*oci)->getMonomer2();
oligomer.cc:790:        seq << "( link '"<<mon1->getId()->symbolName();
oligomer.cc:791:	seq <<" '"<<(*oci)->getName()->symbolName() << " ";
oligomer.cc:792:	this->_fillMonomerAsString(mon2,seq);
oligomer.cc:797:	if ((*oci)->isOfClass<RingCoupling_O>()) continue;
oligomer.cc:798:        Monomer_sp mon2 = (*oci)->getMonomer2();
oligomer.cc:799:        this->_fillSequenceAsStringForChildren(mon2,seq);
oligomer.cc:806:    Monomer_sp mon2 = this->rootMonomer();
oligomer.cc:808:    seq << "(Oligomer :name " << this->_Name->__repr__() << " :parts (list " << endl;
oligomer.cc:809:    this->_fillMonomerAsString(mon2,seq);
oligomer.cc:811:    this->_fillSequenceAsStringForChildren(mon2,seq);
oligomer.cc:812:    for (core::Vector0<Coupling_O>::iterator ci=this->_Couplings.begin(); ci!=this->_Couplings.end(); ci++ )
oligomer.cc:814:	if ( (*ci)->isOfClass<RingCoupling_O>() )
oligomer.cc:816:	    RingCoupling_sp rc = (*ci)->as<RingCoupling_O>();
oligomer.cc:817:	    Monomer_sp mon1 = rc->getMonomer1();
oligomer.cc:818:	    Monomer_sp mon2 = rc->getMonomer2();
oligomer.cc:820:	    seq << mon1->getId()->__repr__();
oligomer.cc:821:	    seq <<" '"<<rc->getPlug1() << " ";
oligomer.cc:822:	    seq << mon2->getId()->__repr__();
oligomer.cc:823:	    seq <<" '"<<rc->getPlug2() << " ";
oligomer.cc:837:    outCouplings = rootMonomer->getOutCouplings();
oligomer.cc:840:        Monomer_sp mon1 = (*oci)->getMonomer1();
oligomer.cc:841:        Monomer_sp mon2 = (*oci)->getMonomer2();
oligomer.cc:842:	seq <<"-" << mon2->getName()->symbolName();
oligomer.cc:846:	if ( (*oci)->isOfClass<RingCoupling_O>() ) continue;
oligomer.cc:847:        Monomer_sp mon2 = (*oci)->getMonomer2();
oligomer.cc:848:        this->_fillSequenceAsFileNameForChildren(mon2,seq);
oligomer.cc:857:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:859:	core::ObjectSet_sp oneMonomerAliases = (*mi)->getAllAliases();
oligomer.cc:860:	aliases->addObjects(oneMonomerAliases);
oligomer.cc:869:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:871:	core::SymbolSet_sp oneMonomerAliases = (*mi)->getMonomerAliases();
oligomer.cc:872:	aliases->insertSymbolSet(oneMonomerAliases);
oligomer.cc:880:    Monomer_sp mon2 = this->rootMonomer();
oligomer.cc:882:    seq << mon2->getName()->symbolName();
oligomer.cc:883:    this->_fillSequenceAsFileNameForChildren(mon2,seq);
oligomer.cc:884://    seq << "_" << this->getName()->symbolName();
oligomer.cc:893:    for ( mi=this->_Monomers.begin(); mi!=this->_Monomers.end(); mi++ )
oligomer.cc:895:	MonomerContext_sp monomerContext = (*mi)->getGeneralMonomerContext();
oligomer.cc:896:	SpecificContextSet_sp oneSpecificSet = monomerContext->getAllSpecificContexts();
oligomer.cc:897:	allContexts->merge(oneSpecificSet);
oligomer.cc:913:    string seq = olig->sequenceAsString();
oligomer.cc:921:    for ( core::Cons_sp p=parts; p.notnilp(); p=p->cdr() )
oligomer.cc:923:	OligomerPart_Base_sp oligPart = p->car<OligomerPart_Base_O>();
oligomer.cc:924:	MultiMonomer_sp mon = oligPart->createMonomer(bdb);
oligomer.cc:925:	this->addMonomer(mon);
oligomer.cc:926:	monomerMap->extend(mon->getId(), mon);
oligomer.cc:927:	if ( oligPart->isOfClass<OligomerPart_Link_O>() )
oligomer.cc:930:	    core::Symbol_sp	mon1Id = link->_Monomer1Id;
oligomer.cc:931:	    core::Symbol_sp	mon2Id = link->_Monomer2->_MonomerId;
oligomer.cc:932:	    if ( !monomerMap->contains(mon1Id) ) SIMPLE_ERROR(BF("Unknown monomer id: %s")%mon1Id);
oligomer.cc:933:	    if ( !monomerMap->contains(mon2Id) ) SIMPLE_ERROR(BF("Unknown monomer id: %s")%mon2Id);
oligomer.cc:934:	    MultiMonomer_sp mon1 = monomerMap->lookup(mon1Id)->as<MultiMonomer_O>();
oligomer.cc:935:	    MultiMonomer_sp mon2 = monomerMap->lookup(mon2Id)->as<MultiMonomer_O>();
oligomer.cc:936:	    this->couple(mon1,link->_Coupling,mon2);
oligomer.cc:952:	me->_assembleFromParts(parts,bdb);
oligomer.cc:961:    core::Cons_sp parts = translate::from_object<core::Cons_O>::convert(env->lookup(Pkg(),"parts"));
oligomer.cc:965:	this->_assembleFromParts(parts,bdb);
oligomer.cc:980:    Oligomer_sp olig = _lisp->create<Oligomer_O>();
oligomer.cc:981:    olig->setName(oligomerName);
oligomer.cc:983:    olig->_assembleFromParts(parts,bdb);
oligomer.cc:985:    sym->defparameter(olig);
oligomer.cc:986://    lisp->globalEnvironment()->extend(sym,olig);
pdb.cc:46:	virtual ~AtomPdbRec() {this->_atom.reset();};
pdb.cc:87:	int	firstChar = firstChar1 - 1;
pdb.cc:88:	int lastChar = lastChar1 - 1;
pdb.cc:120:	this->_atom = _Nil<Atom_O>();
pdb.cc:126:	if ( this->_name.size() > 3 )
pdb.cc:128:	    name = this->_name.substr(3,1)+this->_name.substr(0,3);
pdb.cc:131:	    name = " " + this->_name;
pdb.cc:133:	fout << boost::format( "ATOM%7d %-4s %3s %1s%4d    %8.3f%8.3f%8.3f %5.2f %5.2f           %2s" ) % this->_serial % name % this->_resName % this->_chainId % this->_resSeq % this->_x % this->_y % this->_z % this->_occupancy % this->_tempFactor % this->_element;
pdb.cc:139:	this->_atoms.push_back(atom);
pdb.cc:140:	this->_atomRecIndexFromSerial[atom._serial] = this->_atoms.size()-1;
pdb.cc:146:	this->_connects.push_back(connect);
pdb.cc:155:	this->_line = line;
pdb.cc:156:	this->_recordName = pdb_substr(line,1,6);
pdb.cc:157:	this->_serial = pdb_substr_int(line,7,11,-1);
pdb.cc:160:	this->_name = name3+name1;
pdb.cc:161:	this->_altLoc = pdb_substr(line,17,17);
pdb.cc:162:	this->_resName = pdb_substr(line,18,20);
pdb.cc:163:	this->_chainId = pdb_substr(line,22,22);
pdb.cc:164:	this->_resSeq = pdb_substr_int(line,23,26,0);
pdb.cc:165:	this->_iCode = pdb_substr(line,27,27);
pdb.cc:166:	this->_x = pdb_substr_double(line,31,38,0.0);
pdb.cc:167:	this->_y = pdb_substr_double(line,39,46,0.0);
pdb.cc:168:	this->_z = pdb_substr_double(line,47,54,0.0);
pdb.cc:169:	this->_occupancy = pdb_substr_double(line,55,60,0.0);
pdb.cc:170:	this->_tempFactor = pdb_substr_double(line,61,66,0.0);
pdb.cc:171:	this->_element = pdb_substr(line,77,78);
pdb.cc:172:	this->_charge = pdb_substr(line,79,80);
pdb.cc:179:	atom->setName(this->_name);
pdb.cc:181:	pos.set(this->_x,this->_y,this->_z);
pdb.cc:182:	atom->setPosition(pos);
pdb.cc:183:	if ( this->_element != "" )
pdb.cc:185:	    atom->setElementFromString(this->_element);
pdb.cc:188:	    atom->setElement(elementFromNameCaseInsensitive(this->_name,lisp));
pdb.cc:199:	this->_atom1   = pdb_substr_int(line,  7, 11, -1 );
pdb.cc:200:	this->_bonded[0] = pdb_substr_int(line, 12, 16, -1 );
pdb.cc:201:	this->_bonded[1] = pdb_substr_int(line, 17, 21, -1 );
pdb.cc:202:	this->_bonded[2] = pdb_substr_int(line, 22, 26, -1 );
pdb.cc:203:	this->_bonded[3] = pdb_substr_int(line, 27, 31, -1 );
pdb.cc:211:	fout << this->_atom1;
pdb.cc:214:	    if ( this->_bonded[i]>0 )
pdb.cc:216:		fout << setw(5) << this->_bonded[i];
pdb.cc:225:	Aggregate_sp agg = lisp->create<Aggregate_O>();
pdb.cc:227:	    int moleculeIdx = -1;
pdb.cc:228:	    int residueSeq = -1;
pdb.cc:229:	    int currentResidueIdx = -1;
pdb.cc:231:	    for ( ai=this->_atoms.begin();ai!=this->_atoms.end(); ai++ )
pdb.cc:235:		if ( moleculeIdx != ai->_moleculeIdx )
pdb.cc:236:		{ _BLOCK_TRACEF(BF("Creating molecule with moleculeIdx: %d") % ai->_moleculeIdx );
pdb.cc:237:		    moleculeIdx = ai->_moleculeIdx;
pdb.cc:238:		    ASSERT((unsigned)(moleculeIdx)==this->_molecules.size());
pdb.cc:239:		    this->_molecules.resize(moleculeIdx+1,_Nil<Molecule_O>());
pdb.cc:240:		    Molecule_sp mol = lisp->create<Molecule_O>();
pdb.cc:241:		    mol->setName(ai->_chainId);
pdb.cc:242:		    this->_molecules[moleculeIdx] = mol;
pdb.cc:245:		    residueSeq = -1;	
pdb.cc:246:		    agg->addMatter(mol);
pdb.cc:251:		LOG(BF("residueSeq(%d)   ai->_resSeq(%d)") % residueSeq % ai->_resSeq  );
pdb.cc:252:		if ( residueSeq != ai->_resSeq)
pdb.cc:253:		{ _BLOCK_TRACEF(BF("Creating residue with sequence number: %d  resName: %s") % ai->_resSeq % ai->_resName    );
pdb.cc:254:		    residueSeq = ai->_resSeq;
pdb.cc:255:		    Residue_sp res = lisp->create<Residue_O>();
pdb.cc:256:		    res->setName(ai->_resName);
pdb.cc:257:		    res->setPdbName(ai->_resName);
pdb.cc:258:		    res->setId(ai->_resSeq);
pdb.cc:259:		    res->setFileSequenceNumber(ai->_resSeq);
pdb.cc:260:		    Molecule_sp mol = this->_molecules[ai->_moleculeIdx];
pdb.cc:261:		    mol->addMatter(res);
pdb.cc:262:		    ai->_residueIdx = this->_residues.size();
pdb.cc:263:		    currentResidueIdx = ai->_residueIdx;
pdb.cc:264:		    this->_residues.push_back(res);
pdb.cc:267:		Atom_sp atom = ai->createAtom(lisp);
pdb.cc:268:		ai->_atom = atom;
pdb.cc:270:		ASSERTF(currentResidueIdx>=0,BF("residue index must be positive - line--> %s")%ai->_line );
pdb.cc:271:		ASSERT_lessThan(currentResidueIdx,(int)(this->_residues.size()));
pdb.cc:272:		ai->_residueIdx = currentResidueIdx;
pdb.cc:273:		Residue_sp res = this->_residues[ai->_residueIdx];
pdb.cc:274:		res->addMatter(atom);
pdb.cc:278:	    LOG(BF("There are %d bonds") % this->_connects.size()  );
pdb.cc:279:	    for ( unsigned ci=0; ci<this->_connects.size(); ci++ )
pdb.cc:281:		LOG(BF("CONECT indices: %d %d %d %d %d") % this->_connects[ci]._atom1 % this->_connects[ci]._bonded[0] % this->_connects[ci]._bonded[1] % this->_connects[ci]._bonded[2] % this->_connects[ci]._bonded[3]  );
pdb.cc:285:		LOG(BF("Looking atom with index: %d") % this->_connects[ci]._atom1  );
pdb.cc:286:		int atomRecIndex = this->_atomRecIndexFromSerial[this->_connects[ci]._atom1];
pdb.cc:287:		atomPtr = &(this->_atoms[atomRecIndex]);
pdb.cc:289:		LOG(BF("Found atom entry with serial#%d") % atomPtr->_serial  );
pdb.cc:290:		LOG(BF("Atom.get = %X") % atomPtr->_atom.get()  );
pdb.cc:291:		ANN(atomPtr->_atom);
pdb.cc:292:		ASSERTP(atomPtr->_atom.notnilp(), "Atom is nil");
pdb.cc:293:		bondedIdx = this->_connects[ci]._bonded[0];
pdb.cc:296:		    LOG(BF("Creating bond2 between atoms with indices %d-%d") % atomRecIndex % bondedIdx );
pdb.cc:297:		    bondedAtomRecIdx = this->_atomRecIndexFromSerial[bondedIdx];
pdb.cc:298:		    bondedPtr = &(this->_atoms[bondedAtomRecIdx]);
pdb.cc:299:		    ANN(bondedPtr->_atom);
pdb.cc:300:		    ASSERTP(bondedPtr->_atom.notnilp(), "Atom is nil");
pdb.cc:301:		    atomPtr->_atom->bondTo(bondedPtr->_atom,singleBond);
pdb.cc:303:		bondedIdx = this->_connects[ci]._bonded[1];
pdb.cc:306:		    LOG(BF("Creating bond3 between atoms with indices %d-%d") % atomRecIndex % bondedIdx );
pdb.cc:307:		    bondedAtomRecIdx = this->_atomRecIndexFromSerial[bondedIdx];
pdb.cc:308:		    bondedPtr = &(this->_atoms[bondedAtomRecIdx]);
pdb.cc:309:		    ANN(bondedPtr->_atom);
pdb.cc:310:		    ASSERTP(bondedPtr->_atom.notnilp(), "Atom is nil");
pdb.cc:311:		    atomPtr->_atom->bondTo(bondedPtr->_atom,singleBond);
pdb.cc:313:		bondedIdx = this->_connects[ci]._bonded[2];
pdb.cc:316:		    LOG(BF("Creating bond4 between atoms with indices %d-%d") % atomRecIndex % bondedIdx );
pdb.cc:317:		    bondedAtomRecIdx = this->_atomRecIndexFromSerial[bondedIdx];
pdb.cc:318:		    bondedPtr = &(this->_atoms[bondedAtomRecIdx]);
pdb.cc:319:		    ANN(bondedPtr->_atom);
pdb.cc:320:		    ASSERTP(bondedPtr->_atom.notnilp(), "Atom is nil");
pdb.cc:321:		    atomPtr->_atom->bondTo(bondedPtr->_atom,singleBond);
pdb.cc:323:		bondedIdx = this->_connects[ci]._bonded[3];
pdb.cc:326:		    LOG(BF("Creating bond5 between atoms with indices %d-%d") % atomRecIndex % bondedIdx );
pdb.cc:327:		    bondedAtomRecIdx = this->_atomRecIndexFromSerial[bondedIdx];
pdb.cc:328:		    bondedPtr = &(this->_atoms[bondedAtomRecIdx]);
pdb.cc:329:		    ANN(bondedPtr->_atom);
pdb.cc:330:		    ASSERTP(bondedPtr->_atom.notnilp(), "Atom is nil");
pdb.cc:331:		    atomPtr->_atom->bondTo(bondedPtr->_atom,singleBond);
pdb.cc:342:	PdbReader_sp pdb = lisp->create<PdbReader_O>();
pdb.cc:343:	Aggregate_sp agg = pdb->parse(fileName,lisp);
pdb.cc:349:	PdbReader_sp pdb = lisp->create<PdbReader_O>();
pdb.cc:350:	Aggregate_sp agg = pdb->parse(fileName,lisp);
pdb.cc:364:	Aggregate_sp agg = PdbReader_O::loadPdbConnectAtoms(fileName->get(),_lisp);
pdb.cc:370:	this->Base::initialize();
pdb.cc:436:    me->open(fileName);
pdb.cc:445:	string fn = env->lookup(_lisp->internWithPackageName(ChemPkg,"fileName"))->as<core::Str_O>()->get();
pdb.cc:446:	this->open(fn);
pdb.cc:455:	this->Base::initialize();
pdb.cc:456:	this->_Out = NULL;
pdb.cc:484:		atom._name = a->getName();
pdb.cc:485:		atom._element = a->getElementAsString();
pdb.cc:488:		atom._resName = res->getPdbName();
pdb.cc:493:		atom._chainId = chainId+'A'-1;
pdb.cc:495:		atom._x = a->getPosition().getX();
pdb.cc:496:		atom._y = a->getPosition().getY();
pdb.cc:497:		atom._z = a->getPosition().getZ();
pdb.cc:500:		a->setTempInt(pdbAtoms.size());
pdb.cc:507:	    vector<Atom_sp>	bonded = ai->_atom->getBondedAtoms();
pdb.cc:511:		if ( ai->_atom->getTempInt()<(*bi)->getTempInt() )
pdb.cc:519:		connect._atom1 = ai->_atom->getTempInt()+1;
pdb.cc:522:		    connect._bonded[i] = uniqueBonded[i]->getTempInt()+1;
pdb.cc:539:	    ai->write(fout);
pdb.cc:544:	    ci->write(fout);
pdb.cc:552:	if ( this->_Out!=NULL)
pdb.cc:554:	    this->close();
pdb.cc:560:	this->_Out = new ofstream();
pdb.cc:561:	this->_Out->open(fileName.c_str());
pdb.cc:567:	if ( matter->isOfClass<Aggregate_O>() )
pdb.cc:585:	    _setupAtomAndConnectRecordsForOneMolecule(matter->as<Molecule_O>(),pdbAtoms,pdbConnects,1, _lisp);
pdb.cc:593:	ASSERT(this->_Out!=NULL);
pdb.cc:594:	*(this->_Out) << (BF("MODEL     %d") % model).str() << endl;
pdb.cc:595:	this->write(matter);
pdb.cc:596:	*(this->_Out) << "ENDMDL" << endl;
pdb.cc:601:	if ( this->_Out != NULL )
pdb.cc:603:	    *(this->_Out) << "END" << endl;
pdb.cc:604:	    (*(this->_Out)).close();
pdb.cc:605:	    delete this->_Out;
pdb.cc:606:	    this->_Out = NULL;
pdb.cc:612:	PdbWriter_sp writer = matter->lisp()->create<PdbWriter_O>();
pdb.cc:613:	writer->open(fileName);
pdb.cc:614:	writer->write(matter);
pdb.cc:615:	writer->close();
pdbMonomer.cc:57:	this->_PdbCode = core::trimWhiteSpace(line.substr(10,3));
pdbMonomer.cc:58:	this->_NumAtoms = atoi(core::trimWhiteSpace(line.substr(17,3)).c_str());
pdbMonomer.cc:74:	this->_MainAtom = parts[1];
pdbMonomer.cc:75:	this->_Bonded = core::StringSet_O::create();
pdbMonomer.cc:78:	    this->_Bonded->insert(parts[idx]);
pdbMonomer.cc:90:	this->_PdbCode = core::trimWhiteSpace(line.substr(11,3));
pdbMonomer.cc:91:	this->_LongName = core::trimWhiteSpace(line.substr(15,99999));
pdbMonomer.cc:105:	this->_PdbCode = parts[1];
pdbMonomer.cc:109:	    this->_FormulaTerm[eidx] = parts[idx];
pdbMonomer.cc:110:	    ASSERTF(eidx<MAX_FORMULA_TERMS,BF("Allocate more space for formula terms - need at least %d") % eidx );
pdbMonomer.cc:126:	PdbMonomerDatabase_sp monomerDatabase = _lisp->create<PdbMonomerDatabase_O>();
pdbMonomer.cc:142:		    PdbMonomerConnectivity_sp oneMonomer = _lisp->create<PdbMonomerConnectivity_O>();
pdbMonomer.cc:143:		    oneMonomer->setPdbName(residue._PdbCode);
pdbMonomer.cc:144:		    monomerDatabase->addMonomer(oneMonomer);
pdbMonomer.cc:158:			    oneMonomer->addConnect(connect._MainAtom,connect._Bonded);
pdbMonomer.cc:168:		    PdbMonomerConnectivity_sp oneMonomer = monomerDatabase->findMonomer(hetName._PdbCode);
pdbMonomer.cc:169:		    oneMonomer->addLongName(hetName._LongName);
pdbMonomer.cc:200:	this->_LongNames = _lisp->create<addon::ObjectList_O>();
pdbMonomer.cc:206:	node->attribute("pdbName",this->_PdbName);
pdbMonomer.cc:207:	node->archiveObject("longNames",this->_LongNames);
pdbMonomer.cc:208:	if ( node->loading() )
pdbMonomer.cc:210:	    this->_BondAtomPairs.clear();
pdbMonomer.cc:212:	    node->getDataAsVectorOfStrings(data);
pdbMonomer.cc:216:		this->_BondAtomPairs.push_back(one);
pdbMonomer.cc:221:	    for ( vector<AtomPair>::iterator pi=this->_BondAtomPairs.begin(); pi!=this->_BondAtomPairs.end(); pi++ )
pdbMonomer.cc:223:		sout << pi->first << " " << pi->second << endl;
pdbMonomer.cc:225:	    node->setCharacters(sout.str());
pdbMonomer.cc:235:    for ( vector<AtomPair>::iterator pi=this->_BondAtomPairs.begin(); pi!=this->_BondAtomPairs.end(); pi++ )
pdbMonomer.cc:236:    {_BLOCK_TRACEF(BF("Trying to connect %s - %s") % pi->first % pi->second );
pdbMonomer.cc:237:	string& s1 = pi->first;
pdbMonomer.cc:238:	string& s2 = pi->second;
pdbMonomer.cc:239:	Atom_sp a1 = res->contentWithNameOrNil(s1)->as<Atom_O>();
pdbMonomer.cc:240:	Atom_sp a2 = res->contentWithNameOrNil(s2)->as<Atom_O>();
pdbMonomer.cc:241:	if ( a1->isNil() && a2.notnilp() )
pdbMonomer.cc:243:	    LOG(BF("Could not find atom(%s) - marking atom(%s) as unconnected") % pi->first % pi->second );
pdbMonomer.cc:248:	if ( a2->isNil() && a1.notnilp() ) 
pdbMonomer.cc:250:	    LOG(BF("Could not find atom(%s) - marking atom(%s) as unconnected") % pi->second % pi->first );
pdbMonomer.cc:255:	if ( a1->isNil() && a2->isNil() )
pdbMonomer.cc:257:	    LOG(BF("Could not find either atom(%s) or atom(%s)") % pi->first % pi->second );
pdbMonomer.cc:260:	if ( a1.notnilp() && a2->notNil() ) 
pdbMonomer.cc:262:	    LOG(BF("Connecting atoms %s - %s") % a1->description() % a2->description() )
pdbMonomer.cc:263:	    a1->bondToSingle(a2);
pdbMonomer.cc:276:    this->_PdbName = pdbName;
pdbMonomer.cc:282:	this->_LongNames->append(_lisp->create<core::Str_O>(longName));
pdbMonomer.cc:287:    for ( core::StringSet_O::iterator si=bonded->begin(); si!=bonded->end(); si++ )
pdbMonomer.cc:289:	if ( !this->hasConnection(mainAtom,*si) )
pdbMonomer.cc:292:	    this->_BondAtomPairs.push_back(two);
pdbMonomer.cc:299:    for ( iterator it=this->_BondAtomPairs.begin(); it!=this->_BondAtomPairs.end(); it++ )
pdbMonomer.cc:301:	if ( (it->first==a1 && it->second==a2) || (it->first==a2 && it->second==a1) )
pdbMonomer.cc:334:	node->archiveMap("db",this->_Database);
pdbMonomer.cc:340:    this->_Database.set(mon->getPdbName(),mon);
pdbMonomer.cc:346:    if ( this->_Database.contains(pdbName) )
pdbMonomer.cc:350:    return this->_Database.get(pdbName);
pdbMonomer.cc:358:    for ( vector<Atom_sp>::iterator i1 = atoms.begin(); i1!=atoms.end()-1; i1++ )
pdbMonomer.cc:360:	Vector3 v1 = (*i1)->getPosition();
pdbMonomer.cc:361://	double rad1 = vdwRadiusForElement((*i1)->getElement());
pdbMonomer.cc:364:	    Vector3 v2 = (*i2)->getPosition();
pdbMonomer.cc:367:	    double maxLen = maximumBondLengthBetweenElements((*i1)->getElement(),(*i2)->getElement());
pdbMonomer.cc:370:		if (!(*i1)->isBondedTo(*i2))
pdbMonomer.cc:372:		    LOG(BF("Forming bond between atom(%s) and atom(%s) - they were %lf angstroms apart < max(%lf)") % (*i1)->description() % (*i2)->description() % len % maxLen );
pdbMonomer.cc:373:		    (*i1)->bondToSingle(*i2);
pdbMonomer.cc:396:	{_BLOCK_TRACEF(BF("Looking at residue(%s)") % lResidues.getResidue()->getPdbName() );
pdbMonomer.cc:398:	    if ( this->_Database.contains(res->getPdbName()) )
pdbMonomer.cc:400:		LOG(BF("Found residue(%s) in database connecting atoms") % res->getPdbName()   );
pdbMonomer.cc:401:		PdbMonomerConnectivity_sp connector = this->_Database.get(res->getPdbName());
pdbMonomer.cc:402:		numConnect += connector->connectAtomsAndReturnUnconnected(res,unconnectedAtoms);
pdbMonomer.cc:405:		LOG(BF("Could not find residue(%s) pushing %d atoms into unconnectedAtoms") % res->getPdbName() % res->numberOfAtoms() );
pdbMonomer.cc:406:		for ( Matter_O::contentIterator ci=res->begin_contents(); 
pdbMonomer.cc:407:		      ci != res->end_contents(); ci++ )
pdbMonomer.cc:409:		    unconnectedAtoms.push_back((*ci)->as<Atom_O>());
pdbMonomer.cc:413:	uint numVdwConnected = this->connectVdwOverlappingUnconnectedAtoms(unconnectedAtoms);
pdbMonomer.cc:416:	_lisp->print(BF("Number of unconnected atoms(%d)") % unconnectedAtoms.size() );
pdbMonomer.cc:417:	_lisp->print(BF("Number of atoms connected by monomer connectivity(%d)") % numConnect );
pdbMonomer.cc:418:	_lisp->print(BF("Number of atoms connected by vdw overlap(%d)") % numVdwConnected);
plug.cc:25://    mate->setCandoDatabase(db);
plug.cc:33:	return _lisp->intern("UnnamedRingClosingMate");
plug.cc:62:	this->Base::archiveBase(node);
plug.cc:97:	mate->setCandoDatabase(db);
plug.cc:112:	this->_Cap = ss._Cap;
plug.cc:122:	ss << "( Cap "<< this->_Cap<<") ";
plug.cc:129:	this->Base::archiveBase(node);
plug.cc:130:	node->attribute( "cap", this->_Cap );
plug.cc:159:    me->_Cap = cap;
plug.cc:167:	this->Base::__init__(exec,args,env,lisp);
plug.cc:168:	this->_Cap = translate::from_object<core::Symbol_O>::convert(env->lookup(ChemPkg,"cap"));
plug.cc:180:	this->Base::initialize();
plug.cc:181:	this->_WeakConstitution = Constitution_O::_nil;
plug.cc:182:	this->_Name = _Nil<core::Symbol_O>();
plug.cc:213:    me->_Name = name;
plug.cc:221:	this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(ChemPkg,"name"));
plug.cc:231:	this->_WeakConstitution = p._WeakConstitution;
plug.cc:232:	this->_Name = p._Name;
plug.cc:233:	LOG(BF("Copy constructed %s") % this->description().c_str()  );
plug.cc:241:	ss << this->Base::descriptionOfContents() << " ";
plug.cc:242:	ss << "( Name " << this->_Name->__repr__() << " )";
plug.cc:251:	this->_WeakConstitution = con->sharedThis<Constitution_O>();
plug.cc:258:	ASSERTNOTNULL(this->_WeakConstitution);
plug.cc:259:	if ( this->_WeakConstitution.lock()->isNil() )
plug.cc:263://	    this->_WeakConstitution = this->ownerWithClass<Constitution_O>();
plug.cc:265:	return this->_WeakConstitution.lock();
plug.cc:274:	return DirectionalCoupling_O::otherPlugName(this->_Name,_lisp);
plug.cc:281:	this->Base::archiveBase(node);
plug.cc:282:	if ( node->saving() ) this->getConstitution();
plug.cc:283:	node->archiveWeakPointer("constitution",this->_WeakConstitution);
plug.cc:285:	node->attribute("name",this->_Name);
plug.cc:287:	if ( node->loading() )
plug.cc:289:	    if ( node->hasAttribute("name") )
plug.cc:291:		node->attribute("name",this->_Name);
plug.cc:294:		node->attribute("_key",this->_Name);
plug.cc:298:	    node->attribute("name",this->_Name);
plug.cc:349:	this->Base::initialize();
plug.cc:360:    me->_B0 = bond0;
plug.cc:361:    me->_B1 = bond1;
plug.cc:362:    me->_Mates.clear();
plug.cc:363:    me->_Mates.fillFromCons(mates);
plug.cc:371:	this->Base::__init__(exec,args,env,lisp);
plug.cc:372:	this->_B0 = translate::from_object<string>::convert(env->lookup(ChemPkg,"bond0"));
plug.cc:373:	this->_B1 = translate::from_object<string>::convert(env->lookup(ChemPkg,"bond1"));
plug.cc:374:	core::Cons_sp mates = translate::from_object<core::Cons_O>::convert(env->lookup(ChemPkg,"mates"));
plug.cc:375:	this->_Mates.clear();
plug.cc:376:	this->_Mates.fillFromCons(mates);
plug.cc:386:	this->_B0 = p._B0;
plug.cc:387:	this->_B1 = p._B1;
plug.cc:388:	this->_Mates.clear();
plug.cc:394:	    this->_Mates.push_back(rn);
plug.cc:396:	LOG(BF("Copy constructed %s") % this->description().c_str()  );
plug.cc:402:	ss << this->Base::descriptionOfContents() << " ";
plug.cc:404:	ss << "#" << this->_Mates.size() << " ";
plug.cc:406:	for ( vi=this->_Mates.begin(); vi!=this->_Mates.end(); vi++ )
plug.cc:408:	    ss << (*vi)->description() << ", ";
plug.cc:418:	ss << "( " << this->className() << " '"<< this->getName()->__repr__() << " :mates ";
plug.cc:420:	for ( Mates::const_iterator it=this->_Mates.begin(); it!=this->_Mates.end(); it++ )
plug.cc:422:	    ss << (*it)->__repr__() << " ";
plug.cc:430:	this->Base::archiveBase(node);
plug.cc:431:	node->attributeIfNotDefault<string>("b0",this->_B0,"");
plug.cc:432:	node->attributeIfNotDefault<string>("b1",this->_B1,"");
plug.cc:433:	node->archiveVector0("mates",this->_Mates);
plug.cc:442:	for ( mi=this->_Mates.begin(); mi!=this->_Mates.end(); mi++ ) {
plug.cc:443:	    if ( (*mi)->recognizesNameOrPdb(name) ) return true;
plug.cc:450:	this->Base::initialize();
plug.cc:475:    me->_StubPivotAtom = stubPivotAtom;
plug.cc:483:	this->Base::__init__(exec,args,env,lisp);
plug.cc:484:	this->_StubPivotAtom = translate::from_object<string>::convert(env->lookup(ChemPkg,"stubPivotAtom"));
plug.cc:495:	LOG(BF("Copy constructed %s") % this->description().c_str()  );
plug.cc:503:	ss << this->Base::descriptionOfContents() << " ";
plug.cc:512:	this->Base::archiveBase(node);
plug.cc:513:	node->attribute("stubPivotAtom",this->_StubPivotAtom);
plug.cc:521:	this->Base::initialize();
plug.cc:545:	return this->Base::descriptionOfContents();
plug.cc:577:	this->Base::initialize();
plug.cc:578:	this->_JumpAtomName = "";
plug.cc:598:    me->_JumpAtomName = jumpAtomName;
plug.cc:606:	this->Base::__init__(exec,args,env,lisp);
plug.cc:607:	this->_JumpAtomName = translate::from_object<string>::convert(env->lookup(ChemPkg,"jumpAtomName"));
plug.cc:617:	this->_JumpAtomName = p._JumpAtomName;
plug.cc:626:	ss << this->Base::descriptionOfContents() << " ";
plug.cc:627:	ss << "JumpAtomName[" << this->_JumpAtomName << "]";
plug.cc:635:	this->Base::archiveBase(node);
plug.cc:636:	node->attribute("jumpAtom",this->_JumpAtomName);
plug.cc:655:	this->Base::initialize();
plug.cc:682:    me->_RingClosingMates.fillFromCons(ringClosingMates);
plug.cc:690:	this->Base::__init__(exec,args,env,lisp);
plug.cc:691:	core::Cons_sp mates = translate::from_object<core::Cons_sp>::convert(env->lookup(ChemPkg,"ringClosingMates"));
plug.cc:692:	this->_RingClosingMates.fillFromCons(mates);
plug.cc:707:	    this->_RingClosingMates.push_back(rn);
plug.cc:709:	LOG(BF("Copy constructed %s") % this->description().c_str()  );
plug.cc:717:	ss << this->Base::descriptionOfContents() << " ";
plug.cc:719:	ss << "#" << this->_RingClosingMates.size() << " ";
plug.cc:721:	for ( vi=this->_RingClosingMates.begin(); vi!=this->_RingClosingMates.end(); vi++ ) {
plug.cc:722:	    ss << (*vi)->description() << ", ";
plug.cc:732:	this->Base::archiveBase(node);
plug.cc:733:	node->archiveVector0("ringCLosingMates",this->_RingClosingMates);
plug.cc:787:	ss << "( " << this->className();
plug.cc:788:	if (this->isNil()) ss << " -nil-";
plug.cc:791:	    if ( this->getName().notnilp() )
plug.cc:793:		ss << " :name " << this->getName()->__repr__();
plug.cc:796:	if ( this->_EntityNames.use_count() != 0 )
plug.cc:798:	    ss << " :contents " << this->_EntityNames->asString();
plug.cc:801:	    ss << " :contents -UNDEFINED-";
plug.cc:929:	return this->_RingClosingMates.asCons(_lisp);
plug.cc:936:	for ( it=this->_RingClosingMates.begin(); it!=this->_RingClosingMates.end(); it++ )
plug.cc:938:	    if ( (*it)->recognizesMonomerName(mateName)) return true;
properTorsion.cc:12:// ----------------------------------------------------------------------
properTorsion.cc:21:	obj->setup(a1,a2,a3,a4);
properTorsion.cc:28:	this->_a1 = a1;
properTorsion.cc:29:	this->_a2 = a2;
properTorsion.cc:30:	this->_a3 = a3;
properTorsion.cc:31:	this->_a4 = a4;
properTorsion.cc:55:        this->Base::archiveBase(node);
properTorsion.cc:63:        this->Base::initialize();
properTorsion.cc:71:	ss << this->className() << "["<<this->_a1->getName()<<"-"<<this->_a2->getName()<<"-"<<this->_a3->getName()<<"-"<<this->_a4->getName()<<"]";
randomGenerators.cc:21://    this->_Generator = new boost::mt19937();
randomGenerators.cc:22:    this->_Distribution = new boost::normal_distribution<> (mean,stdev);
randomGenerators.cc:23:    this->_VariateGenerator = new boost::variate_generator<boost::mt19937&,
randomGenerators.cc:24:	boost::normal_distribution<> > (_OnlyGenerator,*(this->_Distribution));
randomGenerators.cc:25://    this->_VariateGenerator = new boost::variate_generator<boost::mt19937&,boost::normal_distribution<> > (*(this->_Generator),*(this->_Distribution));
randomGenerators.cc:34:    delete this->_VariateGenerator;
randomGenerators.cc:35:    delete this->_Distribution;
randomGenerators.cc:36://    delete this->_Generator;
randomGenerators.cc:42:    return (*(this->_VariateGenerator))();
readAmberParameters.cc:22:    this->Base::initialize();
readAmberParameters.cc:23:    this->_Types = FFTypesDb_O::_nil;
readAmberParameters.cc:24:    this->_ForceField = ForceField_O::_nil;
readAmberParameters.cc:30:    this->_Types = this->parseTypeRules(fileName);
readAmberParameters.cc:36:    this->_ForceField = this->parseAmberFormattedForceField(fileName);
readAmberParameters.cc:43:    if ( this->_ForceField.notnilp() )
readAmberParameters.cc:45:	this->_ForceField->setFFTypeDb(this->_Types);
readAmberParameters.cc:47:    if ( this->_ForceField->isNil() )
readAmberParameters.cc:50:	this->_ForceField = temp;
readAmberParameters.cc:52:    this->_ForceField->setFFTypeDb(this->_Types);
readAmberParameters.cc:53:    return this->_ForceField;
readAmberParameters.cc:74:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:81:            wildCardElementDictionary->addWildName(wildName);
readAmberParameters.cc:84:                wildCardElementDictionary->addWildNameMap(wildName,*it);
readAmberParameters.cc:98:	typeRule->compileAntechamber(ei->second,wildCardElementDictionary);
readAmberParameters.cc:99:        if ( typeRule->compileSucceeded() )
readAmberParameters.cc:101:            ffTypesDb->add(typeRule);
readAmberParameters.cc:104:	    SIMPLE_ERROR(BF("Antechamber compile failed on: "+ei->second+"\n"+typeRule->compilerMessage() ));
readAmberParameters.cc:121:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:133:            ffNonbond->setType(typeName);
readAmberParameters.cc:134:            ffNonbond->setMass(mass);
readAmberParameters.cc:135:            ffNonbond->setPolarizability(polarizability);
readAmberParameters.cc:136:            ffNonbondDb->add(ffNonbond);
readAmberParameters.cc:139:    fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:151:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:159:            vector<string>typeParts = core::split(types,"-");
readAmberParameters.cc:163:            ffStretch->_Type1 = type1Name;
readAmberParameters.cc:164:            ffStretch->_Type2 = type2Name;
readAmberParameters.cc:169:	    ffStretch->setKb_kJPerNanometerSquared(kb_kJPerNanometerSquared);
readAmberParameters.cc:170:	    ffStretch->setR0_Nanometer(r0_Nanometer);
readAmberParameters.cc:171://            print "(%s)-(%s) k=%lf len=%lf"%(ffStretch._Type1,ffStretch._Type2,ffStretch._kb, ffStretch._r0)
readAmberParameters.cc:172:            ffStretchDb->add(ffStretch);
readAmberParameters.cc:189:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:198:            vector<string>typeParts = core::split(types,"-");
readAmberParameters.cc:203:            ffAngle->_Type1 = t1;
readAmberParameters.cc:204:            ffAngle->_Type2 = t2;
readAmberParameters.cc:205:            ffAngle->_Type3 = t3;
readAmberParameters.cc:208:            ffAngle->_K2__kJPerRadianSquared = kCalPerRadianSquared_to_kJPerRadianSquared(atof(parmsParts[0].c_str()));
readAmberParameters.cc:209:            ffAngle->_AngRad = core::radians(atof(parmsParts[1].c_str()));
readAmberParameters.cc:210://            print "(%s)-(%s)-(%s) k=%lf ang(deg)=%lf"%(ffAngle._Type1,ffAngle._Type2, ffAngle._Type3,ffAngle._K2, ffAngle._AngRad/0.0174533)
readAmberParameters.cc:211:            ffAngleDb->add(ffAngle);
readAmberParameters.cc:229:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:238:            vector<string>typeParts = core::split(types,"-");
readAmberParameters.cc:246:            ffPtor->setTypes(t1,t2,t3,t4);
readAmberParameters.cc:254:            ffPtor->setV_kCal(pn,pk/idivf);
readAmberParameters.cc:255:            ffPtor->setPhaseRad(pn,phaseRad);
readAmberParameters.cc:256:            ffPtorDb->add(ffPtor);
readAmberParameters.cc:276:	fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:285:            vector<string>typeParts = core::split(types,"-");
readAmberParameters.cc:294:            ffItor->setTypes(t1,t2,t3,t4);
readAmberParameters.cc:302:            ffItor->setV_kCal(pn,pk);
readAmberParameters.cc:303:            ffItor->setPhaseRad(pn,phaseRad);
readAmberParameters.cc:304:            ffItorDb->add(ffItor);
readAmberParameters.cc:319:    fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:330:        fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:340:	    if ( ffNonbondDb->hasType(type) )
readAmberParameters.cc:342:		ffNonbond = ffNonbondDb->findType(type);
readAmberParameters.cc:353:            ffNonbond->setRadius_Angstroms(radius);
readAmberParameters.cc:354:	    ffNonbond->setEpsilon_kCal(edep);
readAmberParameters.cc:374:    fin.getline(buffer,sizeof(buffer)-1);
readAmberParameters.cc:376:    FFNonbondDb_sp ffNonbondsDb = this->parseFirstNonbondDb(fin);
readAmberParameters.cc:377:    FFStretchDb_sp ffStretchesDb = this->parseStretchDb(fin);
readAmberParameters.cc:378:    FFAngleDb_sp ffAnglesDb = this->parseAngleDb(fin);
readAmberParameters.cc:379:    FFPtorDb_sp ffPtorsDb = this->parsePtorDb(fin);
readAmberParameters.cc:380:    FFItorDb_sp ffItorsDb = this->parseItorDb(fin);
readAmberParameters.cc:381:    fin.getline(buffer,sizeof(buffer)-1); // skp 10-12 hbond
readAmberParameters.cc:382:    fin.getline(buffer,sizeof(buffer)-1); // blank
readAmberParameters.cc:383:    fin.getline(buffer,sizeof(buffer)-1); // skip equivalence
readAmberParameters.cc:384:    fin.getline(buffer,sizeof(buffer)-1); // blank
readAmberParameters.cc:385:    this->parseNonbondDb(fin,ffNonbondsDb);
readAmberParameters.cc:388:    ff->setTitle(title);
readAmberParameters.cc:389:    ff->setFFStretchDb(ffStretchesDb);
readAmberParameters.cc:390:    ff->setFFTypeDb(FFTypesDb_O::_nil);
readAmberParameters.cc:391:    ff->setFFAngleDb(ffAnglesDb);
readAmberParameters.cc:392:    ff->setFFPtorDb(ffPtorsDb);
readAmberParameters.cc:393:    ff->setFFItorDb(ffItorsDb);
readAmberParameters.cc:394:    ff->setFFNonbondDb(ffNonbondsDb);
readAmberParameters.cc:398:    ff->_Angles->addZConstant("H", 0.784);
readAmberParameters.cc:399:    ff->_Angles->addZConstant("C", 1.183);
readAmberParameters.cc:400:    ff->_Angles->addZConstant("N", 1.212);
readAmberParameters.cc:401:    ff->_Angles->addZConstant("O", 1.219);
readAmberParameters.cc:402:    ff->_Angles->addZConstant("F", 1.166);
readAmberParameters.cc:403:    ff->_Angles->addZConstant("Cl", 1.272);
readAmberParameters.cc:404:    ff->_Angles->addZConstant("Br", 1.378);
readAmberParameters.cc:405:    ff->_Angles->addZConstant("I", 1.398);
readAmberParameters.cc:406:    ff->_Angles->addZConstant("P", 1.620);
readAmberParameters.cc:407:    ff->_Angles->addZConstant("S", 1.280);
readAmberParameters.cc:408:    ff->_Angles->addCConstant("C", 1.339);
readAmberParameters.cc:409:    ff->_Angles->addCConstant("N", 1.300);
readAmberParameters.cc:410:    ff->_Angles->addCConstant("O", 1.249);
readAmberParameters.cc:411:    ff->_Angles->addCConstant("P", 0.906);
readAmberParameters.cc:412:    ff->_Angles->addCConstant("S", 1.448);
readAmberParameters.cc:417:    ff->_Stretches->addEstimateStretch( "H", "H", 0.738, 4.661 );
readAmberParameters.cc:418:    ff->_Stretches->addEstimateStretch( "C", "C", 1.526, 7.643 );
readAmberParameters.cc:419:    ff->_Stretches->addEstimateStretch( "N", "N", 1.441, 7.634 );
readAmberParameters.cc:420:    ff->_Stretches->addEstimateStretch( "O", "O", 1.460, 7.561 );
readAmberParameters.cc:421:    ff->_Stretches->addEstimateStretch( "F", "F", 1.406, 7.358 );
readAmberParameters.cc:422:    ff->_Stretches->addEstimateStretch( "Cl", "Cl", 2.031, 8.648 );
readAmberParameters.cc:423:    ff->_Stretches->addEstimateStretch( "Br", "Br", 2.337, 9.012 );
readAmberParameters.cc:424:    ff->_Stretches->addEstimateStretch( "I", "I", 2.836, 9.511 );
readAmberParameters.cc:425:    ff->_Stretches->addEstimateStretch( "P", "P", 2.324, 8.805 );
readAmberParameters.cc:426:    ff->_Stretches->addEstimateStretch( "S", "S", 2.038, 8.316 );
readAmberParameters.cc:427:    ff->_Stretches->addEstimateStretch( "H", "C", 1.090, 6.217 );
readAmberParameters.cc:428:    ff->_Stretches->addEstimateStretch( "H", "N", 1.010, 6.057 );
readAmberParameters.cc:429:    ff->_Stretches->addEstimateStretch( "H", "O", 0.960, 5.794 );
readAmberParameters.cc:430:    ff->_Stretches->addEstimateStretch( "H", "F", 0.920, 5.600 );
readAmberParameters.cc:431:    ff->_Stretches->addEstimateStretch( "H", "Cl", 1.280, 6.937 );
readAmberParameters.cc:432:    ff->_Stretches->addEstimateStretch( "H", "Br", 1.410, 7.301 );
readAmberParameters.cc:433:    ff->_Stretches->addEstimateStretch( "H", "I", 1.600, 7.802 );
readAmberParameters.cc:434:    ff->_Stretches->addEstimateStretch( "H", "P", 1.410, 7.257 );
readAmberParameters.cc:435:    ff->_Stretches->addEstimateStretch( "H", "S", 1.340, 7.018 );
readAmberParameters.cc:436:    ff->_Stretches->addEstimateStretch( "C", "N", 1.470, 7.504 );
readAmberParameters.cc:437:    ff->_Stretches->addEstimateStretch( "C", "O", 1.440, 7.347 );
readAmberParameters.cc:438:    ff->_Stretches->addEstimateStretch( "C", "F", 1.370, 7.227 );
readAmberParameters.cc:439:    ff->_Stretches->addEstimateStretch( "C", "Cl", 1.800, 8.241 );
readAmberParameters.cc:440:    ff->_Stretches->addEstimateStretch( "C", "Br", 1.940, 8.478 );
readAmberParameters.cc:441:    ff->_Stretches->addEstimateStretch( "C", "I", 2.160, 8.859 );
readAmberParameters.cc:442:    ff->_Stretches->addEstimateStretch( "C", "P", 1.830, 8.237 );
readAmberParameters.cc:443:    ff->_Stretches->addEstimateStretch( "C", "S", 1.820, 8.117 );
readAmberParameters.cc:444:    ff->_Stretches->addEstimateStretch( "N", "O", 1.420, 7.526 );
readAmberParameters.cc:445:    ff->_Stretches->addEstimateStretch( "N", "F", 1.420, 7.475 );
readAmberParameters.cc:446:    ff->_Stretches->addEstimateStretch( "N", "Cl", 1.750, 8.266 );
readAmberParameters.cc:447:    ff->_Stretches->addEstimateStretch( "N", "Br", 1.930, 8.593 );
readAmberParameters.cc:448:    ff->_Stretches->addEstimateStretch( "N", "I", 2.120, 8.963 );
readAmberParameters.cc:449:    ff->_Stretches->addEstimateStretch( "N", "P", 1.720, 8.212 );
readAmberParameters.cc:450:    ff->_Stretches->addEstimateStretch( "N", "S", 1.690, 8.073 );
readAmberParameters.cc:451:    ff->_Stretches->addEstimateStretch( "O", "F", 1.410, 7.375 );
readAmberParameters.cc:452:    ff->_Stretches->addEstimateStretch( "O", "Cl", 1.700, 8.097 );
readAmberParameters.cc:453:    ff->_Stretches->addEstimateStretch( "O", "Br", 1.790, 8.276 );
readAmberParameters.cc:454:    ff->_Stretches->addEstimateStretch( "O", "I", 2.110, 8.854 );
readAmberParameters.cc:455:    ff->_Stretches->addEstimateStretch( "O", "P", 1.640, 7.957 );
readAmberParameters.cc:456:    ff->_Stretches->addEstimateStretch( "O", "S", 1.650, 7.922 );
readAmberParameters.cc:457:    ff->_Stretches->addEstimateStretch( "F", "Cl", 1.648, 7.947 );
readAmberParameters.cc:458:    ff->_Stretches->addEstimateStretch( "Cl", "I", 2.550, 9.309 );
readAmberParameters.cc:459:    ff->_Stretches->addEstimateStretch( "Br", "I", 2.671, 9.380 );
readAmberParameters.cc:460:    ff->_Stretches->addEstimateStretch( "F", "P", 1.500, 7.592 );
readAmberParameters.cc:461:    ff->_Stretches->addEstimateStretch( "F", "S", 1.580, 7.733 );
readAmberParameters.cc:462:    ff->_Stretches->addEstimateStretch( "Cl", "P", 2.040, 8.656 );
readAmberParameters.cc:463:    ff->_Stretches->addEstimateStretch( "Cl", "S", 2.030, 8.619 );
readAmberParameters.cc:464:    ff->_Stretches->addEstimateStretch( "Br", "P", 2.240, 8.729 );
readAmberParameters.cc:465:    ff->_Stretches->addEstimateStretch( "Br", "S", 2.210, 8.728 );
readAmberParameters.cc:466:    ff->_Stretches->addEstimateStretch( "I", "P", 2.490, 9.058 );
readAmberParameters.cc:467:    ff->_Stretches->addEstimateStretch( "I", "S", 2.560, 9.161 );
readAmberParameters.cc:468:    ff->_Stretches->addEstimateStretch( "P", "S", 2.120, 8.465 );
representedEntityNameSet.cc:23:	this->Base::initialize();
representedEntityNameSet.cc:24:	this->_Representative = _Nil<core::Symbol_O>();
representedEntityNameSet.cc:25:	LOG(BF("Creating %s") % this->description()  );
representedEntityNameSet.cc:34://    this->_IsConstitutionGroup = ss._IsConstitutionGroup;
representedEntityNameSet.cc:35:	this->_Representative = ss._Representative;
representedEntityNameSet.cc:42:	ss << "( " << this->className() ;
representedEntityNameSet.cc:43:	ss << " :name " << this->_Name->__repr__();
representedEntityNameSet.cc:44:	ss << " :representative " <<this->_Representative->__repr__();
representedEntityNameSet.cc:45:	ss << " :entityNames " << this->_EntityNames->__repr__() << " )";
representedEntityNameSet.cc:54:	newCopy = RP_Copy<RepresentedEntityNameSet_O>(this->const_sharedThis<RepresentedEntityNameSet_O>());
representedEntityNameSet.cc:60:	return this->_Representative;
representedEntityNameSet.cc:65:	this->_Representative = cc;
representedEntityNameSet.cc:70:	return this->_Representative.notnilp();
representedEntityNameSet.cc:78:	newGroup = RP_Copy<RepresentedEntityNameSet_O>(this->sharedThis<RepresentedEntityNameSet_O>());
representedEntityNameSet.cc:79:	newGroup->_ContainedNames = core::StringSet_O::create();
representedEntityNameSet.cc:80:	newGroup->_ContainedNames->insert(this->_Name);
representedEntityNameSet.cc:90:	this->Base::archiveBase(node);
representedEntityNameSet.cc:91:	node->attributeSymbolIfNotNil("representative", this->_Representative);
representedEntityNameSet.cc:104:	if ( this->_Representative->isNil() )
representedEntityNameSet.cc:106:	    LOG(BF("this->_Representative->isNil -- expanding my EntryNames"));
representedEntityNameSet.cc:107:	    return this->Base::expandedRepresentativeList();
representedEntityNameSet.cc:109:	ASSERTP(bdb->recognizesEntityName(this->_Representative),
representedEntityNameSet.cc:110:		"candoDatabase does not recognize entity name("+this->_Representative->__repr__()+")");
representedEntityNameSet.cc:111:	obj = bdb->getEntity(this->_Representative);
representedEntityNameSet.cc:112:	ASSERTF(obj->isTerminalName(),
representedEntityNameSet.cc:113:		BF("Representatives must always be terminal names, this representative(%s) is NOT")% obj->getName() );
representedEntityNameSet.cc:114:	objList = _lisp->create<RepresentativeList_O>();
representedEntityNameSet.cc:116:	expanded->expandToTerminalEntityNames();
representedEntityNameSet.cc:117:	LOG(BF("I have a representative[%s] so I'm created a RepresentedEntityNameSet: %s") % expanded->__repr__() );
representedEntityNameSet.cc:118:	objList->append(expanded);
representedEntityNameSet.cc:130:    me->_Representative = representativeName;
representedEntityNameSet.cc:138:	this->Base::__init__(exec,args,env,lisp);
representedEntityNameSet.cc:139:	this->_Representative = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"representativeName"));
residue.cc:41:    this->_Constitution = CandoDatabaseReference_O::_nil;
residue.cc:48://    return this->ownerWithClass<Constitution_O>().notnilp();
residue.cc:56:   CandoDatabase_sp bdb = cc->getCandoDatabase();
residue.cc:57:   this->_Constitution = CandoDatabaseReference_O::create(_lisp,bdb,"Constitution="+cc->getName());
residue.cc:64:    if ( this->eq(obj) ) return true;
residue.cc:65:    if ( !obj->isOfClass<Residue_O>() ) return false;
residue.cc:66:    Residue_sp other = obj->as<Residue_O>();
residue.cc:67:    if ( other->getName() != this->getName() ) return false;
residue.cc:68:    if ( other->_contents.size() != this->_contents.size() ) return false;
residue.cc:70:    for ( tit=this->_contents.begin(), oit=other->_contents.begin();
residue.cc:71:	    tit!=this->_contents.end(); tit++, oit++ )
residue.cc:73:	if ( ! (*tit)->equal(*oit) ) return false;
residue.cc:81:    if ( !obj->isOfClass<Residue_O>() ) 
residue.cc:85:    Residue_sp other = obj->as<Residue_O>();
residue.cc:86:    if ( other->_contents.size() != this->_contents.size() )
residue.cc:91:    for ( tit=this->_contents.begin(), oit=other->_contents.begin();
residue.cc:92:	    tit!=this->_contents.end(); tit++, oit++ )
residue.cc:94:	(*tit)->transferCoordinates(*oit);
residue.cc:104:    // Constitution_sp c = this->ownerWithClass<Constitution_O>();
residue.cc:106:    if ( c->isNil() ) 
residue.cc:120:    this->addMatter(a);
residue.cc:121:    LOG(BF("Added %s to %s") % a->description().c_str() % this->description().c_str() );
residue.cc:127:    if ( this->_MonomerAliases->isNil() ) return false;
residue.cc:128:    return this->_MonomerAliases->contains(s);
residue.cc:133:    this->_MonomerAliases = s;
residue.cc:138:    if (this->_MonomerAliases->isNil() )
residue.cc:140:	this->_MonomerAliases = core::SymbolSet_O::create();
residue.cc:142:    this->_MonomerAliases->insert(s);
residue.cc:149:    ASSERTNOTNULL(this->_MonomerAliases);
residue.cc:150:    return this->_MonomerAliases;
residue.cc:156:    LOG(BF("Residue_O::addVirtualAtom adding virtual atom with name(%s) in residue(%s)") % name.c_str() % this->getName().c_str()  );
residue.cc:157:    if ( this->hasAtomWithName(name) )
residue.cc:160:	ss << "The " << this->description() << " already has the virtual atom: " << name;
residue.cc:164:    va->setElement(element_Dummy);
residue.cc:165:    this->addMatter(va);
residue.cc:166:    va->calculatePosition();
residue.cc:172://    this->getConstitution();
residue.cc:173:    this->Matter_O::archiveBase(node);
residue.cc:174://    this->getConstitution();
residue.cc:176:    node->attribute("pdb",this->pdbName);
residue.cc:177:    node->attributeIfNotDefault<string>("uniqueLabel",this->_UniqueLabel,"");
residue.cc:178:    node->attributeIfNotDefault("NetCharge",this->_NetCharge,0);
residue.cc:179:    node->attributeIfNotDefault("fileSeqNum",this->_FileSequenceNumber,UndefinedUnsignedInt);
residue.cc:180://    node->archiveObjectIfDefined("constitution", this->_Constitution );
residue.cc:181:    node->archiveObjectIfDefined("monomerAliases",this->_MonomerAliases);
residue.cc:183:    if ( node->saving() ) {
residue.cc:185:        _BLOCK_TRACE("Xmling intra-residue bonds");
residue.cc:191:	    for ( aPPCur=this->getContents().begin();
residue.cc:192:			aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:195:		a->addUniqueIntraResidueBondCopiesToBondList(bondList);
residue.cc:201:	node->archiveObject<BondList_O>("bl",bondList);
residue.cc:208:	node->archiveObject<BondList_O>("bl",bondList);
residue.cc:210:	bondList->imposeYourself();
residue.cc:221://    this->getConstitution();
residue.cc:222:    this->Base::serialize(node);
residue.cc:223://    this->getConstitution();
residue.cc:225:    node->attribute("pdb",this->pdbName);
residue.cc:226:    node->attributeIfNotDefault<string>("uniqueLabel",this->_UniqueLabel,"");
residue.cc:227:    node->attributeIfNotDefault("NetCharge",this->_NetCharge,0);
residue.cc:228:    node->attributeIfNotDefault("fileSeqNum",this->_FileSequenceNumber,UndefinedUnsignedInt);
residue.cc:229://    node->archiveObjectIfDefined("constitution", this->_Constitution );
residue.cc:230:    node->archiveObjectIfDefined("monomerAliases",this->_MonomerAliases);
residue.cc:232:    if ( node->saving() ) {
residue.cc:234:        _BLOCK_TRACE("Xmling intra-residue bonds");
residue.cc:240:	    for ( aPPCur=this->getContents().begin();
residue.cc:241:			aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:244:		a->addUniqueIntraResidueBondCopiesToBondList(bondList);
residue.cc:250:	node->archiveObject<BondList_O>("bl",bondList);
residue.cc:257:	node->archiveObject<BondList_O>("bl",bondList);
residue.cc:259:	bondList->imposeYourself();
residue.cc:276:    ss << this->className();
residue.cc:282:    this->Base::initialize();
residue.cc:283://    this->_Constitution = CandoDatabaseReference_O::_nil;
residue.cc:284:    this->_FileSequenceNumber = -1;
residue.cc:285:    this->_NetCharge = 0;
residue.cc:286:    this->_MonomerAliases = core::SymbolSet_O::_nil;
residue.cc:287:    this->_UniqueLabel = "";
residue.cc:297:    this->_Selected = res._Selected;
residue.cc:298:    this->tempInt = res.tempInt;
residue.cc:299:    this->pdbName = res.pdbName;
residue.cc:301://    this->_Constitution = res._Constitution;
residue.cc:302:    this->_FileSequenceNumber = res._FileSequenceNumber;
residue.cc:303:    this->_MonomerAliases = res._MonomerAliases;
residue.cc:304:    this->_UniqueLabel = res._UniqueLabel;
residue.cc:333://    rPNew->duplicateFrom(this); //    *rPNew = *this;
residue.cc:334:    rPNew->eraseContents();
residue.cc:335:    for ( a=this->getContents().begin(); a!=this->getContents().end(); a++ ) 
residue.cc:337:	aorig = (*a)->as<Atom_O>();
residue.cc:338:	acopy = aorig->copy()->as<Atom_O>();
residue.cc:339:	LOG(BF("Copying atom(%s) with %d bonds") % aorig->getName().c_str() % aorig->numberOfBonds()  );
residue.cc:340:	rPNew->addMatter((Matter_sp)(acopy));
residue.cc:341:	acopy->setId(aorig->getId());
residue.cc:342:	LOG(BF("Completed copy for new %s") % acopy->description().c_str()  );
residue.cc:344:    rPNew->copyRestraintsDontRedirectAtoms(this);
residue.cc:345:    LOG(BF("Just created copy residue %s use_count=%d") % rPNew->description().c_str() % rPNew.use_count()  );
residue.cc:352:    for ( contentIterator a=this->begin_contents(); a!=this->end_contents(); a++ )
residue.cc:354:	Atom_sp at = (*a)->as<Atom_O>();
residue.cc:356:	    % at->description() % at->numberOfBonds() );
residue.cc:357:	at->redirectAtoms();
residue.cc:359:    this->redirectRestraintAtoms();
residue.cc:366:    Residue_sp newRes = this->copyDontRedirectAtoms()->as<Residue_O>();
residue.cc:367:    LOG(BF("Just copied residue %s use_count=%d") % newRes->description() % newRes.use_count()  );
residue.cc:368:    newRes->redirectAtoms();
residue.cc:376:    for ( ; c.notnilp(); c = c->cdr() )
residue.cc:378:	string atomName = c->car<core::Str_O>()->get();
residue.cc:379:	Atom_sp a = this->atomWithName(atomName);
residue.cc:380:	this->removeAtomDeleteBonds(a);
residue.cc:394:    for ( atom=this->getContents().begin();
residue.cc:395:		atom != this->getContents().end(); atom++ ) {
residue.cc:398:	    this->eraseContent(atom);
residue.cc:399:	    aTemp->removeAllBonds();
residue.cc:401:    	    aTemp->setContainedByNothing();
residue.cc:413:    Residue_sp res = a->getResidueContainedBy();
residue.cc:430:    for ( atom=this->getContents().begin();
residue.cc:431:		atom != this->getContents().end(); atom++ ) {
residue.cc:433:	LOG(BF("Looking for atom name: %s in residue with name: %s") % a->getName().c_str() % aTemp->getName().c_str()  );
residue.cc:436:	    this->eraseContent(atom);
residue.cc:438:    	    aTemp->setContainedByNothing();
residue.cc:457:    for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
residue.cc:459:	atoms.push_back((*aCur)->as<Atom_O>());
residue.cc:463:	(*it)->fillInImplicitHydrogensOnCarbon();
residue.cc:473:    for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ ) 
residue.cc:475:	Atom_sp atom = (*aCur)->as<Atom_O>();
residue.cc:476:	if ( uniqueNames.count(atom->getName()) == 0 )
residue.cc:478:	    uniqueNames.insert(atom->getName());
residue.cc:481:	    problems->writeln("Atom with name(" +atom->getName() + ") is not unique");
residue.cc:492: * Make all the atom names unique by suffixing the non-unique ones with
residue.cc:500:    for ( ai=this->getContents().begin();
residue.cc:501:		ai != this->getContents().end(); ai++ ) {
residue.cc:502:	Atom_sp atom = (*ai)->as<Atom_O>();
residue.cc:503:	LOG(BF("Looking at atom name(%s)") % atom->getName().c_str()  );
residue.cc:504:	allNames.insert(atom->getName());
residue.cc:505:	allNamesAccumulate.insert(atom->getName());
residue.cc:506:	atomsThatShareName.insert(pair<string,Atom_sp>(atom->getName(),atom));
residue.cc:520:		newName << mi->second->getName();
residue.cc:527:		    mi->second->setName(newName.str());
residue.cc:544:    ASSERT_eq(aliasAtoms->length(),atomAliases->length());
residue.cc:547:	core::Str_sp aliasAtom = aliasAtoms->car<core::Str_O>();
residue.cc:548:	core::Symbol_sp atomAlias = atomAliases->car<core::Symbol_O>();
residue.cc:549:	Atom_sp a = this->atomWithName(aliasAtom->get());
residue.cc:550:	a->setAlias(atomAlias);
residue.cc:551:	aliasAtoms = aliasAtoms->cdr();
residue.cc:552:	atomAliases = atomAliases->cdr();
residue.cc:567:    for ( atom=this->getContents().begin();
residue.cc:568:		atom != this->getContents().end(); atom++ ) {
residue.cc:570:	unique->insert(aTemp->getName());
residue.cc:585:    for ( atom=this->getContents().begin();
residue.cc:586:		atom != this->getContents().end(); atom++ ) {
residue.cc:588:	unique.insert(aTemp->getName());
residue.cc:603:    for ( atom=this->getContents().begin();
residue.cc:604:		atom != this->getContents().end(); atom++ ) {
residue.cc:622:    for ( aPPCur=this->getContents().begin();
residue.cc:623:		aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:625:	a->addUniqueIntraResidueBondsToVectorBonds(bonds);
residue.cc:641:    for ( aPPCur=this->getContents().begin();
residue.cc:642:		aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:644:	a->addInterResidueBondsToVectorBonds(bonds);
residue.cc:653:    for ( aCur=this->_contents.begin();aCur!=this->_contents.end(); aCur++ )
residue.cc:655:	Atom_sp a = (*aCur)->as<Atom_O>();
residue.cc:656:	LOG(BF("Looking at(%s) for alias(%s)") % (*aCur)->getName().c_str() % alias->__repr__()  );
residue.cc:657:        if ( a->getAlias() == alias)
residue.cc:667:    Atom_sp a = this->atomWithAliasOrNil(alias);
residue.cc:669:    LOG(BF("Matter(%s) with %d contents does not contain content with alias(%s)") % this->name.c_str() % this->_contents.size() % alias->__repr__()  );
residue.cc:671:    ss << "residue (" << this->name << ") does not contain atom with alias(" << alias->__repr__() << ")";
residue.cc:672:    THROW(_lisp->create<core::ContentException_O>(ss.str()));
residue.cc:680:    for ( aPPCur=this->getContents().begin();
residue.cc:681:		aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:683:	if ( a->invalid() ) return true;
residue.cc:690:    Atom_sp a = this->atomWithName(name);
residue.cc:691:    return a->getPosition();
residue.cc:695:    if ( this->invalid() ) {
residue.cc:696:	SIMPLE_ERROR(boost::format("INVALID %s")% this->description());
residue.cc:706:    for ( aPPCur=this->getContents().begin();
residue.cc:707:		aPPCur != this->getContents().end(); aPPCur++ ) {
residue.cc:709:	a->setAnchorPos(a->getPosition());
residue.cc:710:	a->setAnchorRestraintOn();
residue.cc:719:    return this->_contents.size();
residue.cc:725:	AtomIdToAtomMap_sp atomIdMap = _lisp->create<AtomIdToAtomMap_O>();
residue.cc:726:	atomIdMap->resize(1);
residue.cc:728:	atomIdMap->resize(mid,1);
residue.cc:730:	int numAtoms = this->_contents[mid]->_contents[rid]->_contents.size();
residue.cc:731:	atomIdMap->resize(mid,rid,numAtoms);
residue.cc:735:	    atomIdMap->set(atomId,this->_contents[mid]->_contents[rid]->_contents[aid]->as<Atom_O>());
residue.cc:744:	int aid = atomId->atomId();
residue.cc:745:	if ( aid >=0 && aid <=(int)this->_contents.size() )
residue.cc:747:	    Atom_sp atom = this->_contents[aid]->as<Atom_O>();
residue.cc:750:	SIMPLE_ERROR(BF("Illegal atomId[%d] must be less than %d") % aid % this->_contents.size() );
restraint.cc:87:    this->_A = old._A;
restraint.cc:88:    this->_AnchorPos = old._AnchorPos;
restraint.cc:95:    rest->_A = this->getAtom();
restraint.cc:101:    this->_A = this->getAtom()->getCopyAtom();
restraint.cc:108:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:109:    node->archivePlainObject<Vector3>("AnchorPos","AnchorPos",this->_AnchorPos);
restraint.cc:110:    node->attribute("weight",this->_Weight);
restraint.cc:118:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:119:    node->namedPOD("AnchorPos",this->_AnchorPos);
restraint.cc:120:    node->attribute("weight",this->_Weight);
restraint.cc:128:    this->_AnchorPos.set(this->_AnchorPos.getX(),this->_AnchorPos.getY(),this->_AnchorPos.getZ()*-1.0);
restraint.cc:137:    this->_A = old._A;
restraint.cc:138:    this->_Chirality = old._Chirality;
restraint.cc:145:    rest->_A = this->getAtomA();
restraint.cc:151:    this->_A = this->getAtomA()->getCopyAtom();
restraint.cc:158:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:159:    node->attribute("Chirality",this->_Chirality);
restraint.cc:167:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:168:    node->attribute("Chirality",this->_Chirality);
restraint.cc:174:    this->_Chirality *= -1.0;
restraint.cc:188:    this->_A = old._A;
restraint.cc:189:    this->_B = old._B;
restraint.cc:190:    this->_Min = old._Min;
restraint.cc:191:    this->_Max = old._Max;
restraint.cc:192:    this->_Weight = old._Weight;
restraint.cc:198:    rest->_A = this->getAtomA();
restraint.cc:199:    rest->_B = this->getAtomB();
restraint.cc:205:    this->_A = this->getAtomA()->getCopyAtom();
restraint.cc:206:    this->_B = this->getAtomB()->getCopyAtom();
restraint.cc:230:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:231:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:232:    node->attribute("Min",this->_Min);
restraint.cc:233:    node->attribute("Max",this->_Max);
restraint.cc:234:    node->attribute("Weight",this->_Weight);
restraint.cc:242:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:243:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:244:    node->attribute("Min",this->_Min);
restraint.cc:245:    node->attribute("Max",this->_Max);
restraint.cc:246:    node->attribute("Weight",this->_Weight);
restraint.cc:252:    this->_A = old._A;
restraint.cc:253:    this->_B = old._B;
restraint.cc:254:    this->_C = old._C;
restraint.cc:255:    this->_MinRad = old._MinRad;
restraint.cc:256:    this->_MaxRad = old._MaxRad;
restraint.cc:257:    this->_Weight = old._Weight;
restraint.cc:263:    rest->_A = this->getAtomA();
restraint.cc:264:    rest->_B = this->getAtomB();
restraint.cc:265:    rest->_C = this->getAtomC();
restraint.cc:272:    this->_A = this->getAtomA()->getCopyAtom();
restraint.cc:273:    this->_B = this->getAtomB()->getCopyAtom();
restraint.cc:274:    this->_C = this->getAtomC()->getCopyAtom();
restraint.cc:280:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:281:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:282:    node->archiveWeakPointer("AtomC",this->_C);
restraint.cc:283:    node->attribute("MinRad",this->_MinRad);
restraint.cc:284:    node->attribute("MaxRad",this->_MaxRad);
restraint.cc:285:    node->attribute("Weight",this->_Weight);
restraint.cc:293:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:294:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:295:    node->archiveWeakPointer("AtomC",this->_C);
restraint.cc:296:    node->attribute("MinRad",this->_MinRad);
restraint.cc:297:    node->attribute("MaxRad",this->_MaxRad);
restraint.cc:298:    node->attribute("Weight",this->_Weight);
restraint.cc:305:    this->_A = old._A;
restraint.cc:306:    this->_B = old._B;
restraint.cc:307:    this->_C = old._C;
restraint.cc:308:    this->_D = old._D;
restraint.cc:309:    this->_MinDegrees = old._MinDegrees;
restraint.cc:310:    this->_MaxDegrees = old._MaxDegrees;
restraint.cc:311:    this->_Weight = old._Weight;
restraint.cc:317:    rest->_A = this->getAtomA();
restraint.cc:318:    rest->_B = this->getAtomB();
restraint.cc:319:    rest->_C = this->getAtomC();
restraint.cc:320:    rest->_D = this->getAtomD();
restraint.cc:326:    this->_A = this->getAtomA()->getCopyAtom();
restraint.cc:327:    this->_B = this->getAtomB()->getCopyAtom();
restraint.cc:328:    this->_C = this->getAtomC()->getCopyAtom();
restraint.cc:329:    this->_D = this->getAtomD()->getCopyAtom();
restraint.cc:335:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:336:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:337:    node->archiveWeakPointer("AtomC",this->_C);
restraint.cc:338:    node->archiveWeakPointer("AtomD",this->_D);
restraint.cc:339:    node->attribute("MinDegrees",this->_MinDegrees);
restraint.cc:340:    node->attribute("MaxDegrees",this->_MaxDegrees);
restraint.cc:341:    node->attribute("Weight",this->_Weight);
restraint.cc:349:    node->archiveWeakPointer("AtomA",this->_A);
restraint.cc:350:    node->archiveWeakPointer("AtomB",this->_B);
restraint.cc:351:    node->archiveWeakPointer("AtomC",this->_C);
restraint.cc:352:    node->archiveWeakPointer("AtomD",this->_D);
restraint.cc:353:    node->attribute("MinDegrees",this->_MinDegrees);
restraint.cc:354:    node->attribute("MaxDegrees",this->_MaxDegrees);
restraint.cc:355:    node->attribute("Weight",this->_Weight);
restraint.cc:361:    this->_MinDegrees = 360.0 - this->_MinDegrees;
restraint.cc:362:    this->_MaxDegrees = 360.0 - this->_MaxDegrees;
restraint.cc:388:    nb->setMatter(matter);
restraint.cc:395:    this->_Matter = Matter_O::_nil;
restraint.cc:401:    node->archiveObject("matter",this->_Matter);
restraint.cc:409:    node->archiveObject("matter",this->_Matter);
restraint.cc:428:    node->archiveVector0("Entries",this->_Restraints);
restraint.cc:436:    node->namedVector0("Entries",this->_Restraints);
restraint.cc:443:    if ( this->isNil() ) return _Nil<RestraintList_O>();
restraint.cc:446:    for ( it=this->_Restraints.begin(); it!=this->_Restraints.end(); it++ )
restraint.cc:448:	newList->_Restraints.push_back((*it)->copyDontRedirectAtoms());
restraint.cc:458:    for ( it=this->_Restraints.begin(); it!=this->_Restraints.end(); it++ )
restraint.cc:460:	(*it)->redirectAtoms();
restraint.cc:470:    for ( ri=rl->_Restraints.begin(); ri!=rl->_Restraints.end(); ri++ ) {
restraint.cc:472:	this->addRestraint(rr);
ringFinder.cc:34:    this->Base::initialize();
ringFinder.cc:35:    this->_beep = core::SimpleBitVector_O::_nil;
ringFinder.cc:36:    this->_firstVertex= AGVertex_O::_nil;
ringFinder.cc:37:    this->_lastVertex = AGVertex_O::_nil;
ringFinder.cc:38:    this->_firstEdge = AGEdge_O::_nil;
ringFinder.cc:44:    this->_graph = orig._graph;
ringFinder.cc:47:    LOG(BF(" beep->isNil() = %d") % orig._beep->isNil()  );
ringFinder.cc:48:    if ( orig._beep->isNil() ) 
ringFinder.cc:50:	this->_beep = core::SimpleBitVector_O::_nil;
ringFinder.cc:51:	LOG(BF("Setting this->_beep to nil") );
ringFinder.cc:54:	LOG(BF("Copying this->_beep") );
ringFinder.cc:55:	this->_beep = orig._beep->deepCopy()->as<core::SimpleBitVector_O>();
ringFinder.cc:58:    this->_firstVertex = orig._firstVertex;
ringFinder.cc:59:    this->_firstEdge = orig._firstEdge;
ringFinder.cc:60:    this->_lastVertex = orig._lastVertex;
ringFinder.cc:67:    pm->_graph = graph;
ringFinder.cc:68:    pm->_beep = core::SimpleBitVector_O::create(graph->getNumberOfEdges(),lisp);
ringFinder.cc:69:    pm->_firstVertex = firstVertex;
ringFinder.cc:70:    pm->_firstEdge = firstEdge;
ringFinder.cc:71:    pm->_lastVertex = lastVertex;
ringFinder.cc:72:    pm->_beep->setBit(firstEdge->getId(),1);
ringFinder.cc:88:    this->_beep->inPlaceOr(other->_beep);
ringFinder.cc:93:    return this->_firstVertex;
ringFinder.cc:98:    return this->_firstEdge;
ringFinder.cc:104:    return this->_lastVertex;
ringFinder.cc:109:    this->_lastVertex = vert;
ringFinder.cc:114:    this->_lastVertex = vertex;
ringFinder.cc:115:    uint ei = edge->getId();
ringFinder.cc:116:    this->_beep->setBit(ei,1);
ringFinder.cc:122:    Atom_sp a1 = this->_firstVertex->getAtom();
ringFinder.cc:123:    string firstName = a1->getName();
ringFinder.cc:124:    uint firstResidue = a1->getResidueContainedBy()->getId();
ringFinder.cc:125:    Atom_sp a2 = this->_lastVertex->getAtom();
ringFinder.cc:126:    string lastName = a2->getName();
ringFinder.cc:127:    uint lastResidue = a2->getResidueContainedBy()->getId();
ringFinder.cc:128:    _lisp->print(BF("Ring start: %d:%s end: %d:%s") % firstResidue %  firstName
ringFinder.cc:131:    _lisp->print(BF("Edges: "));
ringFinder.cc:134:    this->_beep->getOnIndices(vals);
ringFinder.cc:137:	AGEdge_sp edge = this->getGraph()->getEdge(*ei);
ringFinder.cc:138:	a1 = edge->getVertex1()->getAtom();
ringFinder.cc:139:	uint r1 = a1->getResidueContainedBy()->getId();
ringFinder.cc:140:	string s1 = a1->getName();
ringFinder.cc:141:	a2 = edge->getVertex2()->getAtom();
ringFinder.cc:142:	uint r2 = a2->getResidueContainedBy()->getId();
ringFinder.cc:143:	string s2 = a2->getName();
ringFinder.cc:144:	_lisp->print(BF("    %d:%s - %d:%s") % r1% s1.c_str()% r2% s2.c_str() );
ringFinder.cc:155:    this->_beep->getOnIndices(edges);
ringFinder.cc:159:	AGEdge_sp edge = this->getGraph()->getEdge(*ei);
ringFinder.cc:160:	Atom_sp a1 = edge->getVertex1()->getAtom();
ringFinder.cc:162:	Atom_sp a2 = edge->getVertex2()->getAtom();
ringFinder.cc:177:    return this->_beep;
ringFinder.cc:182:// -------------------------------------------------------------------
ringFinder.cc:183:// -------------------------------------------------------------------
ringFinder.cc:184:// -------------------------------------------------------------------
ringFinder.cc:193:    v->_graph = graph;
ringFinder.cc:194:    v->_atom = atom;
ringFinder.cc:195:    v->_edges.clear();
ringFinder.cc:196:    v->_seenId = UndefinedUnsignedInt;
ringFinder.cc:197:    v->emptySendBuffer();
ringFinder.cc:198:    v->emptyReceiveBuffer();
ringFinder.cc:205:    return this->_atom.get();
ringFinder.cc:211:    for ( vector<AGEdge_sp>::iterator ei=this->_edges.begin();
ringFinder.cc:212:    		ei!=this->_edges.end(); ei++ )
ringFinder.cc:223:    ss << this->className() << "{";
ringFinder.cc:224:    ss << this->_atom->description() << "}";
ringFinder.cc:230:    this->_atom->dump();
ringFinder.cc:232:    for ( cur=this->getConnectedVertices(); cur.notnilp(); cur = cur->cdr() )
ringFinder.cc:234:	_lisp->prin1(BF("%s ") % cur->car<AGVertex_O>()->getAtom()->getName() );
ringFinder.cc:236:    _lisp->print(BF(""));
ringFinder.cc:242:    return this->_atom;
ringFinder.cc:248:    this->_edges.push_back(edge);
ringFinder.cc:253:    this->_sendBuffer = core::Cons_O::_nil;
ringFinder.cc:259:    this->_receiveBuffer = core::Cons_O::_nil;
ringFinder.cc:265:    this->emptySendBuffer();
ringFinder.cc:267:    for ( x=this->_edges.begin(); x!=this->_edges.end(); x++ )
ringFinder.cc:269:	AGVertex_sp nVertex = (*x)->otherVertex(this);
ringFinder.cc:270:	PathMessage_sp mess = PathMessage_O::create(_lisp,this->getGraph(),nVertex,*x,nVertex);
ringFinder.cc:271:	this->_sendBuffer = core::Cons_O::create(mess,this->_sendBuffer,_lisp);
ringFinder.cc:278:    if ( this->_edges.size() == 0 ) return;
ringFinder.cc:280:    for ( edge=this->_edges.begin(); edge!=this->_edges.end(); edge++ )
ringFinder.cc:282:	AGVertex_sp neighbor = (*edge)->otherVertex(this);
ringFinder.cc:283:	_BLOCK_TRACEF(BF("sending messages to Vertex: %s") % neighbor->description().c_str() );
ringFinder.cc:285:	for ( msgCur=this->_sendBuffer; msgCur.notnilp(); msgCur=msgCur->cdr())
ringFinder.cc:287:	    PathMessage_sp msg = msgCur->car<PathMessage_O>();
ringFinder.cc:288:	    LOG(BF("Sending message: %s") % msg->beep()->__repr__() );
ringFinder.cc:291:	    if ( msg->getLastVertex() == neighbor ) continue;
ringFinder.cc:296:	    if ( msg->getFirstVertex() == neighbor ) continue;
ringFinder.cc:297:	    PathMessage_sp newMsg = msg->copy();
ringFinder.cc:298:	    newMsg->update(*edge,this->sharedThis<AGVertex_O>());
ringFinder.cc:299:	    neighbor->acceptMessage(newMsg);
ringFinder.cc:302:    this->emptySendBuffer();
ringFinder.cc:307:    this->_receiveBuffer = core::Cons_O::create(msg,this->_receiveBuffer,_lisp);
ringFinder.cc:315:    if ( this->_edges.size() == 0 ) return;
ringFinder.cc:320:    RingFinder_sp		graph = this->getGraph();
ringFinder.cc:321:    edgeArray0.resize(graph->getNumberOfEdges(),PathMessage_O::_nil);
ringFinder.cc:322:    edgeArray1.resize(graph->getNumberOfEdges(),PathMessage_O::_nil);
ringFinder.cc:324:    LOG(BF("Stage(%d) Vertex(%s) distributing receiveBuffer, there are %d messages") % stage % this->_atom->description().c_str() % this->_receiveBuffer->length() );
ringFinder.cc:327:    ASSERTP(this->_receiveBuffer.notnilp(),"The receive buffer is empty for atom("+this->_atom->description()+")!");
ringFinder.cc:328:    for ( msgCur = this->_receiveBuffer; msgCur.notnilp(); msgCur=msgCur->cdr())
ringFinder.cc:330:	PathMessage_sp msg = msgCur->car<PathMessage_O>();
ringFinder.cc:331:	_BLOCK_TRACEF(BF("Stage(%d) Vertex(%s) received bitVector: %s") % stage % this->_atom->getName() % msg->beep()->__repr__() );
ringFinder.cc:332:	AGEdge_sp edge = msg->getFirstEdge();
ringFinder.cc:333:	AGVertex_sp vert = msg->getFirstVertex();
ringFinder.cc:334:	uint side = edge->getSide(vert);
ringFinder.cc:335:	uint edgeId = edge->getId();
ringFinder.cc:337:	    if ( edgeArray0[edgeId]->isNil() )
ringFinder.cc:344:	    if ( edgeArray1[edgeId]->isNil() )
ringFinder.cc:357:	    // They represent odd-membered rings
ringFinder.cc:359:    { _BLOCK_TRACEF(BF("Detecting odd-membered rings numberOfEdges=%d") % graph->getNumberOfEdges() );
ringFinder.cc:360:	numEdges = graph->getNumberOfEdges();
ringFinder.cc:363:	    LOG(BF("Detecting odd-membered rings i = %d") % i );
ringFinder.cc:364:		    // detect odd-membered rings
ringFinder.cc:365:	    if ( edgeArray0[i].notnilp() && edgeArray1[i]->notNil() )
ringFinder.cc:367:		PathMessage_sp ring = edgeArray0[i]->copy();
ringFinder.cc:368:		ring->join(edgeArray1[i]);
ringFinder.cc:371:		ring->updateLastVertex(this->sharedThis<AGVertex_O>());
ringFinder.cc:372:		graph->addRing(ring,stage);
ringFinder.cc:383:    {_BLOCK_TRACE("Detecting even-membered rings");
ringFinder.cc:387:	    LOG(BF("Detecting even-membered rings: i = %d") % i );
ringFinder.cc:391:		void* nodeId = msg->getFirstVertex()->getId();
ringFinder.cc:403:		void* nodeId = msg->getFirstVertex()->getId();
ringFinder.cc:420:    {_BLOCK_TRACEF(BF("Detecting even-membered rings"));
ringFinder.cc:426:		    // a node-collision, combine the messages and
ringFinder.cc:429:	    if ( it->second->cdr().notnilp() )
ringFinder.cc:432:		for ( first=it->second; first.notnilp(); first = first->cdr() )
ringFinder.cc:435:		    for ( second=first->cdr();second.notnilp();second=second->cdr())
ringFinder.cc:437:			PathMessage_sp ring = first->car<PathMessage_O>()->copy();
ringFinder.cc:438:			ring->join(second->car<PathMessage_O>());
ringFinder.cc:439:			ring->updateLastVertex(this->sharedThis<AGVertex_O>());
ringFinder.cc:440:			graph->addRing(ring,stage);
ringFinder.cc:445:		this->_sendBuffer = core::Cons_O::create(it->second->car<PathMessage_O>(),
ringFinder.cc:446:						    this->_sendBuffer,_lisp);
ringFinder.cc:450:    this->emptyReceiveBuffer();
ringFinder.cc:460:    edge->_graph = graph;
ringFinder.cc:461:    edge->_id = graph->getNextEdgeId();
ringFinder.cc:462:    if ( atom1->atLowerAddressThan(atom2) )
ringFinder.cc:464:	edge->_vertex1 = graph->vertexForAtom(atom1);
ringFinder.cc:465:	edge->_vertex2 = graph->vertexForAtom(atom2);
ringFinder.cc:468:	edge->_vertex2 = graph->vertexForAtom(atom1);
ringFinder.cc:469:	edge->_vertex1 = graph->vertexForAtom(atom2);
ringFinder.cc:471:    edge->_vertex1->addEdge(edge);
ringFinder.cc:472:    edge->_vertex2->addEdge(edge);
ringFinder.cc:479:    return this->_vertex1;
ringFinder.cc:484:    return this->_vertex2;
ringFinder.cc:489:    return this->_id;
ringFinder.cc:496:    if ( firstVertex == this->_vertex1.get() )
ringFinder.cc:498:	return this->_vertex2;
ringFinder.cc:500:    return this->_vertex1;
ringFinder.cc:506:    if ( vert == this->_vertex1 )
ringFinder.cc:517:    graph->defineForMolecule(mol);
ringFinder.cc:527:    this->_vertices.clear();
ringFinder.cc:531:	if ( at->isOfClass<VirtualAtom_O>() ) continue;
ringFinder.cc:532:	LOG(BF("### Adding atom: %s id:%p to graph") % at->description().c_str() % at.get()  );
ringFinder.cc:533:	if ( this->_vertices.count(at.get() ) != 0 )
ringFinder.cc:535:	    THROW(_lisp->create<core::ContentException_O>("Non unique atom id"));
ringFinder.cc:537:	AGVertex_sp vert = AGVertex_O::create(_lisp,this->sharedThis<RingFinder_O>(),at);
ringFinder.cc:538:	this->_vertices[at.get()] = vert;
ringFinder.cc:541:    this->_edges.clear();
ringFinder.cc:546:	AGEdge_sp edge = AGEdge_O::create(_lisp,this->sharedThis<RingFinder_O>(),a1,a2);
ringFinder.cc:547:	this->_edges.push_back(edge);
ringFinder.cc:553:    return this->_edges.size();
ringFinder.cc:560:    it = this->_vertices.begin();
ringFinder.cc:561:    return it->second->getAtom();
ringFinder.cc:567:    return this->_vertices[anAtom.get()];
ringFinder.cc:576:    for ( it=this->_vertices.begin(); it!=this->_vertices.end(); it++ )
ringFinder.cc:578:	it->second->dump();
ringFinder.cc:581:    _lisp->print(BF("There are %d atoms") % cnt );
ringFinder.cc:587:    return this->_vertices;
ringFinder.cc:592:    return this->_edges;
ringFinder.cc:597:    return this->_edges.size();
ringFinder.cc:602:    LOG(BF("this->_edges.size() = %d") % this->_edges.size()  );
ringFinder.cc:603:    LOG(BF("this->_vertices.size() = %d") % this->_vertices.size()  );
ringFinder.cc:604:    int num = this->_edges.size()-this->_vertices.size()+1;
ringFinder.cc:614:    this->_rings.clear();
ringFinder.cc:615:    this->_finalRings.clear();
ringFinder.cc:616://    this->_numberRings = 0;
ringFinder.cc:618:    for ( x=this->_vertices.begin(); x!=this->_vertices.end(); x++ )
ringFinder.cc:620:	(x->second)->initializeRingSearch();
ringFinder.cc:622:    this->_gaussian.clear();
ringFinder.cc:630:	for ( vi=this->_vertices.begin(); vi!=this->_vertices.end(); vi++ )
ringFinder.cc:632:	    vi->second->send();
ringFinder.cc:636:	for ( vi=this->_vertices.begin(); vi!=this->_vertices.end(); vi++ )
ringFinder.cc:638:	    vi->second->receive(stage);
ringFinder.cc:648:    this->initializeRingSearch();
ringFinder.cc:649:    unsigned numberOfRingsExpected = this->getNumberOfRingsExpected();
ringFinder.cc:655:    while ( this->_finalRings.size() < numberOfRingsExpected )
ringFinder.cc:658:        this->advanceRingSearch(stage);
ringFinder.cc:660:	    % this->_finalRings.size()  );
ringFinder.cc:662:	trigger--;
ringFinder.cc:665:	    SIMPLE_ERROR(BF("We advanced the ring search way beyond the number of times we should have needed to - there are %d atoms and %d rings expected and we advanced the search %d times") % numAtoms % numberOfRingsExpected % stage );
ringFinder.cc:673:    core::SimpleBitVector_sp beep = ring->beep();
ringFinder.cc:674:    LOG(BF("Adding ring with beep=%s") % beep->__repr__() );
ringFinder.cc:676:    beep->sxhash(hg);
ringFinder.cc:679:    if ( this->_rings.count(hash) != 0 )
ringFinder.cc:681:	ringList = this->_rings[hash];
ringFinder.cc:684:	this->_rings[hash] = core::Cons_O::_nil;
ringFinder.cc:688:    for ( ; ringList.notnilp(); ringList = ringList->cdr() )
ringFinder.cc:690:	if ( ringList->car<PathMessage_O>()->beep()->equal(beep) ) return;
ringFinder.cc:694:    this->_rings[hash] = core::Cons_O::create(ring,this->_rings[hash],_lisp);
ringFinder.cc:695:    if ( this->linearlyIndependentRing(ring) )
ringFinder.cc:697:	this->_finalRings.push_back(ring);
ringFinder.cc:704:    core::SimpleBitVector_sp beep = ring->beep()->deepCopy()->as<core::SimpleBitVector_O>();
ringFinder.cc:708:    uint glast = this->_gaussian.size();
ringFinder.cc:709:    this->_gaussian.push_back(beep);
ringFinder.cc:713:    if ( this->_gaussian.size() == 1 ) return true;
ringFinder.cc:718:    uint left = this->_gaussian[glast]->lowestIndex();
ringFinder.cc:721:	uint gleft = this->_gaussian[z]->lowestIndex();
ringFinder.cc:726:	    core::SimpleBitVector_sp temp = this->_gaussian[z];
ringFinder.cc:727:	    this->_gaussian[z] = this->_gaussian[glast];
ringFinder.cc:728:	    this->_gaussian[glast] = temp;
ringFinder.cc:732:	    this->_gaussian[glast]->inPlaceXor(this->_gaussian[z]);
ringFinder.cc:733:	    left = this->_gaussian[glast]->lowestIndex();
ringFinder.cc:738:    if ( this->_gaussian[glast]->isZero() )
ringFinder.cc:740:	this->_gaussian.pop_back();
ringFinder.cc:754:    for ( it=this->_finalRings.begin(); it!=this->_finalRings.end(); it++ )
ringFinder.cc:756:	core::Cons_sp oneRing = (*it)->getAtoms();
ringFinder.cc:758:	LOG(BF("Ring #%d = size(%d) %s") % ridx % oneRing->length() % oneRing->__repr__().c_str()  );
ringFinder.cc:778:	    if ( atom->totalBondOrder() > atom->maxTotalBondOrder() )
ringFinder.cc:781:		ss << "There is a problem with atom " << atom->description() << " the sum of bond orders is: " << atom->totalBondOrder() << " and it should never be more than " << atom->maxTotalBondOrder();
ringFinder.cc:784:	    atom->clearAllRingMembershipFlags();
ringFinder.cc:785:	    atom->setRingMembershipCount(0);
ringFinder.cc:789:    RingFinder_sp atomGraph = RingFinder_O::create(molecule->lisp(),molecule);
ringFinder.cc:791:	atomGraph->findRings(numAtoms);
ringFinder.cc:795:	rings = atomGraph->getAllRingsAsListsOfAtoms();
ringFinder.cc:796:	for ( core::Cons_sp curRing=rings; curRing.notnilp(); curRing = curRing->cdr() )
ringFinder.cc:798:	    core::Cons_sp atoms = curRing->car<core::Cons_O>();
ringFinder.cc:799:	    uint ringSize = atoms->length();
ringFinder.cc:800:	    for ( core::Cons_sp atomCons = atoms; atomCons.notnilp(); atomCons = atomCons->cdr() )
ringFinder.cc:802:		Atom_sp atom = atomCons->car<Atom_O>();
ringFinder.cc:803:		atom->setInRingOfSize(ringSize);
ringFinder.cc:804:		atom->incrementRingMembershipCount();
ringFinder.cc:805:		LOG(BF("Set %s as part of ring[%d]") % atom->description() % ringSize);
ringFinder.cc:827:    if ( matter->isOfClass<Molecule_O>() )
ringFinder.cc:833:    if ( matter->isOfClass<Aggregate_O>() )
ringFinder.cc:846:		rings = rings->cdr();
ringFinder.cc:847:		one->setCdr(allRings);
ringFinder.cc:863:	for ( core::Cons_sp cur=atoms; cur.notnilp(); cur = cur->cdr() )
ringFinder.cc:865:	    Atom_sp atom = cur->car<Atom_O>();
ringFinder.cc:866:	    LOG(BF("Atom in ring: %s") % atom->description());
ringFinder.cc:867:	    atomSet.insert(cur->car<Atom_O>());
ringFinder.cc:872:	for ( core::Cons_sp cur=atoms; cur.notnilp(); cur=cur->cdr() )
ringFinder.cc:874:	    Atom_sp atom = cur->car<Atom_O>();
ringFinder.cc:875:	    VectorBond bonds = atom->getBonds();
ringFinder.cc:878:		LOG(BF("Testing %s") % (*bi)->describeOther(atom));
ringFinder.cc:879:		if ( atomSet.count((*bi)->getAtom1()) && atomSet.count((*bi)->getAtom2()))
rotamer.cc:18:    node->attribute("d",this->_Distance);
rotamer.cc:19:    node->attribute("a",this->_Angle);
rotamer.cc:20:    node->attribute("t",this->_Torsion);
rotamer.cc:21:    LOG(BF("Serialized RotamerAtom@%X = %lf, %lf, %lf") % this % this->_Distance % this->_Angle % this->_Torsion );
rotamer.cc:32:// ----------------------------------------------------------------------
rotamer.cc:57:	if ( node->saving() ) {
rotamer.cc:58:	    uint sz = this->_RotamerAtoms.size();
rotamer.cc:59:	    node->attribute("size",sz);
rotamer.cc:63:	    for ( i=0,vi=this->_RotamerAtoms.begin(); vi!=this->_RotamerAtoms.end(); i++,vi++ ) {
rotamer.cc:64:		vnode = node->createChildNode("V");
rotamer.cc:65:		vnode->attribute("i",i);
rotamer.cc:70:	    node->attribute("size",sz);
rotamer.cc:71:	    this->_RotamerAtoms.resize(sz);
rotamer.cc:74:	    for ( vi=node->begin_Children(); vi!=node->end_Children(); vi++ ) {
rotamer.cc:75:		(*vi)->setRecognized(true);
rotamer.cc:76:		(*vi)->attribute("i",i);
rotamer.cc:77:		this->_RotamerAtoms[i].archive(*vi);
rotamer.cc:87:        this->Base::initialize();
searchStatistics.cc:34:    this->Base::initialize();
searchStatistics.cc:35:    this->_ReportFrequency = UndefinedUnsignedInt;
searchStatistics.cc:36:    this->reset();
searchStatistics.cc:41:    this->_Builds = 0;
searchStatistics.cc:42:    this->_Rejects = 0;
searchStatistics.cc:43:    this->_Hits = 0;
searchStatistics.cc:51:    this->Base::archiveBase(node);
searchStatistics.cc:52:    node->attribute("ReportFrequency",this->_ReportFrequency);
searchStatistics.cc:53:    node->attribute("Builds",this->_Builds);
searchStatistics.cc:54:    node->attribute("Rejects",this->_Rejects);
searchStatistics.cc:55:    node->attribute("Hits",this->_Hits);
searchStatistics.cc:62:    this->_ReportFrequency = i;
searchStatistics.cc:68:    this->_Builds++;
searchStatistics.cc:69:    if ( this->_ReportFrequency == UndefinedUnsignedInt ) return;
searchStatistics.cc:70:    if ( ( this->_Builds % this->_ReportFrequency ) == 0 )
searchStatistics.cc:72:        _lisp->print(BF("SearchStatistics_O::incrementBuilds>>%s") % this->description().c_str() );
searchStatistics.cc:78:    return this->_Builds;
searchStatistics.cc:84:    this->_Rejects++;
searchStatistics.cc:89:    return this->_Rejects;
searchStatistics.cc:95:    this->_Hits++;
searchStatistics.cc:100:    return this->_Hits;
searchStatistics.cc:106:    fmt % this->_Builds % this->_Rejects % this->_Hits;
spanningLoop.cc:35:    me->setTop(root);
spanningLoop.cc:43:	Atom_sp root = translate::from_object<Atom_O>::convert(env->lookup(ChemPkg,"root"));
spanningLoop.cc:44:	this->setTop(root);
spanningLoop.cc:65:	fFlags = aAtom->getFlags();
spanningLoop.cc:66:	if ( (fFlags&this->fVisibleFlagsOn)!=this->fVisibleFlagsOn )
spanningLoop.cc:70:	if ( (fFlags|(~(this->fVisibleFlagsOff)))!=(~(this->fVisibleFlagsOff)) )
spanningLoop.cc:79:	if ( this->fVisibilityFlags & TEMPINTUSED ) {
spanningLoop.cc:80:	    if ( this->fVisibilityFlags & TEMPINTINVISIBLE ) {
spanningLoop.cc:81:		if ( aAtom->getTempInt() == this->iTempInt ) {
spanningLoop.cc:86:		if ( aAtom->getTempInt() != this->iTempInt ) {
spanningLoop.cc:98:	if ( this->aInvisibleAtom.use_count() != 0 )
spanningLoop.cc:100:	    if ( this->aInvisibleAtom == aAtom ) 
spanningLoop.cc:126:	if ( this->_OnlyFollowRealBonds )
spanningLoop.cc:133:	if ( aAtom->getSeenId() == this->iSeenId ) {
spanningLoop.cc:141:	if ( this->iMaxDistanceFromRoot >=0 ) {
spanningLoop.cc:142:	    if ( this->iMaxDistanceFromRoot <
spanningLoop.cc:143:		 this->aCurSpan->getBackCount()+1 ) {
spanningLoop.cc:147:	return(this->bLoopAtomVisible( aAtom ));
spanningLoop.cc:163:	this->top = 	c;
spanningLoop.cc:164:	this->initialized = false;
spanningLoop.cc:165:	this->done	= 	false;
spanningLoop.cc:170:	this->iTempInt = 0;
spanningLoop.cc:171:	this->fVisibilityFlags = 0;
spanningLoop.cc:176:	LOG(BF("SpanningLoop_O::setTop atom moeIndex =%d") % (c->getMoeIndex() ) );
spanningLoop.cc:177:	this->iMaxDistanceFromRoot = -1;
spanningLoop.cc:178:	this->aCurSpan = c;
spanningLoop.cc:179:	this->aLastSpan = c;
spanningLoop.cc:182:	this->iSeenId = SiNextSeenId;
spanningLoop.cc:183:	this->iInvisibleCollisions = 0;
spanningLoop.cc:184:	this->aLastCollision = Atom_sp();
spanningLoop.cc:185:	this->fVisibilityFlags = 0;
spanningLoop.cc:186:	this->fVisibleFlagsOn = 0;
spanningLoop.cc:187:	this->fVisibleFlagsOff = 0;
spanningLoop.cc:194:	return downcast<Atom_O>(this->currentObject);
spanningLoop.cc:199:	if ( !this->done) {
spanningLoop.cc:200:	    this->advanceLoop();
spanningLoop.cc:209:	this->Base::initialize();
spanningLoop.cc:210:	this->initialized = false;
spanningLoop.cc:211:	this->_OnlyFollowRealBonds = false;
spanningLoop.cc:231:	if ( !this->initialized ) {
spanningLoop.cc:232:	    downcast<Atom_O>(this->top)->invalidateBackSpan();
spanningLoop.cc:233:	    downcast<Atom_O>(this->top)->setBackCount(0);
spanningLoop.cc:234:	    downcast<Atom_O>(this->top)->setSeenId(this->iSeenId);
spanningLoop.cc:235:	    this->initialized = true;
spanningLoop.cc:238:	LOG(BF("--- Entered nextSpanningAtom aCurSpan = %d; nextSpan valid?=%d") 
spanningLoop.cc:239:	    % this->aCurSpan->getMoeIndex() % this->aCurSpan->isNextSpanValid() );
spanningLoop.cc:240:	ASSERT(this->aCurSpan.notnilp());
spanningLoop.cc:241://    if (IsNull(this->aCurSpan)) {
spanningLoop.cc:242://	LOG(BF("this->aCurSpan is NULL") );
spanningLoop.cc:244://	this->done = true;
spanningLoop.cc:251:	aPrev = this->aLastSpan;
spanningLoop.cc:252:	aPrev->invalidateNextSpan();
spanningLoop.cc:253:	LOG(BF("--- Invalidated nextSpan for atom: %d") % (aPrev->getMoeIndex() ) );
spanningLoop.cc:254:	LOG(BF("--- Currently on atom: %d") % (this->aCurSpan->getMoeIndex() ) );
spanningLoop.cc:255:	for ( i=0; i<this->aCurSpan->coordination(); i++ ) {
spanningLoop.cc:256:	    aBond = this->aCurSpan->bondedNeighbor( i );
spanningLoop.cc:257:	    BondOrder order = this->aCurSpan->bondedOrder(i);
spanningLoop.cc:260:	    if ( this->bSpanAtomVisible( aBond, order, &bSeenBefore ) ) {
spanningLoop.cc:261:		LOG(BF("--- looking at bonded atom: %d") % (aBond->getMoeIndex() ) );
spanningLoop.cc:262:		aBond->setSeenId( this->iSeenId );
spanningLoop.cc:263:		aBond->setBackCount( this->aCurSpan->getBackCount()+1 );
spanningLoop.cc:264:		aBond->setBackSpan( this->aCurSpan );
spanningLoop.cc:265:		aPrev->setNextSpan( aBond );
spanningLoop.cc:266:		LOG(BF("--- Setting atom: %d nextSpan to: %d") % (aPrev->getMoeIndex()) % (aBond->getMoeIndex() ) );
spanningLoop.cc:268:		aBond->invalidateNextSpan();
spanningLoop.cc:269:		LOG(BF("--- Is atom: %d nextSpan valid? ==> %d") % (aPrev->getMoeIndex()) % (aPrev->isNextSpanValid() ) );
spanningLoop.cc:272:		LOG(BF("--- NOT Visible") );
spanningLoop.cc:279:		    LOG(BF("--- COLLISION!") );
spanningLoop.cc:280:		    this->iInvisibleCollisions++;
spanningLoop.cc:281:		    this->aLastCollision = aBond;
spanningLoop.cc:288:	this->aLastSpan = aPrev;
spanningLoop.cc:289:	oObject = this->aCurSpan;
spanningLoop.cc:290:	if ( this->aCurSpan->isNextSpanValid() ) {
spanningLoop.cc:291:	    this->aCurSpan = this->aCurSpan->getNextSpan();
spanningLoop.cc:292:	    LOG(BF("--- Setting this->aCurSpan to: %d") % (this->aCurSpan->getMoeIndex() ) );
spanningLoop.cc:293:	    LOG(BF("--- Is atom: %d nextSpan valid? ==> %d") % (this->aCurSpan->getMoeIndex()) % (this->aCurSpan->isNextSpanValid() ) );
spanningLoop.cc:295:	    LOG(BF("atom %d does not have a next span atom, loop done") % (this->aCurSpan->getMoeIndex() ) );
spanningLoop.cc:296:	    this->done = true;
spanningLoop.cc:312:// At the end of this function either this->currentObject is the next object
spanningLoop.cc:313:// or this->done == true, in which case this->currentObject is invalid.
spanningLoop.cc:319:	LOG(BF("SpanningLoop_O::advanceLoop STARTING ---------- ") );
spanningLoop.cc:320:	if ( this->done ) {
spanningLoop.cc:327:	retVal = this->nextSpanningAtom();
spanningLoop.cc:328:	LOG(BF("SpanningLoop_O::advanceLoop advanced to moeIndex =%d") % (retVal->getMoeIndex() ) );
spanningLoop.cc:331:	this->currentObject = retVal;
spanningLoop.cc:332:	LOG(BF("SpanningLoop_O::advanceLoop returning --------------") );
spanningLoop.cc:341:	Atom_sp theTop = this->top;
spanningLoop.cc:342:	this->setTop(theTop);
spanningLoop.cc:343:	while ( this->advanceLoopAndProcess() )
spanningLoop.cc:345:	    core::Cons_sp one = core::Cons_O::create(this->getAtom(),core::Cons_O::_nil,_lisp);
spanningLoop.cc:346:	    cur->setCdr(one);
spanningLoop.cc:349:	return first->cdr();
sparseMatrix.cc:49:    this->_RowMatrix = true;
sparseMatrix.cc:50:    this->_MatrixType = type;
sparseMatrix.cc:51:    this->_Columns = cols;
sparseMatrix.cc:52:    this->_Rows = rows;
sparseMatrix.cc:53:    this->_Values.empty();
sparseMatrix.cc:54:    this->_SliceStarts.resize(rows+1);
sparseMatrix.cc:55:    this->_SliceStarts.fill(0);	// Fill with zero
sparseMatrix.cc:67:    this->_Columns = 0;
sparseMatrix.cc:68:    this->_Rows = 0;
sparseMatrix.cc:69:    this->_Values.empty();
sparseMatrix.cc:70:    this->_SliceStarts.empty(0);
sparseMatrix.cc:74://    THE NONZERO ENTRIES OF THE SPARSE MATRIX ARE STORED ROW-BY-ROW IN THE
sparseMatrix.cc:80://    I.E., IF M(I,J) IS THE FIRST NONZERO ENTRY (STORED) IN THE I-TH ROW
sparseMatrix.cc:83://    THUS, THE NUMBER OF ENTRIES IN THE I-TH ROW IS  IA(I+1) - IA(I),
sparseMatrix.cc:84://    THE NONZERO ENTRIES IN THE I-TH ROW ARE STORED CONSECUTIVELY IN
sparseMatrix.cc:86://            A(IA(I)),  A(IA(I)+1),  ..., A(IA(I+1)-1),
sparseMatrix.cc:90://            JA(IA(I)), JA(IA(I)+1), ..., JA(IA(I+1)-1).
sparseMatrix.cc:104://         ---+--------------------------------------
sparseMatrix.cc:112://         ---+--------------------------
sparseMatrix.cc:123:    this->_orderIndices(c,r);
sparseMatrix.cc:125:    if ( c >= this->_Columns || r >= this->_Rows ) {
sparseMatrix.cc:128:    ssstart = &(this->_Values[this->_SliceStarts[r]];
sparseMatrix.cc:129:    send = &(this->_Values[this->_SliceStarts[r+1]-1];
sparseMatrix.cc:130:    if ( c < sstart->_Offset ) return NULL;
sparseMatrix.cc:131:    if ( c > send->_Offset ) return NULL;
sparseMatrix.cc:132:    if ( c == ss->this->_Values[sliceStart]._Offset ) return &this->_Values[sliceStart]._Value;
sparseMatrix.cc:133:    if ( c == this->_Values[sliceEnd]._Offset ) return &this->_Values[sliceEnd]._Value;
sparseMatrix.cc:140:	if ( c == this->_Values
sparseMatrix.cc:149:    return this->_dPValues+(r)*this->_Columns+(c);
specificContext.cc:17:    this->_SelfName = ss._SelfName;
specificContext.cc:18:    this->_Neighbors = ss._Neighbors;
specificContext.cc:32:    this->Base::initialize();
specificContext.cc:33:    this->_Neighbors.clear();
specificContext.cc:34:    this->_SelfName = _Nil<core::Symbol_O>();
specificContext.cc:40:    this->_Neighbors.clear();
specificContext.cc:41:    this->_SelfName = _Nil<core::Symbol_O>();
specificContext.cc:54:   this->_SelfName = selfName; 
specificContext.cc:62:    this->_Neighbors.push_back(one);
specificContext.cc:67:    ASSERT_gt(this->_Neighbors.size(),0);
specificContext.cc:68:    KeyEntry& one = this->_Neighbors.back();
specificContext.cc:74:    this->_Neighbors.pop_back();
specificContext.cc:81:    if ( !bdb->recognizesMonomerName(this->_SelfName) ) return false;
specificContext.cc:82:    for ( vector<KeyEntry>::iterator it = this->_Neighbors.begin();
specificContext.cc:83:    		it!=this->_Neighbors.end(); it++ )
specificContext.cc:85:	if ( !bdb->recognizesMonomerName(it->_Monomer) ) return false;
specificContext.cc:94:    ss << this->_SelfName->identifierName();
specificContext.cc:96:    for ( vector<KeyEntry>::iterator it = this->_Neighbors.begin();
specificContext.cc:97:    		it!=this->_Neighbors.end(); it++ )
specificContext.cc:99:	ss << it->_Coupling->identifierName();
specificContext.cc:102:	ss << it->_Monomer->identifierName();
specificContext.cc:142:    this->Base::initialize();
specificContext.cc:156:    this->_KeySets.set(keyKey, key );
specificContext.cc:162:    LOG(BF("adding SpecificContext |%s|") % key->asString().c_str()  );
specificContext.cc:163:    this->addWithKey(key->asString(),key);
specificContext.cc:169:    return this->_KeySets.count(key->asString())>0;
specificContext.cc:175:    for ( it=s->begin(); it!=s->end(); it++ )
specificContext.cc:177:	this->addWithKey(it->first,it->second);
specificContext.cc:185:    for ( it=s->begin(); it!=s->end(); it++ )
specificContext.cc:187:	string key = it->second->asString();
specificContext.cc:188:	if ( this->_KeySets.count(key)>0 )
specificContext.cc:190:	    this->_KeySets.remove(key);
specificContext.cc:199:    for ( it=this->begin(); it!=this->end(); it++ )
specificContext.cc:201:	keys->insert(it->first);
specificContext.cc:213:    for ( it=this->begin(); it!=this->end(); it++ )
specificContext.cc:215:	core::Cons_sp one = core::Cons_O::create(it->second,core::Cons_O::_nil,_lisp);
specificContext.cc:216:	cur->setCdr(one);
specificContext.cc:219:    return first->cdr();
spline.cc:39:	double mSpline[] = { 	-1,  2, -1,  0,
spline.cc:40:				 3, -5,  0,  2,
spline.cc:41:				-3,  4,  1,  0,
spline.cc:42:				 1, -1,  0,  0 };
spline.cc:46:	this->mbAMatrix = m;
spline.cc:47:	this->mbBMatrix = m;
spline.cc:48:	this->mbsMatrix = m;
spline.cc:49:	this->mbYMatrix = m;
spline.cc:50:	this->mbZMatrix = m;
spline.cc:61:    this->iType = iSplineType;
spline.cc:62:    this->defineMatrices(iSplineType);
spline.cc:63:    this->definePoints(points);
spline.cc:73:   p1 = points[i4-3];
spline.cc:74:   p2 = points[i4-2];
spline.cc:75:   p3 = points[i4-1];
spline.cc:107:    gmSize = points.size() - 3;
spline.cc:108:    this->gmMatrices.resize(gmSize,m);
spline.cc:110:	m = this->mbsMatrix;
spline.cc:112:	    m = this->mbBMatrix;
spline.cc:114:	    m = this->mbAMatrix;
spline.cc:115:	} else if (i == gmSize-2) {
spline.cc:116:	    m = this->mbYMatrix;
spline.cc:117:	} else if (i == gmSize-1) {
spline.cc:118:	    m = this->mbZMatrix;
spline.cc:120:	g = this->gMatrixForPoints( points, i+3 );
spline.cc:121:	this->gmMatrices[i] = g * m;
spline.cc:129:    _lisp->print(BF( "spline type = %d") % this->iType );
spline.cc:130:    _lisp->print(BF( "gmMatrices ======>" ));
spline.cc:131:    for ( i=0; i<this->gmMatrices.size(); i++ ) {
spline.cc:132:	this->gmMatrices[i].dump();
spline.cc:133:	_lisp->print(BF( "--------------" ));
spline.cc:135:    _lisp->print(BF( "mbAMatrix ======>" ));
spline.cc:136:    this->mbAMatrix.dump();
spline.cc:137:    _lisp->print(BF( "mbBMatrix ======>" ));
spline.cc:138:    this->mbBMatrix.dump();
spline.cc:139:    _lisp->print(BF( "mbsMatrix ======>" ));
spline.cc:140:    this->mbsMatrix.dump();
spline.cc:141:    _lisp->print(BF( "mbYMatrix ======>" ));
spline.cc:142:    this->mbYMatrix.dump();
spline.cc:143:    _lisp->print(BF( "mbZMatrix ======>" ));
spline.cc:144:    this->mbZMatrix.dump();
spline.cc:163:    if ( i>=this->gmMatrices.size() ) {
spline.cc:164:	i = this->gmMatrices.size()-1;
spline.cc:167:	t = ti - i;
spline.cc:169:    m = this->gmMatrices[i];
spline.cc:187:    sp = this->evaluateAtIndex(index);
spline.cc:188:    diff = pnt - sp;
statusTracker.cc:22:    this->Base::initialize();
statusTracker.cc:23:    this->_HasError = false;
statusTracker.cc:24:    this->_ErrorStream.str("");
statusTracker.cc:25:    this->_MessageStream.str("");
statusTracker.cc:33:    this->_HasError = ss._HasError;
statusTracker.cc:34:    this->_MessageStream.str(ss._MessageStream.str());
statusTracker.cc:35:    this->_ErrorStream.str(ss._ErrorStream.str());
statusTracker.cc:52:    node->attribute("hasError", this->_HasError );
statusTracker.cc:53:    node->archiveStringStreamIfDefined("ErrorMessages",this->_ErrorStream);
statusTracker.cc:54:    node->archiveStringStreamIfDefined("Messages",this->_MessageStream);
statusTracker.cc:65:    this->_MessageStream << msg << endl;
statusTracker.cc:75:    this->_HasError = true;
statusTracker.cc:76:    this->_ErrorStream << msg << endl;
statusTracker.cc:86:    this->_HasError = false;
statusTracker.cc:87:    this->_ErrorStream.str("");
statusTracker.cc:88:    this->_MessageStream.str("");
statusTracker.cc:95:    stuff << this->_MessageStream.str();
statusTracker.cc:96:    if ( this->_HasError )
statusTracker.cc:98:        stuff << this->_ErrorStream.str();
stereochemistry.cc:31:/*! Return +1 for "R" and -1 for "S"
stereochemistry.cc:35:    if ( this->_Configuration == "R" ) {
stereochemistry.cc:39:    return -1;
stereochemistry.cc:47:    node->attribute("atom",this->_AtomName);
stereochemistry.cc:48:    node->attribute("config",this->_Configuration);
stereochemistry.cc:58:Provide the atom name and the stereo-configuration \sa{configuration} of "R" or "S".
stereochemistry.cc:70:    me->_AtomName = atomName;
stereochemistry.cc:71:    me->_Configuration = config;
stereochemistry.cc:79:    this->_AtomName = env->lookup(Pkg(),"atomName")->as<core::Str_O>()->get();
stereochemistry.cc:80:    this->_Configuration = translate::from_object<string>::convert(env->lookup(Pkg(),"config"));
stereochemistry.cc:91:    ASSERT_eq(atomNames->length(), configurations->length() );
stereochemistry.cc:98:	one->setAtomName(curName->car<core::Str_O>()->get());
stereochemistry.cc:99:	one->setConfiguration(curConfig->car<core::Str_O>()->get());
stereochemistry.cc:101:	curName = curName->cdr();
stereochemistry.cc:102:	curConfig = curConfig->cdr();
stereochemistry.cc:131:		one = core::Cons_O::create(lisp->create<core::Str_O>("R"),one,lisp);
stereochemistry.cc:134:		one = core::Cons_O::create(lisp->create<core::Str_O>("S"),one,lisp);
stereochemistry.cc:153:	uint numberOfCenters = numcenters->get();
stereochemistry.cc:164:    this->Base::initialize();
stereochemistry.cc:165:    this->_Name = _Nil<core::Symbol_O>();
stereochemistry.cc:166:    this->_Pdb = _Nil<core::Symbol_O>();
stereochemistry.cc:167:    this->_WeakConstitution = _Nil<Constitution_O>();
stereochemistry.cc:168:    this->_Enantiomer = _Nil<core::Symbol_O>();
stereochemistry.cc:175:    if ( node->saving() ) this->getConstitution();
stereochemistry.cc:176:    this->Base::archiveBase(node);
stereochemistry.cc:177:    node->archiveWeakPointer("constitution",this->_WeakConstitution);
stereochemistry.cc:178:    node->attribute("name",this->_Name );
stereochemistry.cc:179:    node->attribute("pdb", this->_Pdb );
stereochemistry.cc:180:    node->attributeSymbolIfNotNil("enantiomer", this->_Enantiomer);
stereochemistry.cc:181:    node->archiveVector0OfObjectsSubClassOf<StereoConfiguration_O>( this->_Configurations );
stereochemistry.cc:189:    ss->insert(this->getName());
stereochemistry.cc:199:    RepresentativeList_sp ss = _lisp->create<RepresentativeList_O>();
stereochemistry.cc:200:    RepresentedEntityNameSet_sp gr = _lisp->create<RepresentedEntityNameSet_O>();
stereochemistry.cc:201:    gr->setName(this->getName());
stereochemistry.cc:202:    gr->setRepresentative(this->getName());
stereochemistry.cc:203:    gr->addEntityName(this->getName());
stereochemistry.cc:204:    ss = _lisp->create<RepresentativeList_O>();
stereochemistry.cc:205:    ss->append(gr);
stereochemistry.cc:213:    ss << "Stereoisomer-name(" << this->_Name->__repr__() << ")-pdbName(" << this->_Pdb->__repr__() << ")";
stereochemistry.cc:219:    for ( core::Vector0<StereoConfiguration_O>::iterator it=this->_Configurations.begin();
stereochemistry.cc:220:          it!=this->_Configurations.end(); it++ )
stereochemistry.cc:222:	if ( (*it)->getAtomName() == centerName )
stereochemistry.cc:224:	    return (*it)->getConfiguration();
stereochemistry.cc:232:    ASSERTNOTNULL(this->_WeakConstitution);
stereochemistry.cc:235:    if ( this->_WeakConstitution.lock()->isNil() )
stereochemistry.cc:238://	this->_WeakConstitution = this->ownerWithClass<Constitution_O>();
stereochemistry.cc:240:    return this->_WeakConstitution.lock();
stereochemistry.cc:258:    me->_Name = name;
stereochemistry.cc:259:    me->_Pdb = pdb;
stereochemistry.cc:261://    configs->setOwnerOfAllEntries(me);
stereochemistry.cc:262:    me->_Configurations.clear();
stereochemistry.cc:263:    for ( ; configs.notnilp(); configs = configs->cdr() )
stereochemistry.cc:265:	me->_Configurations.push_back(configs->car<StereoConfiguration_O>() );
stereochemistry.cc:274:    this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"name"));
stereochemistry.cc:275:    this->_Pdb = translate::from_object<core::Symbol_O>::convert(env->lookup(Pkg(),"pdb"));
stereochemistry.cc:276:    core::Cons_sp configs = translate::from_object<core::Cons_O>::convert(env->lookup(Pkg(),"configs"));
stereochemistry.cc:277:    configs->setOwnerOfAllEntries(this->sharedThis<Stereoisomer_O>());
stereochemistry.cc:278:    this->_Configurations.clear();
stereochemistry.cc:279:    for ( ; configs.notnilp(); configs = configs->cdr() )
stereochemistry.cc:281:	this->_Configurations.push_back(configs->car<StereoConfiguration_O>() );
stereochemistry.cc:297:#define ARGS_af_multiStereoisomers "(name-template centers configs)"
stereochemistry.cc:311:    if ( this->_NameOrPdbToStereoisomer.count(s->getName())>0 ) {
stereochemistry.cc:312:	SIMPLE_ERROR(boost::format("addStereoisomer monomer name (%s) has already been used") % s->getName());
stereochemistry.cc:314:    if ( this->_NameOrPdbToStereoisomer.count(s->getPdb())>0 ) {
stereochemistry.cc:315:	SIMPLE_ERROR(boost::format("addStereoisomer pdb name (%s) has already been used") % s->getPdb() );
stereochemistry.cc:317:    this->_NameOrPdbToStereoisomer.set(s->getName(),s);
stereochemistry.cc:318:    this->_NameOrPdbToStereoisomer.set(s->getPdb(),s);
stereochemistry.cc:319:    this->_Stereoisomers.append(s);
stereochemistry.cc:325:    for ( core::Vector0<Stereoisomer_O>::iterator it=this->_Stereoisomers.begin(); it!=this->_Stereoisomers.end(); it++ )
stereochemistry.cc:327:	if ( (*it)->getName()->isNil() ) 
stereochemistry.cc:331:	if ( (*it)->getPdb()->isNil() ) 
stereochemistry.cc:350:    this->_ProChiralCenters.push_back(s);
stereochemistry.cc:357:    return this->_NameOrPdbToStereoisomer.get(nameOrPdb,_lisp);
stereochemistry.cc:363:    node->archiveVector0OfObjectsSubClassOf<Stereoisomer_O>(this->_Stereoisomers);
stereochemistry.cc:364://    node->archiveVector0OfObjectsSubClassOf<O_ProChiralCenter>( this->_ProChiralCenters);
stereochemistry.cc:365:    node->archiveVector0( "complexRestraints", this->_ComplexRestraints);
stereochemistry.cc:366:    node->needsFinalization();
stereochemistry.cc:374:    for ( si=this->_Stereoisomers.begin(); si!=this->_Stereoisomers.end(); si++ )
stereochemistry.cc:376:    	LOG(BF("Adding stereoisomer with name: %s") % (*si)->getName().c_str()  );
stereochemistry.cc:377:        this->_NameOrPdbToStereoisomer.set((*si)->getName(), (*si));
stereochemistry.cc:378:        this->_NameOrPdbToStereoisomer.set((*si)->getPdb(), (*si));
stereochemistry.cc:402:    me->_Stereoisomers.fillFromCons(stereoisomers);
stereochemistry.cc:404://    stereoisomers->setOwnerOfAllEntries(me);
stereochemistry.cc:405:    me->_NameOrPdbToStereoisomer.clear();
stereochemistry.cc:406:    for ( core::Vector0<Stereoisomer_O>::iterator it = me->_Stereoisomers.begin();
stereochemistry.cc:407:	  it != me->_Stereoisomers.end(); it++ )
stereochemistry.cc:409:	if ( me->_NameOrPdbToStereoisomer.count((*it)->getName()) >0 )
stereochemistry.cc:411:	      SIMPLE_ERROR(BF("Stereoisomer name: "+(*it)->getName()->__repr__()+" has already been defined"));
stereochemistry.cc:413:	if ( me->_NameOrPdbToStereoisomer.count((*it)->getPdb()) >0 )
stereochemistry.cc:415:	      SIMPLE_ERROR(BF("Stereoisomer pdb: "+(*it)->getPdb()->__repr__()+" has already been defined"));
stereochemistry.cc:417:	me->_NameOrPdbToStereoisomer.set((*it)->getName(), (*it));
stereochemistry.cc:418:	me->_NameOrPdbToStereoisomer.set((*it)->getPdb(), (*it));
stereochemistry.cc:427:    this->Base::__init__(exec,args,env,lisp);
stereochemistry.cc:428:    core::Cons_sp stereoisomers = env->lookup(Pkg(),"stereoisomers")->as<core::Cons_O>();
stereochemistry.cc:429:    core::Cons_sp restraints = env->lookup(Pkg(),"restraints")->as<core::Cons_O>();
stereochemistry.cc:430:    this->_Stereoisomers.fillFromCons(stereoisomers);
stereochemistry.cc:431:    stereoisomers->setOwnerOfAllEntries(this->sharedThis<StereoInformation_O>());
stereochemistry.cc:432:    this->_NameOrPdbToStereoisomer.clear();
stereochemistry.cc:433:    for ( core::Vector0<Stereoisomer_O>::iterator it = this->_Stereoisomers.begin();
stereochemistry.cc:434:    		it != this->_Stereoisomers.end(); it++ )
stereochemistry.cc:436:	if ( this->_NameOrPdbToStereoisomer.count((*it)->getName()) >0 )
stereochemistry.cc:438:	    SIMPLE_ERROR(BF("Stereoisomer name: "+(*it)->getName()->__repr__()+" has already been defined"));
stereochemistry.cc:440:	if ( this->_NameOrPdbToStereoisomer.count((*it)->getPdb()) >0 )
stereochemistry.cc:442:	    SIMPLE_ERROR(BF("Stereoisomer pdb: "+(*it)->getPdb()->__repr__()+" has already been defined"));
stereochemistry.cc:444:	this->_NameOrPdbToStereoisomer.set((*it)->getName(), (*it));
stereochemistry.cc:445:	this->_NameOrPdbToStereoisomer.set((*it)->getPdb(), (*it));
stereochemistry.cc:449://    core::Cons_sp proChiralCenters = dict->getAndRemoveOrDefault("proChiralCenters",core::Cons_O::_nil)->as<core::Cons_O>();
stereochemistry.cc:450://    proChiralCenters->setOwnerOfAllEntries(this->sharedThis<StereoInformation_O>());
stereochemistry.cc:451://    this->_ProChiralCenters.fillFromCons(proChiralCenters);
stereochemistry.cc:452:    restraints->setOwnerOfAllEntries(this->sharedThis<StereoInformation_O>());
stereochemistry.cc:453:    this->_ComplexRestraints.fillFromCons(restraints);
stereochemistry.cc:469:    for ( mnpi=this->_Stereoisomers.begin();
stereochemistry.cc:470:		mnpi!=this->_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:471:	names->append((*mnpi)->getName()->identifierName());
stereochemistry.cc:485:    for ( mnpi=this->_Stereoisomers.begin();
stereochemistry.cc:486:		mnpi!=this->_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:487:	names->insert((*mnpi)->getName());
stereochemistry.cc:503:    for ( mnpi=this->_Stereoisomers.begin();
stereochemistry.cc:504:		mnpi!=this->_Stereoisomers.end(); mnpi++ ) {
stereochemistry.cc:505:	names->append((*mnpi)->getPdb()->identifierName());
stereochemistry.cc:513:	    .value(_lisp->intern("undefinedConfiguration"), _lisp->intern("U"), undefinedConfiguration )
stereochemistry.cc:514:	    .value(_lisp->intern("S"), S_Configuration )
stereochemistry.cc:515:	    .value(_lisp->intern("R"), R_Configuration )
stereochemistry.cc:518:	    .value(_lisp->intern("undefChirality"), _lisp->intern("u"),undefinedCenter)
stereochemistry.cc:519:	    .value(_lisp->intern("chiral"), _lisp->intern("c"), chiralCenter)
stereochemistry.cc:520:	    .value(_lisp->intern("prochiral"), _lisp->intern("p"), prochiralCenter)
stereochemistry.cc:536://	def("stereochemicalPermutations",&StereoConfiguration_O::stereochemicalPermutations,lisp->lisp());
stereochemistry.cc:551://	defNoWrapPackage(ChemPkg,"stereochemicalPermutations",&prim_stereochemicalPermutations,lisp->lisp());
stereochemistry.cc:552://	defNoWrapPackage(ChemPkg,"StereoConfiguration_createMultiple",&prim_StereoConfiguration_create_multiple,lisp->lisp());
stereochemistry.cc:553://	def("stereochemicalPermutations",&StereoConfiguration_O::stereochemicalPermutations,lisp->lisp());
stereoisomerAtoms.cc:49:	if ( constitutionAtom->isAssignableTo<ConstitutionVirtualAtom_O>() )
stereoisomerAtoms.cc:51:	    ConstitutionVirtualAtom_sp cva = constitutionAtom->as<ConstitutionVirtualAtom_O>();
stereoisomerAtoms.cc:56:	ta->_AtomName = constitutionAtom->_AtomName;
stereoisomerAtoms.cc:57:	ta->_AtomIndex = constitutionAtom->_AtomIndex;
stereoisomerAtoms.cc:58:	ta->_Charge = 0.0;
stereoisomerAtoms.cc:59:	ta->_AtomTypeString = "";
stereoisomerAtoms.cc:65:	this->_AtomName = "";
stereoisomerAtoms.cc:66:	this->_AtomIndex = UndefinedUnsignedInt;
stereoisomerAtoms.cc:67:	this->_AtomTypeString = "";
stereoisomerAtoms.cc:68:	this->_Charge = 0.0;
stereoisomerAtoms.cc:75:	this->Base::archiveBase(node);
stereoisomerAtoms.cc:76:	node->attribute("atomName",this->_AtomName);
stereoisomerAtoms.cc:77:	node->attribute("ci",this->_AtomIndex);
stereoisomerAtoms.cc:78:	node->attribute("charge",this->_Charge);
stereoisomerAtoms.cc:79:	node->attribute("type",this->_AtomTypeString);
stereoisomerAtoms.cc:86:	ss << "( " << this->className() << " ";
stereoisomerAtoms.cc:87:	ss << " :atomName \"" << this->_AtomName << "\"";
stereoisomerAtoms.cc:88:	ss << " :atomIndex " << this->_AtomIndex << " )";
stereoisomerAtoms.cc:117:	StereoisomerVirtualAtom_sp ta = lisp->create<StereoisomerVirtualAtom_O>();
stereoisomerAtoms.cc:118:	ta->_AtomName = atom->_AtomName;
stereoisomerAtoms.cc:119:	ta->_AtomIndex = atom->_AtomIndex;
stereoisomerAtoms.cc:125:	this->Base::initialize();
stereoisomerAtoms.cc:131:	this->Base::archiveBase(node);
stereoisomerAtoms.cc:149:	    .def("stereoisomer-atoms-index",&StereoisomerAtoms_O::index)
stereoisomerAtoms.cc:160:	    .def("stereoisomer-atoms-index",&StereoisomerAtoms_O::index)
stereoisomerAtoms.cc:170:	for ( ConstitutionAtoms_O::iterator it=constitutionAtoms->_Atoms.begin();
stereoisomerAtoms.cc:171:	      it!=constitutionAtoms->_Atoms.end(); it++)
stereoisomerAtoms.cc:175:	    topologyAtoms->_Atoms.append(ta);
stereoisomerAtoms.cc:183:	ConstitutionAtomIndex0N nextIndex = this->_Atoms.size();
stereoisomerAtoms.cc:184:	ca->_AtomIndex = nextIndex;
stereoisomerAtoms.cc:185:	this->_Atoms.append(ca);
stereoisomerAtoms.cc:191:	ASSERTF(idx>=0&&idx<(int)(this->_Atoms.size()),BF("index[%d] out of range") % idx );
stereoisomerAtoms.cc:192:	StereoisomerAtom_sp& ca = this->_Atoms[(uint)idx];
stereoisomerAtoms.cc:193:	ASSERTF(idx==ca->_AtomIndex,BF("A mismatch has occured between the index[%d] in the StereoisomerAtoms array and the StereoisomerAtom index[%d] - these have to match or we can't quickly look up atoms by their index") % idx % ca->_AtomIndex );
stereoisomerAtoms.cc:199:	core::StringSet_sp ss = _lisp->create<core::StringSet_O>();
stereoisomerAtoms.cc:200:	for ( core::Vector0<StereoisomerAtom_O>::const_iterator ci=this->_Atoms.begin();
stereoisomerAtoms.cc:201:	      ci!=this->_Atoms.end(); ci++ )
stereoisomerAtoms.cc:203:	    ss->insert((*ci)->_AtomName);
stereoisomerAtoms.cc:215:	this->Base::archiveBase(n);
stereoisomerAtoms.cc:216:	n->archiveVector0("atoms",this->_Atoms);
stereoisomerAtoms.cc:223:	for ( core::Vector0<StereoisomerAtom_O>::const_iterator ci=this->_Atoms.begin();
stereoisomerAtoms.cc:224:	      ci!=this->_Atoms.end(); ci++ )
stereoisomerAtoms.cc:226:	    if ( (*ci)->_AtomName == nm ) return *ci;
stereoisomerAtoms.cc:234:	return this->_Atoms[id];
stereoisomerAtoms.cc:239:	for ( int idx=0; idx<(int)this->_Atoms.size(); idx++ )
stereoisomerAtoms.cc:241:	    const StereoisomerAtom_sp& atom = this->_Atoms[idx];
stereoisomerAtoms.cc:242:	    if ( atom->_AtomName == name ) return idx;
structureComparer.cc:30:    this->Base::initialize();
structureComparer.cc:31:    this->_AllAtoms.clear();
structureComparer.cc:32:    this->_SuperposeAtoms.clear();
structureComparer.cc:42:    this->_Matter = matter;
structureComparer.cc:43:    this->_AllAtoms.clear();
structureComparer.cc:47:	this->_AllAtoms.insert(a);
structureComparer.cc:49:    this->_SuperposeAtoms.clear();
structureComparer.cc:56:    this->_FixedCoordinates = _lisp->create<addon::CoordinateArray_O>(this->_SuperposeAtoms.size());
structureComparer.cc:58:    for ( oa=this->_SuperposeAtoms.begin(),ia=0; oa!=this->_SuperposeAtoms.end(); oa++,ia++ )
structureComparer.cc:60:        this->_FixedCoordinates->setElement(ia,(*oa)->getPosition());
structureComparer.cc:67:    this->_SuperposeAtoms = atoms;
structureComparer.cc:68:    this->initializeFixedCoordinates();
structureComparer.cc:74:    this->_SuperposeAtoms.clear();
structureComparer.cc:75:    for ( oa=this->_AllAtoms.begin(); oa!=this->_AllAtoms.end(); oa++ )
structureComparer.cc:77:        if ( (*oa)->getElement() != element_H )
structureComparer.cc:79:	    this->_SuperposeAtoms.insert(*oa);
structureComparer.cc:82:    this->initializeFixedCoordinates();
structureComparer.cc:98:    if ( matter != this->_Matter )
structureComparer.cc:103:    if ( this->_SuperposeAtoms.size() < 3 )
structureComparer.cc:107:    LOG(BF("Number of superpose atoms = %d") % this->_SuperposeAtoms.size()  );
structureComparer.cc:114:    moveableCoordinates= _lisp->create<addon::CoordinateArray_O>(this->_SuperposeAtoms.size());
structureComparer.cc:115:    for ( ai=this->_SuperposeAtoms.begin(), i=0;
structureComparer.cc:116:		ai!=this->_SuperposeAtoms.end(); ai++, i++)
structureComparer.cc:118:	LOG(BF("Extracting coordinate for superpose atom(%s)") % (*ai)->getName().c_str()  );
structureComparer.cc:119:	moveableCoordinates->setElement(i,(*ai)->getPosition());
structureComparer.cc:121:    LOG(BF("There are %d superposable atoms") % this->_SuperposeAtoms.size()  );
structureComparer.cc:126:    superposer = _lisp->create<SuperposeEngine_O>();
structureComparer.cc:127:    superposer->setFixedAllPoints(this->_FixedCoordinates);
structureComparer.cc:128:    superposer->setMoveableAllPoints(moveableCoordinates);
structureComparer.cc:130:    this->_TransformToFixed = superposer->superpose();
structureComparer.cc:131:    rms = superposer->rootMeanSquareDifference();
structureComparer.cc:140:    node->archiveObject( "Matter", this->_Matter );
structureComparer.cc:141:    node->archiveOrderedSet( "AllAtoms", this->_AllAtoms );
structureComparer.cc:142:    node->archiveOrderedSet( "SuperposeAtoms", this->_SuperposeAtoms );
structureComparer.cc:143:    node->archiveObject("FixedCoordinates",this->_FixedCoordinates);
structureList.cc:41:    this->Base::initialize();
structureList.cc:43:    this->_Members = 0;
structureList.cc:44:    this->_AllCoordinates = _lisp->create<addon::CoordinateArray_O>();
structureList.cc:45:    this->_SuperposeCoordinates = _lisp->create<addon::CoordinateArray_O>();
structureList.cc:46:    this->_Data = _lisp->create<addon::ObjectDictionary_O>();
structureList.cc:54:    node->archiveWeakPointer( "structureList", this->_WeakStructureList );
structureList.cc:55:    node->archiveObject("allCoords", this->_AllCoordinates );
structureList.cc:56:    node->archiveObject("superposeCoords", this->_SuperposeCoordinates );
structureList.cc:57:    node->archiveObject("data",this->_Data);
structureList.cc:58:    if ( node->loading() )
structureList.cc:61:	LOG(BF("allCoords =%s") % (this->_AllCoordinates->asXmlString().c_str() ) );
structureList.cc:62:	LOG(BF("superposeCoords =%s") % (this->_SuperposeCoordinates->asXmlString().c_str() ) );
structureList.cc:66:	LOG(BF("allCoords =%s") % (this->_AllCoordinates->asXmlString().c_str() ) );
structureList.cc:67:	LOG(BF("superposeCoords =%s") % (this->_SuperposeCoordinates->asXmlString().c_str() ) );
structureList.cc:75:    LOG(BF("setAllCoordinates:%s") % (ac->asXmlString().c_str() ) );
structureList.cc:77:    this->_AllCoordinates = ac;
structureList.cc:82:    LOG(BF("setSuperposeCoordinates:%s") % (ac->asXmlString().c_str() ) );
structureList.cc:83:    this->_SuperposeCoordinates = ac;
structureList.cc:99:    this->Base::initialize();
structureList.cc:100:    this->_RmsCutOff = 0.05;
structureList.cc:101:    this->_Matter = Matter_O::_nil;
structureList.cc:102:    this->_SuperposeAtoms.clear();
structureList.cc:103:    this->_AllAtoms.clear();
structureList.cc:104:    this->_Data = _lisp->create<addon::ObjectDictionary_O>();
structureList.cc:105:    this->clearEntries();
structureList.cc:114:    sl = this->getStructureList();
structureList.cc:115:    for ( ai=sl->begin_AllAtoms(),ci=this->_AllCoordinates->begin(); ai!=sl->end_AllAtoms(); ai++, ci++ )
structureList.cc:117:        (*ai)->setPosition(*ci);
structureList.cc:126:    for ( ci=this->_AllCoordinates->begin(); ci!=this->_AllCoordinates->end(); ci++ )
structureList.cc:130:    for ( ci=this->_SuperposeCoordinates->begin(); ci!=this->_SuperposeCoordinates->end(); ci++ )
structureList.cc:144:    this->_Status->addMessage("extractCoordinatesFromMatter");
structureList.cc:146:    sl = this->getStructureList();
structureList.cc:147:    for ( ai=sl->begin_AllAtoms(),ci=this->_AllCoordinates->begin(); ai!=sl->end_AllAtoms(); ai++, ci++ )
structureList.cc:149:        *ci = (*ai)->getPosition();
structureList.cc:151:    for ( ai=sl->begin_SuperposeAtoms(),ci=this->_SuperposeCoordinates->begin(); ai!=sl->end_SuperposeAtoms(); ai++, ci++ )
structureList.cc:153:        *ci = (*ai)->getPosition();
structureList.cc:159:    this->_Entries.clear();
structureList.cc:169:    this->_Matter = matter;
structureList.cc:170:    this->_AllAtoms.clear();
structureList.cc:174:	this->_AllAtoms.insert(a);
structureList.cc:176:    this->_SuperposeAtoms.clear();
structureList.cc:193:    if ( matter != this->_Matter )
structureList.cc:198:    if ( this->_SuperposeAtoms.size() < 4 )
structureList.cc:202:    LOG(BF("Number of superpose atoms = %d") % this->_SuperposeAtoms.size()  );
structureList.cc:209:    newConf = addon::CoordinateArray_O::create(this->_SuperposeAtoms.size(),_lisp);
structureList.cc:210:    for ( ai=this->_SuperposeAtoms.begin(), i=0;
structureList.cc:211:		ai!=this->_SuperposeAtoms.end(); ai++, i++)
structureList.cc:213:	LOG(BF("Extracting coordinate for superpose atom(%s)") % (*ai)->getName().c_str()  );
structureList.cc:214:	newConf->setElement(i,(*ai)->getPosition());
structureList.cc:216:    LOG(BF("There are %d superposable atoms") % this->_SuperposeAtoms.size()  );
structureList.cc:220:	LOG(BF("Fixed points at the start of superposer: %s") % (newConf->asXmlString().c_str() ) );
structureList.cc:227:	    superposer = _lisp->create<SuperposeEngine_O>();
structureList.cc:228:	    superposer->setFixedAllPoints(newConf);
structureList.cc:234:		// Loop through the low-high entry range and compare the structures
structureList.cc:237:	    for ( ci=this->_Entries.begin(); ci!=this->_Entries.end(); ci++ )
structureList.cc:239:	        moveable = (*ci)->getSuperposeCoordinates();
structureList.cc:240:		LOG(BF("Moveable points before superpose:%s") % (moveable->asXmlString().c_str() ) );
structureList.cc:241:		superposer->setMoveableAllPoints(moveable);
structureList.cc:242:		transform = superposer->superpose();
structureList.cc:243:		rms = superposer->rootMeanSquareDifference();
structureList.cc:244:		LOG(BF("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)") % rms % i % this->_RmsCutOff  );
structureList.cc:245:		if ( rms < this->_RmsCutOff )
structureList.cc:249:		    (*ci)->setMembers((*ci)->getMembers()+1);
structureList.cc:252:	    	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf->asXmlString().c_str() ) );
structureList.cc:255:		LOG(BF("Moveable points after superpose:%s") % (moveable->asXmlString().c_str() ) );
structureList.cc:257:	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf->asXmlString().c_str() ) );
structureList.cc:264:    entry = Structure_Old_ListEntry_O::create(this->sharedThis<Structure_Old_List_O>(),_lisp);
structureList.cc:265:    entry->setMembers(1);
structureList.cc:270:    newConf = addon::CoordinateArray_O::create(this->_AllAtoms.size(),_lisp);
structureList.cc:271:    for ( lai=this->_AllAtoms.begin(),i=0;
structureList.cc:272:		lai!=this->_AllAtoms.end(); lai++, i++)
structureList.cc:274:	newConf->setElement(i,(*lai)->getPosition());
structureList.cc:276:    entry->setAllCoordinates(newConf);
structureList.cc:281:    newConf = addon::CoordinateArray_O::create(this->_SuperposeAtoms.size(),_lisp);
structureList.cc:282:    for ( ai=this->_SuperposeAtoms.begin(),i=0;
structureList.cc:283:		ai!=this->_SuperposeAtoms.end(); ai++, i++)
structureList.cc:285:	newConf->setElement(i,(*ai)->getPosition());
structureList.cc:287:    LOG(BF("Writing superpose coordinates to entry:%s") % (newConf->asXmlString().c_str() ) );
structureList.cc:288:    entry->setSuperposeCoordinates(newConf);
structureList.cc:294:    this->_Entries.append(entry);
structureList.cc:305:    matter = orig->getMatter();
structureList.cc:306:    ASSERTP(matter==this->getMatter(),"The Matter objects must match");
structureList.cc:307:    for ( si=orig->begin_Entries(); si!=orig->end_Entries(); si++ )
structureList.cc:309:        (*si)->writeCoordinatesToMatter(matter);
structureList.cc:310:	entry = this->createStructureListEntryIfConformationIsNew(matter);
structureList.cc:314:            this->addEntry(entry);
structureList.cc:327:    this->_SuperposeAtoms = atoms;
structureList.cc:333:    this->_SuperposeAtoms.insert(a);
structureList.cc:341:    this->_SuperposeAtoms.clear();
structureList.cc:342:    for ( oa=this->_AllAtoms.begin(); oa!=this->_AllAtoms.end(); oa++ )
structureList.cc:344:        if ( (*oa)->getElement() != element_H )
structureList.cc:346:	    this->_SuperposeAtoms.insert(*oa);
structureList.cc:357:    node->archiveObject( "Matter", this->_Matter );
structureList.cc:358:    node->archiveObjectIfDefined( "Data", this->_Data );
structureList.cc:359:    node->archiveVector0( "Entries", this->_Entries );
structureList.cc:360:    node->archiveOrderedSet( "AllAtoms", this->_AllAtoms );
structureList.cc:361:    node->archiveOrderedSet( "SuperposeAtoms", this->_SuperposeAtoms );
structureList.cc:362:    node->attribute( "RmsCutOff", this->_RmsCutOff );
structureList.cc:369:    this->archiveBase(node);
structureList.cc:380:    xml = _lisp->create<core::XmlLoadArchive_O>();
structureList.cc:381:    xml->parse(fn);
structureList.cc:382:    res = downcast<Structure_Old_List_O>(xml->get("structureList"));
structureList.cc:393:    xml = _lisp->create<core::XmlSaveArchive_O>();
structureList.cc:394:    xml->put("structureList",this->sharedThis<Structure_Old_List_O>());
structureList.cc:395:    xml->saveAs(fn);
structureList.cc:413:    frames = _lisp->create<addon::FrameList_O>();
structureList.cc:414:    matter = this->getMatter();
structureList.cc:415:    if ( this->_Entries.size() == 0 )
structureList.cc:417:	dlMatter = _lisp->create<GrPickableMatter_O>();
structureList.cc:418:	dlMatter->setName(_lisp->internKeyword("molecule"));
structureList.cc:419:	dlMatter->setFromMatter(matter);
structureList.cc:420:	frames->add(dlMatter);
structureList.cc:423:	for ( si=this->begin_Entries(); si!=this->end_Entries(); si++ )
structureList.cc:425:	    parts = _lisp->create<addon::DisplayList_O>();
structureList.cc:426:	    (*si)->writeCoordinatesToMatter(matter);
structureList.cc:427:	    dlMatter = _lisp->create<GrPickableMatter_O>();
structureList.cc:428:	    dlMatter->setName(_lisp->internKeyword("molecule"));
structureList.cc:429:	    dlMatter->setFromMatter(matter);
structureList.cc:430:	    parts->append(dlMatter);
structureList.cc:431:	    dlSuperpose = _lisp->create<addon::DisplayList_O>();
structureList.cc:432:	    dlSuperpose->setName(_lisp->internKeyword("superpose"));
structureList.cc:434:	    dlSuperpose->append(grColor);
structureList.cc:435:	    superposeCoords = (*si)->getSuperposeCoordinates();
structureList.cc:436:	    grSpheres = _lisp->create<O_GrSphereList>();
structureList.cc:437:	    grSpheres->setRadius(0.2);
structureList.cc:438:	    for ( ci=superposeCoords->begin(); ci!=superposeCoords->end(); ci++ )
structureList.cc:440:		grSpheres->addVertex(*ci);
structureList.cc:442:	    dlSuperpose->append(grSpheres);
structureList.cc:443:	    parts->append(dlSuperpose);
structureList.cc:444:	    frames->add(parts);
structureList.cc:457:    ASSERT_lessThan(i,this->_Entries.size());
structureList.cc:459:    e = this->_Entries[i];
superposableConformationCollection.cc:26:    this->Base::initialize();
superposableConformationCollection.cc:27:    this->_SuperposeAtomIndices = core::IntArray_O::create();
superposableConformationCollection.cc:28:    this->_RmsCutOff = 0.1;
superposableConformationCollection.cc:42:    this->ConformationCollection_O::archive(node);
superposableConformationCollection.cc:43:    node->attribute("RmsCutOff",this->_RmsCutOff);
superposableConformationCollection.cc:44:    node->archiveObject("SuperposeAtomIndices",this->_SuperposeAtomIndices);
superposableConformationCollection.cc:53:    ASSERTNOTNULL(this->_SuperposeAtomIndices);
superposableConformationCollection.cc:54:    this->_SuperposeAtomIndices->clear();
superposableConformationCollection.cc:63:    ASSERTNOTNULL(this->_SuperposeAtomIndices);
superposableConformationCollection.cc:64:    for ( idx=0,ai=this->begin_AllAtoms(); ai!=this->end_AllAtoms(); idx++,ai++ )
superposableConformationCollection.cc:68:	    this->_SuperposeAtomIndices->append(idx);
superposableConformationCollection.cc:72:    SIMPLE_ERROR(BF("You cannot add superpose atom: "+a->description()+" because it isn't in the ConformationCollection"));
superposableConformationCollection.cc:79:    this->clearSuperposeAtoms();
superposableConformationCollection.cc:82:        this->addSuperposeAtom(*ai);
superposableConformationCollection.cc:90:    ASSERTNOTNULL(this->_SuperposeAtomIndices);
superposableConformationCollection.cc:91:    this->clearSuperposeAtoms();
superposableConformationCollection.cc:92:    for ( idx=0,ai=this->begin_AllAtoms(); ai!=this->end_AllAtoms(); idx++,ai++ )
superposableConformationCollection.cc:94:        if ( (*ai)->getElement() != element_H )
superposableConformationCollection.cc:96:	    this->_SuperposeAtomIndices->append(idx);
superposableConformationCollection.cc:107:    ASSERTNOTNULL(this->_SuperposeAtomIndices);
superposableConformationCollection.cc:108:    for ( si=this->_SuperposeAtomIndices->begin();si!=this->_SuperposeAtomIndices->end(); si++ )
superposableConformationCollection.cc:110:        a = this->_AllAtoms[*si];
superposableConformationCollection.cc:119:    return this->_SuperposeAtomIndices->size();
superposableConformationCollection.cc:133:    ASSERT(matter==this->_Matter);
superposableConformationCollection.cc:134:    LOG(BF("Number of superpose atoms = %d") % this->_SuperposeAtomIndices->size()  );
superposableConformationCollection.cc:135:    ASSERT(this->_SuperposeAtomIndices->size() >= 4 );
superposableConformationCollection.cc:142:    newConf = this->_extractCoordinateArray(matter);
superposableConformationCollection.cc:146:	LOG(BF("Fixed points at the start of superposer: %s") % (newConf->asXmlString().c_str() ) );
superposableConformationCollection.cc:153:	    superposer = _lisp->create<SuperposeEngine_O>();
superposableConformationCollection.cc:154:	    superposer->setFixedPoints(this->_SuperposeAtomIndices,newConf);
superposableConformationCollection.cc:160:		// Loop through the low-high entry range and compare the structures
superposableConformationCollection.cc:163:	    for ( ci=this->_Entries.begin(); ci!=this->_Entries.end(); ci++ )
superposableConformationCollection.cc:165:	        moveable = (*ci)->getAllCoordinates();
superposableConformationCollection.cc:166:		LOG(BF("Moveable points before superpose:%s") % (moveable->asXmlString()) );
superposableConformationCollection.cc:167:		superposer->setMoveablePoints(this->_SuperposeAtomIndices, moveable);
superposableConformationCollection.cc:169:		transform = superposer->superpose();
superposableConformationCollection.cc:170:		rms = superposer->rootMeanSquareDifference();
superposableConformationCollection.cc:173:		LOG(BF("The rms difference(%lf) with structure(%d) " "compared to _RmsCutOff(%lf)") % rms % i % this->_RmsCutOff  );
superposableConformationCollection.cc:175:		if ( rms < this->_RmsCutOff )
superposableConformationCollection.cc:181:	    	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf->asXmlString().c_str() ) );
superposableConformationCollection.cc:184:		LOG(BF("Moveable points after superpose:%s") % (moveable->asXmlString().c_str() ) );
superposableConformationCollection.cc:186:	    LOG(BF("Fixed points at the end of superposer: %s") % (newConf->asXmlString().c_str() ) );
superposableConformationCollection.cc:193:    entry = this->createEntry();
superposableConformationCollection.cc:194:    entry->setAllCoordinates(newConf);
superposableConformationCollection.cc:212:    frames = _lisp->create<addon::FrameList_O>();
superposableConformationCollection.cc:213:    matter = this->getMatter();
superposableConformationCollection.cc:214:    for ( si=this->begin_Entries(); si!=this->end_Entries(); si++ )
superposableConformationCollection.cc:216:        (*si)->writeCoordinatesToMatter(matter);
superposableConformationCollection.cc:217:	dlAll = _lisp->create<addon::DisplayList_O>();
superposableConformationCollection.cc:218:	dlMatter = _lisp->create<GrPickableMatter_O>();
superposableConformationCollection.cc:219:	dlMatter->setName(_lisp->internKeyword("minimized"));
superposableConformationCollection.cc:220:	dlMatter->setFromMatter(matter);
superposableConformationCollection.cc:221:	dlAll->add(dlMatter);
superposableConformationCollection.cc:222:	dlSuperpose = _lisp->create<addon::DisplayList_O>();
superposableConformationCollection.cc:223:	dlSuperpose->setName(_lisp->internKeyword("superposeAtoms"));
superposableConformationCollection.cc:224:	dlSuperpose->add(O_GrColor::systemColor(_kw_yellow));
superposableConformationCollection.cc:225:	RPGrSphereList sphereList = _lisp->create<O_GrSphereList>();
superposableConformationCollection.cc:226:	sphereList->setRadius(0.2);
superposableConformationCollection.cc:227:	for ( ii=this->_SuperposeAtomIndices->begin(); ii!=this->_SuperposeAtomIndices->end(); ii++ )
superposableConformationCollection.cc:229:	    sphereList->addVertex(this->_AllAtoms[*ii]->getPosition());
superposableConformationCollection.cc:231:	dlSuperpose->add(sphereList);
superposableConformationCollection.cc:232:	dlAll->add(dlSuperpose);
superposableConformationCollection.cc:233:	frames->add(dlAll);
superposableConformationCollection.cc:246:    superposer->setFixedPoints(this->_SuperposeAtomIndices,
superposableConformationCollection.cc:247:    				entry->getAllCoordinates());
superposableConformationCollection.cc:255:    superposer->setMoveablePoints(this->_SuperposeAtomIndices,
superposableConformationCollection.cc:256:    				entry->getAllCoordinates());
superposeEngine.cc:81:    this->Base::archiveBase(node);
superposeEngine.cc:82:    node->archiveObject("fixedIndices",this->_FixedIndices);
superposeEngine.cc:83:    node->archiveObject("fixedCoordinates",this->_FixedCoordinates);
superposeEngine.cc:84:    node->archiveObject("moveableIndices",this->_MoveableIndices);
superposeEngine.cc:85:    node->archiveObject("moveableCoordinates",this->_MoveableCoordinates);
superposeEngine.cc:94:	for (uint i=0; i<this->_FixedIndices->size(); i++ )
superposeEngine.cc:96:	    int idx = this->_FixedIndices->get(i);
superposeEngine.cc:97:	    ss << "Fixed#" << i << " " << this->_FixedCoordinates->getElement(idx).asString() << endl;
superposeEngine.cc:99:	for (uint j=0; j<this->_MoveableIndices->size(); j++ )
superposeEngine.cc:101:	    int idx = this->_MoveableIndices->get(j);
superposeEngine.cc:102:	    ss << "Moveable#" << j << " " << this->_MoveableCoordinates->getElement(idx).asString() << endl;
superposeEngine.cc:123:    ASSERTP(indices->size()<=pnts->size(),"There must be at least as many indices as coordinates");
superposeEngine.cc:125:    if ( indices->size() == 0 ) return pos;
superposeEngine.cc:127:    for ( it=indices->begin();
superposeEngine.cc:128:	  it!=indices->end();
superposeEngine.cc:130:	pos = pos + pnts->getElement(*it);
superposeEngine.cc:132:    pos = pos.multiplyByScalar(1.0/((double)(indices->size())));
superposeEngine.cc:138:    this->Base::initialize();
superposeEngine.cc:139:    this->_FixedIndices = _lisp->create<core::IntArray_O>();
superposeEngine.cc:140:    this->_MoveableIndices = _lisp->create<core::IntArray_O>();
superposeEngine.cc:141:    this->_FixedCoordinates = _lisp->create<addon::CoordinateArray_O>();
superposeEngine.cc:142:    this->_MoveableCoordinates = _lisp->create<addon::CoordinateArray_O>();
superposeEngine.cc:149:    this->_MoveableIndices->clear();
superposeEngine.cc:150:    this->_MoveableCoordinates->clear();
superposeEngine.cc:155:    this->_FixedIndices->clear();
superposeEngine.cc:156:    this->_FixedCoordinates->clear();
superposeEngine.cc:161:    ASSERT(this->_MoveableIndices.notnilp());
superposeEngine.cc:162:    ASSERT(this->_MoveableCoordinates.notnilp());
superposeEngine.cc:164:    int idx = this->_MoveableCoordinates->size();
superposeEngine.cc:165:    this->_MoveableIndices->append(idx);
superposeEngine.cc:166:    this->_MoveableCoordinates->push_back(pos);
superposeEngine.cc:167:    LOG(BF("There are now %d MoveableIndices") % this->_MoveableIndices->size());
superposeEngine.cc:168:    LOG(BF("There are now %d MoveableCoordinates") % this->_MoveableCoordinates->size());
superposeEngine.cc:173:    ASSERT(this->_FixedIndices.notnilp());
superposeEngine.cc:174:    ASSERT(this->_FixedCoordinates.notnilp());
superposeEngine.cc:176:    int idx = this->_FixedCoordinates->size();
superposeEngine.cc:177:    this->_FixedIndices->append(idx);
superposeEngine.cc:178:    this->_FixedCoordinates->push_back(pos);
superposeEngine.cc:179:    LOG(BF("There are now %d FixedIndices") % this->_FixedIndices->size());
superposeEngine.cc:180:    LOG(BF("There are now %d FixedCoordinates") % this->_FixedCoordinates->size());
superposeEngine.cc:187:    return this->_FixedIndices->size();
superposeEngine.cc:193:    return this->_MoveableIndices->size();
superposeEngine.cc:212:    fixedIndicesSize = this->_FixedIndices->size();
superposeEngine.cc:213:    moveableIndicesSize = this->_MoveableIndices->size();
superposeEngine.cc:217:    Sj.resize(this->_FixedIndices->size());
superposeEngine.cc:218:    if ( this->_MoveableIndices->size() < 3 )
superposeEngine.cc:222:    Si.resize(this->_MoveableIndices->size());
superposeEngine.cc:223:    LOG(BF("this->_FixedIndices->size()=%d") % this->_FixedIndices->size()  );
superposeEngine.cc:224:    LOG(BF("this->_MoveableIndices->size()=%d") % this->_MoveableIndices->size()  );
superposeEngine.cc:227:	fixedCenter = geometricCenterOfPointsIndirect(this->_FixedIndices,this->_FixedCoordinates);
superposeEngine.cc:230:	for ( iaV=this->_FixedIndices->begin(),itS=Sj.begin();
superposeEngine.cc:231:	      iaV!=this->_FixedIndices->end();
superposeEngine.cc:233:	    LOG(BF("index=%d   *iaV=%d    pnt=%s") % (iaV-this->_FixedIndices->begin()) 
superposeEngine.cc:234:		% *iaV % this->_FixedCoordinates->getElement(*iaV).asString().c_str() ); 
superposeEngine.cc:235:	    *itS = this->_FixedCoordinates->getElement(*iaV) - fixedCenter;
superposeEngine.cc:240:	for ( iaV=this->_MoveableIndices->begin(); iaV !=this->_MoveableIndices->end(); iaV++ ) {
superposeEngine.cc:241:	    moveableCenter = this->_MoveableCoordinates->getElement(*iaV) + moveableCenter;
superposeEngine.cc:243:	moveableCenter = moveableCenter.multiplyByScalar(1.0/(double)(this->_MoveableIndices->size()));
superposeEngine.cc:245:	for ( iaV=this->_MoveableIndices->begin(),itS=Si.begin();
superposeEngine.cc:248:	    *itS = this->_MoveableCoordinates->getElement(*iaV) - moveableCenter;
superposeEngine.cc:250:		% (iaV-this->_MoveableIndices->begin())
superposeEngine.cc:252:		% this->_FixedCoordinates->getElement(*iaV).asString().c_str() );
superposeEngine.cc:261:	X0 = itSj->getX();
superposeEngine.cc:262:	X1 = itSj->getY();
superposeEngine.cc:263:	X2 = itSj->getZ();
superposeEngine.cc:264:	x0 = itSi->getX();
superposeEngine.cc:265:	x1 = itSi->getY();
superposeEngine.cc:266:	x2 = itSi->getZ();
superposeEngine.cc:290:    P = M + (MT - (trM*2.0));
superposeEngine.cc:291:    P.atRowColPut(0,3,M.atRowCol(1,2)-M.atRowCol(2,1));
superposeEngine.cc:293:    P.atRowColPut(1,3,M.atRowCol(2,0)-M.atRowCol(0,2));
superposeEngine.cc:295:    P.atRowColPut(2,3,M.atRowCol(0,1)-M.atRowCol(1,0));
superposeEngine.cc:319:    rot.atRowColPut( 0,0, ll - mm - nn + ss );
superposeEngine.cc:320:    rot.atRowColPut( 0,1,  2*(l*m - n*s));
superposeEngine.cc:323:    rot.atRowColPut( 1,1,  -ll + mm - nn + ss);
superposeEngine.cc:324:    rot.atRowColPut( 1,2,  2*(m*n - l*s));
superposeEngine.cc:325:    rot.atRowColPut( 2,0,  2*(l*n - m*s));
superposeEngine.cc:327:    rot.atRowColPut( 2,2,  -ll - mm + nn + ss);
superposeEngine.cc:330:    vTemp = moveableCenter*-1.0;
superposeEngine.cc:338:    this->_Transform = trans*mat;
superposeEngine.cc:354:    ASSERTNOTNULL(this->_MoveableIndices);
superposeEngine.cc:355:    ASSERTNOTNULL(this->_FixedIndices);
superposeEngine.cc:358:    LOG_SCORE(scorerState,BF("There are %d moveable indices")%this->_MoveableIndices->size() );
superposeEngine.cc:359:    LOG_SCORE(scorerState,BF("There are %d fixed indices")%this->_FixedIndices->size() );
superposeEngine.cc:360:    for ( ititMoved = this->_MoveableIndices->begin(),
superposeEngine.cc:361:	      itFixed = this->_FixedIndices->begin();
superposeEngine.cc:362:	  itFixed != this->_FixedIndices->end();
superposeEngine.cc:366:		  this->_FixedCoordinates->getElement(*itFixed).asString()
superposeEngine.cc:367:		  % this->_MoveableCoordinates->getElement(*ititMoved).asString()
superposeEngine.cc:370:    LOG_SCORE(BF(scorerState,"SuperposeEngine_O calculated transform\n%s")% this->_Transform.asString());
superposeEngine.cc:372:    double result = this->sumOfSquaresOfDifferences();
superposeEngine.cc:391:    ASSERTNOTNULL(this->_MoveableIndices);
superposeEngine.cc:392:    ASSERTNOTNULL(this->_FixedIndices);
superposeEngine.cc:394:    LOG(BF("There are %d moveable indices") % this->_MoveableIndices->size()  );
superposeEngine.cc:395:    LOG(BF("There are %d fixed indices") % this->_FixedIndices->size()  );
superposeEngine.cc:396:    for ( ititMoved = this->_MoveableIndices->begin(),
superposeEngine.cc:397:	      itFixed = this->_FixedIndices->begin();
superposeEngine.cc:398:	  itFixed != this->_FixedIndices->end();
superposeEngine.cc:402:	    % this->_FixedCoordinates->getElement(*itFixed).asString()
superposeEngine.cc:403:	    % this->_MoveableCoordinates->getElement(*ititMoved).asString() );
superposeEngine.cc:406:    ASSERT(this->_FixedIndices->size()!=0);
superposeEngine.cc:408:    for ( ititMoved = this->_MoveableIndices->begin(),
superposeEngine.cc:409:	      itFixed = this->_FixedIndices->begin();
superposeEngine.cc:410:	  itFixed != this->_FixedIndices->end();
superposeEngine.cc:412:	moved = this->_Transform.multiplyByVector3(this->_MoveableCoordinates->getElement(*ititMoved));
superposeEngine.cc:413:	diff = this->_FixedCoordinates->getElement(*itFixed)-moved;
superposeEngine.cc:427:    double sumOfSquares = this->sumOfSquaresOfDifferences();
superposeEngine.cc:428:    LOG(BF("Number of moveable indices = %d") % this->_MoveableIndices->size() );
superposeEngine.cc:429:    ASSERT_gt(this->_MoveableIndices->size(),0);
superposeEngine.cc:431:    double meanSumOfSquares = sumOfSquares/this->_MoveableIndices->size();
superposeEngine.cc:445:    LOG(BF("SuperposeEngine_O::setFixedPoints --> number of points=%d") % fc->size()  );
superposeEngine.cc:446:    if ( !((fi->size()>=3) && ((fi->size()<=fc->size()))) )
superposeEngine.cc:449:	ss << "In SuperposeEngine setFixedPoints - number of indices fi->size() = ";
superposeEngine.cc:450:	ss << fi->size() << " must be at least 3"<< endl;
superposeEngine.cc:451:	ss << "Number of coordinates --> fc->size() = ";
superposeEngine.cc:452:	ss << fc->size() << " must be greator than or equal to fi->size(";
superposeEngine.cc:453:	ss << fi->size() << ")" << endl;
superposeEngine.cc:455:	THROW(_lisp->create<core::ContentException_O>(ss.str()));
superposeEngine.cc:457:    this->_FixedIndices = fi;
superposeEngine.cc:458:    this->_FixedCoordinates = fc;
superposeEngine.cc:467:    this->_FixedCoordinates = fc;
superposeEngine.cc:468:    this->_FixedIndices = core::IntArray_O::create(fc->size(),_lisp);
superposeEngine.cc:470:    for ( ii=0; ii<fc->size(); ii++ )
superposeEngine.cc:472:        this->_FixedIndices->put(ii,ii);
superposeEngine.cc:482:    LOG(BF("SuperposeEngine_O::setMoveablePoints --> number of points=%d") % mc->size()  );
superposeEngine.cc:483:    ASSERTP( (mi->size()>=3), "There must be at least three indices" );
superposeEngine.cc:484:    ASSERTP( mi->size()<=mc->size(), "There must be at least as many coordinates as indices");
superposeEngine.cc:485:    this->_MoveableIndices = mi;
superposeEngine.cc:486:    this->_MoveableCoordinates = mc->copy();
superposeEngine.cc:493:    ASSERTF(mc->size()>=3,BF("You must have at least three moveable points and there are only %d") % mc->size() );
superposeEngine.cc:494:    this->_MoveableCoordinates = mc;
superposeEngine.cc:495:    this->_MoveableIndices = core::IntArray_O::create(mc->size(),_lisp);
superposeEngine.cc:496:    for ( ii=0; ii<mc->size(); ii++ )
superposeEngine.cc:498:        this->_MoveableIndices->put(ii,ii);
superposeEngine.cc:512:    this->doSuperpose();
superposeEngine.cc:513:    LOG(BF("Carried out superpose and the transform is:%s") % (this->_Transform.asString().c_str() ) );
superposeEngine.cc:514:    return this->_Transform;
superposeEngine.cc:541:    this->Base::initialize();
superposeEngine.cc:542:    this->_Matter = Matter_O::_nil;
superposeEngine.cc:543:    this->_SuperposeAtoms.clear();
superposeEngine.cc:550:    this->Base::archiveBase(node);
superposeEngine.cc:551:    node->archiveObject("matter",this->_Matter);
superposeEngine.cc:552:    node->archiveVector0("superposeAtoms",this->_SuperposeAtoms);
superposeEngine.cc:560:    this->_SuperposeAtoms.clear();
superposeEngine.cc:561:    lAtoms.loopTopGoal(this->_Matter,ATOMS);
superposeEngine.cc:568:	if ( a->getPropertyOrDefault(superposeSymbol,_lisp->_boolean(true))->isTrue() )
superposeEngine.cc:570:	    this->_SuperposeAtoms.push_back(a);
superposeEngine.cc:577:    ASSERT_gt(this->_SuperposeAtoms.size(),0);
superposeEngine.cc:583:    this->_Matter = matter->copy();
superposeEngine.cc:584:    this->_SuperposeAtoms.clear();
superposeEngine.cc:589:    this->setMatter(matter);
superposeEngine.cc:590:    this->updateSuperposeAtoms();
superposeEngine.cc:597:    if ( !this->_Matter->equal(matter) )
superposeEngine.cc:601:    this->_Matter->transferCoordinates(matter);
superposeEngine.cc:602:    ASSERT_gt(this->_SuperposeAtoms.size(),0);
superposeEngine.cc:603:    addon::CoordinateArray_sp coords = _lisp->create<addon::CoordinateArray_O>(this->_SuperposeAtoms.size());
superposeEngine.cc:605:    for (core::Vector0<Atom_O>::iterator ai=this->_SuperposeAtoms.begin(); ai!=this->_SuperposeAtoms.end(); ai++, idx++ )
superposeEngine.cc:607:	coords->setElement(idx,(*ai)->getPosition());
superposeEngine.cc:615:    return this->_Matter;
superposeEngine.cc:620:    addon::CoordinateArray_sp ca = this->extractCoordinates(matter);
superposeEngine.cc:621:    ASSERT_gt(ca->size(),0);
superposeEngine.cc:622:    this->setFixedAllPoints(ca);
superposeEngine.cc:627:    addon::CoordinateArray_sp ca = this->extractCoordinates(matter);
superposeEngine.cc:628:    ASSERT_gt(ca->size(),0);
superposeEngine.cc:629:    this->setMoveableAllPoints(ca);
table.cc:50:	TableEntry_sp entry = lisp->create<TableEntry_O>();
table.cc:52://	entry->setOwner(owner);
table.cc:53:	entry->_Fields.resize(numFields,core::T_O::_nil);
table.cc:79:	this->Base::initialize();
table.cc:85://	return this->owner()->as<Table_O>();
table.cc:93:	this->Base::archiveBase(node);
table.cc:94:	node->archiveVector0("fields",this->_Fields);
table.cc:101:	Table_sp table = this->getTable();
table.cc:102:	uint fieldIdx = table->indexOfField(fieldSymbol);
table.cc:103:	return this->_Fields.get(fieldIdx);
table.cc:108:	ASSERT_lt(fieldIndex,this->_Fields.size());
table.cc:109:	return this->_Fields.get(fieldIndex);
table.cc:114:	Table_sp table = this->getTable();
table.cc:115:	uint fieldIdx = table->indexOfField(fieldSymbol);
table.cc:116:	this->_Fields.set(fieldIdx,obj);
table.cc:121:	ASSERT_lt(fieldIndex,this->_Fields.size());
table.cc:122:	this->_Fields.set(fieldIndex,obj);
table.cc:130:	this->_Fields.push_back(val);
table.cc:131:	return this->_Fields.size()-1;
table.cc:138:	ASSERT_lt(position,this->_Fields.size());
table.cc:140:	it = this->_Fields.begin()+position;
table.cc:141:	this->_Fields.insert(it,val);
table.cc:152:	for ( si=this->_Fields.begin(), idx=0;
table.cc:153:	      si!=this->_Fields.end(); si++,idx++ )
table.cc:155:	    if ( (*si)->canRender() )
table.cc:157:		addon::Render_sp rend = (*si)->rendered(opts);
table.cc:158:		rend->setName(this->getTable()->fieldSymbol(idx));
table.cc:159:		dl->append(rend);
table.cc:163:		ss << this->getTable()->fieldSymbol(idx)->fullName() << " -> ";
table.cc:164:		ss << (*si)->__repr__() << endl;
table.cc:166:		dl->append(info);
table.cc:177:	for ( core::Vector0<core::T_O>::const_iterator fi=this->_Fields.begin(); fi!=this->_Fields.end(); fi++, idx++ )
table.cc:179:	    ss << this->getTable()->fieldSymbol(idx)->fullName() << " -> " << (*fi)->__repr__() << endl;
table.cc:240:	this->Base::initialize();
table.cc:246:	this->Base::archiveBase(node);
table.cc:247:	if ( node->saving() )
table.cc:250:	    for ( core::Vector0<core::Symbol_O>::iterator si=this->_FieldSymbols.begin(); si!=this->_FieldSymbols.end(); si++ )
table.cc:252:		symbolNames.push_back((*si)->fullName());
table.cc:254:	    node->archiveVectorStrings("symbolNames",symbolNames);
table.cc:256:	    for ( core::Vector0<core::Class_O>::iterator ci=this->_FieldClasses.begin(); ci!=this->_FieldClasses.end(); ci++ )
table.cc:258:		classNames.push_back((*ci)->instanceClassName());
table.cc:260:	    node->archiveVectorStrings("classNames",classNames);
table.cc:264:	    node->archiveVectorStrings("symbolNames",symbolNames);
table.cc:266:	    node->archiveVectorStrings("classNames",classNames);
table.cc:268:	    this->_FieldSymbols.clear();
table.cc:269:	    this->_FieldClasses.clear();
table.cc:270:	    this->_FieldIndices.clear();
table.cc:274:		core::Symbol_sp fieldSymbol = _lisp->intern(*si);
table.cc:275:		this->_FieldSymbols.push_back(fieldSymbol);
table.cc:276:		core::Class_sp mc = _lisp->classFromClassName(*ci);
table.cc:277:		if ( mc->isNil() )
table.cc:279:		    core::Symbol_sp classSymbol = _lisp->intern(*ci);
table.cc:282:		    mc = _lisp->defineStandardClass(classSymbol,core::T_O::_nil,core::Cons_O::_nil);
table.cc:285:		this->_FieldClasses.push_back(mc);
table.cc:286:		this->_FieldIndices[fieldSymbol] = idx;
table.cc:289:	node->archiveVector0("entries",this->_Entries);
table.cc:290:	if ( node->loading() )
table.cc:292:	    this->_Entries.setOwnerOfAll(this->sharedThis<Table_O>());
table.cc:299:	ASSERT_lt(idx,this->_FieldSymbols.size());
table.cc:300:	return this->_FieldSymbols.get(idx);
table.cc:306:	map<core::Symbol_sp,uint>::iterator pi = this->_FieldIndices.find(positionSymbol);
table.cc:307:	if ( pi==this->_FieldIndices.end() )
table.cc:309:	    SIMPLE_ERROR(BF("This table doesn't contain the field(%s)") % positionSymbol->fullName() );
table.cc:311:	return pi->second;
table.cc:317:	return (this->_FieldIndices.count(fieldSymbol) != 0);
table.cc:322:	if ( this->hasField(fieldSymbol) )
table.cc:324:	    return this->_FieldClasses[this->_FieldIndices[fieldSymbol]];
table.cc:332:	if ( this->_FieldIndices.count(fieldSymbol) != 0 )
table.cc:334:	    SIMPLE_ERROR(BF("This table already contains a field named(%s)") % fieldSymbol->fullName() );
table.cc:336:	uint idx = this->_FieldSymbols.size();
table.cc:337:	this->_FieldSymbols.push_back(fieldSymbol);
table.cc:338:	this->_FieldClasses.push_back(fieldClass);
table.cc:339:	for ( uint idx=0; idx<this->numberOfEntries(); idx++ )
table.cc:341:	    this->_Entries.get(idx)->appendField(core::T_O::_nil);
table.cc:343:	this->_FieldIndices[fieldSymbol] = idx;
table.cc:349:	uint pos = this->indexOfField(positionSymbol);
table.cc:350:	this->_FieldSymbols.insert(this->_FieldSymbols.begin()+pos,fieldSymbol);
table.cc:351:	this->_FieldClasses.insert(this->_FieldClasses.begin()+pos,fieldClass);
table.cc:356:	for ( pi=this->_FieldIndices.begin(); pi!=this->_FieldIndices.end(); pi++ )
table.cc:358:	    if ( pos <= pi->second )
table.cc:360:		pi->second++;
table.cc:363:	this->_FieldIndices[fieldSymbol] = pos;
table.cc:368:	for ( uint idx=0; idx<this->numberOfEntries(); idx++ )
table.cc:370:	    this->_Entries.get(idx)->insertField(pos,core::T_O::_nil);
table.cc:378:	ASSERT_lt(entryIdx,this->_Entries.size());
table.cc:379:	uint fieldIdx =  this->indexOfField(field);
table.cc:380:	TableEntry_sp entry = this->_Entries[entryIdx];
table.cc:381:	if ( !val->isAssignableToClass(this->_FieldClasses[fieldIdx]) )
table.cc:383:	    SIMPLE_ERROR(BF("You tried to put a value of class(%s) into a field of a table that expected a %s") % val->className() % this->_FieldClasses[fieldIdx]->instanceClassName() );
table.cc:385:	entry->putField(fieldIdx,val);
table.cc:390:	ASSERT_lt(entryIdx,this->_Entries.size());
table.cc:393:	    core::Symbol_sp sym = core::oCar(values)->as<core::Symbol_O>();
table.cc:394:	    values = values->cdr();
table.cc:396:	    values = values->cdr();
table.cc:397:	    this->writeField(entryIdx,sym,obj);
table.cc:404:	TableEntry_sp entry = TableEntry_O::createWithFields(this->_FieldSymbols.size(),this->sharedThis<Table_O>(),_lisp);
table.cc:405:	this->_Entries.push_back(entry);
table.cc:411:	TableEntry_sp entry = this->appendEntry();
table.cc:414:	    core::Symbol_sp sym = core::oCar(values)->as<core::Symbol_O>();
table.cc:415:	    values = values->cdr();
table.cc:417:	    values = values->cdr();
table.cc:418:	    entry->write(sym,obj);
table.cc:425:	return this->_Entries.asCons(_lisp);
table.cc:431:	ASSERT_lt(position,this->_Entries.size());
table.cc:432:	core::Vector0<TableEntry_O>::iterator it = this->_Entries.begin()+position;
table.cc:433:	TableEntry_sp entry = TableEntry_O::createWithFields(this->_FieldSymbols.size(),this->sharedThis<Table_O>(),_lisp);
table.cc:434:	this->_Entries.insert(it,entry);
table.cc:440:	return this->_Entries.size();
table.cc:446:	ASSERT_lt(idx,this->_Entries.size());
table.cc:447:	return this->_Entries.get(idx);
table.cc:452:	ASSERT_lt(entryIdx,this->_Entries.size());
table.cc:453:	uint fieldIdx =  this->indexOfField(field);
table.cc:454:	TableEntry_sp entry = this->_Entries[entryIdx];
table.cc:455:	return entry->getField(fieldIdx);
table.cc:461:	if ( this->_FieldSymbols.size() != other->_FieldSymbols.size() ) return false;
table.cc:464:	for ( ms=this->_FieldSymbols.begin(), os = other->_FieldSymbols.begin(), 
table.cc:465:		  mc = this->_FieldClasses.begin(), oc = other->_FieldClasses.begin();
table.cc:466:	      ms < this->_FieldSymbols.end(); ms++, os++, mc++, oc++ )
table.cc:476:	if ( !this->fieldsMatch(other) )
table.cc:480:	    ss << "this: " << this->__repr__() << endl;
table.cc:481:	    ss << "other: " << other->__repr__() << endl;
table.cc:485:	for ( it=other->_Entries.begin(); it!=other->_Entries.end(); it++ )
table.cc:487:	    TableEntry_sp one = this->appendEntry();
table.cc:488:	    for ( uint i=0; i<this->_FieldSymbols.size(); i++ )
table.cc:490:		one->putField(i,(*it)->getField(i));
table.cc:501:	sout << (BF("Table number of fields: %d") % this->_FieldSymbols.size() ) << endl;
table.cc:504:	for ( core::Vector0<core::Symbol_O>::const_iterator it = this->_FieldSymbols.begin(); it!=this->_FieldSymbols.end(); it++ )
table.cc:507:	    sout << " " << (*it)->fullName();
table.cc:508:	    map<core::Symbol_sp,uint>::const_iterator fi = this->_FieldIndices.find(sym);
table.cc:509:	    ASSERT(fi!=this->_FieldIndices.end());
table.cc:510:	    uint fieldIdx = fi->second;
table.cc:514:		sout << "<-INDEX_WRONG!";
table.cc:520:	for ( core::Vector0<core::Class_O>::const_iterator mi = this->_FieldClasses.begin(); mi!=this->_FieldClasses.end(); mi++ )
table.cc:522:	    sout << " " << (*mi)->instanceClassName();
table.cc:524:	sout << "Number of entries: " << this->_Entries.size() << endl;
table.cc:533:	frames->setName(_lisp->internKeyword("entry"));
table.cc:535:	for ( si=this->_Entries.begin(); si!=this->_Entries.end(); si++ )
table.cc:537:	    if ( (*si)->canRender() )
table.cc:539:		addon::Render_sp rend = (*si)->rendered(opts);
table.cc:540:		frames->append(rend);
table.cc:551:	for (core::Vector0<TableEntry_O>::iterator ei=this->_Entries.begin(); ei!=this->_Entries.end(); ei++,idx++ )
table.cc:553:	    ss << "entry("<<idx<<"):: " << (*ei)->__repr__();
tableOperations.cc:21:	if ( table->numberOfEntries() <= 1 ) return true;
tableOperations.cc:22:	TableEntry_sp firstEntry = *(table->beginEntry());
tableOperations.cc:23:	core::T_sp firstObject = firstEntry->read(field);
tableOperations.cc:25:	for (Table_O::entryIterator it=table->beginEntry()+1; it!=table->endEntry(); it++,idx++ ) 
tableOperations.cc:27:	    core::T_sp otherObject = (*it)->read(field);
tableOperations.cc:28:	    if ( !firstObject->equal(otherObject) ) 
tableOperations.cc:30:		LOG(BF("The firstEntry field(%s)/value(%s) is not equal to that of entry(%d)/value(%s)") % field->fullName() % firstObject->__repr__() % idx % otherObject->__repr__() );
tableOperations.cc:42:	if ( !table->hasField(writeRmsd) )
tableOperations.cc:44:	    table->appendField(writeRmsd,core::DoubleFloat_O::___staticClass);
tableOperations.cc:46:	if ( !(table->fieldClass(writeRmsd) == core::DoubleFloat_O::___staticClass ))
tableOperations.cc:54:	TableEntry_sp first = *(table->beginEntry());
tableOperations.cc:59:	first->write(writeRmsd,val0);
tableOperations.cc:60:	if ( table->numberOfEntries() <= 1 ) return false;
tableOperations.cc:65:	sm->setMatter(first->read(matterField)->as<Matter_O>());
tableOperations.cc:66:	Loop lAtoms(sm->getMatter(),ATOMS);
tableOperations.cc:71:	    a->clearProperty(superposeSymbol);
tableOperations.cc:72:	    if ( a->isHeavyAtom() )
tableOperations.cc:74:		a->setPropertyTrue(superposeSymbol);
tableOperations.cc:77:	sm->updateSuperposeAtoms();
tableOperations.cc:78:	sm->copyMatterCoordinatesIntoFixedCoordinates(first->read(matterField)->as<Matter_O>());
tableOperations.cc:80:	for ( ei=table->beginEntry()+1; ei!=table->endEntry(); ei++ )
tableOperations.cc:82:	    sm->copyMatterCoordinatesIntoMoveableCoordinates((*ei)->read(matterField)->as<Matter_O>());
tableOperations.cc:83:	    sm->doSuperpose();
tableOperations.cc:84:	    (*ei)->write(writeRmsd,core::DoubleFloat_O::create(sm->rootMeanSquareDifference()));
tableOperations.cc:85:	    (*ei)->read(matterField)->as<Matter_O>()->applyTransformToAtoms(sm->superpose());
tableOperations.cc:102:	this->_compareForm = compareForm;
tableOperations.cc:106:	core::T_sp result = core::eval::funcall(this->_compareForm,x,y);
tableOperations.cc:107:	if ( result->isTrue() ) return true;
tableOperations.cc:120:	core::sort::quickSort(table->beginEntry(), table->endEntry(),orderer, _lisp );
tableOperations.cc:130:    for ( Table_O::entryIterator ei=table->beginEntry(); ei!=table->endEntry(); ei++ )
topology.cc:33:	if ( node->saving() ) this->getConstitution();
topology.cc:34:	node->archiveWeakPointer("constitution",this->_WeakConstitution);
topology.cc:36:	node->attribute("name",this->_Name);
topology.cc:38:	if ( node->loading() )
topology.cc:40:	    if ( node->hasAttribute("name") )
topology.cc:42:		node->attribute("name",this->_Name);
topology.cc:45:		node->attribute("_key",this->_Name);
topology.cc:49:	    node->attribute("name",this->_Name);
topology.cc:52:	node->attributeIfNotDefault("ResidueNetCharge",this->_ResidueNetCharge,0);
topology.cc:53:	node->attributeIfNotDefault("suppressTrainers",this->_SuppressTrainers,false);
topology.cc:54:	node->archiveSymbolMap( "topologyPlugs", this->_Plugs );
topology.cc:55:	node->archiveSymbolMapIfDefined("stereoisomerAtomProperties",this->_StereoisomerAtomProperties);
topology.cc:56:	LOG(BF("About to get core for topology (%s)") % this->_Name->__repr__()  );
topology.cc:57://	node->archiveObjectIfDefined("atomTreeTemplate",this->_AtomTreeTemplate);
topology.cc:58://	node->archiveObjectIfDefined("chiList",this->_ChiList);
topology.cc:59:	node->archiveObject("properties",this->_Properties);
topology.cc:71:    me->_Name = name;
topology.cc:72:    me->_ResidueNetCharge = netCharge;
topology.cc:77:    me->_Plugs.clear();
topology.cc:79:    for ( ; curPlug.notnilp(); curPlug = curPlug->cdr() )
topology.cc:81:	plugType p = curPlug->car<plugOType>();
topology.cc:82:	me->addPlug(p->getName(),p);
topology.cc:86:    me->_AtomTreeTemplate = atomTreeTemplate;
topology.cc:89:    me->_ChiList = chiList;
topology.cc:90:    ASSERTF(me->_AtomTreeTemplate.notnilp(),BF("You must provide the atomTreeTemplate"));
topology.cc:92:    me->_Properties->addAllBindings(properties);
topology.cc:100:	this->_Name = translate::from_object<core::Symbol_O>::convert(env->lookup(ChemPkg,"name"));
topology.cc:101:	this->_ResidueNetCharge = translate::from_object<int>::convert(env->lookup(ChemPkg,"netCharge"));
topology.cc:102:	core::Binder_sp properties = env->lookup(ChemPkg,"properties")->as<core::Binder_O>();
topology.cc:107:	core::Cons_sp curPlug = translate::from_object<core::Cons_O>::convert(env->lookup(ChemPkg,"plugs"));
topology.cc:108:	this->_Plugs.clear();
topology.cc:109:	for ( ; curPlug.notnilp(); curPlug = curPlug->cdr() )
topology.cc:111:	    plugType p = curPlug->car<plugOType>();
topology.cc:112:	    this->addPlug(p->getName(),p);
topology.cc:114:	ConstitutionAtoms_sp residue = translate::from_object<ConstitutionAtoms_O>::convert(env->lookup(ChemPkg,"constitutionAtoms"));
topology.cc:117:	this->_AtomTreeTemplate = translate::from_object<kinematics::AtomTemplate_O>::convert(env->lookup(Topology_O::Package(),"atomTreeTemplate"));
topology.cc:120:	this->_ChiList = env->lookup(_lisp->internWithPackageName(ChemPkg,"chiList"))->as<kinematics::ChiList_O>();
topology.cc:121:	ASSERTF(this->_AtomTreeTemplate.notnilp(),BF("You must provide the atomTreeTemplate"));
topology.cc:123:	this->_Properties->addAllBindings(properties);
topology.cc:138:	Fragment_sp frag = extractFrag->getFragment();
topology.cc:139:	core::StringSet_sp atomNames = frag->getAtomNames();
topology.cc:140:	for ( core::StringSet_O::iterator ni = atomNames->begin(); ni!=atomNames->end(); ni++ )
topology.cc:142:	    if ( missingAtomNames->contains(*ni) )
topology.cc:144:		missingAtomNames->remove(*ni);
topology.cc:150:		over._Fragments.insert(frag->getName());
topology.cc:156:		over._Fragments.insert(frag->getName());
topology.cc:166:	core::StringSet_sp missingAtomNames = residue->atomNamesAsStringSet();
topology.cc:168:	__checkExtractFragment(this->_ExtractCoreFragment,missingAtomNames,overlaps);
topology.cc:169:	for ( core::Vector0<ExtractFragment_O>::iterator it=this->_ExtractFragments.begin();
topology.cc:170:	      it!=this->_ExtractFragments.end(); it++ )
topology.cc:174:	if ( missingAtomNames->size() != 0 )
topology.cc:177:	    ss << "The Topology " << this->getName() << " ExtractFragments do not include all atoms" << endl;
topology.cc:178:	    ss << " of the Constitution.  The following atom names are missing: " << missingAtomNames->asString();
topology.cc:185:	    if ( oi->second._TimesSeen > 1 )
topology.cc:188:		so << "Multiple references for atom(" <<oi->first<<") in fragments: ";
topology.cc:189:		for ( set<string>::iterator si=oi->second._Fragments.begin(); si!=oi->second._Fragments.end();si++ )
topology.cc:198:	    se << "In definition of Topology(" << this->getName() << ") there were overlapping ExtractFragment definitions"<<endl;
topology.cc:208:	MonomerContext_sp context = _lisp->create<MonomerContext_O>();
topology.cc:210:	Constitution_sp constitution = this->getConstitution();
topology.cc:211:	context->setFocus(selfSet);
topology.cc:218:	return this->_Properties;
topology.cc:225:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:227:	    if ( i->second->getIsIn() ) return true;
topology.cc:237:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:239:	    if ( i->second->getIsIn() ) 
topology.cc:241:		return i->second;
topology.cc:252:	LOG(BF("The number of plugs = %d") % this->_Plugs.size()  );
topology.cc:253:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:255:	    LOG(BF("Adding plug: %s") % i->second->getName());
topology.cc:256:	    core::Cons_sp one = core::Cons_O::create(i->second,core::Cons_O::_nil,_lisp);
topology.cc:257:	    cur->setCdr(one);
topology.cc:261:	return first->cdr();
topology.cc:269:	LOG(BF("The number of plugs = %d") % this->_Plugs.size()  );
topology.cc:270:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:273:	    if ( !i->second->isAssignableTo<PlugWithMates_O>() ) continue;
topology.cc:274:	    LOG(BF("Adding plug: %s") % i->second->__repr__() );
topology.cc:275:	    core::Cons_sp one = core::Cons_O::create(i->second,core::Cons_O::_nil,_lisp);
topology.cc:276:	    cur->setCdr(one);
topology.cc:280:	return first->cdr();
topology.cc:287:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:289:	    Plug_sp plug = i->second;
topology.cc:290:	    if ( !plug->getIsIn() )
topology.cc:292:		core::Cons_sp one = core::Cons_O::create(i->second,core::Cons_O::_nil,_lisp);
topology.cc:293:		cur->setCdr(one);
topology.cc:297:	return first->cdr();
topology.cc:306:	ASSERTNOTNULL(this->_WeakConstitution);
topology.cc:307:	if ( this->_WeakConstitution.lock()->isNil() )
topology.cc:311:	    this->_WeakConstitution = this->ownerWithClass<Constitution_O>();
topology.cc:313:	return this->_WeakConstitution.lock();
topology.cc:320:	ss << this->core::T_O::description();
topology.cc:322:	ss << " Name(" << me->getName() << ")";
topology.cc:323:	ss << " Constitution("<< me->getConstitution()->getName() << ")";
topology.cc:325:	for ( Plugs::const_iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:327:	    ss << (BF("%s@%p ") % i->second->getName()->__repr__() % i->second->getName().get() ).str();
topology.cc:335:    {_GF(BF("Looking at topology[%s]") % this->getName()->__repr__() );
topology.cc:336:	core::SymbolSet_sp myPlugSet = _lisp->create<core::SymbolSet_O>();
topology.cc:337:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:339:	    LOG(BF("Looking at plug[%s]") % i->second->getName()->__repr__() );
topology.cc:340:	    if (i->second->isAssignableTo<PlugWithMates_O>() )
topology.cc:342:		myPlugSet->insert(i->first);
topology.cc:345:	LOG(BF("Topology plugs are: %s") % myPlugSet->asString() );
topology.cc:346:	bool match = plugSet->equal(myPlugSet);
topology.cc:347:	LOG(BF("Do they match the plugs passed as arguments[%s] --> %d") % plugSet->asString() % match );
topology.cc:355:	LOG(BF("Checking if monomer[%s] matches the topology environment") % mon->description() );
topology.cc:357:	for ( Plugs::iterator i=this->_Plugs.begin(); i!= this->_Plugs.end(); i++)
topology.cc:359:	    LOG(BF("Looking at plug[%s]") % i->second->getName()->__repr__() );
topology.cc:360:	    if (!i->second->isAssignableTo<PlugWithMates_O>() )
topology.cc:365:	    if ( !mon->hasCouplingWithPlugName(i->second->getName()) ) 
topology.cc:367:		LOG(BF("The monomer doesn't have a coupling with plug name[%s]") % i->second->getName()->__repr__() );
topology.cc:372:	if ( numPlugsWithMates != mon->numberOfCouplings() ) 
topology.cc:374:	    LOG(BF("There is a mismatch with the number of plugs in the topology[%d] and the number of couplings for the monomer[%d]") % numPlugsWithMates % mon->numberOfCouplings() );
topology.cc:387:	for ( Plugs::iterator i=this->_Plugs.begin();
topology.cc:388:	      i!= this->_Plugs.end(); i++)
topology.cc:390:	    if (!i->second->isAssignableTo<PlugWithMates_O>() ) continue;
topology.cc:391:	    if ( i->second->isAssignableTo<RingClosingPlug_O>() )
topology.cc:393:		missingRingClosingPlug = i->second->as<RingClosingPlug_O>();
topology.cc:396:	    if ( !mon->hasCouplingWithPlugName(i->second->getName()) ) return RingClosingPlug_O::_nil;
topology.cc:399:	if ( numPlugsWithMates != mon->numberOfCouplings() ) return RingClosingPlug_O::_nil;
topology.cc:406:	return this->_Flags;
topology.cc:411:	return this->_Flags->contains(f);
topology.cc:418:	for ( Plugs::iterator i=this->_Plugs.begin();
topology.cc:419:	      i!= this->_Plugs.end(); i++)
topology.cc:421:	    if (!i->second->isAssignableTo<PlugWithMates_O>() ) continue;
topology.cc:422:	    if ( !cm->hasNeighborWithCouplingName(i->second->getName()) ) return false;
topology.cc:425:	if ( numPlugsWithMates != cm->numberOfNeighbors() ) return false;
topology.cc:432:	LOG(BF("Looking for plug name[%s@%p]") % name->__repr__() % name.get() );
topology.cc:433:	for (Plugs::const_iterator ki=this->_Plugs.begin(); ki!=this->_Plugs.end(); ki++ )
topology.cc:435:	    LOG(BF(" available Symbol key: %s@%p") % ki->first->__repr__() % ki->first.get() );
topology.cc:438:	bool res = this->_Plugs.contains(name);
topology.cc:446:	    % name->__repr__()
topology.cc:447:	    % core::StringSet_O::create_fromKeysOfSymbolMap(this->_Plugs,_lisp)->asString());
topology.cc:448:	bool res = this->_Plugs.contains(name);
topology.cc:451:	return this->_Plugs.get(name,_lisp);
topology.cc:460:	this->Base::initialize();
topology.cc:461:	this->_WeakConstitution = Constitution_O::_nil;
topology.cc:462:	this->_Flags = core::StringSet_O::create();
topology.cc:463:	this->_Name = _Nil<core::Symbol_O>();
topology.cc:464:	this->_ResidueNetCharge = 0;
topology.cc:465:	this->_Plugs.clear();
topology.cc:466:	this->_TemporaryObject = core::T_O::_nil;
topology.cc:467:	this->_SuppressTrainers = false;
topology.cc:468:	this->_Properties = core::Binder_O::create();
topology.cc:476:	this->_TemporaryObject = o;
topology.cc:481:	ASSERTNOTNULL(this->_TemporaryObject);
topology.cc:482:	return this->_TemporaryObject;
topology.cc:488:	core::SymbolMap<StereoisomerAtoms_O>::iterator it= this->_StereoisomerAtomProperties.find(stereoisomerName);
topology.cc:490:	if ( it==this->_StereoisomerAtomProperties.end() )
topology.cc:492:	    Constitution_sp constitution = this->getConstitution();
topology.cc:493:	    ASSERTF(constitution->hasStereoisomerWithName(stereoisomerName),BF("Could not find stereoisomer named[%s] in constitution[%s]") % stereoisomerName->__repr__() % constitution->getName());
topology.cc:494:	    ConstitutionAtoms_sp constitutionAtoms = constitution->getConstitutionAtoms();
topology.cc:496:	    this->_StereoisomerAtomProperties.set(stereoisomerName,result);
topology.cc:499:	    result = this->_StereoisomerAtomProperties.get(stereoisomerName,_lisp);
topology.cc:516:	    .def("topology-suppress-trainers",&Topology_O::suppressTrainers)
topology.cc:543:	    .def("topology-suppress-trainers",&Topology_O::suppressTrainers)
torsionDriver.cc:36:	if ( a->getName() == name ) count++;
torsionDriver.cc:55:	if ( a->getName() == name ) {
torsionDriver.cc:97:    for ( pos=this->torsions.begin()+1;
torsionDriver.cc:98:		pos!=this->torsions.end();
torsionDriver.cc:100:	if ( fixed->getTempInt() < pos->fixed->getTempInt() ) break;
torsionDriver.cc:105:    torsion.parent = -1;
torsionDriver.cc:106:    if ( pos==this->torsions.end() ) {
torsionDriver.cc:107:	this->torsions.push_back(torsion);
torsionDriver.cc:109:	this->torsions.insert(pos,torsion);
torsionDriver.cc:125:    for ( segment=this->torsions.begin()+start;
torsionDriver.cc:126:		segment != this->torsions.end();
torsionDriver.cc:128:	parent = &(this->torsions[segment->parent]);
torsionDriver.cc:129:	mat = segment->relative*(*(segment->rotation));
torsionDriver.cc:130:	segment->accumulated = parent->accumulated*mat;
torsionDriver.cc:136:    segment = &(this->torsions[start]);
torsionDriver.cc:137:    parent = &(this->torsions[segment->parent]);
torsionDriver.cc:138:    mat = segment->relative*(*(segment->rotation));
torsionDriver.cc:139:    segment->accumulated = parent->accumulated*mat;
torsionDriver.cc:144:	segment->rotation->dump();
torsionDriver.cc:146:	segment->accumulated.dump();
torsionDriver.cc:152:    for ( pos=this->torsions[start].children.begin();
torsionDriver.cc:153:	    pos!=this->torsions[start].children.end();
torsionDriver.cc:155:	this->updateAccumulatedTransforms(*pos);
torsionDriver.cc:177:    this->driveMode = false;	// We are about to start adding torsions
torsionDriver.cc:178:    this->torsions.erase(this->torsions.begin(),this->torsions.end());
torsionDriver.cc:179:    this->aggregate = agg; // Should I use a copy?
torsionDriver.cc:181:    lAtoms.loopTopGoal( this->aggregate, ATOMS );
torsionDriver.cc:184:	if ( atom->getName() == rootName ) {
torsionDriver.cc:201:    spanning = agg->lisp()->create<SpanningLoop_O>();
torsionDriver.cc:202:    spanning->setTop(root);
torsionDriver.cc:204:    while ( spanning->advanceLoopAndProcess() ) {
torsionDriver.cc:205:	atom = spanning->getAtom();
torsionDriver.cc:206:	atom->setTempInt(spanningIndex);
torsionDriver.cc:215:    this->torsions.push_back(torsion);
torsionDriver.cc:231:    if ( this->driveMode ) {
torsionDriver.cc:234:    ANN(this->aggregate);
torsionDriver.cc:235:    if ( this->aggregate->isNil() )
torsionDriver.cc:239:    if ( this->countOfAtomsWithName(this->aggregate,atom1 ) != 1 ) {
torsionDriver.cc:242:    if ( this->countOfAtomsWithName(this->aggregate,atom2 ) != 1 ) {
torsionDriver.cc:245:    a1 = this->aggregate->firstAtomWithName(atom1);
torsionDriver.cc:246:    a2 = this->aggregate->firstAtomWithName(atom2);
torsionDriver.cc:247:    backSpan = a2->getBackSpan();
torsionDriver.cc:248:    if ( a1 == a2->getBackSpan() ) {
torsionDriver.cc:249:	this->insertTorsion( a1, a2, steps );
torsionDriver.cc:252:    if ( a2 == a1->getBackSpan() ) {
torsionDriver.cc:253:	this->insertTorsion( a2, a1, steps );
torsionDriver.cc:283:    if ( this->driveMode ) {
torsionDriver.cc:291:    for ( pos=this->torsions.begin()+1;
torsionDriver.cc:292:		pos!=this->torsions.end();
torsionDriver.cc:294:	bo = pos->movable->bondOrderTo(pos->fixed);
torsionDriver.cc:296:	    SIMPLE_ERROR(boost::format("The two atoms of a torsion must be bonded. Atom: %s is not bonded to %s") % pos->fixed->getName() % pos->movable->getName() );
torsionDriver.cc:298:	pos->order = bo;
torsionDriver.cc:299:	pos->fixed->removeBondBetween(pos->movable,pos->fixed);
torsionDriver.cc:316:    spanning = _lisp->create<SpanningLoop_O>();
torsionDriver.cc:317:    for ( pos=this->torsions.begin()+1;
torsionDriver.cc:318:		pos!=this->torsions.end();
torsionDriver.cc:320:	spanning->setTop(pos->movable);
torsionDriver.cc:321:	while ( spanning->advanceLoopAndProcess() ) {
torsionDriver.cc:322:	    a = spanning->getAtom();
torsionDriver.cc:325:	    pos->atoms.push_back(tatom);
torsionDriver.cc:326:	    a->setTempInt(pos-this->torsions.begin());
torsionDriver.cc:334:    LOG(BF("Constructing the matrix update tree - parents") );
torsionDriver.cc:335:    for ( pos=this->torsions.begin(), index = 0;
torsionDriver.cc:336:		pos!=this->torsions.end();
torsionDriver.cc:339:		// That will be -1 if the segment is the first one
torsionDriver.cc:341:	if ( pos == this->torsions.begin() ) {
torsionDriver.cc:342:	    pos->parent = -1;
torsionDriver.cc:343:	} else if ( pos== this->torsions.begin()+1 ) {
torsionDriver.cc:344:	    pos->parent = 0;
torsionDriver.cc:346:	    pos->parent = pos->fixed->getTempInt();
torsionDriver.cc:352:    LOG(BF("Constructing the matrix update tree - children") );
torsionDriver.cc:353:    for ( pos=this->torsions.begin()+1, index = 1;
torsionDriver.cc:354:		pos!=this->torsions.end();
torsionDriver.cc:357:		// That will be -1 if the segment is the first one
torsionDriver.cc:359:	this->torsions[pos->parent].children.push_back(index);
torsionDriver.cc:364:	// with its Z-axis along the line joining the fixed atom to the
torsionDriver.cc:365:	// movable one and its X-axis perpendicular to the Z-axis.
torsionDriver.cc:368:    for ( pos=this->torsions.begin();
torsionDriver.cc:369:		pos!=this->torsions.end();
torsionDriver.cc:375:	if ( pos==this->torsions.begin() ) {
torsionDriver.cc:379:	    pos->coord = CoordinateSystem_O::create();
torsionDriver.cc:380:	    pos->coord->defineForVectorsOriginXDirZDir(origin,xDir,zDir);
torsionDriver.cc:383:	    origin = pos->fixed->getPosition();
torsionDriver.cc:384:	    zDir = pos->movable->getPosition()-pos->fixed->getPosition();
torsionDriver.cc:386:	    if ( pos->movable->numberOfBonds() == 0 ) {
torsionDriver.cc:388:					% pos->fixed->getName() % pos->movable->getName() );
torsionDriver.cc:390:	    vTemp = pos->movable->bondedNeighbor(0)->getPosition()
torsionDriver.cc:391:			    - pos->movable->getPosition();
torsionDriver.cc:398:	    pos->coord = CoordinateSystem_O::create();
torsionDriver.cc:399:	    pos->coord->defineForVectorsOriginXDirZDir( origin, xDir, zDir );
torsionDriver.cc:404:	    pos->fixed->bondTo( pos->movable, pos->order );
torsionDriver.cc:412:    for ( pos=this->torsions.begin()+1;
torsionDriver.cc:413:		pos!=this->torsions.end();
torsionDriver.cc:415:	LOG(BF("  for pos=%d") % (pos-this->torsions.begin() ) );
torsionDriver.cc:416:	LOG(BF("  Parent =%d") % (pos->parent ) );
torsionDriver.cc:417:	parent = this->torsions.begin()+pos->parent;
torsionDriver.cc:419:	coord = parent->coord;
torsionDriver.cc:421:	pos->relative = coord->matrixForTransformTo(pos->coord);
torsionDriver.cc:430:    for ( pos=this->torsions.begin();
torsionDriver.cc:431:		pos!=this->torsions.end();
torsionDriver.cc:433:	LOG(BF("Generating rotation matrices for segment: %d") % (pos-this->torsions.begin() ) );
torsionDriver.cc:434:	for ( i=0; i<pos->steps; i++ ) {
torsionDriver.cc:435:	    angle = i*(0.0174533*360.0/pos->steps);
torsionDriver.cc:437:	    rot.rightHandedRotationZ(-angle);
torsionDriver.cc:438:	    pos->rotations.push_back(rot);
torsionDriver.cc:440:        pos->rotation = pos->rotations.begin();
torsionDriver.cc:450:    pos = this->torsions.begin()+1;
torsionDriver.cc:451:    this->torsions.begin()->accumulated.setToIdentity(); // = pos->coord->matrixFromCanonical();
torsionDriver.cc:454:    this->updateAccumulatedTransforms(1);
torsionDriver.cc:462:    for ( pos=this->torsions.begin()+1; pos!=this->torsions.end(); pos++ ) {
torsionDriver.cc:463:	toCanonical = pos->coord->matrixToCanonical();
torsionDriver.cc:464:	for ( tai=pos->atoms.begin(); tai!=pos->atoms.end(); tai++ ) {
torsionDriver.cc:465:	    tai->setUntransformed(toCanonical*(tai->getAtom()->getPosition()));
torsionDriver.cc:469:    this->driveMode = true;
torsionDriver.cc:494:    if ( !this->driveMode ) {
torsionDriver.cc:504:    aggGraphics = this->aggregate->asXmlWithCoordinates();
torsionDriver.cc:505:    graphics->addChild(aggGraphics);
torsionDriver.cc:512:    for ( pos=this->torsions.begin(); pos!=this->torsions.end(); pos++ ) {
torsionDriver.cc:513:	gr = pos->coord->renderXml(1.0,1.0);
torsionDriver.cc:514:	graphics->addChild(gr);
torsionDriver.cc:515:	for ( tai=pos->atoms.begin(); tai!=pos->atoms.end(); tai++ ) {
torsionDriver.cc:516:	    gr = xmlSphere(XML_YELLOW,tai->getUntransformed(),0.3);
torsionDriver.cc:517:	    graphics->addChild(gr);
torsionDriver.cc:525:    coords->addChild(gr);
torsionDriver.cc:528:    coords->addChild(gr);
torsionDriver.cc:531:    coords->addChild(gr);
torsionDriver.cc:532:    graphics->addChild(coords);
torsionDriver.cc:549:    for ( pos=this->torsions.begin()+start; pos!=this->torsions.end(); pos++ ) {
torsionDriver.cc:550:	LOG(BF("Applying matrix at segment: %d") % (pos-this->torsions.begin() ) );
torsionDriver.cc:552:	pos->accumulated.dump();
torsionDriver.cc:554:	for ( tai=pos->atoms.begin(); tai!=pos->atoms.end(); tai++ ) {
torsionDriver.cc:555:	    LOG(BF("Transforming atom: %s") % (tai->getAtom()->getName().c_str() ) );
torsionDriver.cc:556:	    trans = pos->accumulated*(tai->getUntransformed());
torsionDriver.cc:557:	    tai->getAtom()->setPosition(trans);
torsionDriver.cc:576:    LOG(BF("----Advancing from segment: %d highest: %d") % (segment) % (this->torsions.end()-this->torsions.begin()-1) );
torsionDriver.cc:577:    if (segment > this->highestSegmentIndex() ) {
torsionDriver.cc:578:	segment = this->highestSegmentIndex();
torsionDriver.cc:580:    } else if ( segment < this->highestSegmentIndex()) {
torsionDriver.cc:582:	for ( pos=this->torsions.begin()+segment+1;
torsionDriver.cc:583:		pos!=this->torsions.end();
torsionDriver.cc:585:	    pos->rotation = pos->rotations.begin();
torsionDriver.cc:588:        for ( cpos=this->torsions[segment].children.begin();
torsionDriver.cc:589:		cpos!=this->torsions[segment].children.end();
torsionDriver.cc:591:	    this->resetRotation(*cpos);
torsionDriver.cc:596:    pos = this->torsions.begin()+segment; // this->torsions.end()-1;
torsionDriver.cc:597:    while ( pos > this->torsions.begin() ) {
torsionDriver.cc:598:	LOG(BF("Incrementing segment: %d") % (pos-this->torsions.begin() ) );
torsionDriver.cc:600:	pos->rotation++;
torsionDriver.cc:601:	LOG(BF("Incremented rotation %d of %d") % (pos->rotation-pos->rotations.begin()) % (pos->rotations.end()-pos->rotations.begin() ) );
torsionDriver.cc:602:	if ( pos->rotation != pos->rotations.end() ) break;
torsionDriver.cc:604:	pos->rotation = pos->rotations.begin();
torsionDriver.cc:605:	pos--;
torsionDriver.cc:607:    if ( pos > this->torsions.begin() ) {
torsionDriver.cc:608:	LOG(BF("Updating transforms and coordinates from segment: %d") % (pos-this->torsions.begin() ) );
torsionDriver.cc:609:	this->updateAccumulatedTransforms(pos-this->torsions.begin());
torsionDriver.cc:610:	this->calculateNewCoordinates(pos-this->torsions.begin());
torsionDriver.cc:611:	return pos-this->torsions.begin();
torsionDriver.cc:631:    if ( this->driveMode ) {
torsionDriver.cc:632:	_lisp->print(BF( "Torsion driver in DRIVE mode" ));
torsionDriver.cc:634:	_lisp->print(BF( "Torsion driver in ADD_TORSION mode" ));
torsionDriver.cc:636:    for ( pos=this->torsions.begin(); pos != this->torsions.end(); pos++ ) {
torsionDriver.cc:637://	printf( "Driven torsion #%lX\n", (pos-this->torsions.begin() );
torsionDriver.cc:638:	if ( pos!=this->torsions.begin() ) {
torsionDriver.cc:639:	    _lisp->print(BF( "  Parent: %d") % pos->parent );
torsionDriver.cc:640:	    _lisp->print(BF( "      Fixed: %s") % pos->fixed->getName().c_str() );
torsionDriver.cc:641:	    _lisp->print(BF( "    Movable: %s") % pos->movable->getName().c_str() );
torsionDriver.cc:642:	    _lisp->print(BF( "      Steps: %d") % pos->steps );
torsionDriver.cc:643:	    _lisp->print(BF("      Atoms: " );
torsionDriver.cc:644:	    for ( ap=pos->atoms.begin(); ap!=pos->atoms.end(); ap++ ) {
torsionDriver.cc:645:		_lisp->print(BF(" %s", ap->getAtom()->getName().c_str() );
torsionDriver.cc:647:	    _lisp->print(BF( "" ));
torsionDriver.cc:648:		_lisp->print(BF("      Children: " );
torsionDriver.cc:649:	    for ( ip=pos->children.begin(); ip!=pos->children.end(); ip++ ) {
torsionDriver.cc:650:		_lisp->print(BF(" %3d", *ip );
torsionDriver.cc:652:	    _lisp->print(BF( "" ));
torsionDriver.cc:653:	    _lisp->print(BF( "      coordinate system:" ));
torsionDriver.cc:654:	    pos->coord->dump();
torsionDriver.cc:655:	    _lisp->print(BF( "      relative matrix: " ));
torsionDriver.cc:656:	    pos->relative.dump();
torsionDriver.cc:657:	    for (mp=pos->rotations.begin(); mp!=pos->rotations.end(); mp++ ) {
torsionDriver.cc:658://		_lisp->print(BF( "      rotation matrix %d: ") % mp-pos->rotations.begin() );
torsionDriver.cc:659:	        mp->dump();
torsionDriver.cc:661://	    _lisp->print(BF( "      current rotation: %d") % pos->rotation-pos->rotations.begin() );
torsionDriver.cc:664:	_lisp->print(BF( "      accumulated matrix: " ));
torsionDriver.cc:665:	pos->accumulated.dump();
torsionDriver.cc:666:	_lisp->print(BF( "" ));
torsionDriver.cc:683:    for ( pos=this->torsions.begin()+1; pos < this->torsions.end(); pos++ ) {
torsionDriver.cc:684:	ss << pos->fixed->getName();
torsionDriver.cc:685:	ss << "-";
torsionDriver.cc:686:	ss << pos->movable->getName();
torsionDriver.cc:688:	ss << (pos->rotation-pos->rotations.begin()) << ") ";
torsionDriver.cc:709:    count = this->torsions[segment].steps;
torsionDriver.cc:710:    for ( child=this->torsions[segment].children.begin();
torsionDriver.cc:711:		child!=this->torsions[segment].children.end();
torsionDriver.cc:713:	count *= this->basicCountConformations(*child);
trainer.cc:23:    return this->_UniqueIndex;
trainer.cc:28:    return this->_History;
trainer.cc:32:    return this->_Data;
trainer.cc:38:    this->_MostConformationalSearchFailsSeen = 0;
trainer.cc:43:    if ( i > this->_MostConformationalSearchFailsSeen )
trainer.cc:45:	this->_MostConformationalSearchFailsSeen = i;
trainer.cc:51:    return this->_MostConformationalSearchFailsSeen;
trainer.cc:56:    return this->_MostConformationalSearchFailsSeen<this->_MaxConformationalSearchFailsRequired;
trainer.cc:62:    this->_MaxConformationalSearchFailsRequired = i;
trainer.cc:67:    return this->_MaxConformationalSearchFailsRequired;
trainer.cc:73:    this->_SecondsSpentConformationalSearching = i;
trainer.cc:78:    return this->_SecondsSpentConformationalSearching;
trainer.cc:87:	core::Path_sp path = _lisp->create<core::Path_O>(this->_Path->getPath());
trainer.cc:95:    this->_Data->extend(key,val);
trainer.cc:101:    return this->_Data->lookup(key);
trainer.cc:106:    return this->_Data->contains(key);
trainer.cc:111:    return this->_Context;
trainer.cc:115:    this->_Context = co;
trainer.cc:120:    this->_State = str;
trainer.cc:125:    this->setState(str);
trainer.cc:126:    this->setStateMessage(msg);
trainer.cc:133:    this->_UniqueIndex = i;
trainer.cc:138:    this->Base::initialize();
trainer.cc:139:    this->_Data = _lisp->create<core::Binder_O>();
trainer.cc:140:    this->_Context = MonomerContext_O::_nil;
trainer.cc:141:    this->_History = _lisp->create<TrainerHistory_O>();
trainer.cc:142:    this->_TopDirectory = "";
trainer.cc:143:    this->_State = "";
trainer.cc:144:    this->_StateMessage = "";
trainer.cc:145:    this->_History->clear();
trainer.cc:146:    this->_Context = MonomerContext_O::_nil;
trainer.cc:147:    this->_MostConformationalSearchFailsSeen = 0;
trainer.cc:148:    this->_MaxConformationalSearchFailsRequired = DEFAULT_MAX_CONFORMATIONAL_SEARCH_FAILS_REQUIRED;
trainer.cc:149:    this->_SecondsSpentConformationalSearching = 0;
trainer.cc:157:    node->attribute("TopDirectory", this->_TopDirectory );
trainer.cc:158:    node->archiveObject("Path", this->_Path );
trainer.cc:159:    node->attribute("State", this->_State );
trainer.cc:160:    node->archiveStringIfNotDefault("StateMessage", this->_StateMessage, "" );
trainer.cc:161:    node->attributeIfNotDefault("NotPartOfSeedDatabase", this->_NotPartOfSeedDatabase, true);
trainer.cc:162:    node->archiveObject("data",this->_Data);
trainer.cc:163:    node->archiveObject("context",this->_Context);
trainer.cc:164:    node->attribute("UniqueIndex", this->_UniqueIndex );
trainer.cc:165:    node->archiveObject("history",this->_History);
trainer.cc:166:    node->attributeIfNotDefault("MostConformationalSearchFailsSeen",this->_MostConformationalSearchFailsSeen,(uint)(0));
trainer.cc:167:    node->attributeIfNotDefault("MaxConformationalSearchFailsRequired",this->_MaxConformationalSearchFailsRequired,(uint)(DEFAULT_MAX_CONFORMATIONAL_SEARCH_FAILS_REQUIRED));
trainer.cc:168:    node->attribute("SecondsSpentConformationalSearching",this->_SecondsSpentConformationalSearching);
trainer.cc:175:    LOG(BF("Generating file name directory(%s)") % this->_TopDirectory.c_str() );
trainer.cc:176:    LOG(BF("Generating file name fileNamePrefix(%s)") % this->getTrainerFileNamePrefix().c_str()  );
trainer.cc:178:    fileName << (BF("%s/%s") % this->_TopDirectory % this->getTrainerFileNamePrefix() ).str();
trainer.cc:186:    return this->_Context->getKey();
trainer.cc:195:    this->Base::initialize();
trainer.cc:196:    this->_Data = _lisp->create<core::Binder_O>();
trainer.cc:202:    node->archiveObject("header",this->_Header);
trainer.cc:203:    node->archiveObject("data",this->_Data);
trainer.cc:209:    core::XmlSaveArchive_sp a = _lisp->create<core::XmlSaveArchive_O>();
trainer.cc:210:    core::Path_sp path = this->getHeader()->constructPath(this->getHeader()->trainerFileName());
trainer.cc:211:    a->put("job",this->sharedThis<Trainer_O>());
trainer.cc:212:    a->saveAs(path->asString());
trainer.cc:217:    return downcast<ConformationExplorer_O>(this->getData(_lisp->internWithPackageName(ChemPkg,"_ConformationExplorer")));
trainer.cc:221:    this->setData(_lisp->internWithPackageName(ChemPkg,"_ConformationExplorer"),str);
trainer.cc:227:    return this->_Data->rendered(opts);
trainer.cc:232:    this->_Header = head;
trainer.cc:236:    return this->_Header;
trainer.cc:241:    this->_Data->extend(key,data);
trainer.cc:246:    return this->_Data->contains(key);
trainer.cc:250:    return this->_Data->lookup(key);
trainer.cc:255:    return this->_Data;
trainer.cc:262:    string fileName = path->asString();
trainer.cc:270:    core::Class_sp trainerHeaderClass = lisp->classFromClassName(TrainerHeader_O::static_className());
trainer.cc:271:    string search = trainerHeaderClass->getPackagedName();
trainer.cc:285:	    trimmed = trimmed.substr(0,trimmed.size()-1); // remove ">"
trainer.cc:297:	dict->put(onePair[0],lisp->create<core::Str_O>(onePair[1].substr(1,onePair[1].size()-2)));
trainer.cc:323:    a = lisp->create<core::XmlLoadArchive_O>();
trainer.cc:325:    trainerPath->path_append(TrainerHeader_O::trainerFileName());
trainer.cc:326:    string fileName = trainerPath->asString();
trainer.cc:327:    a->parse(fileName);
trainer.cc:328:    job = downcast<Trainer_O>(a->get("job"));
trainer.cc:340:    jobHeader = job->getHeader();
trainer.cc:345:    Residue_sp focusResidue = safe_downcast<Residue_O>(job->getData("FocusResidue"));
trainer.cc:346:    Constitution_sp focusResidueConstitution = focusResidue->getConstitution();
trainer.cc:347:    string constitutionName = focusResidueConstitution->getName();
trainer.cc:348:    chem::CandoDatabase_sp oldTrainerCandoDatabase = job->getCandoDatabase();
trainer.cc:350:    oldTrainerCandoDatabase->giveYourDependantObjectsTo(bdh);
trainer.cc:351:    Constitution_sp newFocusResidueConstitution = bdh->monomerConstitutionForName(constitutionName);
trainer.cc:352:    LOG(BF("Setting constitution for FocusResidue to: %s") % newFocusResidueConstitution->description().c_str()  );
trainer.cc:353:    focusResidue->setConstitution(newFocusResidueConstitution);
trainer.cc:354:    LOG(BF("Setting constitution for FocusResidue: %s") % focusResidue->description().c_str()  );
trainer.cc:355:    LOG(BF("    constitution = %s") % newFocusResidueConstitution->description().c_str()  );
trainer.cc:356:    job->setCandoDatabase(bdh);
trainer.cc:367:    job->getHeader()->setPathName(pathName);
trainer.cc:368:    a = job->lisp()->create<core::XmlSaveArchive_O>();
trainer.cc:369:    a->put("job",job);
trainer.cc:371:    a->saveAs(fileName);
trainer.cc:383:    this->Base::initialize();
trainer.cc:384:    this->_Data = core::Binder_O::create();
trainer.cc:391:    node->archiveMap("entries",this->_Entries);
trainer.cc:392:    node->archiveObject("data",this->_Data);
trainer.cc:398:    return this->_Entries.size(); 
trainer.cc:403:    this->_Data->extend(key,data);
trainer.cc:408:    return this->_Data->contains(key);
trainer.cc:412:    return this->_Data->lookup(key);
trainer.cc:417:    core::StringMap<TrainerHeader_O>::value_iterator TrainerOrganizer_O::begin_Entries() { return this->_Entries.begin_value(); };
trainer.cc:418:    core::StringMap<TrainerHeader_O>::value_iterator TrainerOrganizer_O::end_Entries() { return this->_Entries.end_value(); };
trainer.cc:424:   val = _lisp->create<core::Str_O>(topDir);
trainer.cc:425:   this->_Data->extend(_lisp->internWithPackageName(ChemPkg,"_TopDirectory"), val );
trainer.cc:429:    return (downcast<core::Str_O>(this->_Data->lookup(_lisp->internWithPackageName(ChemPkg,"_TopDirectory"))))->get();
trainer.cc:434:    val = _lisp->create<core::Str_O>(str);
trainer.cc:435:    this->_Data->extend(_lisp->internWithPackageName(ChemPkg,"_CandoDatabaseFileName"), val );
trainer.cc:439:    return (downcast<core::Str_O>(this->_Data->lookup(ChemPkg,"_CandoDatabaseFileName")))->get();
trainer.cc:445:    this->_Entries.set(head->getContextKey(),head);
trainer.cc:449:    return this->_Entries.get(key);
trainer.cc:455:    key = context->getKey();
trainer.cc:456:    return this->_Entries.contains(key);
trainer.cc:464:    ASSERT(this->_Entries.contains(key));
trainer.cc:465:    return this->_Entries.get(key);
trainer.cc:472:    for ( entryIterator ei=this->_Entries.begin(); 
trainer.cc:473:    		ei!=this->_Entries.end(); ei++ )
trainer.cc:475:        MonomerContext_sp organizerContext = (ei->second)->getContext();
trainer.cc:476:	if ( context->containsMonomerContext(organizerContext) )
trainer.cc:478:	    return (ei->second);
trainer.cc:489:    for ( ei=this->_Entries.begin(); ei!=this->_Entries.end(); ei++ )
trainer.cc:491:	highestUniqueIndex = max(highestUniqueIndex,(ei->second)->getUniqueIndex());
trainer.cc:504:    for ( it=this->_Entries.begin(); it!=this->_Entries.end(); it++ )
trainer.cc:506:	core::Cons_sp one = core::Cons_O::createList(_lisp->create<core::Str_O>(it->first),it->second);
trainer.cc:508:	if ( entries->isNil() )
trainer.cc:514:	    tail->setCdr(cur);
trainer.cc:524:    archive = org->lisp()->create<core::XmlSaveArchive_O>();
trainer.cc:525:    archive->put("organizer",org);
trainer.cc:526:    archive->saveAs("_organizer.cxml");
trainer.cc:535:    archive = lisp->create<core::XmlLoadArchive_O>();
trainer.cc:536:    archive->parse("_organizer.cxml");
trainer.cc:537:    org = downcast<TrainerOrganizer_O>(archive->get("organizer"));
trainerArchive.cc:22:    this->Base::initialize();
trainerArchive.cc:23:    this->_CandoDatabase = CandoDatabase_O::_nil;
trainerArchive.cc:24:    this->_Trainers.clear();
trainerArchive.cc:30:    node->archiveObject("CandoDatabase",this->_CandoDatabase);
trainerArchive.cc:31:    node->archiveMap("Trainers",this->_Trainers);
trainerArchive.cc:40:    this->_CandoDatabase = hold;
trainerArchive.cc:47:    key = job->getHeader()->getContextKey();
trainerArchive.cc:48:    this->_Trainers.set(key,job);
trainerArchive.cc:54:    return this->_Trainers.contains(key);
trainerArchive.cc:59:    return this->_Trainers.get(key);
trajectory.cc:62:    this->Base::initialize();
trajectory.cc:68:    this->Base::archiveBase(node);
trajectory.cc:69:    node->archiveObject("coords",this->_Coordinates);
trajectory.cc:76:    this->_Coordinates = _lisp->create<addon::CoordinateArray_O>(atomList.size());
trajectory.cc:79:    for ( ai=atomList.begin(), ci = this->_Coordinates->begin(); ai!=atomList.end(); ai++, ci++ )
trajectory.cc:81:	(*ci) = (*ai)->getPosition();
trajectory.cc:89:    ASSERT_eq(this->_Coordinates->size(),atomList.size());
trajectory.cc:92:    for ( ai=atomList.begin(), ci = this->_Coordinates->begin(); ai!=atomList.end(); ai++, ci++ )
trajectory.cc:94:	(*ai)->setPosition(*ci);
trajectory.cc:128:    this->Base::oldLispInitialize(kargs,env);
trajectory.cc:129:    Matter_sp matter = kargs->getAndRemove("matter")->as<Matter_O>();
trajectory.cc:130:    this->_setupAtomList(matter);
trajectory.cc:138:    this->Base::initialize();
trajectory.cc:139:    this->_Matter = Matter_O::_nil;
trajectory.cc:140:    this->_Namespace = addon::ObjectDictionary_O::create();
trajectory.cc:146:    this->_Matter = matter;
trajectory.cc:147:    this->_AtomList.clear();
trajectory.cc:149:    lAtoms.loopTopGoal(this->_Matter,ATOMS);
trajectory.cc:152:	this->_AtomList.push_back(lAtoms.getAtom());
trajectory.cc:154:    this->_Frames.clear();
trajectory.cc:161:    this->Base::archiveBase(node);
trajectory.cc:162:    node->archiveObject("matter",this->_Matter);
trajectory.cc:163:    node->archiveObject("namespace",this->_Namespace);
trajectory.cc:164:    node->archiveVector0("atomList",this->_AtomList);
trajectory.cc:165:    node->archiveVector0("frames",this->_Frames);
trajectory.cc:173:    ASSERTP(matter == this->_Matter,"The matter argument must match the Matter used to define this trajectory");
trajectory.cc:175:    frame->fillFromMatter(this->_AtomList);
trajectory.cc:176:    this->_Frames.push_back(frame);
trajectory.cc:183:    return this->_Frames.size();
trajectory.cc:189:    ASSERT_lt(i,this->_Frames.size());
trajectory.cc:190:    return this->_Frames[i];
trajectory.cc:197:    for ( core::Vector0<TrajectoryFrame_O>::iterator it=this->_Frames.begin(); it!=this->_Frames.end(); it++ )
trajectory.cc:199:	this->applyTrajectoryFrameToMatter(*it);
trajectory.cc:200:	frames->append(this->_Matter->rendered(kargs));
trajectory.cc:208:    f->applyToMatter(this->_AtomList);
twister.cc:31:    this->Base::initialize();
twister.cc:32:    this->_FixedRef = Atom_O::_nil;
twister.cc:33:    this->_Fixed = Atom_O::_nil;
twister.cc:34:    this->_Movable = Atom_O::_nil;
twister.cc:35:    this->_MovableRef = Atom_O::_nil;
twister.cc:36:    this->_Atoms.clear();
twister.cc:44:    node->archiveObject("Fixed",this->_Fixed);
twister.cc:45:    node->archiveObject("Movable",this->_Movable);
twister.cc:46:    node->archiveVector0("MoveAtoms",this->_Atoms);
twister.cc:54:    this->_Fixed = fixed;
twister.cc:55:    this->_Movable = movable;
twister.cc:60:    this->_Atoms.push_back(a);
twister.cc:69:    BondOrder bo = a1->bondOrderTo(a2);
twister.cc:70:    bool hasBond = a1->isBondedTo(a2);
twister.cc:73:	a1->removeBondTo(a2);
twister.cc:80:    span1->setTop(a1);
twister.cc:81:    while ( span1->advance() )
twister.cc:83:	a1Atoms = core::Cons_O::create(span1->getAtom(),a1Atoms,_lisp);
twister.cc:87:    span2->setTop(a2);
twister.cc:88:    while ( span2->advance() )
twister.cc:90:	a2Atoms = core::Cons_O::create(span2->getAtom(),a2Atoms,_lisp);
twister.cc:103:	if ( a1Atoms->length() < a2Atoms->length() )
twister.cc:124:	a1->bondTo(a2,bo);
twister.cc:126:    this->_Atoms.clear();
twister.cc:127:    this->setFixedAndMovable(twistFixed,twistMovable);
twister.cc:128:    this->_FixedRef = twistFixedRef;
twister.cc:129:    this->_MovableRef = twistMovableRef;
twister.cc:130:    for ( core::Cons_sp cur=twistAtoms; cur.notnilp(); cur = cur->cdr() )
twister.cc:132:	this->addAtom(cur->car<Atom_O>());
twister.cc:140:    this->_defineForDihedral(a1ref,a1,a2,a2ref,false);
twister.cc:148:    this->_defineForDihedral(Atom_O::_nil,a1,a2,Atom_O::_nil,false);
twister.cc:154:    this->_defineForDihedral(Atom_O::_nil,afixed,amobile,Atom_O::_nil, true);
twister.cc:164:    ASSERTNOTNULLP(this->_Fixed,"Fixed atom undefined");
twister.cc:165:    ASSERTNOTNULLP(this->_Movable,"Movable atom is undefined");
twister.cc:166:    ASSERTP(this->_Atoms.size()>0,"There must be atoms to rotate");
twister.cc:167:    rotVec = this->_Movable->getPosition()-this->_Fixed->getPosition();
twister.cc:169:    tv = this->_Movable->getPosition();
twister.cc:170:    tv = tv.multiplyByScalar(-1.0);
twister.cc:175:    tv = this->_Movable->getPosition();
twister.cc:180:    for ( vector<Atom_sp>::iterator ai=this->_Atoms.begin();
twister.cc:181:	  ai!=this->_Atoms.end(); ai++ ) {
twister.cc:182:	LOG(BF("Perturbing atom(%s)  start position = %lf, %lf, %lf") % (*ai)->description().c_str() % (*ai)->getPosition().getX() % (*ai)->getPosition().getY() % (*ai)->getPosition().getZ()  );
twister.cc:183:	tv = (*ai)->getPosition();
twister.cc:185:	(*ai)->setPosition(tv);
twister.cc:186:	LOG(BF("                     pert. position = %lf, %lf, %lf") % (*ai)->getPosition().getX() % (*ai)->getPosition().getY() % (*ai)->getPosition().getZ()  );
twister.cc:195:    if (this->_FixedRef->isNil() )
twister.cc:197:	THROW(_lisp->create<core::ContentException_O>("For absolute rotations the reference atoms of the twister must be defined"));
twister.cc:199:    Vector3 v1 = this->_FixedRef->getPosition();
twister.cc:200:    Vector3 v2 = this->_Fixed->getPosition();
twister.cc:201:    Vector3 v3 = this->_Movable->getPosition();
twister.cc:202:    Vector3 v4 = this->_MovableRef->getPosition();
twister.cc:205:    double delta = angle - currentAngle;
twister.cc:206:    _lisp->print(BF("current dihedral = %8.3lf  desired dihedral = %8.3lf delta=%8.3lf") % (currentAngle/0.0174533) % (angle/0.0174533) % (delta/0.0174533) );
twister.cc:207:    this->rotate(delta);
twister.cc:209:    v1 = this->_FixedRef->getPosition();
twister.cc:210:    v2 = this->_Fixed->getPosition();
twister.cc:211:    v3 = this->_Movable->getPosition();
twister.cc:212:    v4 = this->_MovableRef->getPosition();
twister.cc:214:    _lisp->print(BF("      result dihedral = %8.3lf") % (resultAngle/0.0174533) );
twister.cc:222:    ss << "Twister[Fixed[" << this->_Fixed->description();
twister.cc:223:    ss << "] Moveable[" << this->_Movable->description() << "]";
twister.cc:232:    node->archiveObject("Aggregate",this->_Aggregate);
twister.cc:233:    node->archiveVector0("Twisters",this->_Twisters);
twister.cc:240:    this->_Twisters.push_back(twister);
twister.cc:246:    ASSERT_lessThan(i,this->_Twisters.size());
twister.cc:247:    return this->_Twisters[i];
twister.cc:254:    if ( this->_Twisters.size() == 0 )
twister.cc:259:    it = core::randomNumber01()*this->_Twisters.size();
twister.cc:262:    LOG(BF("Perturbing twister#%d of %d by %lf degrees") % it % this->_Twisters.size() % (ang/0.0174533)  );
twister.cc:263:    this->_Twisters[it]->rotate(ang);
twister.cc:269:    ss << "TwisterDriver[#twisters("<<this->_Twisters.size()<<")]";
typeAssignmentRules.cc:18:    this->Base::initialize();
typeAssignmentRules.cc:19:    this->_Match = ChemInfo_O::_nil;
typeAssignmentRules.cc:25:    node->attribute("assignTypeName",this->_AssignTypeName);
typeAssignmentRules.cc:26:    node->archiveObject("match",this->_Match);
typeAssignmentRules.cc:33:    return this->_Match->matches(atom);
typeAssignmentRules.cc:41:    this->Base::initialize();
typeAssignmentRules.cc:42:    this->_WildElementDict = WildElementDict_O::_nil;
typeAssignmentRules.cc:48:    node->archiveObject("WildElementDict",this->_WildElementDict);
typeAssignmentRules.cc:49:    node->archiveVector0("Rules",this->_Rules);
typeAssignmentRules.cc:56:    for ( core::Vector0<OneTypeRule_O>::iterator it=this->_Rules.begin();
typeAssignmentRules.cc:57:    		it!=this->_Rules.end(); it++ )
typeAssignmentRules.cc:59:	if ( (*it)->testMatch(a) )
typeAssignmentRules.cc:61:	    return (*it)->getAssignTypeName();
typeAssignmentRules.cc:64:    return "UNASSIGNED-TYPE";
virtualAtom.cc:23:    va->setName(name);
virtualAtom.cc:25:    va->_CalculatePosition = proc;
virtualAtom.cc:36:    this->_CalculatePosition = ss._CalculatePosition;
virtualAtom.cc:37://    this->_Environment = ss._Environment;
virtualAtom.cc:47:{_GF(BF("%s")%this->description());
virtualAtom.cc:51:    this->copyAtom = aNew;
virtualAtom.cc:52:    LOG(BF("    copy atom== %s") % aNew->description().c_str() );
virtualAtom.cc:60:    this->Base::initialize();
virtualAtom.cc:61:    this->_CalculatePosition = CalculatePosition_O::_nil;
virtualAtom.cc:66:    if ( this->eq(obj) ) return true;
virtualAtom.cc:67:    if ( !obj->isOfClass<VirtualAtom_O>() )
virtualAtom.cc:69:	VirtualAtom_sp other = obj->as<VirtualAtom_O>();
virtualAtom.cc:70:	if ( other->getName() != this->getName() ) return false;
virtualAtom.cc:71:	if ( other->numberOfBonds() != this->numberOfBonds() ) return false;
virtualAtom.cc:83:    this->Base::archive(node);
virtualAtom.cc:84:    node->archiveObjectIfDefined("calculatePosition",this->_CalculatePosition);
virtualAtom.cc:85://    node->archiveObject("environment",this->_Environment);
virtualAtom.cc:93:    ASSERTNOTNULL(this->_CalculatePosition);
virtualAtom.cc:94://    ASSERTNOTNULL(this->_Environment);
virtualAtom.cc:95:    Matter_wp wmres = this->containedBy();
virtualAtom.cc:99:    Residue_sp res = mres->as<Residue_O>();
virtualAtom.cc:100:    Vector3 vpos = this->_CalculatePosition->calculatePosition(res);
virtualAtom.cc:101:    this->setPosition(vpos);
virtualSphere.cc:73:	c[0] = a[1] * b[2] - a[2] * b[1];
virtualSphere.cc:74:	c[1] = a[2] * b[0] - a[0] * b[2];
virtualSphere.cc:75:	c[2] = a[0] * b[1] - a[1] * b[0];
virtualSphere.cc:96: *	Convert X-Y coordinates into a 4x4 rotation matrix
virtualSphere.cc:115:		return -2;
virtualSphere.cc:117:		return -3;
virtualSphere.cc:121:		f[2] = sqrt(1 - d1);
virtualSphere.cc:132:		t[2] = sqrt(1 - d2);
virtualSphere.cc:146:		return -1;
virtualSphere.cc:156:	 * the from-vector to xyz-space) and the transform matrix
virtualSphere.cc:157:	 * (to go from xyz-space to to-vector).  The product of
virtualSphere.cc:225:    halfWidth = this->_WindowWidth/2;
virtualSphere.cc:226:    halfHeight = this->_WindowHeight/2;
virtualSphere.cc:228:    rx = (ax-halfWidth)/radius;
virtualSphere.cc:229://    ry = (halfHeight - ay)/radius;
virtualSphere.cc:230://    rx = (halfWidth-ax)/radius;
virtualSphere.cc:231:    ry = (ay-halfHeight)/radius;
virtualSphere.cc:244:    this->Base::archiveBase(node);
virtualSphere.cc:245:    node->attribute("windowHeight",this->_WindowHeight);
virtualSphere.cc:246:    node->attribute("windowWidth",this->_WindowWidth);
virtualSphere.cc:247:    node->attribute("startX",this->_StartX);
virtualSphere.cc:248:    node->attribute("startY",this->_StartY);
virtualSphere.cc:249:    node->attribute("mouseX",this->_MouseX);
virtualSphere.cc:250:    node->attribute("mouseY",this->_MouseY);
virtualSphere.cc:251://    node->attribute("mouseMode",this->_MouseMode);
virtualSphere.cc:252:    node->attribute("recalculate",this->_Recalculate);
virtualSphere.cc:253:    node->attribute("scale",this->_Scale);
virtualSphere.cc:254:    node->archivePlainObject<Vector3>( "translate","Vector3",this->_Translate);
virtualSphere.cc:255:    node->archivePlainObject<Vector3>( "center","Vector3",this->_Center);
virtualSphere.cc:256:    node->archivePlainObject( "rotate","Matrix",this->_Rotate);
virtualSphere.cc:257:    node->archivePlainObject( "overall","Matrix",this->_Overall);
virtualSphere.cc:264:    this->Base::initialize();
virtualSphere.cc:265:    this->_MouseMode = vsIdle;
virtualSphere.cc:266:    this->_Recalculate = true;
virtualSphere.cc:267:    this->_Scale = 0.25;
virtualSphere.cc:268:    this->_Translate.set(0.0,0.0,0.0);
virtualSphere.cc:269:    this->_Center.set(0.0,0.0,0.0);
virtualSphere.cc:276:    ss << "VirtualSphere dump  _Recalculate = " << this->_Recalculate << endl;
virtualSphere.cc:277:    ss << "_Scale = " << this->_Scale << endl;
virtualSphere.cc:278:    ss << "_Translate = " << this->_Translate.asString() << endl;
virtualSphere.cc:279:    ss << "_Center = " << this->_Center.asString() << endl;
virtualSphere.cc:280:    ss << "_Rotate = " << this->_Rotate.asString() << endl;
virtualSphere.cc:300:	VirtualSphereMotionMode mode = this->mouseModeFromSymbol(sym);
virtualSphere.cc:301:	this->setMouseStart(mode,x,y,w,h);
virtualSphere.cc:305:	this->_MouseMode = mode;
virtualSphere.cc:306:	this->_StartX = x;
virtualSphere.cc:307:	this->_StartY = y;
virtualSphere.cc:308:	this->_MouseX = x;
virtualSphere.cc:309:	this->_MouseY = y;
virtualSphere.cc:310:	this->_WindowHeight = h;
virtualSphere.cc:311:	this->_WindowWidth = w;
virtualSphere.cc:312:	this->_Recalculate = true;
virtualSphere.cc:323:    this->_MouseX = x;
virtualSphere.cc:324:    this->_MouseY = y;
virtualSphere.cc:325:    switch ( this->_MouseMode )
virtualSphere.cc:330:	this->convertToRelative( this->_StartX, this->_StartY, sx,sy );
virtualSphere.cc:331:	this->convertToRelative( this->_MouseX, this->_MouseY, tx,ty );
virtualSphere.cc:335:	    this->_Rotate = mtemp.multiplyByMatrix(this->_Rotate);
virtualSphere.cc:336://	        this->_Rotate = this->_Rotate.multiplyByMatrix(mtemp);
virtualSphere.cc:338:	this->_StartX = this->_MouseX;
virtualSphere.cc:339:	this->_StartY = this->_MouseY;
virtualSphere.cc:340:	this->_Recalculate = true;
virtualSphere.cc:342:	this->notify(_kw_changed,_Nil<core::Cons_O>());
virtualSphere.cc:345:	this->convertToRelative( this->_StartX, this->_StartY, sx,sy );
virtualSphere.cc:346:	this->convertToRelative( this->_MouseX, this->_MouseY, tx,ty );
virtualSphere.cc:347:	delta.set(tx-sx,ty-sy,0.0);
virtualSphere.cc:348:	this->_Translate = this->_Translate.add(delta*10);
virtualSphere.cc:349://	    printf("translation delta = %f,%f,%f\n", tx-sx,ty-sy,0.0 );
virtualSphere.cc:351://				this->_Translate.getX(),
virtualSphere.cc:352://				this->_Translate.getY(),
virtualSphere.cc:353://				this->_Translate.getZ() );
virtualSphere.cc:354:	this->_StartX = this->_MouseX;
virtualSphere.cc:355:	this->_StartY = this->_MouseY;
virtualSphere.cc:356:	this->_Recalculate = true;
virtualSphere.cc:357:	this->notify(_kw_changed,_Nil<core::Cons_O>());
virtualSphere.cc:360:	this->convertToRelative( this->_StartX, this->_StartY, sx,sy );
virtualSphere.cc:361:	this->convertToRelative( this->_MouseX, this->_MouseY, tx,ty );
virtualSphere.cc:362:	scaleDelta = sy - ty;
virtualSphere.cc:368:	this->_Scale *= scaleDelta;
virtualSphere.cc:369://	    printf( "this->_Scale = %f\n", this->_Scale);
virtualSphere.cc:370://	    this->_Scale = MAX(this->_Scale,0.005);
virtualSphere.cc:371://	    this->_Scale = MIN(this->_Scale,50.0);
virtualSphere.cc:372:	this->_StartX = this->_MouseX;
virtualSphere.cc:373:	this->_StartY = this->_MouseY;
virtualSphere.cc:374:	this->_Recalculate = true;
virtualSphere.cc:387:	this->_Scale *= scaleDelta;
virtualSphere.cc:388://	    printf( "this->_Scale = %f\n", this->_Scale);
virtualSphere.cc:389://	this->_Scale = MAX(this->_Scale,0.005);
virtualSphere.cc:390://	this->_Scale = MIN(this->_Scale,50.0);
virtualSphere.cc:391:	this->_Recalculate = true;
virtualSphere.cc:400:	VirtualSphereMotionMode mode = this->mouseModeFromSymbol(smode);
virtualSphere.cc:412:	    if ( w < -1.0 ) w = -1.0;
virtualSphere.cc:414:	    this->_Rotate = mtemp.multiplyByMatrix(this->_Rotate);
virtualSphere.cc:416://	        this->_Rotate = this->_Rotate.multiplyByMatrix(mtemp);
virtualSphere.cc:417:	    this->_Recalculate = true;
virtualSphere.cc:425:	    this->_Translate = this->_Translate.add(delta);
virtualSphere.cc:426:	    this->_Recalculate = true;
virtualSphere.cc:431:	    this->setScaleChange(w);
virtualSphere.cc:443:	VirtualSphereMotionMode mode = this->mouseModeFromSymbol(smode);
virtualSphere.cc:454:	    if ( w < -1.0 ) w = -1.0;
virtualSphere.cc:456:	    this->_Rotate = mtemp.multiplyByMatrix(this->_Rotate);
virtualSphere.cc:458://	        this->_Rotate = this->_Rotate.multiplyByMatrix(mtemp);
virtualSphere.cc:459:	    this->_Recalculate = true;
virtualSphere.cc:467:	    this->_Translate = this->_Translate.add(delta);
virtualSphere.cc:468:	    this->_Recalculate = true;
virtualSphere.cc:473:	    this->setScaleChange(w);
virtualSphere.cc:486:    this->_Center = pos;
virtualSphere.cc:487:    this->_Recalculate = true;
virtualSphere.cc:494:    this->_Translate = pos;
virtualSphere.cc:495:    this->_Recalculate = true; 
virtualSphere.cc:503:    if ( this->_Scale < minScale )
virtualSphere.cc:505:	this->_Scale = minScale;
virtualSphere.cc:507:    if ( this->_Scale > maxScale )
virtualSphere.cc:509:	this->_Scale = maxScale;
virtualSphere.cc:511:    return this->_Scale;
virtualSphere.cc:521:    if (this->_Recalculate == false ) {
virtualSphere.cc:522:        LOG(BF("Returning pre-calculated matrix") );
virtualSphere.cc:523:	result = this->_Overall;
virtualSphere.cc:538:    vCent = this->_Center.multiplyByScalar(-1.0);
virtualSphere.cc:541:    mTranslateOriginToCenter.translate(&this->_Center);
virtualSphere.cc:542:    mTranslate.translate(&this->_Translate);
virtualSphere.cc:544:    mA = this->_Rotate.multiplyByMatrix(mTranslateCenterToOrigin);
virtualSphere.cc:546:    mScale.scale(this->_Scale);
virtualSphere.cc:555:    mA = this->_Rotate.multiplyByMatrix(mTranslateCenterToOrigin);
virtualSphere.cc:560:    this->_Overall = result;
virtualSphere.cc:561:    this->_Recalculate = false;
zMatrix.cc:50:	this->Base::initialize();
zMatrix.cc:51:	this->_Value = 0.0;
zMatrix.cc:52:	this->_Constrain = false;
zMatrix.cc:59:	node->archiveWeakPointer("WeakZMatrix",this->_WeakZMatrix);
zMatrix.cc:60:	node->attribute("InternalName",this->_InternalName);
zMatrix.cc:61:	node->attributeIfNotDefault("Constrain",this->_Constrain,false);
zMatrix.cc:62:	node->attribute("AtomNew",this->_AtomNew);
zMatrix.cc:63:	node->attributeIfNotDefault("Value",this->_Value,0.0);
zMatrix.cc:72:	return this->getZMatrix()->_getAtomAtIndex(this->_AtomNew);
zMatrix.cc:78:	this->_AtomNew = atomIndices[atom];
zMatrix.cc:85:	ss << this->_InternalName << " " << this->_AtomNew << " ";
zMatrix.cc:127:	ss << this->ZMatrixInternal_O::__repr__();
zMatrix.cc:128:	ss << " " << this->_AtomBond;
zMatrix.cc:136:	atomNew = this->getAtomNew();
zMatrix.cc:137:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:138:	this->setConstrain(true);
zMatrix.cc:139:	if ( atomNew->getMask()==m ||
zMatrix.cc:140:	     atomBond->getMask()==m )
zMatrix.cc:142:	    this->setConstrain(false);
zMatrix.cc:150:	atomNew = this->getAtomNew();
zMatrix.cc:151:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:152:	value = calculateDistance(atomNew->getPosition(),
zMatrix.cc:153:				  atomBond->getPosition(),_lisp);
zMatrix.cc:154:	this->setValue(value);
zMatrix.cc:162:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomBond);
zMatrix.cc:169:	this->ZMatrixInternal_O::archiveBase(node);
zMatrix.cc:170:	node->attribute("AtomBond",this->_AtomBond);
zMatrix.cc:181:	this->setAtomNew(atomNew,atomIndices);
zMatrix.cc:183:	this->setInternalName(name.str());
zMatrix.cc:184:	this->_AtomBond = atomIndices[atomBond];
zMatrix.cc:185:	this->setValue(0.0);
zMatrix.cc:227:	ss << this->ZMatrixInternal_O::__repr__();
zMatrix.cc:228:	ss << " " << this->_AtomBond;
zMatrix.cc:229:	ss << " " << this->_AtomAngle;
zMatrix.cc:238:	atomNew = this->getAtomNew();
zMatrix.cc:239:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:240:	atomAngle = this->getZMatrix()->_getAtomAtIndex(this->_AtomAngle);
zMatrix.cc:241:	this->setConstrain(true);
zMatrix.cc:242:	if ( atomNew->getMask()==m ||
zMatrix.cc:243:	     atomBond->getMask()==m ||
zMatrix.cc:244:	     atomAngle->getMask()==m )
zMatrix.cc:246:	    this->setConstrain(false);
zMatrix.cc:255:	atomNew = this->getAtomNew();
zMatrix.cc:256:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:257:	atomAngle = this->getZMatrix()->_getAtomAtIndex(this->_AtomAngle);
zMatrix.cc:258:	value = calculateAngle(atomNew->getPosition(),
zMatrix.cc:259:			       atomBond->getPosition(),
zMatrix.cc:260:			       atomAngle->getPosition(), _lisp );
zMatrix.cc:261:	this->setValue(value);
zMatrix.cc:270:	this->ZMatrixInternal_O::archiveBase(node);
zMatrix.cc:271:	node->attribute("AtomBond",this->_AtomBond);
zMatrix.cc:272:	node->attribute("AtomAngle",this->_AtomAngle);
zMatrix.cc:278:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomBond);
zMatrix.cc:283:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomAngle);
zMatrix.cc:290:	this->setAtomNew(atomNew,atomIndices);
zMatrix.cc:292:	this->setInternalName(name.str());
zMatrix.cc:293:	this->_AtomBond = atomIndices[atomBond];
zMatrix.cc:294:	this->_AtomAngle = atomIndices[atomAngle];
zMatrix.cc:295:	this->setValue(0.0);
zMatrix.cc:343:	ss << this->ZMatrixInternal_O::__repr__();
zMatrix.cc:344:	ss << " " << this->_AtomBond;
zMatrix.cc:345:	ss << " " << this->_AtomAngle;
zMatrix.cc:346:	ss << " " << this->_AtomDihedral;
zMatrix.cc:353:	atomNew = this->getAtomNew();
zMatrix.cc:354:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:355:	atomAngle = this->getZMatrix()->_getAtomAtIndex(this->_AtomAngle);
zMatrix.cc:356:	atomDihedral = this->getZMatrix()->_getAtomAtIndex(this->_AtomDihedral);
zMatrix.cc:357:	this->setConstrain(true);
zMatrix.cc:358:	if ( atomNew->getMask()==m ||
zMatrix.cc:359:	     atomBond->getMask()==m ||
zMatrix.cc:360:	     atomAngle->getMask()==m ||
zMatrix.cc:361:	     atomDihedral->getMask()==m )
zMatrix.cc:363:	    this->setConstrain(false);
zMatrix.cc:371:	atomNew = this->getAtomNew();
zMatrix.cc:372:	atomBond = this->getZMatrix()->_getAtomAtIndex(this->_AtomBond);
zMatrix.cc:373:	atomAngle = this->getZMatrix()->_getAtomAtIndex(this->_AtomAngle);
zMatrix.cc:374:	atomDihedral = this->getZMatrix()->_getAtomAtIndex(this->_AtomDihedral);
zMatrix.cc:375:	value = calculateDihedral(atomNew->getPosition(),
zMatrix.cc:376:				  atomBond->getPosition(),
zMatrix.cc:377:				  atomAngle->getPosition(),
zMatrix.cc:378:				  atomDihedral->getPosition(), _lisp
zMatrix.cc:380:	this->setValue(value);
zMatrix.cc:387:	this->ZMatrixInternal_O::archiveBase(node);
zMatrix.cc:388:	node->attribute("AtomBond",this->_AtomBond);
zMatrix.cc:389:	node->attribute("AtomAngle",this->_AtomAngle);
zMatrix.cc:390:	node->attribute("AtomDihedral",this->_AtomDihedral);
zMatrix.cc:396:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomBond);
zMatrix.cc:401:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomAngle);
zMatrix.cc:406:	return this->getZMatrix()->_getAtomZMatrixNameAtIndex(this->_AtomDihedral);
zMatrix.cc:417:	this->setAtomNew(atomNew,atomIndices);
zMatrix.cc:419:	this->setInternalName(name.str());
zMatrix.cc:420:	this->_AtomBond = atomIndices[atomBond];
zMatrix.cc:421:	this->_AtomAngle = atomIndices[atomAngle];
zMatrix.cc:422:	this->_AtomDihedral = atomIndices[atomDihedral];
zMatrix.cc:423:	this->setValue(0.0);
zMatrix.cc:471:	name << atom->getElementAsString() << atomIndices.size();
zMatrix.cc:472:	entry->_Atom = atom;
zMatrix.cc:473:	entry->_ZMatrixAtomName = name.str();
zMatrix.cc:480:	this->Base::initialize();
zMatrix.cc:481:	this->_ZMatrixAtomName = "";
zMatrix.cc:482:	this->_Atom = Atom_O::_nil;
zMatrix.cc:483:	this->_Bond = ZMatrixBondInternal_O::_nil;
zMatrix.cc:484:	this->_Angle = ZMatrixAngleInternal_O::_nil;
zMatrix.cc:485:	this->_Dihedral = ZMatrixDihedralInternal_O::_nil;
zMatrix.cc:495:	node->attribute("ZMatrixAtomName",this->_ZMatrixAtomName);
zMatrix.cc:496:	ASSERTNOTNULL(this->_Atom);
zMatrix.cc:497:	node->archiveObject("Atom",this->_Atom);
zMatrix.cc:498:	node->archiveObjectIfDefined("Bond",this->_Bond);
zMatrix.cc:499:	node->archiveObjectIfDefined("Angle",this->_Angle);
zMatrix.cc:500:	node->archiveObjectIfDefined("Dihedral",this->_Dihedral);
zMatrix.cc:507:	return this->_getAtomZMatrixNameAtIndex(i);
zMatrix.cc:517:	    .def("zmatrix-entry-with-name",&ZMatrix_O::zMatrixEntryWithName)
zMatrix.cc:518:	    .def("all-zmatrix-atom-names-as-string",&ZMatrix_O::allZMatrixAtomNamesAsString)
zMatrix.cc:519:	    .def("get-zmatrix-atom-name-at-index",&ZMatrix_O::getZMatrixAtomNameAtIndex)
zMatrix.cc:529:	    .def("zmatrix-entry-with-name",&ZMatrix_O::zMatrixEntryWithName)
zMatrix.cc:530:	    .def("all-zmatrix-atom-names-as-string",&ZMatrix_O::allZMatrixAtomNamesAsString)
zMatrix.cc:531:	    .def("get-zmatrix-atom-name-at-index",&ZMatrix_O::getZMatrixAtomNameAtIndex)
zMatrix.cc:551:      if ( rootAtom->isNil() )
zMatrix.cc:553:	  me->defineForMatter(matter);
zMatrix.cc:556:	  me->defineForMatterWithStartingAtom(matter,rootAtom);
zMatrix.cc:565:	Matter_sp matter = translate::from_object<Matter_sp>::convert(env->lookup(Pkg(),"matter"));
zMatrix.cc:566:	Atom_sp rootAtom = translate::from_object<Atom_sp>::convert(env->lookup(Pkg(),"rootAtom"));
zMatrix.cc:567:	if ( rootAtom->isNil() )
zMatrix.cc:569:	    this->defineForMatter(matter);
zMatrix.cc:572:	    this->defineForMatterWithStartingAtom(matter,rootAtom);
zMatrix.cc:586:	node->archiveObject("Matter",this->_Matter);
zMatrix.cc:587:	node->archiveVector0("ZMatrix",this->_ZMatrix);
zMatrix.cc:588:	node->archiveVector0("Internals",this->_Internals);
zMatrix.cc:594:	ASSERT_lessThan(i,this->_ZMatrix.size());
zMatrix.cc:595:	return this->_ZMatrix.get(i)->getAtom();
zMatrix.cc:600:	LOG(BF("Looking for atom at index: %d    _ZMatrix.size=%d") % i % this->_ZMatrix.size()  );
zMatrix.cc:601:	ASSERT_lessThan(i,this->_ZMatrix.size());
zMatrix.cc:602:	return this->_ZMatrix.get(i)->getTargetAtomZMatrixName();
zMatrix.cc:615:	LOG(BF("Starting on atom: %s") % atom->description().c_str()  );
zMatrix.cc:616:	this->_Matter = matter;
zMatrix.cc:617:	span = _lisp->create<SpanningLoop_O>();
zMatrix.cc:618:	span->setTop(atom);
zMatrix.cc:620:	while ( span->advanceLoopAndProcess() )
zMatrix.cc:622:	    newAtom = span->getAtom();
zMatrix.cc:623:	    _BLOCK_TRACEF(BF("ZMatrix entry for: %s") % newAtom->description().c_str() );
zMatrix.cc:624:	    atomIndices[newAtom] = this->_ZMatrix.size();
zMatrix.cc:626:	    this->_ZMatrix.append(entry);
zMatrix.cc:627:	    numberOfEntries = this->_ZMatrix.size();
zMatrix.cc:628:	    if ( ! newAtom->isBackSpanValid() )
zMatrix.cc:632:	    bondToAtom = newAtom->getBackSpan();
zMatrix.cc:633:	    LOG(BF("bondToAtom = %s") % bondToAtom->description().c_str() );
zMatrix.cc:634:	    bondInternal = ZMatrixBondInternal_O::create(_lisp,newAtom,bondToAtom,atomIndices,this->sharedThis<ZMatrix_O>());
zMatrix.cc:635:	    this->_Internals.append(bondInternal);
zMatrix.cc:636:	    entry->_Bond = bondInternal;
zMatrix.cc:637:	    if ( !bondToAtom->isBackSpanValid() )
zMatrix.cc:642:	    angleToAtom = bondToAtom->getBackSpan();
zMatrix.cc:643:	    LOG(BF("angleToAtom = %s") % angleToAtom->description().c_str() );
zMatrix.cc:645:							   angleToAtom,atomIndices,this->sharedThis<ZMatrix_O>(), _lisp);
zMatrix.cc:646:	    this->_Internals.append(angleInternal);
zMatrix.cc:647:	    entry->_Angle = angleInternal;
zMatrix.cc:648:	    if ( !angleToAtom->isBackSpanValid() )
zMatrix.cc:654:		    dihedralToAtom = this->_getAtomAtIndex(2);
zMatrix.cc:662:		dihedralToAtom = angleToAtom->getBackSpan();
zMatrix.cc:664:	    LOG(BF("dihedralToAtom = %s") % dihedralToAtom->description().c_str() );
zMatrix.cc:666:								 angleToAtom,dihedralToAtom,atomIndices,this->sharedThis<ZMatrix_O>(),_lisp);
zMatrix.cc:668:	    this->_Internals.append(dihedralInternal);
zMatrix.cc:669:	    LOG(BF("Setting entry->_Dihedral") );
zMatrix.cc:670:	    entry->_Dihedral = dihedralInternal;
zMatrix.cc:687:	    if ( atom->numberOfBonds() == 1 )
zMatrix.cc:694:	this->defineForMatterWithStartingAtom(matter,atom);
zMatrix.cc:701:	for ( it=this->_Internals.begin(); it!=this->_Internals.end(); it++ )
zMatrix.cc:703:	    (*it)->extractInternal();
zMatrix.cc:711:	for ( it=this->_Internals.begin(); it!=this->_Internals.end(); it++ )
zMatrix.cc:713:	    (*it)->constrainIfNoAtomsWithMask(mask);
zMatrix.cc:722:	return this->_ZMatrix.asCons(_lisp);
zMatrix.cc:727:	for ( const_zMatrixEntryIterator it = this->begin_ZMatrixEntries();
zMatrix.cc:728:	      it != this->end_ZMatrixEntries(); it++ )
zMatrix.cc:730:	    if ( (*it)->getTargetAtomZMatrixName()==atomZMatrixName) return *it;
zMatrix.cc:739:	for ( const_zMatrixEntryIterator it = this->begin_ZMatrixEntries();
zMatrix.cc:740:	      it != this->end_ZMatrixEntries(); it++ )
zMatrix.cc:742:	    ss << (*it)->getTargetAtomZMatrixName() << " ";
